<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="敢做就能赢！">
<meta property="og:type" content="website">
<meta property="og:title" content="大麦田程序猿">
<meta property="og:url" content="http://hellomyshadow.github.io/page/4/index.html">
<meta property="og:site_name" content="大麦田程序猿">
<meta property="og:description" content="敢做就能赢！">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="大麦田程序猿">
<meta name="twitter:description" content="敢做就能赢！">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hellomyshadow.github.io/page/4/">





  <title>大麦田程序猿</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大麦田程序猿</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/05/03/SpringCloud组件2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/03/SpringCloud组件2/" itemprop="url">SpringCloud组件2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-03T00:00:00+08:00">
                2016-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><pre><code>1. Hystrix：Netflix公司的一款组件，是一种保护机制;
2. Hystrix是Netflix开源的一个延迟和容错库，用于隔离访问远程服务、第三方库，防止出现级联失败;
3. 雪崩问题
    1. 微服务中，服务间的关系错综复杂，一个请求可能需要调用多个微服务接口才能实现，形成非常复杂的调用链路;
    2. 一旦被调用的服务提供者发生异常，请求阻塞，用户不会得到响应，那么Tomcat的这个线程也不会被释放;
    3. 随着越来越多的用户请求到来，越来越多的线程也会随之阻塞，而服务器支持的线程和并发数量是有限的，
    最后会导致服务器资源耗尽，从而会导致其他服务都不可用，这就是雪崩效应;
    4. 比如一个汽车生产线，如果某个零件因为种种原因无法供应，那么整台车就无法装配，陷入等待零件状态；
    5. 如果很多车型都需要这个零件，那么整个车间都会陷入等待状态，导致所有生产都陷入瘫痪；
4. Hystrix解决雪崩问题的手段主要有两种方式：线程隔离、服务熔断
</code></pre><h3 id="线程隔离，服务降级"><a href="#线程隔离，服务降级" class="headerlink" title="线程隔离，服务降级"></a>线程隔离，服务降级</h3><pre><code>1. 线程隔离
    1. Hystrix为每个依赖服务调用分配一个小线程池，如果线程池已满，调用会被立即拒绝，默认不采用排队，加速失败的判定时间;
    2. 用户的请求不再直接访问服务，而是通过线程池中的空闲线程来访问，如果线程池已满或者请求超时，则会进行降级处理;
2. 服务降级：优先保证核心服务，而非核心服务不可用或弱可用;
    1. 用户的请求故障时，不会被阻塞，更不会无限等待或者返回系统崩溃，至少可以看到一个执行结果，比如等待超过5s，
    则返回&quot;服务器繁忙&quot;的友好提示信息;
    2. 服务降级虽然导致请求失败，但不会导致阻塞，而且最多影响这个依赖服务对应的线程池中的资源，对其他服务没有影响;
3. 触发 Hystrix 服务降级的两种情况：线程池已满、请求超时;
</code></pre><h3 id="降级处理"><a href="#降级处理" class="headerlink" title="降级处理"></a>降级处理</h3><pre><code>1. 降级处理发生在服务的调用方(消费者)
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
    &lt;/dependency&gt;
    1. 在启动类上注解 @EnableCircuitBreaker，启用Hystrix，注解 @EnableHystrix 也可以，但无法启用服务熔断;
        @EnableCircuitBreaker
        @EnableDiscoveryClient
        @SpringBootApplication
        public class ConsumerApplication {
            @Bean
            @LoadBalanced
            public RestTemplate getRestTemplate() {
                return new RestTemplate();
            }
            public static void main(String[] args) {
                SpringApplication.run(ConsumerApplication.class, args);
            }
        }
    2. @SpringCloudApplication = @EnableCircuitBreaker+@EnableDiscoveryClient+@SpringBootApplication
        @SpringCloudApplication
        public class ConsumerApplication {
            ...
        }
    3. 在Controller方法上注解 @HystrixCommand 开启降级处理，fallbackMethod属性指定错误处理的方法名;
        @GetMapping(&quot;{id}&quot;)
        @HystrixCommand(fallbackMethod = &quot;findByIdFallback&quot;)
        public String findById(@PathVariable(&quot;id&quot;) Long id) {
            String url = &quot;http://user-service/user/&quot; + id;
            String user = rest.getForObject(url, String.class);  //返回一个字符串，不再转为POJO对象
            return user;
        }

        public String findByIdFallback(Long id) {
            return &quot;服务器繁忙！&quot;
        }
    4. 熔断的降级处理方法与正常请求的方法：参数列表和返回值必须保证一致！
2. 在服务提供方加延迟，模拟降级处理
    @Service
    public class UserService {
        @Autowired
        private UserMapper mapper;
        public User findById(Long id) {
            Thread.sleep(2000L);
            return mapper.selectByPrimaryKey(id);
        }
    }
3. 启用降级处理后，默认超过 1s 获取不到响应结果，就会触发服务降级;
    http://localhost:8080/consumer/9  --&gt; 服务器繁忙！
4. @DefaultProperties：注解在Controller类上，配置默认Fallback
    @RestController
    @RequestMapping(&quot;consumer&quot;)
    @DefaultProperties(defaultFallback = &quot;defFallback&quot;)
    public class ConsumerController {
        @Autowired
        private RestTemplate rest;

        @GetMapping(&quot;{id}&quot;)
        @HystrixCommand  -------&gt; 启用降级
        public String findById(@PathVariable(&quot;id&quot;) Long id) {
            String url = &quot;http://user-service/user/&quot; + id;
            String user = rest.getForObject(url, String.class);
            return user;
        }

        public String defFallback() {
            return &quot;服务器繁忙！&quot;
        }
    }
    1. 默认Fallback指向的方法不能有参数列表;
    2. 访问：http://localhost:8080/consumer/9  --&gt; 服务器繁忙！
5. @HystrixCommand 的属性 commandProperties 可以配置方法的超时时间，不同的业务配置不同的超时时间;
    @GetMapping(&quot;{id}&quot;)
    @HystrixCommand(commandProperties = {
        @HystrixPropery(name=&quot;execution.isolation.thread.timeoutInMilliseconds&quot;, value=&quot;2000&quot;) #2s超时
    })
    public String findById(@PathVariable(&quot;id&quot;) Long id) {
        ...
    }
6. 在消费者的配置文件中，全局配置默认超时时间，同时 @HystrixCommand 中不要再配置超时属性commandProperties;
    hystrix:
        command:
            default:
                execution:
                    isolation:
                        thread:
                            timeoutInMilliseconds: 3000  #3s超时
7. 另外，还可以只针对某个调用的服务，甚至某个Controller方法去配置超时时间;
    hystrix:
        command:
            default:
                execution:
                    isolation:
                        thread:
                            timeoutInMilliseconds: 3000  # 默认超时时间
            user-service:  #调用该服务时，启用降级处理的超时时间
                execution:
                    isolation:
                        thread:
                            timeoutInMilliseconds: 3000
            findById:  #调用该方法时，启用降级处理的超时时间
                execution:
                    isolation:
                        thread:
                            timeoutInMilliseconds: 3000
</code></pre><h3 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h3><pre><code>1. 熔断器又叫断路器，Circult Breaker，类似电路熔断器(保险丝)，如果发生短路，立刻熔断电路，避免发生灾难;
2. 在分布式系统中，服务调用方可以自己判断某些服务反应慢或者存在大量超时的情况时，能够主动熔断，防止整个系统被拖垮;
3. 不同于保险丝不会重连，Hystrix可以实现弹性容错，当情况好转后，可以自动重连;
4. @EnableCircuitBreaker：注解在启动器上，同时会启用Hystrix熔断器;
5. Hystrix的熔断机模型
</code></pre><p><img src="//hellomyshadow.github.io/2016/05/03/SpringCloud组件2/熔断器模型.jpg" alt="Zuul"></p>
<pre><code>    1. 三种状态：Closed、Open、Half Open
    2. Closed：熔断器关闭状态，所有请求都能正常访问;
    3. Open：熔断器打开，所有请求被降级处理;
    4. 默认情况下，如果请求次数超过20，且失败比例达到50%(阈值)，则打开熔断器;
    5. Half Open：熔断器处于半开状态;
6. Open状态不是永久的，它会进入休眠状态(默认5s)，称为休眠时间窗，随后熔断器会自动进入半开状态，放进来一部分请求，
   测试该服务是否正常，如果请求仍然失败，则重新进入Open状态，直到放进的请求完全成功，才会进入Closed状态;
    1. 默认请求次数：circuitBreaker.requestVolumeThreshold = 20
    2. 默认失败比率：circuitBreaker.errorThresholdPercentage = 50
    3. 默认默认休眠时间(ms)：circuitBreaker.sleepWindowInMilliseconds = 5000
7. 在服务消费者中，通过抛出异常的方式，手动控制熔断器断开，并配置熔断器的参数;
    1. 对同一个服务发起10次请求，超过6次都是失败的，则开启熔断器; 休眠10s后，进入半开状态，放进一部分请求;
    @GetMapping(&quot;{id}&quot;)
    @HystrixCommand(commandProperties = {
        @HystrixProperty(name=&quot;circuitBreaker.requestVolumeThreshold&quot;, value=&quot;10&quot;),   #10次请求
        @HystrixProperty(name=&quot;circuitBreaker.errorThresholdPercentage&quot;, value=&quot;60&quot;), #失败比率60%
        @HystrixProperty(name=&quot;circuitBreaker.sleepWindowInMilliseconds&quot;, value=&quot;10000&quot;), #休眠时间10s
    })
    public String findById(@PathVariable(&quot;id&quot;) Long id) {
        if(id%2 == 0) {
            throw new RuntimeException(&quot;&quot;); //抛出异常会直接触发熔断
        }
        String url = &quot;http://user-service/user/&quot; + id;
        String user = rest.getForObject(url, String.class);
        return user;
    }
    2. 测试：
        http://localhost:8080/consumer/1  --&gt; 正常返回
        http://localhost:8080/consumer/2 --&gt; 抛出异常，服务降级处理，返回&quot;服务器繁忙！&quot;
    3. 快速访问 http://localhost:8080/consumer/2 超过10次 -&gt;再立即访问 http://localhost:8080/consumer/1
    请求也会被降级处理，返回 &quot;服务器繁忙！&quot;，10s后又可以正常获取数据;
</code></pre><h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><pre><code>1. Feign：简化服务调用，可以把Rest的请求进行隐藏，伪装成类似SpringMVC的Controller，无需再拼接URL、参数等等;
    String url = &quot;http://user-service/user/&quot; + id;
    String user = rest.getForObject(url, String.class);
2. 在服务消费者中
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
    &lt;/dependency&gt;
    1. Feign内部已经依赖了Ribbon和Hystrix，所以在 pom.xml 不用手动引入Ribbon依赖，但Hystrix依赖最好还要引入;
    2. @EnableFeignClients：注解在在启动器类，启用Feign，并去除RestTemplate的注册;
    @EnableFeignClients
    @SpringCloudApplication
    public class ConsumerApplication {
        public static void main(String[] args) {
            SpringApplication.run(ConsumerApplication.class, args);
        }
    }
3. Feign客户端接口
    @FeignClient(&quot;user-service&quot;)  --&gt; 服务ID
    public interface UserClient {
        @GetMapping(&quot;user/{id}&quot;)  --&gt; 请求资源路径，SpringMVC的注解
        User findById(@PathVariable(&quot;id&quot;) Long id);
    }
    1. @FeignClient：声明Feign客户端，指定服务ID，再交给Ribbon实现负载均衡;
    2. 客户端中的方法上完全使用 SpringMVC 的注解，Feign会根据注解生成URL;
    3. Feign会通过动态代理，为Feign客户端接口生成实现类，类似Mybatis的mapper;
4. Web层，使用Feign客户端发起请求
    @RestController
    @RequestMapping(&quot;consumer&quot;)
    public class ConsumerController {
        @Autowired
        private UserClient client;

        @GetMapping(&quot;{id}&quot;)
        public User findById(@PathVariable(&quot;id&quot;) Long id) {
            User user = client.findById(id);
            return user;
        }
    }
5. Feign内部集成了Ribbon依赖和自动配置，在配置文件中配置Ribbon的超时时间
    ribbon:
        ConnectTimeout: 1000  # 连接超时时间
        ReadTimeout: 3000  # 读取数据的超时时间
    1. ConnectTimeout：Ribbon连接服务的超时时间，默认1000ms，超过1000ms没有连接上服务，则抛出异常;
    2. ReadTimeout：Ribbon读取数据的超时时间，默认1000ms，超过1000ms还没有获取到响应，则抛出异常;
</code></pre><h3 id="Feign集成Hystrix"><a href="#Feign集成Hystrix" class="headerlink" title="Feign集成Hystrix"></a>Feign集成Hystrix</h3><pre><code>1. 默认是关闭的，在配置文件中开启
    feign:
        hystrix:
            enabled: true  # 开启Feign的熔断功能
2. 在 @FeignClient 中配置属性 fallback，属性值是一个类.class，且这个类要实现注解的接口，用于处理服务降级;
    @FeignClient(value = &quot;user-service&quot;, fallback = UserClientFallback.class)
    public interface UserClient {
        @GetMapping(&quot;user/{id}&quot;)
        User findById(@PathVariable(&quot;id&quot;) Long id);
    }
    @Component
    public class UserClientFallback implements UserClient {
        public User findById(Long id) {  // 服务降级的处理
            User u = new User();
            u.setId(id);
            u.setName(&quot;未知用户！&quot;);
            return u;  //响应数据
        }
    }
3. 关闭 user-service 服务，访问服务消费者：http://localhost:8080/consumer/1
</code></pre><h3 id="请求压缩"><a href="#请求压缩" class="headerlink" title="请求压缩"></a>请求压缩</h3><pre><code>1. Feign支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗;
2. 开启压缩
    feign:
        compression:
            request:
                enabled: true  #开启请求压缩
                mime-types: text/html,application/xml,application/json  #设置压缩的数据类型
                min-request-size: 2048  # 触发压缩的大小下限
            response:
                enabled: true  #开启响应压缩
</code></pre><h3 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h3><pre><code>1. 通过 logging.level.xx=debug 来设置日志级别，但是它对Feign客户端没有效果，因为 @FeignClient 注解的客户端
   在动态代理时，都会生成一个新的 Feign.Logger 实例，需要额外指定它的日志级别;
2. 设置 cn.cloud 包下的日志级别都是 debug
    logging:
        level:
            cn.cloud: debug
3. 使用配置类定义日志级别
    @Configuration
    public class FeignConf {
        @Bean
        Logger.Level feignLoggerLevel() {
            return Logger.Level.FULL;  //设置日志级别为FULL，另外还有 NONE、BASIC、HEADERS...
        }
    }
    1. NONE：不记录任何日志信息，默认值；
    2. BASIC：仅记录请求的方法、URL以及响应状态码和执行时间；
    3. HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息；
4. 在Feign客户端的注解上，指定配置类
    @FeignClient(value = &quot;user-service&quot;, 
        fallback = UserClientFallback.class, configuration = FeignConf.class)
    public interface UserClient {
        @GetMapping(&quot;user/{id}&quot;)
        User findById(@PathVariable(&quot;id&quot;) Long id);
    }
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/05/02/SpringCloud组件1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/02/SpringCloud组件1/" itemprop="url">SpringCloud组件1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-02T00:00:00+08:00">
                2016-05-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><pre><code>1. Eureka注册中心：服务的管理
    1. Eureka负责管理、记录服务提供者的信息，服务调用者无需自己去查找服务，而是把自己的需求告诉Eureka，
    由Eureka把查找符合的服务提供者;
    2. 服务提供者与Eureka之间通过 心跳机制 进行监控，当某个服务提供者出现问题，Eureka会把它从服务列表中剔除;
    3. 这样就是实现了服务的自动注册、发现、状态监控;
2. Eureka的基本架构
</code></pre><p><img src="//hellomyshadow.github.io/2016/05/02/SpringCloud组件1/Eureka.jpg" alt="Eureka"></p>
<pre><code>    1. Eureka既是服务注册中心，也是一个独立的服务，还可以是一个集群，对外暴露自己的地址;
    2. 服务提供者：启动后向Eureka注册自己的信息，包括地址、提供什么服务;
    3. 服务消费者：向Eureka订阅服务，Eureka会将对应服务的地址列表发送给消费者，并定期更新;
    4. 心跳：服务提供者定期通过HTTP向Eureka刷新自己的状态;
3. Eureka架构的三个核心角色
    1. 服务注册中心：Eureka的服务端应用，提供服务注册和发现功能;
    2. 服务提供者：提供服务的应用，可以是SpringBoot应用，也可以是其他任意技术实现，对外提供Rest风格的服务;
    3. 服务消费者：消费应用从注册中心获取服务列表，从而得知每个服务提供者的信息，知道去哪儿调用服务;
4. 创建子工程eurekaserver，作为Eureka服务注册中心
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
    &lt;/dependency&gt;
    1. application.yml
        server:
            port: 8761  #官方默认的Eureka端口号
    2. 创建启动器，并注解 @EnableEurekaServer 启用Eureka
        @EnableEurekaServer
        @SpringBootApplication
        public class EurekaServer {
            public static void main(String[] args) {
                SpringApplication.run(EurekaServer.class, args);
            }
        }
5. SpringCloud的Eureka依赖中，已经实现了服务的发现、注册、状态监控等功能;
6. 启动服务，访问注册中心的管理平台：http://localhost:8761/
</code></pre><h3 id="报错问题"><a href="#报错问题" class="headerlink" title="报错问题"></a>报错问题</h3><pre><code>1. 导致无法启动的版本问题：java.lang.NoSuchMethodError: com.google.gson.GsonBuilder.setLenient()
2. 启动时可能不停地报 eureka-client的相关错误，但能访问注册中心
    1. Eureka是一个注册中心，一定不能宕掉，所以会搭建Eureka服务集群，而集群中的Eureka之间也需要注册和通信;
    2. 所以Eureka既是服务端，又是客户端，Eureka服务启动时会尝试注册其他Eueka服务，但又没有其他Eureka服务可以注册，
    所以才会报错;
    3. 解决方式：让当前Eureka服务注册自己，在 application.yml 中配置注册地址;
    eureka:
        client:
            service-url:
                defaultZone: http://127.0.0.1:8761/eureka
    4. 重新启动服务，会报错一次，因为自己还没有启动完成，所以会注册失败一次;
3. Eureka服务注册中心作为客户端尝试注册自己时，也可能报错：
    java.net.ConnectException: Connection refused: connect
    TransportException: Cannot execute request on any known server
    1. 解决方式：禁用它的客户端注册行为，不让Eureka注册自己;
        eureka:
            client:
                service-url:
                    defaultZone: http://127.0.0.1:8761/eureka
                register-with-eureka: false
                fetch-registry: false
    2. 禁用了Eureka的注册行为之后，Eureka注册中心的服务列表上就不会再列出当前Eureka服务了.
4. 在服务启动时，可能使用的是当前主机的拨号IP地址，而不是回环地址，则在配置文件中明确指定使用IP地址;
    eureka:
        instance:
            prefer-ip-address: true
            ip-address: 127.0.0.1
5. 在注册中心的服务列表上显示UNKNOWN，是因为没有配置服务名称，通常情况下会把服务名称作为服务的ID;
    spring:
        application:
            name: eureka-server  # 配置Eureka服务名称
</code></pre><h3 id="服务的注册"><a href="#服务的注册" class="headerlink" title="服务的注册"></a>服务的注册</h3><pre><code>1. 服务提供者
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
    &lt;/dependency&gt;
    1. application.yml
        spring:
            application:
                name: user-service  # 指定服务名称
            datasource:
                ......
        eureka:
            client:
                service-url:
                    defaultZone: http://127.0.0.1:8761/eureka  # 配置注册中心的地址
    2. @EnableDiscoveryClient：注解在启动器上，启动自动注册服务，不要使用 @EnableEurekaClient;
    3. SpringCloud集成的注册中心不仅仅只有Eureka，还有consul、Zookeeper... @EnableDiscoveryClient都能兼容;
        @EnableDiscoveryClient
        @SpringBootApplication
        @MapperScan(&quot;cn.cloud.mapper&quot;)
        public class UserApplication {
            ...
        }
    4. SpringBoot版本和SpringCloud版本不兼容时，启动时可能报错：
        The bean &apos;dataSource&apos;, defined in BeanDefinition defined ... and overriding is disabled.
2. 服务消费者
    1. 引入Eureka客户端的依赖、添加注解@EnableDiscoveryClient、修改配置文件;
        spring:
            application:
                name: consumer-service
        eureka:
            client:
                service-url:
                    defaultZone: http://127.0.0.1:8761/eureka
    2. web层：根据服务ID获取服务实例，调用服务功能
        @RestController
        @RequestMapping(&quot;consumer&quot;)
        public class ConsumerController {
            @Autowired
            private RestTemplate rest;

            @Autowired
            private DiscoveryClient client;

            @GetMapping(&quot;{id}&quot;)
            public User findById(@PathVariable(&quot;id&quot;) Long id) {
                //获取服务的实例并不是一个，是因为在集群环境中，一个服务可以启动多次
                List&lt;ServiceInstance&gt; instances =  client.getInstances(&quot;user-service&quot;); 
                ServiceInstance inst = instances.get(0);
                String url = &quot;http://&quot; + inst.getHost() + &quot;:&quot; + inst.getPort() + &quot;/user/&quot; + id;
                User user = rest.getForObject(url, User.class);
                return user;
            }
        }
3. 先启动Eureka服务，再启动其他两个服务;
    1. 查看注册中心的服务列表，有三个服务：EUREKA-SERVER、USER-SERVICE、CONSUMER-SERVICE
    2. 测试服务的消费方：http://localhost:8080/consumer/9
</code></pre><h3 id="Eureka集群"><a href="#Eureka集群" class="headerlink" title="Eureka集群"></a>Eureka集群</h3><pre><code>1. 多个Eureka服务注册中心相互注册为服务，形成一个高可用的Eureka注册中心集群;
2. 服务同步：当服务注册到Eureka集群中的某个节点时，它会把服务的信息同步给集群中的每个节点，从而实现数据同步;
    1. 注册中心之间相互注册，比如A、B、C三个注册中间，A注册B、C，B注册A、C，C注册A、B
        Eureka-1 &lt;===&gt; Eureka-2
        Client ==&gt; Eureka-1， Client ==&gt; Eureka-2
    2. 一个服务注册到任意一个注册中心上，都可以获取到完整的服务列表.
3. 搭建注册中心的集群：采用一个Eureka服务、多个实例的方式;
    1. 修改工程eureka-server，注册另一个端口号为8762的Eureka服务
        server:
            port: 8761
        spring:
            application:
                name: eureka-server
        eureka:
            client:
                service-url:
                    defaultZone: http://127.0.0.1:8762/eureka
    2. 启动服务，读取配置文件，此时因为找不到端口号8762的Eureka服务，控制台会不停报错;
    3. IDEA不允许同一个应用启动两次，但可以复制启动器：
    Edit Configurations... --&gt; 选中 EurekaServer(eureka-server工程) --&gt; 复制 --&gt; 
        Name: EurekaServer2，(Configuration，VM options: -Dserver.port=8762，固定使用端口号8762)
    4. 修改工程eureka-server的配置文件：端口号8762，注册到端口号8761的Eureka服务上
    server:
        port: 8762 
    eureka:
        client:
            service-url:
                defaultZone: http://127.0.0.1:8761/eureka
    5. 启动 EurekaServer2 服务(8762)，它就会注册到已经启动的 EurekaServer 服务(8761)上;
    6. 同时，EurekaServer(8761)也会发现并注册到 EurekaServer2(8762)上，停止报错;
4. EurekaServer(8761) 和 EurekaServer2(8762) 的 spring.application.name 是相同的，这就是一个服务多个实例;
    1. 它们之间会共享服务列表信息，从而实现Eureka服务注册中心的集群;
    2. 访问8761和8762的注册中心，它们的服务列表是相同的，且 eureka-server 服务显示有两个实例;
5. 启动的问题：eureka-server 服务并没有两个实例，8761注册不了8762，而且8762上的服务实例不稳定，会变成1个;
    1. 让Eureka在注册其他Eureka时，同时注册自己;
    eureka:
        client:
            service-url:
                defaultZone: http://127.0.0.1:8761/eureka, http://127.0.0.1:8762/eureka
    2. 但是，测试发现这种方式并不完全有效，需要继续探索...
6. 客户端(服务提供者和消费者)的注册：
    1. 服务要注册到Eureka集群上，必须要注册到每一个Eureka节点上;
    2. 多个Eureka注册中心的地址以 , 隔开
    spring:
        application:
            name: consumer-service
    eureka:
        client:
            service-url:
                defaultZone: http://127.0.0.1:8761/eureka, http://127.0.0.1:8762/eureka
</code></pre><h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><pre><code>1. 客户端启动时会检测配置文件中的 eureka.client.register-with-eureka 参数，默认值为true;
2. 如果为true，则会向EurekaServer发起一个Rest请求，并携带自己的元数据信息，EurekaServer会把这些信息保存到
    一个双层Map结构中： Map&lt;String, Map&lt;String, ServiceInstance&gt;&gt;
    1. 第一层Map的key就是服务的ID，一般就是配置的 spring.application.name
    2. 第二次Map的key是服务的实例ID，一般为host+serviceId+port，如 localhost:user-service:8081
    3. 值是服务的实例对象，也就是说，一个服务可以同时启动多个实例，从而形成集群;
3. 如果配置为false，那么它就不会申请注册服务；同理，如果EurekaServer配置了这个参数为false，它也不会注册自己了;
</code></pre><h3 id="服务续约"><a href="#服务续约" class="headerlink" title="服务续约"></a>服务续约</h3><pre><code>1. 服务续约(renew)：在注册服务完成后，客户端会维持一个心跳，定时向Eureka服务发起Rest请求，说明自己处于活跃状态;
2. 有两个重要参数可以修改服务续约的行为：
    eureka:
        instance:
            lease-renewal-interval-in-seconds: 30  # 服务续约的间隔，默认30s
            lease-expiration-duration-in-seconds: 90  # 服务失效时间，默认90s
    1. 服务每隔 30s 向注册中心发送一次心跳，证明自己处于活跃状态;
    2. 如果超过 90s 还没有发送心跳，EurekaService就认为该服务宕机了;
3. 服务还会从EurekaService中自动拉取当前的服务列表，并缓存在本地，默认每隔 30s 重新拉取并更新数据;
    eureka:
        client:
            fetch-registry: true  # 是否从注册中心拉取数据，默认为true
            registry-fetch-interval-seconds: 30  # 每次拉取数据的间隔时间，默认30s
4. 默认每隔30s拉取一次服务列表，所以刚刚启动的服务消费者无法访问服务提供者;
</code></pre><h3 id="失效剔除"><a href="#失效剔除" class="headerlink" title="失效剔除"></a>失效剔除</h3><pre><code>1. 服务正常关闭时，它会触发一个 服务下线 的REST请求给Eureka服务，注册中心接收到之后，会把该服务置为下线状态;
2. 失效剔除
    1. 有时候可能由于内存溢出或网络故障等原因，导致服务不能正常工作，而服务注册中心并未受到&quot;服务下线&quot;的请求;
    2. 相对于renew，注册中心在启动时会创建一个定时任务，默认每隔60s将当前列表中超过失效时间(默认90s)的服务剔除;
3. 在注册中心的配置文件中，修改定时任务的轮询时间;
    eureka:
        server:
            eviction-interval-timer-in-ms: 60000  #默认60s
</code></pre><h3 id="自我保护"><a href="#自我保护" class="headerlink" title="自我保护"></a>自我保护</h3><pre><code>1. 关闭一个服务时，就会在注册中心的管理平台上出现一条警告：EMERGENCY... BE SAFE. 这就触发了Eureka的自我保护机制;
2. 当服务未按时进行服务续约时，Eureka会统计服务实例最近15min心跳续约的比例是否低于85%;
3. 在生产环境下，因为网络延迟等原因，服务续约超时的比例很可能超标，但此时就把服务从列表中剔除并不妥当，
   因为服务可能没有宕机，Eureka在这段时间内不会剔除任何服务，直到网络恢复正常;
4. 从而保证在生产环境下，大多数服务依然可用，不过也有可能获取到失败的服务实例，因此服务消费者必须做服务的失败容错;
5. 在注册中心关闭自我保护，默认是打开的
    eureka:
        server:
            enable-self-preservation: false  # 默认为true
</code></pre><h2 id="负载均衡之Ribbon"><a href="#负载均衡之Ribbon" class="headerlink" title="负载均衡之Ribbon"></a>负载均衡之Ribbon</h2><pre><code>1. 在集群环境下，服务提供方会有很多个实例，服务消费者在获取服务列表后，就需要通过负载均衡算法选择一个服务实例;
2. Eureka中集成了Netflix发布的负载均衡组件：Ribbon
3. Ribbon默认提供了很多负载均衡算法，如轮询、随机、Hash... 还可以自定义负载均衡算法;
4. 复制一份服务提供者user-service --&gt; Name: UserApplication2，VM options: -Dserver.port=8082
5. 在服务消费者中
    1. 引入Ribbon依赖
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;
        &lt;/dependency&gt;
    2. 方式一：获取服务实例(不常用)
        @Autowired
        private RestTemplate rest;

        @Autowired
        private RibbonLoadBalancerClient client;  //另外还要注册Bean对象

        @GetMapping(&quot;{id}&quot;)
        public User findById(@PathVariable(&quot;id&quot;) Long id) {
            //默认负载均衡算法是轮询
            ServiceInstance instance = client.choose(&quot;user-service&quot;); 
            String url = &quot;http://&quot; + inst.getHost() + &quot;:&quot; + inst.getPort() + &quot;/user/&quot; + id;
            User user = rest.getForObject(url, User.class);
            return user;
        }
    3. 方式二：在注册 RestTemplate 的方法上注解 @LoadBalanced
        @Bean
        @LoadBalanced
        public RestTemplate getRestTemplate() {
            return new RestTemplate();
        }
        1. @LoadBalanced 内置拦截器会拦截 RestTemplate 的请求，通过负载均衡算法选择一个服务实例;
        2. 发起请求的URL：http://服务ID/资源路径
        @GetMapping(&quot;{id}&quot;)
        public User findById(@PathVariable(&quot;id&quot;) Long id) {
            String url = &quot;http://user-service/user/&quot; + id;
            User user = rest.getForObject(url, User.class);
            return user;
        }
6. 负载均衡策略
    1. Ribbon默认采用的负载均衡策略是轮询，对应的规则对象RoundRobinRule
    2. 修改方式：服务ID.ribbon.NFLoadBalancerRuleClassName，值就是IRule的实现类
    3. 在服务消费者中配置
    user-service:  # 查找的服务实例
        ribbon:
            NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule  #采用随机规则的负载均衡策略
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/05/01/SpringCloud/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/01/SpringCloud/" itemprop="url">SpringCloud</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-01T00:00:00+08:00">
                2016-05-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><pre><code>1. 集中式架构
    用户 --&gt; [商品管理&lt;-&gt;订单管理&lt;-&gt;用户管理&lt;-&gt;购物车管理&lt;-&gt;权限管理&lt;-&gt;内容管理] --&gt; 数据库
    1. 代码耦合、开发维护困难;  无法针对性优化不同模块;
    2. 无法水平扩展;  单点容错率底，并发能力差;
2. 垂直拆分
    用户 --&gt; [用户中心、搜索系统、后台管理、认证中心] --&gt; 数据库
    1. 系统拆分实现了流量分担，解决了并发问题;
    2. 各个模块独立，可以针对性优化不同模块;
    3. 方便水平扩展，负载均衡，容错率提供;
    4. 缺点：系统间相互独立，会造成很多重复开发工作，影响开发相率;
3. 分布式服务
    1. 当垂直应用越来越多时，应用之间的交互不可避免，那么就将核心业务提取出来，作为独立的服务，
    逐渐形成稳定的服务中心，使前端应用能更快地响应多变地市场需求;
    2. 关键在于：提高业务复用及整合的分布式调用;
</code></pre><p><img src="//hellomyshadow.github.io/2016/05/01/SpringCloud/分布式服务.jpg" alt="分布式服务"></p>
<pre><code>    1. 优点：抽取了基础服务，系统间相互调用，提高了代码复用和开发效率;
    2. 缺点：系统间耦合度变高，调用关系错综复杂，难以维护;
4. 流动计算框架(SOA)，面向服务的架构，服务治理
    1. 当服务越来越多，容量的评估、小服务资源的浪费等问题逐渐显现，此时需要增加一个调度中心，
    基于访问压力实时管理集群容量，提高集群利用率;
    2. 关键在于，提高机器利用率的资源和治理中心(SOA)
</code></pre><p><img src="//hellomyshadow.github.io/2016/05/01/SpringCloud/SOA.jpg" alt="SOA"></p>
<pre><code>1. 服务注册中心：实现服务自动注册和发现，无需手动记录服务地址;
2. 服务自动订阅：服务列表自动推送，服务调用透明化，无需关心依赖关系;
3. 动态监控服务状态的监控报告，手动控制服务状态;
4. 缺点：
    1. 服务间会有依赖关系，一旦某个环节出错，会影响较大;
    2. 服务关系复杂，运维、测试部署困难，不符合DevOps思想;
</code></pre><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><pre><code>1. 微服务看起来与SOA类似，也是服务，都是对系统进行拆分，但还是有一些差别的;
</code></pre><p><img src="//hellomyshadow.github.io/2016/05/01/SpringCloud/微服务架构.jpg" alt="微服务架构"></p>
<pre><code>2. 微服务的特点：
    1. 单一职责：微服务中每一个服务都对应唯一的业务能力，做到单一职责；
    2. 微：服务拆分的粒度很小，比如一个用户管理就可以作为一个服务，每个服务虽小，但&quot;五脏俱全&quot;；
    3. 面向服务：每个服务都要对外暴露Rest风格的服务接口，外界不关心服务的技术实现，从而做到与平台和语言无关，
    也不限定使用的技术，只要提供Rest的接口即可;
    4. 自治：服务间相互独立，互不干扰;
        1. 团队独立：每个服务都是一个独立的开发团队，人数不能过多;
        2. 技术独立：因为是面向服务，只需要提供Rest接口，无关使用什么技术实现;
        3. 前后端分离：采用前后端分离开发，提供统一的Rest接口，后台不再为PC、移动端开发不同接口;
        4. 数据库分离：每个服务都使用自己的数据源;
        5. 部署独立：服务间虽有调用，但要做到服务重启不影响其他服务，有利于持续集成和持续交付，
        每个服务都是独立的组件，可复用，可替换，降低耦合，易维护;
3. 服务拆分的临界点是非常模糊的，需要对架构非常了解，拥有丰富的经验，具体业务具体分析。
</code></pre><h2 id="服务调用方式"><a href="#服务调用方式" class="headerlink" title="服务调用方式"></a>服务调用方式</h2><pre><code>1. 无论是微服务还是SOA，都面临着服务间的远程调用问题，常见的两种远程调用方式：RPC、HTTP
2. RPC：Remote Produce Call，远程过程调用，类似的还有RMI
    1. 自定义数据格式，基于原生TCP通信，速度快，效率高;
    2. 早期的WebService，还有当前热门的Dubbo，都是RPC的典型代表;
3. HTTP：一种网络传输协议，规定了数据传输的格式
    1. 缺点：消息封装臃肿，相对于RPC，传输速度会慢一些;
    2. 优势：对服务的提供和调用方没有任何技术限定，自由灵活，更符合微服务的理念;
    3. 现在热门的Rest风格，就可以通过HTTP协议来实现;
4. 如果完全采用Java技术栈，Dubbo作为微服务架构是一个不错的选择;
5. 如果技术栈多样化，而且比较青睐Spring家族，那么SpringCloud搭建微服务是不二之选;
</code></pre><h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><pre><code>1. Java代码间相互调用的主流HTTP客户端：HttpURLConnection(JDK)、HttpClient(Apache)、OKHttp... 
2. Spring提供了一个模板工具类 RestTemplate ，基于HTTP客户端的封装，并且实现了对象的JSON的序列化和反序列化;
3. RestTemplate抽象了HTTP客户端的类型，目前常用的 HttpURLConnection(默认方式)、HttpClient、OKHttp 都支持;
    1. 在SpringBoot项目中，引入web启动器：spring-boot-starter-web
    2. 在启动器类中，注册 RestTemplate
        @Bean
        public RestTemplate getRestTemplate() {
            return new RestTemplate();
        }
    3. 通过 RestTemplate 去请求另一个工程(端口号9999)，获取JSON数据并封装到POJO对象中
        @Autowired
        private RestTemplate rest;
        @Test
        public void test() {
            User user = rest.getForObject(&quot;http:localhost:9999/user/11&quot;, User.class);
        }
4. SpringCloud
    1. SpringCloud是实现微服务的一种架构方式，背后是整个Spring全家桶;
    2. SpringCloud可以和Spring的各个框架无缝整合，完全支持SpringBoot的开发模式;
    3. Spring最擅长的就是集成，它其实是把世界上最好的框架集成到自己的项目中;
    4. SpringCloud也是整合现在非常流行的一些技术，实现注入 配置管理、服务发现、智能路由、负载均衡、熔断器、
    控制总线、集群状态...
    5. 主要涉及的组件包括：Eureka(注册中心)、Zuui(服务网关)、Ribbon(负载均衡)、Feign(服务调用)、Hystix(熔断器)
    6. 这些组件大都来自Netflix公司，它是做在线视频的，流量和压力非常大，所以SpringCloud大多采用Netflix的框架;
5. SpringCloud的版本号没有采用数字，而是A、B、C...开头的单词，据说是伦敦地铁站的名字;
    1. Angle.RELEASE：2015.3
    2. Brixton.RELEASE：2016.5
    3. Camden.RELEASE：2016.9
    4. Dalston.RELEASE：2017.4
    5. Edgware.RELEASE：2017.11，基于SpringBoot1.5以下
    6. Finchley.RELEASE：2018.6，基于SpringBoot2.0
6. SpringBoot
    1. SpringBoot1.5.0-RELEASE：2016.4
    1. SpringBoot2.0.0-RELEASE：2018.3
7. SpringCloud Finchley.RELEASE 中部分重要组件
</code></pre><p><img src="//hellomyshadow.github.io/2016/05/01/SpringCloud/SpringCloud.jpg" alt="SpringCloud"></p>
<h2 id="微服务的环境准备"><a href="#微服务的环境准备" class="headerlink" title="微服务的环境准备"></a>微服务的环境准备</h2><pre><code>1. SpringCloud对版本的要求极其严格，版本冲突会带来很多意想不到的问题;
2. SpringCloud Finchley.RELEASE 搭建微服务时，SpringBoot版本选择v2.0.x，不能是v2.1.x;
3. 为了操作方便，不为每个服务创建独立的工程，而是创建Maven的聚合工程;
4. 创建一个父工程，打包方式为pom，统一管理依赖版本;
    &lt;packaging&gt;pom&lt;/packaging&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.0.4.RELEASE&lt;/version&gt;
    &lt;/parent&gt;
    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
        &lt;spring-cloud.version&gt;Finchley.SR1&lt;/spring-cloud.version&gt;  ==&gt;兼容spring-boot2.0.x
        &lt;mapper.starter.version&gt;2.1.5&lt;/mapper.starter.version&gt;
        &lt;mysql.version&gt;8.0.16&lt;/mysql.version&gt;
    &lt;/properties&gt;
    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
                &lt;version&gt;${spring-cloud.version}&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;
                &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;
                &lt;version&gt;${mapper.starter.version}&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;mysql&lt;/groupId&gt;
                &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
                &lt;version&gt;${mysql.version}&lt;/version&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;version&gt;1.18.8&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
                &lt;!-- &lt;version&gt;2.0.4.RELEASE&lt;/version&gt; --&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
5. spring-cloud-dependencies：SpringCloud版本管理的pom
    1. 它管理了SpringCloud所有组件的版本，在引入这些组件时，不要再指定版本号;
    2. SpringCloud-Finchley.xx 只兼容 SpringBoot-v2.0.x
    3. SpringCloud-Greenwich.xx 可以支持 SpringBoot-v2.1.x
6. 创建子工程userservice，作为服务提供方，端口号8081
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;version&gt;2.0.4.RELEASE&lt;/version&gt;  --&gt;版本号与SpringBoot保持一致
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;
    &lt;/dependency&gt;
    1. application.yml
        server:
            port: 8081
        spring:
            datasource:
                driver-class-name: com.mysql.cj.jdbc.Driver
                url: jdbc:mysql:///db_cloud?serverTimezone=Asia/Shanghai
                username: root
                password: 123456
        mybatis:
            type-aliases-package: cn.cloud.pojo
            impl: org.apache.ibatis.logging.stdout.StdOutImpl
    2. POJO对象
        @Table(name=&quot;tb_user&quot;)
        @Data
        public class User {
            @Id
            @KeySql(useGeneratedKeys = true)
            private Long id;
            ...
        }
    3. Mapper接口
        public interface UserMapper extends Mapper&lt;User&gt; { }
    4. Service层
        @Service
        public class UserService {
            @Autowired
            private UserMapper mapper;

            public User findById(Long id) {
                return mapper.selectByPrimaryKey(id);
            }
        }
    5. Web层
        @RestController
        @RequestMapping(&quot;user&quot;)
        public class UserController {
            @Autowired
            private UserService service;

            @GetMapping(&quot;/{id}&quot;)
            public User findById(@PathVariable(&quot;id&quot;) Long id) {
                return service.findById(id);
            }
        }
    6. 启动类
        @SpringBootApplication
        @MapperScan(&quot;cn.cloud.mapper&quot;)
        public class UserApplication {
            public static void main(String[] args) {
                SpringApplication.run(UserApplication.class, args);
            }
        }
7. 创建子工程consumerservice，作为服务的消费方，端口号8080
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;version&gt;2.0.4.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    1. POJO对象
        @Data
        public class User {
            private Long id;
            ......
        }
    2. Web层
        @RestController
        @RequestMapping(&quot;consumer&quot;)
        public class ConsumerController {
            @Autowired
            private RestTemplate rest;

            @GetMapping(&quot;{id}&quot;)
            public User findById(@PathVariable(&quot;id&quot;) Long id) {
                //访问服务提供者，获取数据
                String url = &quot;http://localhost:8081/user/&quot; + id;
                User user = rest.getForObject(url, User.class);
                return user;
            }
        }
    3. 启动类
        @SpringBootApplication
        public class ConsumerApplication {
            @Bean
            public RestTemplate getRestTemplate() {
                return new RestTemplate();
            }
            public static void main(String[] args) {
                SpringApplication.run(ConsumerApplication.class, args);
            }
        }
8. 启动两个服务，点击右下角的提示：Run Dashboard -&gt; Show run ... -&gt; 弹出 Run Dashboard 窗口，便于管理服务;
    http://localhost:8081/user/9  --&gt; 测试服务的提供方
    http://localhost:8080/consumer/9  --&gt; 测试服务的消费方
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/04/10/Redis高级/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/10/Redis高级/" itemprop="url">Redis高级</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-10T00:00:00+08:00">
                2016-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><pre><code>1. Redis是一种基于C语言开发的NoSQL数据库，代码量只有3万多行，内存级别的读写，而且提供了持久化功能；
2. Redis与Memcache
    1. 它们都是非常流行的两种NoSQL数据库，都能用于服务器端的数据缓存；
    2. 实现方式：Redis是单线程，Memcache是多线程；
    3. 存储方式：Redis支持数据持久化和主从备份，数据更安全；Memcache的数据只存储在内存中，没有持久化功能；
    4. Redis除了基本的 k-v 结构，还支持多种其他复杂结构、事务等高级功能，它已经不仅仅是一个缓存服务；
    5. Memcache只支持基本的 k-v 结构，功能相对单一；
    6. 可用性：Redis支持主从复制、数据分片、哨兵监控；Memcache没有分片功能，需要从客户端支持。
3. 安装
    cd /usr/local/
    wget http://download.redis.io/releases/redis-5.0.4.tar.gz
    tar -zxvf /redis-5.0.4.tar.gz
    cd redis-5.0.4
    make &amp;&amp; make install
</code></pre><h2 id="redis-conf"><a href="#redis-conf" class="headerlink" title="redis.conf"></a>redis.conf</h2><pre><code>1. Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程
    daemonize no
2. 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件
    pidfile /var/run/redis.pid
3. Redis监听端口，默认为6379
    port 6379
4. 绑定的主机地址
    bind 127.0.0.1
5. 当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能
    timeout 300
6. 设置数据库的数量，默认为16，编号0-15，默认操作是 0 号数据库
    databases 16
    1. 虽然分了16个数据库，但其实只是逻辑划分，并不是物理地把硬盘容量分成16份;
    2. 某号数据库存储了数据之后，才会分配容量，所以完全可以把所有的数据都存储在0号数据库;
7. RDB方式的持久化，默认方式
    save 900 1
    save 300 10
    save 60 10000
8. 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩;
    rdbcompression yes
    1. 如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大.
9. 指定本地数据库文件名，默认值为dump.rdb
    dbfilename dump.rdb
10. 指定本地数据库存放目录，默认就是当前目录
    dir ./
11. 当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步
    slaveof &lt;masterip&gt; &lt;masterport&gt;
12. 当master服务设置了密码保护时，slav服务连接master的密码
    masterauth &lt;master-password&gt;
13. 设置Redis连接密码，如果配置了密码，客户端在连接Redis时需要通过AUTH &lt;password&gt;命令提供密码，默认关闭
    requirepass foobared
    1. 登录时提供密码：redis-cli -h IP地址 -p 端口号 -a 密码
    2. 在登录时不提供密码，通过 auth 命令验证密码
        redis-cli -h IP地址 -p 端口号
        &gt;&gt; auth 密码
14. 设置同一时间最大客户端连接数，默认无限制;
    maxclients 128
    1. Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数;
    2. 如果设置 maxclients 0，表示不作限制;
    3. 当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息.
15. 指定Redis最大内存限制
    maxmemory &lt;bytes&gt;
    1. Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key;
    2. 如果这种方式处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作;
    3. Redis新的 vm 机制会把 Key 存放内存，Value 存放在 swap 区.
16. AOF方式的持久化，默认关闭
    appendonly no
    appendfilename appendonly.aof
    appendfsync everysec  # no  always  everysec
17. 指定包含的其它配置文件
    include /path/to/local.conf
    1. 在同一主机上，多个Redis实例可以使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件.
</code></pre><h3 id="远程访问"><a href="#远程访问" class="headerlink" title="远程访问"></a>远程访问</h3><pre><code>1. Redis默认不允许远程访问，修改配置文件：
    1. bind 127.0.0.1 # 注释掉 或者 改为本机的IP地址
    2. protected-mode no  # 如果不设置密码，则关闭保护模式
    3. deamonize yes  # 后台启动运行Redis
2. Redis数据库由一个整数索引标识，而不是一个具体的数据库名称，默认操作的数据库是0号;
    1. select 数据库索引：切换数据库;
    2. move key 数据库索引：移动key到指定数据库;
    3. flushdb：清空当前数据库的key;
    4. flushall：清空所有数据库的key.
</code></pre><h3 id="数据淘汰策略"><a href="#数据淘汰策略" class="headerlink" title="数据淘汰策略"></a>数据淘汰策略</h3><pre><code>1. Redis脚本：Redis使用 Lua 解释器来执行脚本，Redis2.6通过内嵌支持 Lua 环境，执行脚本的常用命令为 EVAL
2. Redis数据淘汰策略
    1. Redis官方的警告：当内存不足时，Redis会根据配置的缓存策略淘汰部分Key，以保证写入成功;
    2. 当无淘汰策略 或者没有找到合适的key时，Redis直接返回 Out of Memory 错误;
    3. 在配置文件 redis.conf 中，允许设置的最大缓存大小：maxmemory 512G
3. Redis提供的数据淘汰策略
    1. volatile-lru：从已设置过期时间的数据集中，挑选最近最少使用的数据淘汰;
    2. volatile-lfu：从已设置过期的key中，淘汰一段时间内使用次数最少的;
    3. volatile-ttl：从已设置过期时间的数据集中，淘汰最近将要过期的数据;
    4. volatile-random：从已设置过期时间的数据集中，随机选择淘汰的数据;
    5. allkeys-lru：从数据集中，淘汰最近最少使用的数据;
    6. allkeys-lfu：从所有key中，淘汰一段时间内使用次数最少的;
    7. allkeys-random：从数据集中，随机选择淘汰的数据;
    8. no-enviction：不采用任何淘汰策略，默认配置.
4. 在平时使用时，应尽量主动设置/更新key的过期时间，主动剔除不活跃的旧数据，有助于提升查询性能.
</code></pre><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><pre><code>1. RDB：默认持久化方案，当满足一定条件时，Redis会自动将内存中的数据全部持久到硬盘文件中;
    1. 在配置文件redis.conf中配置RDB的条件：save (time) (count)
    2. 当满足在time(秒)时间内，至少进行了count次修改后，触发持久化条件，进行RDB快照
2. 默认配置(三者是或的关系)
    save 900 1  # 15分钟内，有至少1个键被更改，则触发RDB快照
    save 300 10  # 5分钟内，有至少10个键被更改
    save 60 10000  # 1分钟内，至少有10000个键被更改
3. 以快照的方式写入到二进制文件中，默认文件名：dump.rdb
    dbfilename dump.rdb  #本地数据库文件
    dir  ./  #本地数据库的存放路径，./ 表示当前目录
4. 快照：保存数据、还原数据极快，适用于灾难性备份;
5. 触发快照的条件，除了配置文件中配置的RDB快照，在服务器正常关闭时，shutdown，也会触发快照;
2. RDB的流程：
    1. Redis使用fork函数来复制一份当前进程(父进程)的副本(子进程);
    2. 父进程继续接收并处理请求，子进程开始把内存中的数据写入硬盘中的临时文件;
    3. 子进程写完后，会使用临时文件替代旧的RDB文件;
</code></pre><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><pre><code>1. AOF：把每一条服务端接收到的写命令都记录下来，每隔一定时间，写入硬盘的AOF文件中;
    1. 当服务器重启后，重新执行这些命令，恢复数据;
    appendonly yes  # 开启AOF
    2. 每收到写命令时，都会记录到文件中，默认文件名：appendonly.aof
2. 这种方式没有RDB快照的限制，适用于Redis意外宕机的数据恢复;
3. AOF的缺点也很明显，占用较大的内存，所以Redis的默认持久化策略是RDB
4. AOF写入的频率：同步策略三选一
    appendfsync always  # 每次都同步(最安全但最慢)
    appendfsync everysec  # 每秒同步(默认)
    appendfsync no  # 不主动同步，由操作系统来决定(最快但不安全)
    1. 默认情况下，文件会先写入到系统的缓存中，系统每30s同步一次，才会真正写入到硬盘;
    2. 如果在这30s内，服务器宕机，那么数据也会丢失;
  5. AOF文件重写
      1. 当记录命令过多时，必然会出现对同一个key的多次写操作，此时只需要记录最后一条即可，前面的记录都毫无意义;
      2. 因此，当满足一定条件时，Redis会对AOF文件进行重写，移除对同一个key的多次操作命令，只保留最后一条;
    auto-aof-rewrite-percentage 100
    1. 当前的AOF文件大小超过上一次重写时的AOF文件大小的百分之多少时，会再次进行重写;
    2. 如果之前没有重写过，则以启动时的AOF文件大小为依据;
    auto-aof-rewrite-min-size 64mb
    1. 限制允许重写的最小AOF文件大小，通常在AOF文件很小的时候、即使其中有些冗余的命令，也是可以忽略的;
</code></pre><h2 id="高级命令"><a href="#高级命令" class="headerlink" title="高级命令"></a>高级命令</h2><pre><code>1. 通配符：*
    1. keys *：所有的键;
    2. keys list*：以 list 开头的所有键;
2. 过期时间
    1. expire [key] [time]：为一个已经存在的key设置过期时间;
    2. ttl [key]：查看一个key的剩余过期时间，-2 表示已经过期了，-1 表示没有设置过期时间;
    3. persist [key]：取消过期时间;
3. move [key] [数据库编号]：把key移动到指定的数据库;
4. rename [key] [newkey]：对key重命名
5. dbsize：查看当前数据库的key数量
6. info：查看Redis的详细信息
7. flushdb、flushall：清空当前数据库、清空所有数据库
8. config get *：查看 redis.conf 的所有配置项
</code></pre><h2 id="订阅发布"><a href="#订阅发布" class="headerlink" title="订阅发布"></a>订阅发布</h2><pre><code>1. Redis的发布订阅是一种消息通信模式：发送者发送消息，订阅者接收消息，客户端可以订阅任意数量的频道;
2. 订阅频道
    1. subscribe 频道1 频道2 ... : 订阅指定的一个或多个频道;
    2. psubscribe 模式1 模式2... : 订阅一个或多个符合指定模式的频道;
3. 发布频道
    publish 频道1 消息
4. 退订频道
    1. unsubscribe 频道1 频道2 ...
    2. punsubscribe 模式1 模式2 ...
5. 比如：客户端1、2 订阅频道cctv5，客户端3 向频道cctv5 发布消息，客户端1、2 就会受到订阅的消息;
6. 应用：构建实时消息系统，如普通的即时聊天、群聊等功能；
    1. 在一个博客网站，有100个粉丝订阅了AA，当AA发布新文章时，就可以推送消息给这100个粉丝;
    2. 微信公众号模式;
</code></pre><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><pre><code>1. Redis事务可以一次执行多个命令，按顺序串行化执行，且执行过程中不许加塞;
    1. 批量操作在发送 EXEC 命令前被放入队列缓存;
    2. 收到 EXEC 命令后，进入事务执行，事务中任何命令执行失败，其余命令依然被执行;
    3. 在事务执行过程中，其他客户端提交的命令请求不会插入到事务执行序列中;
    4. 总的来说，Redis会将一个事务中的所有命令序列化，然后按顺序执行，且不允许出现加塞行为.
2. 事务经历的三个阶段：开启事务 --&gt; 命令入列 --&gt; 执行事务;
3. A向B转账
    multi  #开启事务，以后的命令会依次进入到序列中
    get account:a
    get account:b
    decrby account:a 50  #A减50
    incrby account:b 50  #B加50
    exec  #执行事务
4. discard：取消事务，放弃队列中的所有命令；开启了事务，但不想执行 exec 命令时，可执行 discard 命令取消事务;
5. 错误处理：
    1. 如果队列中的某个命令出现错误，比如操作的key不存在，属于逻辑业务的错误，那么这条命令不再执行，
    而其他命令仍照常执行，而且不会回滚;
    2. 但如果某个命令出现报告错误(语法错误)，比如输入的命令不存在，Redis会立即报错，那么Redis会取消事务，
    所有命令都不会执行;
6. watch/unwatch
    1. 当两个事务同时操作同一个key时，可能会导致数据的不一致;
    2. watch key key ... : 监视key，在开启事务之后、执行事务之前，这个key被其他命令改动了，
    那么当前事务将会被打断，并回滚;
    3. unwatch：取消对所有key的监视;
    4. 如果在执行 watch 命令之后，只要执行了 exec 或 discard 命令，watch会自动取消，无需再执行 unwatch 命令.
7. 应用场景：
    1. 一组命令必须同时执行，或者都不执行;
    2. 保证一组命令在执行过程中不被其他命令插入;
    3. 商品秒杀活动、转账;
</code></pre><h2 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h2><pre><code>1. 缓存穿透
    1. 查询一个不存在数据时，缓存中没有，就需要从数据库中查询，查不到数据就不写入缓存中，导致每次请求
    这个不存在的数据时，都要到数据库中去查询，造成缓存穿透;
    2. 解决方式：持久层查询不到数据时，就缓存一个空结果(空字符串)，每次查询时先判断缓存中是否存在key，
    如果有，则直接返回空值，表示此数据不存在，否则就去查询数据库;
    3. 另外，持久层 insert 此数据时，及时清除查询的key，或者设置空结果的缓存时间;
2. 缓存雪崩
    1. 如果缓存集中在一段时间内失效，发生大量的缓存穿透，所有的查询都落在数据库上，造成缓存雪崩;
    2. 缓存雪崩没有完美的解决方案，应分析用户行为，尽量将缓存失效时间均匀分布;
    3. 大多数系统设计者会考虑加锁/分布式锁，或者队列的方式来保证单线程/进程去写缓存，从而避免失效时
    大量的并发请求落在数据库上;
3. 热点key
    1. 某个key访问非常频繁，当key失效时，将会有大量线程来构建缓存，导致负载增加，系统崩溃;
    2. 解决方案：
        1. 使用锁，单机使用synchronized、lock等，分布式使用分布式锁;
        2. 不设置缓存过期时间，而是在对应的value里设置一个时间，如果检测到超过了这个时间，则异步更新缓存;
        3. 在value里设置一个比过期时间t0小的过期时间t1，当t1过期时，延长t1，并更新缓存;
        4. 设置标签缓存，并设置过期时间，标签缓存过期后，异步更新实际缓存;
4. 缓存预热：在项目即将发布上线之前，清空Redis数据库，然后由开发者把所有的功能调试一遍，
   这样Redis中就有了一些缓存数据，然后再发布项目，这样做也是为了避免大量用户同时去查询MySQL数据库了;
</code></pre><h3 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h3><pre><code>1. 数据一致性：Redis缓存与MySQL中的数据要保证一致性;
2. 实时同步：适用于对一致性要求比较高的业务;
    1. 缓存中不存在，则去数据库查询，并保存到缓存中;
    2. 如果数据库中的数据修改了，缓存也要修改;
3. 在SpringBoot中，采用注解的方式来完成 if-else 的工作
    1. @Cacheable：查询时使用，Long类型需要转为String类型，否则会抛出异常;
    2. @CachePut：更新时使用，此注解一定会从数据库中查询数据;
    3. @CacheEvict：删除时使用;
    4. @Caching：组合用法;
4. 异步队列：对于并发程度较高的情况，则采用异步消息队列的方式同步;
5. 阿里的同步工具canal：模拟MySQL slave和master(主从)的同步机制，监控DB bitlog的日志更新来触发缓存的更新;
6. 采用UDF自定义函数的方式：面向MySQL的API进行编程，利用触发器进行缓存同步，UDF主要由C/C++实现;
</code></pre><h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h2><pre><code>1. 在实际项目中，一般不会只是用一台Redis
    1. 从结构上来说，单个Redis服务器会发生单点故障，并且一台服务器处理所有的请求负载，压力较大;
    2. 从容量上来说，单个Redis服务器的内存容量有限，就算容量为256G，也不能都用作Redis存储内存，
    单台Redis最大使用内存不应超过20G;
2. 高并发的指标：响应时间、吞吐量、每秒查询率QPS、并发用户...
3. 在方法论中，提高系统并发能力的方式主要有两种：垂直扩展、水平扩展
    1. 垂直扩展：提升单机的处理能力，包括增强单机硬件性能、提升单机架构性能;
    2. 水平扩展：增加服务器数量，线性扩充系统性能;
</code></pre><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><pre><code>1. 一个Redis服务有多个复制品，这个服务称为Master，其他复制品称为Slaves;
2. 在Redis主从模式中，一台主库可以有多个从库，但一个从库只能有一个主库，从库还可以连接到其他从库;
3. 主从复制不会阻塞Master和Slaves，在同步数据时，它们可以继续处理Client的请求;
4. 主从复制实现了数据备份，读写分离;
5. 单机主从复制(一台机器，多个Redis服务)，集群主从复制;
    1. A、B、C三个服务器，A作为Master，B、C作为Slave
    2. A [redis.conf]
        bind 192.168.11.8  #使用本机地址，不能使用回环地址
    3. B [redis.conf]
        bind 192.168.11.12
        slaveof 192.168.1.11 6379  #配置Master的IP和端口号
    4. C [redis.conf]
        bind 192.168.11.34
        slaveof 192.168.1.11 6379  #配置Master的IP和端口号
    5. 启动三台服务器上的Redis服务
6. redis-cli 登录某个Redis，通过 info 命令可以查看当前Redis的信息
7. Slave不支持写命令(set)，只能读(get)，否则会报错：(error) READONLY ... read only slave.
</code></pre><h2 id="集群：Redis-Cluster"><a href="#集群：Redis-Cluster" class="headerlink" title="集群：Redis-Cluster"></a>集群：Redis-Cluster</h2><pre><code>1. Redis搭建集群的方案有多种，Redis3.0之前大多采用哨兵模式、主从复制、分片技术;
2. 从Redis3.0开始支持 redis-cluster 集群，至少需要 3(Master)+3(Slave) 才能搭建集群;
</code></pre><h3 id="去中心化"><a href="#去中心化" class="headerlink" title="去中心化"></a>去中心化</h3><pre><code>1. Redis-Cluster采用去中心化结构，每个节点都保存数据和整个集群状态，每个节点都和其他所有节点连接;
2. 所有节点彼此互联(PING-PONG机制)，内部使用二进制协议优化传输速度和带宽;
3. 节点的fail是通过集群中超过半数的节点检测失效时才生效;
4. 客户端与Redis节点直连，不需要中间Proxy层，客户端只需要连接集群中的任意一个节点即可;
5. Redis-Cluster把所有的物理节点映射到 0-16383 slot上，Cluster负责维护;
6. Redis集群预分配 16384 个哈希槽，在Redis集群中放置一个 key-value 时，Redis先对key使用 crc16 算法
   计算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，
   Redis会根据节点数量大致均等地将哈希槽映射到不同的节点上;
</code></pre><h3 id="容错性"><a href="#容错性" class="headerlink" title="容错性"></a>容错性</h3><pre><code>1. 投票机制：由集群中所有的Master参与，如果半数以上的Master节点与当前Master节点通信超时，则认为当前Master节点挂掉;
2. 如果集群中的某个Master挂掉，且它没有Slave，则集群进入fail状态，也可以认为集群的Slot映射 0-16383 不完整时进入fail状态;
3. 如果集群超过半数以上的Master挂掉，无论是否有Slave，集群都进入fail状态.
</code></pre><h3 id="节点分配"><a href="#节点分配" class="headerlink" title="节点分配"></a>节点分配</h3><pre><code>1. 三个主节点分别是A、B、C，它们可以是一台机器上的三个端口，也可以是三台不同的服务器;
2. 采用哈希槽的方式来分配 16384 个Slot时，三个节点分别承担的Slot区间：A[0-5460]，B[5461-10922]，C[10923-16383]
3. 新增一个主节点D，Cluster会从各个主节点的前面各取一部分Slot到 D 上;
    1. A 覆盖 [1365-5460]，B 覆盖 [6827-10922]，C 覆盖 [12288-16383]
    2. D 覆盖 [0-1364，5461-6826，10923-12287]
4. Redis-Cluster的节点分配体现了去中心化思想，不会去优待任何节点;
</code></pre><h3 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h3><pre><code>1. 集群中至少应该有奇数个节点，同时每个节点至少有1个备份节点，主节点、备份节点由 Redis-Cluster 确定;
2. 真集群 - 至少6台机器，假集群 - 一台机器中存在6个Redis服务;
[- 使用一台机器模拟：ubuntu、redis-v5.0.4、一台机器模拟 -]
1. 创建Redis节点安装目录(集群目录)
    mkdir /usr/local/redis_cluster
2. 在 redis_cluster 目录下，创建6个文件夹：7001-7006，分别代表6个节点
    mkdir 7001，mkdir 7002，mkdir 7003，mkdir 7004，mkdir 7005，mkdir 7006
3. 把 redis.conf 分别拷贝到这6个目录下，修改这些目录下的redis.conf，以7001为例
    bind 192.168.13.22  # 直接注释掉，或者使用本机IP，不能使用回环地址(必配)
    port  7001  # 绑定端口号，分别对应7001-7006，以区分Redis服务(必配)
    protected-mode no  #如果不设置密码，则关闭保护模式(必配)
    daemonize  yes  # redis后台运行(守护进程的方式)

    dir ./   # 确保数据文件在各自的目录下，/usr/local/redis_cluster/7001/

    pidfile  /var/run/redis_7001.pid  # 修改PID进程文件名(必配)
    logfile  /usr/local/redis_cluster/7001/redis.log  #日志文件名

    cluster-enabled  yes  # 开启集群(必配)
    cluster-config-file  nodes_7001.conf  # 集群节点的配置文件(必配)
    cluster-node-timeout  15000  #集群节点的超时时间

    apppendonly yes  #开启AOF持久化
4. 启动各个节点
    1. 在编译安装Redis的目录中，有一个src目录，分别拷贝到 7001-7006 目录中;
    2. 分别进入 7001-7006 目录下，使用 sudo src/redis-server ./redis.conf 命令启动当前的Redis服务;  
    3. 当然，也可以不拷贝src目录，使用同一个 redis-server 命令，指定不同的配置文件，启动6个Redis服务;
    4. 切记：启动时一定要有权限，因为设置后台运行之后，如果没有权限，它不会提示！
    5. 查看启动的服务：ps -ef | grep -i redis
5. 客户端连接/断开节点，测试单个Redis服务
    1. 连接：src/redis-cli -p 7001
    2. 停止：src/redis-cli -p 7001 shutdown  //正常关闭，数据会自动保存
    3. kill -9 PID  //非正常关闭，断电，数据容易丢失
</code></pre><h4 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h4><pre><code>1. Redis-v5.0以下版本
    1. 依赖 Ruby 环境
        yum -y install ruby ruby-devel rubygems rpm-build   #安装Ruby
        gem install redis  # gem是ruby的一个工具包，可能会报错，要求Ruby版本为2.2.2以上
     或：
        yum install ruby
        yum install rubygems
        gem install redis
    2. src目录下命令 redis-trib.rb
        1. 注释redis.conf中的 bind 节点，或者绑定为本机IP
            bind 192.168.13.22
        2. 创建集群时要使用本机IP，不能使用回环地址，否则外界无法访问;
        redis-trib.rb create --replicas 1 192.168.13.22:7001 ... 192.168.13.22:7006
    3. --replicas  1  表示自动为每一个master节点分配一个slave节点，按照一定规则生成 3个master 3个slave
2. 创建集群：Redis5.0+
    1. 从 Redis5.0 开始，创建集群不再使用 redis-trib.rb，而是使用C语言实现的 redis-cli 命令;
        redis-cli --cluster create 192.168.13.22:7001 ... 192.168.13.22:7006 --cluster-replicas 1

        ===&gt; Can I set the above configuration?   yes
        [OK] All 16384 slots covered.  ===&gt; 集群创建成功
    2. 默认情况下，前三个会被创建为Master节点，后三个会被创建为Slave节点，且1-4，2-5，3-6的主从配置;
    3. 在分配 Slot 时，只分配给Master，因为 Slave 不支持写命令，只负责读数据;
3. 常见报错
    Node 192.168.13.22:7001 is not empty. Either the node already knows other nodes
    1. 逐个连接Redis服务，清空数据库：flushall
    2. 同时删除生成的相关文件;
5. 关闭集群时，需要逐个关闭集群中的节点;
    redis-cli -c -h IP -p PORT shutdown
</code></pre><h4 id="访问集群"><a href="#访问集群" class="headerlink" title="访问集群"></a>访问集群</h4><pre><code>    redis-cli -c -h IP -p PORT -a Password  # -c表示连接redis集群
1. 登录Redis集群中的任意一个节点
    redis-cli -c -h 192.168.13.22 -p 7001  ==&gt; 没有设置密码，不需要使用 -a
2. 登录之后的命令
    1. info：查看当前Redis服务的详细信息;
    2. info replication：只查看replication，当前节点的身份、状态等信息;
    3. cluster nodes：查看当前集群中的所有节点，及其主从关系;
        7ffc63c7283a05b799d553002bf1d14ef413a655 192.168.13.22:7004@17004 slave 9e191422······
        9e1914220a6300e63fe1532ebdfe50c0d7f28e0b 192.168.13.22:7002@17002 master - 0 155······
        ······
    4. 第一列表示Redis节点的ID值，且此ID将被Redis实例永久使用，以便于在集群中唯一标识一个Redis节点;
    5. 每个节点都会记录其他节点的ID，因为IP或端口号可能发生变化，而ID在整个生命周期内是不会变的;
3. Redis Cluster采用去中心化、去中间件的设计，即集群中的每个节点都是平等的，都保存各自的数据和整个集群的状态;
    1. 每个节点都和其他节点连接，而且这些连接保持活跃，保证了只需要连接集群中的任意节点，就可以获取到其他节点的数据;
    2. 在某个主节点中写入数据时，并不是一定会把数据存储该节点中，它会考虑整个集群环境，有时会重定向到其他主节点;
        登录7001 --&gt; set name Java --&gt; Redirected to slot [xxxx] located at 192.168.13.22:7002
        登录7002 或者 其从节点7005 --&gt; keys * --&gt; name
    3. 在读数据时，Redis Cluster 会在整个集群中查找，数据被存储在哪个 Slot 中，则重定向到该Slot所属的节点;
        登录7001，keys * --&gt; 空的，但执行 get name --&gt; 重定向到7002 --&gt; Java
4. 与主从复制不同，虽然Slave节点也不允许写数据，但在集群中不会报错，而是重定向到Master节点下执行写命令;
5. 如果是外部访问，需要开放 7001-7006 端口，并重启防火墙;
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/04/09/RabbitMQ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/09/RabbitMQ/" itemprop="url">RabbitMQ</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-09T00:00:00+08:00">
                2016-04-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><pre><code>1. 消息队列是典型的 生产者、消费者 模型，简称MQ;
2. MQ是消息通信的模型，并发的具体实现，目前实现MQ的两种主流方式是：AMQP、JMS
3. AMQP：高级消息队列协议，一个进程间传递异步消息的应用层协议，为面向消息的中间件设计；
4. JMS：由Sun公司早期提出的消息标准，为Java应用提供统一的消息操作，与JDBC担任类似的角色；
5. AMQP与JMS
    1. JMS定义了统一的接口，规范消息操作；AMQP是通过协议来统一数据交互的格式；
    2. JMS限定了必须使用Java语言；AMQP只是一种协议，实现方式是跨语言的；
    3. JMS规定了两种消息模型，而AMQP的消息模型更加丰富。
6. 常见的MQ
    1. ActiveMQ：Apache，基于JMS；
    2. RabbitMQ：采用Erlang语言开发，基于AMQP，可靠性、稳定性好；
    3. RocketMQ：阿里巴巴，基于JMS，目前交给Apache；
    4. Kafka：分布式消息系统，高吞吐量。
</code></pre><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><pre><code>1. RabbitMQ最初起源于金融系统，用于在分布式系统中存储、转发消息；
    1. 可靠性：RabbitMQ使用诸如持久化、传输确认、发布确认等机制来保证可靠性；
    2. 灵活的路由：在消息进入队列之前，通过 Exchange 来路由消息；
    3. 消息集群：多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker；
    4. 高可用：队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下仍然可用；
    5. 多种协议：RabbitMQ支持多种消息队列协议，比如 STOMP、MQTT...
    6. 多语言客户端：RabbitMQ几乎支持所有常用语言，比如Java、.NET、Ruby...
    7. 管理界面：RabbitMQ提供了一个易用的用户界面，可以监控和管理消息Broker；
    8. 追踪机制：如果消息异常，RabbitMQ提供了消息跟踪机制，从而查找出原因；
    9. 插件机制：RabbitMQ提供了许多插件，可以从多方面进行扩展，也可以自定义插件。
2. 安装RabbitMQ，启动服务，配置环境和用户、权限...
3. Web管理平台的默认端口号是15672，使用配置的用户去登录管理平台：http://localhost:15672
    1. 创建虚拟主机
        Admin --&gt; Virtual Hosts --&gt; Add virtual host --&gt; 输入Name，如/test
        Admin --&gt; Users --&gt; 选择一个用户 --&gt; Permissions
    2. Current permissions：当前拥有的虚拟主机；
    3. Set permission：为用户添加虚拟主机。
4. RabbitMQ是一个消息的代理者(Message Broker)，负责接收消息并传递消息，传递二进制数据。
</code></pre><h2 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h2><pre><code>1. RabbitMQ提供了6种消息模型，但第6种其实属于RPC(远程服务调用)，并不算是MQ；
    https://www.rabbitmq.com/getstarted.html
2. 搭建环境(两种方式)
    1. 创建SpringBoot项目进行测试，引入启动器：spring-boot-starter-amqp
    2. 创建普通的Maven Java项目，引入依赖：spring-rabbit、slf4j-nop
</code></pre><h3 id="模型一：Hello-World"><a href="#模型一：Hello-World" class="headerlink" title="模型一：Hello World"></a>模型一：Hello World</h3><pre><code>1. 模型：Producer --&gt; MQ --&gt; Consumer，单个生产者和单个消费者
2. 创建连接的工具类
    public class ConnectionUtil {
        public static Connection getConnection() throws IOException, TimeoutException {
            //定义连接工厂
            ConnectionFactory factory = new ConnectionFactory();
            //设置服务地址和端口
            factory.setHost(&quot;192.168.103.30&quot;);
            //Web管理端的默认端口号是15672，访问服务的默认端口号是5672
            factory.setPort(5672);
            //设置账号信息：虚拟主机及其对应的用户名、密码
            factory.setVirtualHost(&quot;/techsel&quot;); //虚拟主机
            factory.setUsername(&quot;java&quot;);  //用户名
            factory.setPassword(&quot;123456&quot;);  //密码
            //通过工厂获取连接
            return factory.newConnection();
        }
    }
3. 生产者
    public class Send {
        //队列名称
        private static final String QUEUE_NAME = &quot;simple_queue&quot;;

        public static void main(String[] args) throws IOException, TimeoutException {
            //创建连接，在Web管理平台：Connections 上会多一条连接信息
            Connection conn = ConnectionUtil.getConnection();
            //创建通道，在Web管理平台：Channels 上会多一条通道信息
            Channel channel = conn.createChannel();
            //声明队列: 设置队列名称, ...
            channel.queueDeclare(QUEUE_NAME, false, false, false, null);
            //消息内容
            String message = &quot;Hello RabbitMQ&quot;;
            //向指定的队列中发送消息，在Web管理平台：Queues 上可以查看消息通道及其详细信息
            channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());
            //关闭通道和连接
            channel.close();
            conn.close();
        }
    }
4. 消费者
    public class Recv {
        //队列名称：与生产者声明的队列名称一致
        private static final String QUEUE_NAME = &quot;simple_queue&quot;;

        public static void main(String[] args) throws IOException, TimeoutException {
            Connection conn = ConnectionUtil.getConnection();
            Channel channel = conn.createChannel();
            //声明队列
            channel.queueDeclare(QUEUE_NAME, false, false, false, null);
            //定义队列的消费者
            DefaultConsumer consumer = new DefaultConsumer(channel){
                //消费的回调方法：消费者会一致阻塞，只要MQ中一有消息，就回调此方法，进行消费
                public void handleDelivery(String consumerTag, Envelope envelope, 
                    AMQP.BasicProperties properties, byte[] body) throws IOException {
                    //消费消息: body
                    String message = new String(body);
                    System.out.println(&quot;消费者：&quot; + message);
                }
            };
            //监听队列：绑定消息队列和消费者，参数2表示：是否自动进行消息确认(手动/自动ACK)
            channel.basicConsume(QUEUE_NAME, true, consumer);
        }
    }
5. 启动消费者，监听队列，等待消费消息；再启动生产者，生产消息；在Web管理平台上跟踪连接、通道、消息;
</code></pre><h3 id="消费者的消息确认机制"><a href="#消费者的消息确认机制" class="headerlink" title="消费者的消息确认机制"></a>消费者的消息确认机制</h3><pre><code>1. 消息确认机制：Acknowlege，当消费者获取消息之后，会向RabbitMQ发送回执ACK，告知消息已经被接收;
2. RabbitMQ收到回执的ACK后，就会立即删除消息;
3. 回执ACK有两种情况：自动ACK、手动ACK
    1. 自动ACK：消息一旦被接收，消费者自动发送ACK;
        channel.basicConsume(QUEUE_NAME, true, consumer);
    2. 手动ACK：消息接收后，不发送ACK，去手动调用;
        channel.basicConsume(QUEUE_NAME, false, consumer);
4. 在自动回执ACK时，回调方法 handleDelivery() 尚未开始执行，但消息已经从MQ中删除了，一旦回调方法中
   发生了异常，消息就找不回来了，所以就需要 手动ACK 的方案，确保一些重要的消息不会丢失；
5. 手动ACK：等待处理逻辑执行完成，再手动回执ACK，从而避免消息的丢失；
    public void handleDelivery(...) {
        String message = new String(body);
        int i = 1/0;  //发生逻辑错误
        //手动回执ACK
        channel.basicAck(envelope.getDeliveryTag(), false);
    }
    1. 因为发生了逻辑错误，没有手动回执ACK，消息会回滚MQ中，然后再分发给其他消费者，保证消息不会被删除;
    2. 但是，因为当前消费者没有ACK，在没有断开重连之前，MQ不会再把消息分发给它，所以如果没有其他消费者，
    就可能造成消息堆积，从而影响MQ的速度.
</code></pre><h3 id="模型二：Work-queues"><a href="#模型二：Work-queues" class="headerlink" title="模型二：Work queues"></a>模型二：Work queues</h3><pre><code>1. 如果消息处理比较耗时，生产消息的速度远远大于消费消息的速度，那么就可能造成消息堆积;
2. 模型：Producer --&gt; MQ --&gt; Consumer1、Consumer2，让多个消费者绑定到一个队列上，共同消费队列的消息;
3. 生产者发送消息
    for (int i=0; i&lt;100; i++) {
        String message = &quot;Hello RabbitMQ : &quot; + i;
        channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());
        Thread.sleep(i * 2);  //休眠一段时间，让消费者去消费消息
    }
4. 消费者消费消息：创建两个消费者，绑定同一个队列
    1. 消费者性能相同，则消费能力相同
        public void handleDelivery(...) {  ---&gt;消费者-1的回调方法
            String message = new String(body);
            System.out.println(&quot;消费者111：&quot; + message);
            //使用手动ACK
            channel.basicAck(envelope.getDeliveryTag(), false);
        }
        public void handleDelivery(...) {  ---&gt;消费者-2的回调方法
            String message = new String(body);
            System.out.println(&quot;消费者222：&quot; + message);
            //使用手动ACK
            channel.basicAck(envelope.getDeliveryTag(), false);
        }
    2. 消费者性能不同，消费者-1的机器配置较差
        public void handleDelivery(...) {  ---&gt;消费者-2的回调方法
            String message = new String(body);
            Thread.sleep(500);  ---&gt; 模拟消费者-2的性能较差，处理消息速度慢
            System.out.println(&quot;消费者222：&quot; + message);
        }
5. 对比结果可知：无论消费者的性能是否相同，它们处理消息的数量总是相同的；
6. 也就是说，不管消费者是否已经消费完消息(发送回执ACK)，MQ总是平均分配消息给每个消费者；
7. 让MQ不要平分消息给消费者，让性能好的消费者多消费，性能差的消费者少消费;
    1. 在每个消息者中，设置 Channel 每次同时只能处理1条消息，在没有回执ACK时，不要再分配消息
        channel.basicQos(1);
</code></pre><h3 id="模型三：Publish-Subscribe"><a href="#模型三：Publish-Subscribe" class="headerlink" title="模型三：Publish/Subscribe"></a>模型三：Publish/Subscribe</h3><pre><code>1. 模型3、4、5其实是类似的，都是订阅模型，在生产者和MQ之间增加了一层交换器exchange;
2. 生产者永远不会把消息直接发给MQ，实际上，生产者也不关心消息是否会被发送给MQ;
3. 生产者只负责把消息发给交换器，由交换器去决定是把消息传递给所有MQ，还是特定的MQ，亦或者是丢弃消息;
4. 交换器处理消息的方式，取决于不同的交换类型：direct、topic、headers、fanout，其中headers不常用;
5. 模型三称为订阅/发布模型，也称为广播，属于交换类型fanout
    Producer --&gt; X --&gt; MQ1-&gt;Consumer1、MQ2-&gt;Consumer2
6. 生产者
    1. 不再直接声明队列，而是声明交换器，并指定交换类型为fanout
    private static final String EXCHANGE_NAME = &quot;fanout_exchange&quot;;
    //声明交换器
    channel.exchangeDeclare(EXCHANGE_NAME, ExchangeTypes.FANOUT);
    2. 发布消息到交换器
    String message = &quot;Hello RabbitMQ&quot;;
    channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, message.getBytes());
    3. 在Web管理平台的 Exchanges 上，可以查看创建的交换器.
7. 消费者
    private static final String EXCHANGE_NAME = &quot;fanout_exchange&quot;;
    1. 消费者1、2 使用不同的队列：
        QUEUE_NAME = &quot;fanout_queue_1&quot;;
        QUEUE_NAME = &quot;fanout_queue_2&quot;;
    2. 声明队列之后，把队列绑定到交换器上，其实就是订阅消息
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);
        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;);
8. 启动消费者1、2，再启动生产者，两个消费者都会收到消息.
</code></pre><h3 id="模型四：Routing"><a href="#模型四：Routing" class="headerlink" title="模型四：Routing"></a>模型四：Routing</h3><pre><code>1. 设置交换类型为direct，与模型三不同的是：它可以订阅不同的消息类型(Routingkey)，实现定向发布;
2. 生产者
    1. 声明交换器
    channel.exchangeDeclare(EXCHANGE_NAME, ExchangeTypes.DIRECT);
    2. 在发送消息时，指定消息的类型
    channel.basicPublish(EXCHANGE_NAME, &quot;delete&quot;, null, message.getBytes());
3. 消费者：在绑定队列到交换器时，指定监听的消息类型；
    1. 消费者-1：监听2种消息类型
    channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;insert&quot;);
    channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;delete&quot;);
    2. 消费者-2：只关心1种消息类型
    channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;delete&quot;);
4. 生产者发送消息类型delete时，消费者-1、2都会收到消息；发送消息类型insert时，只有消费者-1能收到.
</code></pre><h3 id="模型五：Topics"><a href="#模型五：Topics" class="headerlink" title="模型五：Topics"></a>模型五：Topics</h3><pre><code>1. 设置交换类型为topic，与模型四不同的是，它可以使用通配符;
2. 消息类型通常都是一个或多个单词组成，单词之间以 . 分割，如item.insert
3. 通配符的类型和规则
    1. #：匹配一个或多个词，如audit.# 可以匹配 audit.irs.corp、audit.del
    2. *：只能匹配一个词，如audit.* 只能匹配 audit.del、audit.ins
4. 生产者
    channel.exchangeDeclare(EXCHANGE_NAME, ExchangeTypes.TOPIC);
    channel.basicPublish(EXCHANGE_NAME, &quot;intem.delete&quot;, null, message.getBytes());
5. 消费者
    channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;item.*&quot;);
</code></pre><h3 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h3><pre><code>1. 手动回执ACK的方式并不能完全解决消息丢失的问题，比如MQ服务器宕机了;
2. 虽然集群MQ全部宕机的几率很小，但宕机总会导致消息的丢失，这就需要消息的持久化;
3. RabbitMQ默认不会持久化消息，重启RabbitMQ服务，会发现交换器、队列、消息统统丢失了;
    1. 交换器的持久化：生产者声明交换器时，设置第三个参数为true
    channel.exchangeDeclare(EXCHANGE_NAME, ExchangeTypes.TOPIC, true);
    2. 队列的持久化：消费者声明队列时，设置第二个参数为true
    channel.queueDeclare(QUEUE_NAME, true, false, false, null);
4. 消息持久化：生产者发送消息时，设置消息参数BasicProperties
    1. BasicProperties的构造方法特别多，所以它提供了枚举类型MessageProperties，封装了常用设置;
    2. 是否持久化的区别在于：BasicProperties构造方法上的参数deliveryMode，2表示启用持久化;
    3. 默认枚举值BASIC，持久化的枚举值：PERSISTENT_TEXT_PLAIN(文本类型)、PERSISTENT_BASIC(二进制数据流)
    //发送的是字符串，则可以使用文本类型
    channel.basicPublish(EXCHANGE_NAME, &quot;item.delete&quot;, MessageProperties.PERSISTENT_TEXT_PLAIN,
        message.getBytes());
5. 生产者确认机制
    1. 手动回执解决了消费者丢失消息，持久化解决了RabbitMQ丢失消息，但生产者在发送消息到MQ时，也可能发送失败;
    2. 消费者确认机制：消费者收到消息，向MQ发送回执ACK;
    3. 生产者确认机制：MQ收到消息，向生产者发送确认回执;
    4. 在生产者中，开启生产者确认;
        Channel channel = conn.createChannel();
        channel.confirmSelect();
    5. 通过生产者确认的相关API，处理消息回执;
        channel.addConfirmListener(...);  //监听器
        channel.waitForConfirms([long]);  //等待机制
        channel.waitForConfirmsOrDie([long]);  //等待机制
6. 解决消息丢失
    1. 消费者确认机制(ACK)
    2. 持久化
    3. 可靠消息服务：在发送消息前，将消息持久化到数据库，并记录状态
    4. 生产者确认机制
7. 消息发送失败的重试问题：可能导致消息的重复性
    1. 因为网络等原因，导致消息发送时间特别长，但仍发送成功，由于发送时间超时，生产者又发送了一次，导致消息重复;
    2. 在金融方面，消息的重复性可能导致灾难性问题，此时就需要保证消息处理方的幂等性;
    3. 幂等性：同一个接口被重复执行时，其结果应该是一致的;
    4. 有些接口天生就是幂等的，如查询接口；有些接口就不是幂等的，如新增、删除、修改;
    5. 要保证幂等性，就应该在接口中加入一些特殊的标识，以判断重复性操作，通常是在一定时间内去判断.
</code></pre><h2 id="SpringBoot整合RabbitMQ"><a href="#SpringBoot整合RabbitMQ" class="headerlink" title="SpringBoot整合RabbitMQ"></a>SpringBoot整合RabbitMQ</h2><pre><code>1. 创建SpringBoot的项目，引入AMQP的启动器：spring-boot-starter-amqp
2. spring-rabbit 与 spring-amqp
    1. spring-amqp 是对AMQP协议的抽象实现;
    2. spring-rabbit 是对协议的具体实现，也是目前的唯一实现，底层使用的就是RabbitMQ.
3. 在配置文件 application.yml 中，配置RabbitMQ的连接信息
    spring:
        rabbitmq:
            host: 192.168.103.30
            username: java
            password: 123456
            virtual-host: /techsel
4. Spring也为AMQP提供了Template：AmqpTemplate
    1. 向交换器发送消息
        @Autowired
        private AmqpTemplate amqp;

        @Test
        public void contextLoads() {
            String msg = &quot;Hello SpringBoot&quot;;
            amqp.convertAndSend(&quot;boot_exchange&quot;, &quot;item.insert&quot;, msg);
        }
    2. 向MQ中直接发送消息
        amqp.convertAndSend(&quot;boot_queue&quot;, msg);
    3. 底层借助JDK自动对消息进行序列化和反序列化.
5. 从MQ中消费消息
    @Component
    public class Listener {
        @RabbitListener(queues = &quot;boot_queue&quot;)
        public void listen(String msg) {
            System.out.println(&quot;消费者：&quot; + msg);
        }
    }
    1. 一旦监听器中发生异常，消息默认回滚到MQ中;
    2. 对于不希望消息回滚的操作，如发送验证码短信，则使用try-catch捕获异常.
6. 如果监听的队列不存在，就会报错，那么就应该自动创建不存在的队列和交换器，并把队列绑定到交换器;
    @RabbitListener(bindings = @QueueBinding(
        value = @Queue(value = &quot;spring_queue&quot;, durable = &quot;true&quot;), --&gt;声明队列，并持久化
        exchange = @Exchange(
            value = &quot;spring_exchange&quot;,
            ignoreDeclarationExceptions = &quot;true&quot;, --&gt;忽略声明的错误
            type = ExchangeTypes.TOPIC), --&gt;声明交换器，默认就是持久化
        key = {&quot;#.#&quot;}))  --&gt;绑定队列到交换器，&quot;#.#&quot;表示监听一切消息
    public void listen(String msg) {
        System.out.println(&quot;消费者：&quot; + msg);
    }
7. 在实际开发中，可能还会配置更多参数
    spring:
        rabbitmq:
            host: 192.168.103.30
            username: java
            password: 123456
            virtual-host: /techsel
            template:  # 设置AmqpTemplate
                retry: # 发送失败的重试机制
                    enabled: true  # 开启
                    initial-interval: 10000ms  # 重试周期10s(第一次等待10s后再重新发送)
                    max-interval: 30000ms  # 最大重试周期，超过30s，则不再重试
                    multiplier: 2  # 每次重试的基数
                exchange: ly.item.change # 设置默认交换机
            publisher-confirms: true  #开启生产者确认机制
    1. 第一次重试等待10s，第二次重试等待2*10s，第三次等待2*2*10s，已经超过了最大重试周期30s，则不再重试;
    2. 在发送消息时，如果不指定交换机，则使用默认交换机ly.item.change，而不是队列
        amqp.convertAndSend(&quot;item.insert&quot;, msg); //item.insert是消息类型，而不再是队列名称
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/04/05/SpringBoot响应式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/05/SpringBoot响应式/" itemprop="url">SpringBoot响应式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-05T00:00:00+08:00">
                2016-04-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h2><pre><code>1. SpringBoot2.x底层使用Spring5，开始支持响应式编程，Spring又依赖于Reactor
2. 响应式依赖于事件驱动，异步非阻塞，观察者模式;
3. 响应式编程与传统编程的技术对比
</code></pre><p><img src="//hellomyshadow.github.io/2016/04/05/SpringBoot响应式/响应式.png" alt="响应式"></p>
<pre><code>4. 响应式编程的整个链路都不能阻塞，包括数据库访问，比如Redis已经提供了响应式编程的启动器;
</code></pre><h2 id="Spring-WebFlux"><a href="#Spring-WebFlux" class="headerlink" title="Spring WebFlux"></a>Spring WebFlux</h2><pre><code>1. Spring WebFlux 是Spring5.0引进的一个响应式Web框架，通过Reactor项目实现 Reactive Streams 规范;
2. 与SpringMVC不同，Spring WebFlux不需要Servlet API，完全异步非阻塞，事件驱动，流;
3. Flux、Mono
    1. Mono：包含 0 或 1 个元素的异步序列，单一对象，比如根据ID去Redis中查询唯一的用户，Mono&lt;User&gt;
    2. Flux：包含 - 到 N 个元素的异步序列，数据列表对象，比如在Redis中查询一组用户，Flux&lt;User&gt;
    3. Mono 和 Flux 之间可以进行转换;
4. Spring WebFlux有两种风格：基于功能、基于注解
    1. 基于注解的方式非常接近于SpringMVC模型
    @RestController 
    @RequestMapping(&quot;/users&quot;)
    public class UserController {
        @GetMapping(&quot;/{user}&quot;)
        public Mono&lt;User&gt; getUser(@PathVariable Long user) {
            ...
        }
        @GetMapping(&quot;/{user}/customers&quot;)
        public Flux &lt;Customer&gt; getUserCustomers(@PathVariable Long user) {
            ...
        }
        @DeleteMapping(&quot;/{user}&quot;)
        public Mono &lt;User&gt; deleteUser(@PathVariable Long user) {
            ...
        }
    }
    2. 基于功能：路由配置与请求的实际处理逻辑是分开的
    @Configuration
    public class RoutingConfiguration {
        @Bean
        public RouterFunction &lt;ServerResponse&gt; monoRouterFunction（UserHandler userHandler）{
            return route(GET(&quot;/{user}&quot;).and(accept(APPLICATION_JSON))，userHandler :: getUser)
                .andRoute(GET(&quot;/{user}/customers&quot;)
                .and(accept(APPLICATION_JSON))，userHandler :: getUserCustomers)
                .andRoute(DELETE(&quot;/{user}&quot;).and(accept(APPLICATION_JSON))，userHandler :: deleteUser);
        }
    }
    @Component
    public class UserHandler {
        public Mono &lt;ServerResponse&gt; getUser(ServerRequest request) {
            ...
        }
        public Mono &lt;ServerResponse&gt; getUserCustomers(ServerRequest request) {
            ...
        }
        public Mono &lt;ServerResponse&gt; deleteUser(ServerRequest request) {
            ...
        }
    }
5. Spring WebFlux应用不严格依赖于Servlet API，因此不能作为 war 文件部署，也不能使用 src/main/webapp 目录;
6. 除了REST Web服务，Spring WebFlux还提供了动态HTML，支持各种模板引擎：Thymeleaf、FreeMarker...
</code></pre><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><pre><code>1. 创建SpringBoot项目
    1. WebFlux的启动器：spring-boot-starter-webflux
    2. 如果同时存在spring-boot-starter-web，则会优先使用SpringMVC模式，而不是Spring WebFlux
2. WebFlux中，请求和响应对象也不再是ServletRequest和ServletResponse，而是ServerRequest和ServerResponse
3. 创建基于注解的Controller
    @RestController 
    @RequestMapping(&quot;/api&quot;)
    public class TestController {
        @GetMapping(&quot;/test&quot;)
        public Mono&lt;String&gt; test() {
            return Mono.just(&quot;Hello WebFlux&quot;);
        }
    }
4. 启动：默认容器Netty 8080端口，Netty started on port(s): 8080
    http://localhost:8080/api/test  ==&gt; Hello WebFlux
5. 创建User
    public class User {
        private String id;
        private String name;
        ......
    }
6. 创建Service，模拟CURD
    @Service
    public class UserService {
        private static final Map&lt;String, User&gt; dataMap = new HashMap&lt;&gt;();
        static {
            dataMap.put(&quot;1&quot;, new User(&quot;1&quot;, &quot;Java&quot;));
            dataMap.put(&quot;2&quot;, new User(&quot;2&quot;, &quot;Python&quot;));
            dataMap.put(&quot;3&quot;, new User(&quot;3&quot;, &quot;Node&quot;));
            dataMap.put(&quot;4&quot;, new User(&quot;4&quot;, &quot;Node&quot;));
        }
        public Flux&lt;User&gt; getList() {
            Collection&lt;User&gt; list = dataMap.values();
            //把 Collection 转为一个异步序列
            return Flux.fromIterable(list);
        }
        public Mono&lt;User&gt; getById(String id) {
            return Mono.justOrEmpty(dataMap.get(id));
        }
        public Mono&lt;User&gt; delById(String id) {
            return Mono.justOrEmpty(dataMap.remove(id));
        }
    }
7. Controller方法
    @Autowired
    private UserService service;

    @GetMapping(&quot;/find&quot;)
    public Mono&lt;User&gt; findById(String id) {
        return service.getById(id);
    }

    @GetMapping(&quot;/list&quot;)
    public Flux&lt;User&gt; getList() {
        return service.getList();
    }

    http://localhost:8080/api/find?id=2  ==&gt; {&quot;id&quot;: &quot;2&quot;, &quot;name&quot;: &quot;Python&quot;}
8. 模拟耗时的查询一组用户时，每查询到一个就响应一个，而不是等待全部查询结束之后再响应
    @GetMapping(value = &quot;/list&quot;, produces = MediaType.APPLICATION_STREAM_JSON_VALUE)
    public Flux&lt;String&gt; getList() {
        //每条数据延迟2s再响应
        return service.getList().delayElements(Duration.ofSeconds(2));
    }
    http://localhost:8080/api/list  ==&gt; 不考虑网络延迟，每隔2s收到一条数据
    1. produces=MediaType.APPLICATION_STREAM_JSON_VALUE 必须声明响应类型是流;
    2. 如果不声明为流数据，则会等查询到所有数据之后，转为JSON字符串，然后再响应给前端;
</code></pre><h3 id="响应式客户端"><a href="#响应式客户端" class="headerlink" title="响应式客户端"></a>响应式客户端</h3><pre><code>1. WebFlux的客户端WebClient，响应式客户端;
2. 在测试类中使用
    @Test
    public void testBase() {
        Mono&lt;String&gt; body = WebClient.create().get()
            .uri(&quot;http://localhost:8080/api/find?id=2&quot;)
            .accept(MediaType.APPLICATION_JSON)
            .retrieve().bodyToMono(String.class);
        System.out.println(body.block());
    }
    @Test
    public void testPlace() {
        Mono&lt;String&gt; body = WebClient.create().get()
            .uri(&quot;http://localhost:8080/api/find?id={id}&quot;, 2)  //支持占位符
            .accept(MediaType.APPLICATION_JSON)
            .retrieve().bodyToMono(String.class);
    }
</code></pre><h2 id="服务端推送技术"><a href="#服务端推送技术" class="headerlink" title="服务端推送技术"></a>服务端推送技术</h2><pre><code>1. 客户端轮询：AJAX定时拉取数据;
2. WebSocket：全双工通信，基于TCP协议，Socket.IO是基于WebSocket的框架，屏蔽了底层细节，使用更方便;
3. SSE：Server Send Event，HTML5新标准，用于从服务端实时推送数据到浏览器，本质上是一个HTTP长连接;
</code></pre><h3 id="SSE"><a href="#SSE" class="headerlink" title="SSE"></a>SSE</h3><pre><code>1. 服务端
    1. 引入依赖：spring-boot-starter-webflux
    @RestController 
    @RequestMapping(&quot;/sse&quot;)
    public class TestController {
        //数据类型必须设置为event-stream
        @RequestMapping(value = &quot;/test&quot;, produces = &quot;text/event-stream;charset=UTF-8&quot;)
        public String test() {
            Thread.sleep(2000); //模拟业务处理
            return &quot;Hello SSE : &quot; + Math.random();
        }
    }
    2. 在静态资源目录下创建index.html
    &lt;script type=&quot;text/javascript&quot;&gt;
        var source = new EventSource(&quot;sse/test&quot;);
        source.onmessage = function(evt) {
            console.log(evt.data);
        }
    &lt;/script&gt;
2. 客户端：必须支持SSE
    http://localhost:8080/index.html  //大约每2s收到一条消息，本质上是HTTP长连接，所以仍是发起请求
</code></pre><h2 id="Actuator"><a href="#Actuator" class="headerlink" title="Actuator"></a>Actuator</h2><pre><code>1. Actuator：用于监控和管理生产环境的组件，启动器为spring-boot-starter-actuator
2. 启动SpringBoot项目，出于安全考虑，默认只开启了三个端点
    1. http://localhost:8080/actuator  --&gt; 查看可用的端点
    2. http://localhost:8080/actuator/health  --&gt; {&quot;status&quot;: &quot;UP&quot;}  UP 表示应用启动且状态正常
    3. http://localhost:8080/actuator/info  --&gt; 查看详细信息，{} 表示无信息
    4. 对于SpringBoot2.0之前的版本，端点路径上不带 /actuator
3. 在配置文件中，设置开启的监控端点
    1. 开启所有端点
        management.endpoints.web.exposure.include=*
    2. 启动项目时，控制台上会列出可访问的端点，比如/actuator/env，/actuator/metrics ...
    3. 有些端点会暴露敏感信息，比如 /actuator/env 就会暴露应用端口号、数据库连接信息、系统信息...
        management.endpoints.web.exposure.include=metrics  #开启某一个
        management.endpoints.web.exposure.exclude=metrics  #关闭某一个
4. 常用的端点
    /actuator/health  --&gt; 应用健康指标
    /actuator/metrics  --&gt; 应用的基本指标列表
    /actuator/metrics/{name}  --&gt; 某个具体的指标
    /actuator/env  --&gt; 显示来自Spring的ConfigurableEnvironment的属性
5. SpringBoot Admin：可视化的监控管理;
6. 还可以自己开发脚本进行监控;
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/04/03/SpringBoot整合/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/03/SpringBoot整合/" itemprop="url">SpringBoot整合</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-03T00:00:00+08:00">
                2016-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="整合MyBatis"><a href="#整合MyBatis" class="headerlink" title="整合MyBatis"></a>整合MyBatis</h2><pre><code>1. mybatis的启动器，第三方框架的启动器通常不是以 spring- 开头;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
        &lt;version&gt;2.0.1&lt;/version&gt;
    &lt;/dependency&gt;
2. MySQL的连接驱动
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;8.0.16&lt;/version&gt;
    &lt;/dependency&gt;
3. 创建配置文件 resources/application.properties，配置数据库连接信息(覆盖默认配置)
    spring.datasource.driverClassName=com.mysql.cj.jdbc.Driver
    spring.datasource.url=jdbc:mysql://host:port/database?serverTimezone=Asia/Shanghai
    spring.datasource.username=root
    spring.datasource.password=123456
4. 实体类(POJO)：cn.boot.pojo.User
    public class User {
        private Integer id;  //尽量使用包装类型
        private String username;
        private String password;
        ... //getter、setter
    }
5. Dao层：cn.boot.mapper.IUserMapper，Mybatis的两个注解 @Mapper、@MapperScan
    @Mapper
    @Repository
    public interface IUserMapper {
        List&lt;User&gt; findAll();
    }
    1. @Mapper：修饰在Dao层接口上，为其生成实现类;
    2. @MapperScan：修饰在引导类上，指定Mapper接口所在的包，为包下的所有接口生成实现类;
        @SpringBootApplication
        @MapperScan(basePackages={&quot;cn.boot.mapper&quot;})
        public class BootdemoApplication {
             ...
        }
    3. 在使用 @Autowired 注入Dao时，IDE会报错，但能运行，在Dao层接口上注解 @Repository 可以消除错误.
6. 建立POJO与Dao的映射关系
    1. 映射配置文件的方式：resources/mapper/IUserMapper.xml
        &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
        &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
                &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
        &lt;mapper namespace=&quot;cn.boot.mapper.IUserMapper&quot;&gt;
            &lt;select id=&quot;findAll&quot; resultType=&quot;user&quot;&gt;
                select * from user
            &lt;/select&gt;
        &lt;/mapper&gt;
    2. 注解的方式
        @Mapper
        public interface IUserMapper {
            @Select(&quot;select * from user&quot;)
            List&lt;User&gt; findAll();
        }
7. 在 application.properties 中配置Mybatis的信息
    # 开启驼峰扫描
    mybatis.configuration.map-underscore-to-camel-case: true
    # 配置POJO别名的扫描包
    mybatis.type-aliases-package=cn.boot.pojo
    # 加载Mybatis的映射文件(如果使用映射配置文件的方式)
    mybatis.mapper-locations=classpath:mapper/*Mapper.xml
    # 在控制台打印生成的SQL语句
    mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl
8. 在Controller中，使用 @Autowired 注入Dao(Mapper)对象
    @Slf4j
    @RestController
    public class QuickController {
        @Autowired
        private IUserMapper userMapper;

        @RequestMapping(&quot;/test&quot;)
        public String test() {
            List&lt;User&gt; users = userMapper.findAll();
            return &quot;Hello SpringBoot&quot;;
        }
    }
</code></pre><h3 id="通用Mapper"><a href="#通用Mapper" class="headerlink" title="通用Mapper"></a>通用Mapper</h3><pre><code>1. 通用Mapper：一款中国人自己开发的框架，基于Mybatis，只支持单表的CRUD;
    1. 在单表的CURD中，其SQL语句的性能通常是固定的，不像多表的SQL语句那样、有很大的优化余地;
    2. 所以在单表操作时，完全可以为Dao层的方法自动生成SQL语句，这就是通用Mapper的作用.
2. 通用Mapper的启动器：mapper-spring-boot-starter
    1. 启动器中已经引入了 spring-boot-starter、spring-boot-starter-jdbc、mybatis、mybatis-spring
    2. 所以不能再引入 mybatis-spring-boot-starter、spring-boot-starter-jdbc
    3. 而且，通用Mapper 默认开启驼峰匹配，无需在 application.yaml 中手动开启;
    4. 在 application.yaml 中，选择使用Spring的默认连接池，配置数据库连接的4大参数.
    spring:
        datasource:
            ...... # driver-class-name、url、username、password
    mybatis:
        type-aliases-package: cn.boot.pojo
        configuration:
            log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
3. Dao层接口需要继承 Mapper 接口，泛型为实体类
    public interface UserMapper extends Mapper&lt;User&gt; {
        //Mapper中已经提供了常用的CRUD方法
    }
    1. 通用Mapper底层利用Mybatis的拦截器，动态生成SQL语句，并做了SQL缓存，所以性能很好;
    2. @MapperScan、@Mapper 要使用通用Mapper包下的注解，不能再使用Mybatis包下的了.
4. 在启动类上注解通用Mapper的 @MapperScan , 声明扫描Mapper/Dao层接口所在的包
    @SpringBootApplication
    @MapperScan(&quot;cn.boot.mapper&quot;)
    public class StartQuickBoot {
        ...
    }
5. 实体类相关
    1. 通用Mapper默认会使用实体类名作为数据库表名，@Table(name=&quot;表名&quot;) 用于指定数据库表名;
    2. @Id 注解在属性上，指定主键;
    3. 对于自增长的主键，还需要使用 @KeySql(userGeneratedKeys=true) 注解;
    4. 如果实体类的某个属性不作为数据库的字段，则使用 @Transient 注解;
    @Data
    @Table(name=&quot;tl_user&quot;)
    public class User {
        @Id
        @KeySql(userGeneratedKeys=true)
        private Integer id;  //自增长的主键
        private String username;
        @Transient
        private String remark;  //额外的属性
    }
6. Service层：使用 @Transactional 注解引入事务;
    @Service
    public class UserService {
        @Autowired
        private UserMapper mapper;

        public User findById(Integer id) {
            return mapper.selectByPrimaryKey(id);
        }
        @Transactional
        public void insertUser(User user) {  //插入数据时使用事务
            mapper.insert(user);
        }
    }
7. Controller层
    @Autowired
    private UserService service;  //注入Service对象

    @GetMapping(&quot;/{id}&quot;)
    public User test(@PathVariable(&quot;id&quot;) Integer id) {
        log.debug(&quot;test service: {}&quot;, id);
        return service.findById(id);
    }
</code></pre><h2 id="集成Spring-Data-JPA"><a href="#集成Spring-Data-JPA" class="headerlink" title="集成Spring Data JPA"></a>集成Spring Data JPA</h2><pre><code>1. 引入起步依赖：spring-boot-starter-data-jpa
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
    &lt;/dependency&gt;
2. 引入MySQL连接驱动：
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;8.0.16&lt;/version&gt;
    &lt;/dependency&gt;
3. application.properties
    # MySQL连接信息
    spring.datasource.driverClassName=com.mysql.cj.jdbc.Driver
    spring.datasource.url=jdbc:mysql:...
    spring.datasource.username=root
    spring.datasource.password=123456
    # JPA的配置信息
    spring.jpa.database=MySQL
    spring.jpa.show-sql=true
    spring.jpa.generate-ddl=true
    spring.jpa.hibernate.ddl-auto=update
    spring.jpa.hibernate.naming_strategy=org.hibernate.cfg.ImprovedNamingStrategy
4. 创建POJO
    @Entity  --&gt;javax.persistence.Entity
    public class User {
        @Id
        @GeneratedValue(strategy=GenerationType.IDENTITY)
        private Long id;  //使用包装类型
        private String username;
        private String password;
        ... //getter、setter
    }
5. Dao层接口：cn.boot.repository.UserRepository
    public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
        List&lt;User&gt; findAll();
    }
6. 使用junit测试：测试失败，等学了JPA再说吧
    @RunWith(SpringRunner.class)
    @SpringBootTest(classes=引导类.class)
    public class TestIbatis {
        @Autowired
        private UserRepository userRepository;  //注入Repository对象

        @Test
        public void test() {
            List&lt;User&gt; users = userRepository.findAll();
        }
    }
7. JDK9环境可能报异常：JAXBException，是因为缺少依赖;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;
        &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;
        &lt;version&gt;2.3.1&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><pre><code>1. Redis官方推荐的Java客户端有很多，常用的有Jedis、Redisson...
2. 其中，Redisson基于Redis实现了很多常用的结构，甚至还有分布式锁和同步器;
3. Spring对Redis做了集成，SpringDataRedis，最初是基于Jedis，Spring5.0开始转向响应式编程，
   所以 SpringDataRedis 重新采用一套响应式编程实现，性能比Jedis更高;
4. SpringDataRedis属于Spring Data的一部分，也为Redis提供了一个Template对象：RedisTemplate
</code></pre><h3 id="整合Redis"><a href="#整合Redis" class="headerlink" title="整合Redis"></a>整合Redis</h3><pre><code>1. Redis的启动器：spring-boot-starter-data-redis
2. 在 application.yml 中，配置Redis的连接信息
    1. 连接单台Redis服务
    spring:
        redis:
            host: 192.168.103.30
            port: 6379  # 默认6379
            database: 0  # 配置Redis的数据库编号，默认就是0
            timeout: 3000  # 连接超时时间3s
            jedis 或 lettuce:
                pool:  #连接池
                    max-idle=200  #最大空闲连接，默认值8
                    min-idle=200  #最小空闲连接，默认值0
                    max-active=2000  #最大连接实例，设置为-1，表示不做限制
                    max-wait=2000  #等待可用连接的超时时间，默认值-1，表示永不超时
    2. jedis和lettuce都是Redis提供的客户端，默认是jedis，但lettuce是基于netty的，并发性更好;
    3. 连接集群，指定集群的每个节点地址
    spring.redis.cluster.nodes=192.168.103.128:7001, ... ,192.168.103.128:7006
3. 在测试类中，注入 RedisTemplate 对象，操作Redis数据库
    @Autowired
    private RedisTemplate redis;

    @Test
    public void contest() { ... }
4. redis.opsForValue()、opsForList()、opsForSet()、opsForZSet()、opsForHash() 对应Redis中的5种数据结构，
   封装到不同的 Operations 对象中;
    1. 字符串操作对象：ValueOperations ops = redis.opsForValue();
    2. opsForXXX() 在获取Operations对象时做了单例优化，可以不创建Operations对象的变量;
5. redis.boundXXXOps(key)：以绑定key的方式创建 Operations 对象，后续操作不需要再指定key
</code></pre><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><pre><code>1. RedisTemplate 其实是带有泛型的：RedisTemplate&lt;K, V&gt;，分别代表Key、Value的类型;
2. 虽然Redis的key和value通常都是字符串类型：RedisTemplate&lt;String, String&gt;，但底层存储时仍是二进制字节;
3. 泛型的 K、V 可以指定任意类型，RedisTemplate自动把这些类型转为字节进行存储，因为默认使用JDK的序列化工具;
4. 在命令行上查看时，Redis不会转换JDK序列化的结果，可读性很差，所以通常把对象转为JSON字符串，然后存储到Redis中;
5. 考虑到这种转换会很频繁，所以Spring提供了RedisTemplate的子类：SpringRedisTemplate，它的序列化工具不再是JDK，
   而是string.getBytes()，在命令行上查看时，Redis能够自动再转为字符串;
6. 当然RedisTemplate也允许自定义序列化工具。
7. 短信验证码的发送
    1. 把发送事件推送到RabbitMQ中，由消费者调用短信的API;
    2. 短信发送成功后，使用Redis记录下当前手机号，key=sms:phone:手机号，value=当前时间戳，并设置过期时间;
    3. 每次收到发送短信的消息时，先从Redis中获取手机号，如果没有或者时间已经超过了1分钟，则发送，否则不发送，
    避免短信服务的限流;
</code></pre><h2 id="LogBack"><a href="#LogBack" class="headerlink" title="LogBack"></a>LogBack</h2><pre><code>1. 常用的日志组件：slf4j、log4j、logback、common-logging...
2. logback：基于log4j，不能单独使用，一般配合slf4j使用;
3. logback当前分为3个模块：logback-core(基础核心模块)、logback-classic、logback-access
    1. Logger：日志记录器;
    2. Appender：指定日志输出的目的地，控制台、文件;
    3. Layout：日志布局，格式化日志信息的输出;
5. 日志级别：debug &lt; info &lt; warn &lt; error
6. 在线工具：https://logback.qos.ch/translator/，把log4j.properties转为logback.xml
    ===========log4j.properties示例===========
    ### 设置###
    log4j.rootLogger = debug,stdout,D,E
    ### 输出信息到控制抬 ###
    log4j.appender.stdout = org.apache.log4j.ConsoleAppender
    log4j.appender.stdout.Target = System.out
    log4j.appender.stdout.layout = org.apache.log4j.PatternLayout
    log4j.appender.stdout.layout.ConversionPattern = [%-5p] %d{yyyy-MM-dd HH:mm:ss,SSS} method:%l%n%m%n
    ### 输出DEBUG 级别以上的日志到=D://logs/error.log ###
    log4j.appender.D = org.apache.log4j.DailyRollingFileAppender
    log4j.appender.D.File = D://logs/log.log
    log4j.appender.D.Append = true
    log4j.appender.D.Threshold = DEBUG
    log4j.appender.D.layout = org.apache.log4j.PatternLayout
    log4j.appender.D.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n
    ### 输出ERROR 级别以上的日志到=D://logs/error.log ###
    log4j.appender.E = org.apache.log4j.DailyRollingFileAppender
    log4j.appender.E.File =E://logs/error.log
    log4j.appender.E.Append = true
    log4j.appender.E.Threshold = ERROR
    log4j.appender.E.layout = org.apache.log4j.PatternLayout
    log4j.appender.E.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n
</code></pre><h3 id="SpringBoot整合logback"><a href="#SpringBoot整合logback" class="headerlink" title="SpringBoot整合logback"></a>SpringBoot整合logback</h3><pre><code>1. Web启动器spring-boot-starter-web 中已经包含了 logback 的相关依赖;
2. 创建 resources/logback-spring.xml
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
    &lt;configuration&gt;
        &lt;appender name=&quot;consoleApp&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
            &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;
                &lt;pattern&gt;
                    %date{yyyy-MM-dd HH:mm:ss.SSS} %-5level[%thread]%logger{56}.%method:%L -%msg%n
                &lt;/pattern&gt;
            &lt;/layout&gt;
        &lt;/appender&gt;
        &lt;appender name=&quot;fileInfoApp&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
            &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;
                &lt;level&gt;ERROR&lt;/level&gt;
                &lt;onMatch&gt;DENY&lt;/onMatch&gt;
                &lt;onMismatch&gt;ACCEPT&lt;/onMismatch&gt;
            &lt;/filter&gt;
            &lt;encoder&gt;
                &lt;pattern&gt;
                    %date{yyyy-MM-dd HH:mm:ss.SSS} %-5level[%thread]%logger{56}.%method:%L -%msg%n
                &lt;/pattern&gt;
            &lt;/encoder&gt;
            &lt;!-- 滚动策略 --&gt;
            &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
                &lt;!-- 输出到文件的路径 --&gt;
                &lt;fileNamePattern&gt;app_log/log/app.info.%d.log&lt;/fileNamePattern&gt;
            &lt;/rollingPolicy&gt;
        &lt;/appender&gt;
        &lt;appender name=&quot;fileErrorApp&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
            &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;
                &lt;level&gt;ERROR&lt;/level&gt;
            &lt;/filter&gt;
            &lt;encoder&gt;
                &lt;pattern&gt;
                    %date{yyyy-MM-dd HH:mm:ss.SSS} %-5level[%thread]%logger{56}.%method:%L -%msg%n
                &lt;/pattern&gt;
            &lt;/encoder&gt;
            &lt;!-- 设置滚动策略 --&gt;
            &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
                &lt;!-- 输出到文件的路径 --&gt;
                &lt;fileNamePattern&gt;app_log/log/app.err.%d.log&lt;/fileNamePattern&gt;
                &lt;!-- 控制保留的归档文件的最大数量，超出数量就删除旧文件，假设设置每个月滚动，
                    且&lt;maxHistory&gt; 是1，则只保存最近1个月的文件，删除之前的旧文件 --&gt;
                &lt;MaxHistory&gt;1&lt;/MaxHistory&gt;
            &lt;/rollingPolicy&gt;
        &lt;/appender&gt;
        &lt;!-- 控制总的输出级别：level=&quot;INFO&quot; 表示只输出大于等于INFO级别的日志，不会有DEBUG日志 --&gt;
        &lt;root level=&quot;INFO&quot;&gt;  
            &lt;appender-ref ref=&quot;consoleApp&quot;/&gt;
            &lt;appender-ref ref=&quot;fileInfoApp&quot;/&gt;
            &lt;appender-ref ref=&quot;fileErrorApp&quot;/&gt;
        &lt;/root&gt;
    &lt;/configuration&gt;
3. 日志输出
    @GetMapping(&quot;log&quot;)
    public String testLog() {
        log.debug(&quot;this is debug level&quot;);
        log.info(&quot;this is info level&quot;);
        log.warn(&quot;this is warn level&quot;);
        log.error(&quot;this is error level&quot;);
    }
    http://localhost:8080/user/log
4. 在项目目录下生成 app_log/log 目录，其中包含日志文件 app.info.xx.log、app.err.xx.log
5. 日志文件不仅包括 log 打印的，还有大于INFO级别的系统日志;
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/04/02/SpringBoot进阶/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/02/SpringBoot进阶/" itemprop="url">SpringBoot进阶</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-02T00:00:00+08:00">
                2016-04-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="SpringMVC新增注解"><a href="#SpringMVC新增注解" class="headerlink" title="SpringMVC新增注解"></a>SpringMVC新增注解</h2><pre><code>1. Spring4.3中引进了 @GetMapping、@PostMapping、@PutMapping、@DeleteMapping、@PatchMapping
    1. @GetMapping 等效于 @RequestMapping(method=RequestMethod.GET);
    2. @PostMapping 是 @RequestMapping(method=RequestMethod.POST) 的缩写;
2. @RestController：相当于 @ResponseBody + @Controller 的组合;
    @RestController
    @RequestMapping(&quot;/user&quot;)
    public class RestController {
        @GetMapping(&quot;/getList&quot;)
        public List&lt;User&gt; getList() {
            List&lt;User&gt; us = dao.findAll();
            return us;
        }
    }
    1. @RestController 的方法都只能返回String、Object、Json等实体对象;
    2. SpringBoot已经引入了jackson, 返回的对象会被jackson转为JSON字符串，写入响应体中;
    3. 如果想要跳转页面，则用 ModelAndView 封装;
    @GetMapping(&quot;/index&quot;)
    public ModelAndView toIndex() {
        ModelAndView mv = new ModelAndView(&quot;index&quot;);
        return mv;
    }
</code></pre><h2 id="lombok"><a href="#lombok" class="headerlink" title="lombok"></a>lombok</h2><pre><code>    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;version&gt;1.18.6&lt;/version&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
1. @Data：注解在Java类上，在编译期自动生成getter、setter... 源码中没有变化，只存在于编译生成的class文件中;
2. @Setter、@Getter：分别生成 setter、getter 方法;
3. @AllArgsConstructor：添加一个构造函数，该构造函数含有所有已声明的属性参数;
4. @NoArgsConstructor：添加一个无参构造函数;
5. @Slf4j：等效于在Java类中创建Logger对象的属性 log=LoggerFactory.getLogger(类名.class);
6. 但是IDEA并不能自动识别 @Slf4j 提供的变量log，需要安装插件 Settings -&gt; Plugins -&gt; 搜索Lombok
</code></pre><h2 id="Jackson"><a href="#Jackson" class="headerlink" title="Jackson"></a>Jackson</h2><pre><code>1. 常用的JSON框架序列化JSON的性能：Jackson &gt; fastJson &gt; Gson &gt; Json-lib，各有所长，时间换空间、空间换时间;
2. web启动器默认集成了Jackson
    1. @JsonIgnore：指定忽略的字段，不返回给前端;
    2. @JsonFormat(pattern=&quot;yyyy-MM-dd hh:mm:ss&quot;, locale=&quot;zh&quot;, timezone=&quot;GMT+8&quot;)：指定日期格式化;
    3. @JsonInclude(Include.NON_NULL)：空字段不返回;
    4. @JsonProperty：指定别名，隐藏真实的字段名;
    @Data
    public class User {
        @JsonInclude(Include.NON_NULL)
        private Integer id;

        @JsonProperty(&quot;abcd&quot;)
        private String name;

        @JsonIgnore   ------&gt;完全忽略，客户端提交的age参数也会被忽略
        private Integer age;

        private String password;

        @JsonFormat(pattern=&quot;yyyy-MM-dd hh:mm:ss&quot;, locale=&quot;zh&quot;, timezone=&quot;GMT+8&quot;)
        private Date birthday;

        @JsonIgnore  ---&gt; 重写了getter，传递给客户端时忽略
        public String getPassword() {
            return password;
        }
        @JsonProperty  ---&gt; 重写了setter，接收时仍赋值
        public void setPassword(String password) {
            this.password = password;
        }
    }
3. Controller方法
    @RestController
    public class UserController {
        @GetMapping(&quot;/test&quot;)
        public Object test() {
            User user = new User();
            user.setName(&quot;Java&quot;);
            user.setName(&quot;123456&quot;);
            user.setBirthday(new Date())
            return user;  //发送给前端的JSON：{ &quot;abcd&quot;: &quot;123456&quot;, &quot;birthday&quot;: &quot;2019-05-12 07:50:31&quot; }
        }
    }
</code></pre><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><pre><code>1. @EnableScheduling：注解在启动类上，自动扫描，开启定时任务;
2. @Scheduled：注解在任务方法上;
    @Slf4j
    @Component  --&gt;定时任务类必须加入Spring IoC容器才能被扫描
    public class TestTask {
        @Scheduled(fixedRate=2000)  --&gt;每隔2s执行一次
        public void test() {
            log.info(&quot;当前时间：{}&quot;, new Date());
        }
    }
    1. corn：定时任务表达式，比如 cron=&quot;*/1 * * * * *&quot; 表示每秒执行一次，可以使用在线工具生成corn表达式;
    2. fixedRate：上次开始执行后，xx毫秒后再执行;
        @Scheduled(fixedRate=2000)
        public void test() {
            Thread.sleep(4000);   ---&gt;任务执行时间大于fixedRate，那么每隔 4s 执行一次
        }
    3. fixedDelay：上次任务结束之后，延迟xx毫秒再执行；
        @Scheduled(fixedDelay=2000)
        public void test() {
            Thread.sleep(4000);  --&gt; 任务执行时间4s + 延迟时间2s = 6s  --&gt;每隔6s执行一次
        }
    4. fixedRateString、fixedDelayString：字符串形式，可以把延迟时间配置在SpringBoot的配置文件中;
</code></pre><h2 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h2><pre><code>1. @EnableAsync：注解在启动类上，扫描异步任务的注解;
2. @Component：注解在任务类上，加入Spring IoC容器，不能把任务方法写在Controller类中;
3. @Async：注解在任务类或任务方法上，注解在任务类上时，它所有的方法都是异步任务;
    @Slf4j
    @Component
    public class AsyncTask {
        @Async
        public void task1() throws InterruptedException {
            long begin = System.currentTimeMillis();
            Thread.sleep(1000);
            long end = System.currentTimeMillis();
            log.info(&quot;任务-1: {}&quot;, (end-begin));
        }
    }
4. 调用异步任务，不会阻塞主线程
    @Autowired
    private AsyncTask t;

    @GetMapping(&quot;/task&quot;)
    public String task() {
        t.task1();
        return &quot;hello Task!&quot;;  --&gt;响应给前端，不会等待异步任务执行完成
    }
5. 获取异步任务的返回值
    @Async
    public Future&lt;String&gt; task2() throws InterruptedException {
        long begin = System.currentTimeMillis();
        Thread.sleep(2000);
        long end = System.currentTimeMillis();
        log.info(&quot;任务-2: {}&quot;, (end-begin));
        return new AsyncResult&lt;String&gt;(&quot;task2&quot;);
    }
    @Async
    public Future&lt;String&gt; task3() throws InterruptedException {
        long begin = System.currentTimeMillis();
        Thread.sleep(3000);
        long end = System.currentTimeMillis();
        log.info(&quot;任务-3: {}&quot;, (end-begin));
        return new AsyncResult&lt;String&gt;(&quot;task3&quot;);  //返回异步任务执行的结果
    }

    @GetMapping(&quot;/task1&quot;)
    public String task1() {
        Future&lt;String&gt; task2 = t.task2();//执行异步任务
        Future&lt;String&gt; task3 = t.task3();
        for(;;) {
            if(task2.isDone() &amp;&amp; task3.isDone()) { //检查异步任务是否全部执行完成
                break;
            }
        }  ---&gt; 大约耗时：3000，异步任务是同时执行的，所以耗时时间就是执行时间最长的一个异步任务
    }
    @GetMapping(&quot;/task2&quot;)
    public String task2() {
        long begin = System.currentTimeMillis();
        Future&lt;String&gt; task2 = t.task2();
        Future&lt;String&gt; task3 = t.task3();
        String res4 = task4.get();
        String res5 = task5.get();  //阻塞等待获取异步任务的结果
        long end = System.currentTimeMillis();
        System.out.println(&quot;耗时: &quot; + (end-begin)); //大约耗时：3000
    }
</code></pre><h2 id="全局异常"><a href="#全局异常" class="headerlink" title="全局异常"></a>全局异常</h2><pre><code>1. @ControllerAdvice：注解在类上，声明为异常捕获类;
2. @RestControllerAdvice：组合注解，@ControllerAdvice + @ResponseBody
3. @ExceptionHandler(value=Exception.class)：注解在异常处理的方法上，value属性指定捕获的异常;
    @ControllerAdvice
    public class CustomExtHandler {
        @ExceptionHandler(value=Exception.class)  --&gt;Exception表示捕获所有异常
        @ResponseBody
        Object handleException(Exception e, HttpServletRequest request) {
            Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
            map.put(&quot;code&quot;, 100);
            map.put(&quot;msg&quot;, e.getMessage());
            map.put(&quot;url&quot;, request.getRequestURL());
            return map;  //当应用程序中发生了异常时，响应给前台的数据
        }
    }
    1. 在Controller中抛出异常
        @GetMapping(&quot;/ply&quot;)
        public String home() {
            int i = 1/0;  -----&gt; 抛出异常
            ......
        }
    2. http://localhost:8080/ply  --&gt; { &quot;code&quot;: 100, &quot;msg&quot;: &quot;...&quot;, &quot;url&quot;: &quot;...&quot; }
4. 自定义异常，跳转到友好界面(引入依赖thymeleaf)
    1. 自定义异常
        public class PageException extends RuntimeException {
            public PageException(String code, String msg) {
                this.code = code;
                this.msg = msg;
            }
            ......
        }
    2. 在 CustomExtHandler 中追加一个新的处理方法，精确捕获自定义异常
        @ExceptionHandler(value = PageException.class)
        @ResponseBody
        Object handleException(PageException e) {
            ModelAndView mav = new ModelAndView();
            mav.setViewName(&quot;error.html&quot;);
            mav.addObject(&quot;msg&quot;, e.getMsg());
            return mav;
        }
    3. 在Controller中抛出自定义异常
        @GetMapping(&quot;/ply&quot;)
        public String home() {
            throw new PageException(&quot;102&quot;, &quot;错误异常&quot;);
        }
</code></pre><h2 id="Servlet3-0"><a href="#Servlet3-0" class="headerlink" title="Servlet3.0"></a>Servlet3.0</h2><pre><code>1. 在SpringBoot项目中，可以使用Servlet3.0的注解开发Filter、Listener、甚至原生Servlet;
2. @ServletComponentScan：注解在启动类上，进行扫描Servlet3.0的注解;
    @ServletComponentScan
    @SpringBootApplication
    public class BootTestApplication {
        ...
    }
3. 过滤器：@WebFilter
    1. Filter在服务器启动时加载，服务器关闭时销毁，SpringBoot启动时默认加载4个Filter
    characterEncodingFilter -&gt; hiddenHttpMethodFilter -&gt; httpPutFormContentFilter -&gt; requestContextFilter
    2. 使用Servlet3.0的注解自定义Filter时，避免和默认的Filter优先级相同，否则会冲突;
    3. 自定义的Filter 必须实现Filter接口，并注解 @WebFilter，用于配置过滤规则，并加入Spring容器;
    @WebFilter(urlPatterns = &quot;/api/*&quot;, filterName = &quot;loginFilter&quot;)
    public class LoginFilter implements Filter {
        init()、destroy()
        public void doFilter(ServletRequest servReq, ServletResponse servResp, FilterChain chain) {
            HttpServletRequest req = (HttpServletRequest)servReq;
            HttpServletResponse resp = (HttpServletResponse)servResp;
            String username = req.getParameter(&quot;username&quot;);
            if(&quot;admin&quot;.equals(username)) {
                chain.doFilter(servletRequest, servletResponse);
            } else {
                resp.sendRedirect(&quot;/error.html&quot;);
            }
        }
    }
4. 自定义原生Servlet：@WebServlet
    @WebServlet(name=&quot;userServlet&quot;, urlPatterns = &quot;/test/user&quot;)
    public class UserServlet extends HttpServlet {
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp) {
            resp.getWriter().print(&quot;user servlet&quot;);
            resp.getWriter().flush();
            resp.getWriter().close();
        }
    }
5. 自定义原生Listener：@WebListener
    1. 常用监听器：ServletContextListener、HttpSessionListener、ServletRequestListener
    2. ServletContextListener：服务器启动时初始化，常用于一些资源的加载;
    3. ServletRequestListener：一次请求，请求到达则初始化，响应结束则销毁;
    @WebListener
    public class RequestListener implements ServletRequestListener {
        public void requestDestroyed(ServletRequestEvent servletRequestEvent) {
            System.out.println(&quot;RequestListener requestDestroyed&quot;);
        }
        public void requestInitialized(ServletRequestEvent servletRequestEvent) {
            System.out.println(&quot;RequestListener requestInitialized&quot;);
        }
    }
</code></pre><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><pre><code>    public class LoginIntercepter implements HandlerInterceptor {
        preHandle()   --&gt;调用Controller方法之前
        postHandle()  --&gt;Controller方法调用之后，视图渲染之前，如果Controller方法出现异常，则不会执行
        afterCompletion()  --&gt;不管是否有异常，都会执行，常用于资源清理
    }
1. SpringBoot规定：
    1. 如果要保留SpringBoot的一些默认MVC特征，同时又想自定义一些MVC配置，如拦截器、格式化器、视图控制器、
    消息转发器... 就必须实现WebMvcConfigurer，并使用 @Configuration，但一定不能使用 @EnableWebMvc;
    2. 如果想要完全自定义SpringMVC，不保留默认的一切MVC特征，则使用 @Configuration 和 @EnableWebMvc;
2. SpringBoot2.0的拦截器与v2.0之前的配置方式是不同的
    1. 旧版本：extends WebMvcConfigurerAdapter
    @Configuration
    public class OldCusWebMvcConfigurer extends WebMvcConfigurerAdapter {
        public void addInterceptors(InterceptorRegistry registry) {
            //配置拦截器和拦截规则，Ant风格的路径匹配
            registry.addInterceptor(new LoginIntercepter()).addPathPatterns(&quot;/api2/*/**&quot;);
        }
    }
    2. 新版本：implements WebMvcConfigurer
    @Configuration
    public class CusWebMvcConfigurer implements WebMvcConfigurer {
        //配置拦截器和拦截规则
        registry.addInterceptor(new LoginIntercepter())
            .addPathPatterns(&quot;/api2/*/**&quot;)  ----&gt;拦截的资源访问
            .excludePathPatterns(&quot;/api2/xxx/**&quot;);  --&gt;某些不需要拦截的资源访问

        registry.addInterceptor(new LoginIntercepter()).addPathPatterns(&quot;/api2/*/**&quot;);
    }
    3. 配置多个拦截器时，拦截器的执行顺序与配置顺序相同;
3. 拦截器与过滤器
    1. 过滤器依赖于Servlet容器(Web应用)，基于函数回调；而拦截器则不依赖，基于Java的反射机制(AOP)；
    2. 拦截器中可以注入Spring IoC容器的所有Bean对象，实现业务逻辑的调用，而过滤器则不行；
    3. 执行顺序
        Filter --&gt; 拦截器 --&gt; action执行 --&gt; 拦截器 --&gt; 过滤器
</code></pre><h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><pre><code>1. DBCP是一款老牌的JDBC连接池，出自Apache;
2. cp30与Druid都是连接池，一个JDBC组件，速度都差不多;
    1. Hibernate默认使用c3p0;
    2. Druid可以监控每一条SQL语句的执行性能，从而优化SQL语句.
3. 速度最快的JDBC连接池是HikariCP(追光者)，Spring默认内置了HikariCP;
4. Spring提供的JDBC启动器：spring-boot-starter-jdbc，SpringBoot默认集成，无需手动引入;
5. 连接池只是一个JDBC组件，还需要配置数据库驱动，如MySQL的驱动依赖：mysql-connector-java
6. 在 application.yml 中，配置Spring启动器中的默认连接池：连接数据库的4大参数;
    spring:
        datasource:
            driver-class-name: com.mysql.cj.jdbc.Driver
            url: jdbc:mysql://host:port/database?serverTimezone=Asia/Shanghai
            username: root
            password: 123456
7. 默认使用的连接池是HikariCP，如果想使用其他连接池，如阿里的druid
    1. 引入druid的依赖，配置spring.datasource.type=com.zaxxer.hikari.HikariDataSource
    spring:
        datasource:
            type: com.alibaba.druid.pool.DruidDataSource
            ...... # driver-class-name、url、username、password
</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><pre><code>1. Junit的起步依赖：spring-boot-starter-test
2. 在test目录下创建测试类
    @RunWith(SpringRunner.class)
    @SpringBootTest(classes=引导类.class)
    public class TestClient {
        @Autowired
        private IUserMapper userMapper;  //注入Mapper对象

        @Test
        public void test() {
            List&lt;User&gt; users = userMapper.findAll();
        }
    }
3. MockMvc：模拟 SpringMVC 的客户端请求
    @AutoConfigureMockMvc   ----&gt;MockMvc的注解
    @RunWith(SpringRunner.class)
    @SpringBootTest(classes={启动类.class})
    public class TestClient {
        @Autowired
        private MockMvc mvc;

        @Test
        public void test() {
            MvcResult res = mvc.perform(MockMvcRequestBuilders.get(&quot;/ply&quot;))
                .andExpect(MockMvcResultMatchers.status().isOk()).andReturn();  //发起get请求
            String str = res.getResponse().getContentAsString();  //获取请求的内容
        }
    }
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/04/01/SpringBoot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/01/SpringBoot/" itemprop="url">SpringBoot</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-01T00:00:00+08:00">
                2016-04-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="SpringBoot与Spring"><a href="#SpringBoot与Spring" class="headerlink" title="SpringBoot与Spring"></a>SpringBoot与Spring</h2><pre><code>1. Spring的优点：Spring是JavaEE的轻量级框架，通过依赖注入和面向切面编程，用简单的POJO实现EJB的功能;
2. Spring的缺点：虽然Spring的组件代码是轻量级的，但是它的配置文件却是重量级的;
    1. Spring2.5引入基于注解的组件扫描，也是为了消除大量针对应用程序自身组件的XML配置;
    2. Spring3.0引入了基于Java的配置，这是一种类型安全的、可重构的配置方式，可以替代XML;
    3. 除了配置会消耗大量的开发时间，项目的依赖管理也是很麻烦的，版本选择困难，容易冲突.
3. Spring注解的发展
    1. Spring1.0时代因为JDK1.5刚出来，注解开发尚未盛行，所以一切Spring配置皆是XML格式;
    2. Spring2.0时代引入了注解开发，但并未完善，因此并未完全替代XML;
    3. Spring3.0时代的注解已经非常完善了，因此Spring推荐使用注解(Java配置)代替XML.
4. SpringBoot解决了Spring的缺点，基于约定优先于配置，开发者只需要关心逻辑业务的代码编写;
    1. 开箱即用，没有代码生成，也无需XML配置，通过修改默认值来满足特定的需求;
    2. 提供了一些大型项目中常见的非功能性的特性，如嵌入式服务器、安全、指标、健康检测、外部配置...
    3. SpringBoot不是对Spring功能上的增强，而是提供一种基于Spring的快速开发方式.
5. SpringBoot的核心功能
    1. 起步依赖：本质上是一个Maven项目对象模型(POM)，定义了对其他库的传递依赖;
    1. 简单来说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认功能.
    2. 自动配置：SpringBoot的自动配置是一个运行时(应用程序启动时)的过程;
    2. 考虑了众多因素，才决定Spring配置应该用哪个、不应该用哪个，此过程也是Spring自动完成的。
6. 在SpringBoot中，默认采用Servlet3.0，它可以完全使用注解取代web.xml了，所以SpringBoot没有了web.xml;
</code></pre><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><pre><code>1. SpringBoot2.x的依赖环境和版本
    1. JDK8+，因为SpringBoot2.x底层是Spring Framework5
    2. Maven3.2+，Gradle4+
2. 创建一个普通Java项目的Maven工程，添加继承SpringBoot的起步依赖spring-boot-starter-parent
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.1.4.RELEASE&lt;/version&gt;
    &lt;/parent&gt;
    1. spring-boot-starter-parent 中管理了很多其他依赖的版本，所以 &lt;dependencies&gt; 中引入这些的依赖时，
    尽量不要配置它们的版本号，沿用 spring-boot-starter-parent 中的版本号;
    2. Spring对版本的要求比较严格，很多问题都是因为版本不匹配所致.
3. SpringBoot要集成SpringMVC、进行Web/Controller的开发时，只需要导入web的启动器即可;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;!-- 无需指定版本号(如果无法自动配置，则拷贝spring-boot-starter-parent中的版本号) --&gt;
    &lt;/dependency&gt;
4. 创建一个普通类，使用 @SpringBootApplication 声明为一个SpringBoot的引导类(引导应用程序的入口);
    1. 在 main() 中运行引导类：SpringApplication.run(引导类.class, 可选参数);
    @SpringBootApplication
    public class StartSpringBoot {
        public static void main(String[] args) {
            SpringApplication.run(StartSpringBoot.class, args);
        }
    }
5. SpringBoot中内置有Tomcat插件，直接运行 main()，在控制台提示Tomcat启动信息：
    Tomcat started on port(s): 8080 (http) with context path &apos;&apos;
    1. context path &apos;&apos;：表示web应用的名称(虚拟项目名)为空字符串，访问 http://localhost:8080/ ;
    2. 当前没有编写任何页面，所以展示的是 Error Page，但表示已经启动成功了;
6. 无需任何配置，就可以直接编写Controller层
    @Controller
    public class QuickController {
        @RequestMapping(&quot;/test&quot;)
        @ResponseBody
        public String test() {
            return &quot;Hello SpringBoot&quot;;
        }
    }    ---&gt;http://localhost:8080/test  ---&gt; Hello SpringBoot
7. IDEA快速创建SpringBoot工程
    New Project -&gt; Spring Initializr -&gt; Next -&gt; 设置项目信息 -&gt; Next -&gt; 手动选择依赖 -&gt; Finish
</code></pre><h2 id="SpringBoot的原理"><a href="#SpringBoot的原理" class="headerlink" title="SpringBoot的原理"></a>SpringBoot的原理</h2><pre><code>1. 起步依赖
    1. 所有的SpringBoot工程都必须继承 spring-boot-starter-parent，它会对依赖的版本进行管理;
    2. SpringBoot项目引入的依赖往往都是starter，它是一个工具集合，里面包含了很多常用的依赖，便于版本管理;
    3. 比如spring-boot-starter-web，包含了诸如spring-webmvc、spring-web、Tomcat、jackson ...
    4. 第三方框架要对接SpringBoot项目，必须提供起步依赖(启动器)，Spring的官方启动器通常以 spring- 开头;
2. 自动配置
    1. @SpringBootApplication是组合注解：@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan
    2. @SpringBootConfiguration 其实就是 @Configuration，所以引导类也就是一个配置类;
    3. @EnableAutoConfiguration 是自动配置的核心注解，@Import({AutoConfigurationImportSelector.class})
    4. AutoConfigurationImportSelector 中就是自动配置的核心源码;
    5. @ComponentScan：配置扫描的包，默认就会扫描引导类所在包下的所有注解.
</code></pre><h2 id="SpringBoot的配置文件"><a href="#SpringBoot的配置文件" class="headerlink" title="SpringBoot的配置文件"></a>SpringBoot的配置文件</h2><pre><code>1. SpringBoot是基于约定的，所以很多配置都是默认值;
2. 在需要自定义配置时，根据启动器提供的key名，在SpringBoot的配置文件中指定value值即可;
3. spring-boot-starter-parent 会自动加载 resources 目录下的三类配置文件;
    1. application*.yml、application*.yaml、application*.properties;
    2. 加载顺序：yml --&gt; yaml --&gt; properties，当有相同的key名配置时，properties中的优先级最高.
4. 创建 resources/application.properties，实现一些个性化配置;
    server.port=9090    # 配置Tomcat启动的端口号，默认是8080
    server.servlet.context-path=/demo    # 配置web应用虚拟目录名，默认是空字符串
5. YML一种新型配置文件，也是一种标记语言，有两种扩展名：.yml、.yaml
    1. YML文件格式是由YAML编写的，YAML是一种能够被电脑识别的数据序列化格式，且易读性强，以数据为核心，比XML更简洁;
    2. YML文件与脚本语言的交互性强，可以被支持YAML库的编程语言程序导入，如C/C++、Python、Java、C#、PHP、Ruby...
</code></pre><h3 id="yml配置文件"><a href="#yml配置文件" class="headerlink" title="yml配置文件"></a>yml配置文件</h3><pre><code>1. 普通数据
    1. key: value
    2. key和value之间必须有一个空格：name: Jack
2. 对象数据/Map数据
    1. 形式一：缩进形式
        key:
            key1: value1
            key2: value2
    2. key1、key2前面的空格个数不限定，相同缩进代表同一级别;
        person:
            name: Java
            age: 20
    3. 形式二：行内形式
        key: {key1: value1,key2: value2}
3. 数组、List、Set
    1. 存放普通字符串
        key:
            - value1
            - value2
        key: [value1,value2]
    2. 存放对象
        key:
            - key11: value11
              key12: value12
            - key22: value22
              key23: value23
        key: [{key11: value11,key12: value12}, {key22: value22,key23: value23}]
4. resources/application.yaml
    1. 自定义SpringMVC的默认配置
        server:
            port: 8888    # 配置服务器的端口号
            servlet:
                path: &quot;*.do&quot;    # 访问映射路径，默认是&quot;/&quot;，会影响所有的请求路径
    2. Log4j相关
        logging:    # 日志配置(log4j相关的依赖已经被集成)
            level:    # 控制日志级别，是一个Map集合
                cn.boot: debug    # cn.boot包下的日志级别为debug
                org.springframework: debug
</code></pre><h3 id="属性映射"><a href="#属性映射" class="headerlink" title="属性映射"></a>属性映射</h3><pre><code>1. 配置文件被加载后，其中的键-值将会被存放到Spring IoC容器中，那么就可以映射到Spring管理的Bean对象中;
2. application.yml
    jdbc:
        driverClassName: com.mysql.cj.jdbc.Driver
        url: jdbc:mysql://host:port/database?serverTimezone=Asia/Shanghai
        username: root
        password： 123456
3. @Value 的映射：指定配置文件的key名，映射到Spring IoC管理的对象属性上，适合数据量较小的情况;
    @Component
    public class JdbcConf {
        @Value(&quot;${jdbc.driverClassName}&quot;)
        private String driverClassName;

        @Value(&quot;${jdbc.url}&quot;)
        private String url;

        @Value(&quot;${jdbc.username}&quot;)
        private String username;

        @Value(&quot;${jdbc.password}&quot;)
        private String password;
    }
4. @ConfigurationProperties：把配置文件中的键值数据映射到当前Java类的属性上;
    @ConfigurationProperties(prefix=&quot;jdbc&quot;)
    public class JdbcConf {
        private String driverClassName;
        private String url;
        private String username;
        private String password;
    }
    1. prefix属性：声明配置文件中的字段前缀，自动映射到Java类的同名属性上;
    2. 使用 @ConfigurationProperties 时，还需要引入其执行器;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
    3. 先在Bean中定义需要的属性，然后在配置文件中配置时，执行器就会提示可配置的属性.
5. @EnableConfigurationProperties：使用 @ConfigurationProperties 注解的Java类;
    @Configuration
    @EnableConfigurationProperties(JdbcConf.class)
    public class TestConfigure {
        @Autowired
        private JdbcConf jdbc;  //1. @Autowired的方式注入JdbcConf对象

        public TestConfigure(JdbcConf jdbc) { //2.构造方法的方式注入JdbcConf对象

        }
        @Bean
        public DataSource getDataSource(JdbcConf prop) {  //3.方法参数的方式注入
            //阿里的druid
            DruidDataSource ds = new DruidDataSource();
            ds.setDriverClassName(prop.getDriverClassName());
            ds.setUrl(prop.getUrl());
            ds.setUsername(prop.getUsername());
            ds.setPassword(prop.getPassword());
            return ds;
        }
    }
6. 如果只有一个Bean对象使用JDBC的连接信息，还可以优雅地映射配置文件中的键-值
    @Configuration
    public class JdbcConfig {
        @Bean
        @ConfigurationProperties(prefix=&quot;jdbc&quot;)
        public DataSource getDataSource(JdbcProperties prop) {
            return new DruidDataSource();
        }
    }
    1. 这种方式不再需要映射配置类JdbcConf，直接在对应Bean对象上使用 @ConfigurationProperties;
    2. DruidDataSource对象中有同名属性：driverClassName、url、username、password，从而实现映射;
</code></pre><h3 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h3><pre><code>1. ResourceProperties中定义了静态资源的查找方向
    classpath:/META-INF/resources/ --&gt;classpath:/resources/ --&gt;classpath:/static/ --&gt;classpath:/public/
2. 注意：classpath 指的就是 src/main/resources 目录，这4个目录都在 src/main/resources 目录下;
3. 这些静态资源目录不受Controller管控，可以直接被访问，用于放入图片、CSS、JS、HTML等静态资源;
4. 创建 resources/static/index.html，访问：localhost:8080/index.html
5. 在配置文件 application.yml 中，可以加入自定义的静态资源目录：
    spring:
        resources:
            static-locations:
                - classpath:/META-INF/resources/
                - classpath:/resources/
                - classpath:/static/
                - classpath:/public/
                - classpath:/abc/
</code></pre><h2 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h2><pre><code>1. 添加起步依赖
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
    &lt;/dependency&gt;
2. IDEA默认不支持热部署，需要设置
    1. Settings --&gt; Compiler --&gt; 勾选 Build project automatically
    2. Ctrl+Shift+Alt+/ --&gt; Registry --&gt; 勾选 compiler.automake.allow.when.app.running
3. 每次修改了Controller层之后，等待服务器重启，刷新浏览器页面;
4. 在配置文件 application.properties  中，配置不被热部署的文件
    spring.devtools.restart.exclude=static/**, application.properties
5. 通过触发器，手动控制热部署
    1. 创建 resources/trigger.txt，添加内容 verion=1
    2. 配置触发器
        spring.devtools.restart.trigger-file=trigger.txt
    3. 需要热部署时，修改触发器：version=2，保存文件即触发热加载部署;
</code></pre><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><pre><code>1. SpringBoot项目中，使用 MultipartFile 对象接收上传的文件时，控制文件的大小;
    1. 在启动类中注册 MultipartConfigElement，设置文件大小
    @Bean
    public MultipartConfigElement getMultipartConfigElement() {
        MultipartConfigFactory factory = new MultipartConfigElement();
        factory.setMaxFileSize(&quot;10240KB&quot;);  //单个文件最大10240KB
        factory.setMaxRequestSize(&quot;102400KB&quot;);  //总上传数据最大102400KB
        return factory.createMultipartConfig();
    }
2. 文件服务器：fastdfs，阿里云oss，nginx搭建一个简单的文件服务器;
3. 上传过程操作的是磁盘的绝对路径，打成了jar包之后，无法直接访问磁盘目录，需要把目录加入静态资源目录列表中;
    images-path=D:\report\
    spring.resources.static-locations=classpath:/META-INF/resources/, ... , file:${images-path}
</code></pre><h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><pre><code>1. 主流的JavaWeb模板引擎：JSP、Velocity、Freemarker、Thymeleaf
    1. JSP：动态网页技术，JavaWeb官方推荐，支持EL、JSTL表达式，本质上也是一个Servlet，占用JVM内存;
    2. Freemarker：文件一般保存为 xxx.ftl，严格依赖MVC模式，不依赖Servlet容器(不占用JVM内存)，内建函数;
    3. Thymeleaf：SpringBoot主推，轻量级模板引擎，后缀名就是.html，浏览器可以直接访问;
2. Thymeleaf不推荐在页面中做复杂的逻辑业务，因为解析DOM/XML会占用较大的内存;
3. Thymeleaf的启动器：spring-boot-starter-thymeleaf
    spring.thymeleaf.cache=false #是否缓存
    spring.thymeleaf.mode=HTML5
    spring.thymeleaf.encoding=UTF-8  #编码
    spring.thymeleaf.content-type=text/html  #类型
    spring.thymeleaf.suffix=.html  #文件后缀名
    spring.thymeleaf.prefix=classpath:/templates/  #前缀：存放路径
4. 创建 resources/templates/user/info.html
        @GetMapping(&quot;info&quot;)
        public String info() {
            return &quot;user/info&quot;;  ---&gt;渲染resources/templates/user/info.html
        }
5. resources/templates 目录不是静态资源目录，需要放在静态资源列表中才能直接访问
    spring.resources.static-locations = classpath:/META-INF/resources/, ... ,classpath:/templates/
6. 页面静态化
    1. Thymeleaf不仅可以把渲染结果写入Response，还可以写到本地文件中，从而实现页面静态化;
    2. 页面静态化：把动态渲染的HTML页面变成静态内容保存，比如部署在Nginx中;
    3. 以后的用户请求到来时，直接访问静态页面，不再经过服务的渲染，从而大大提高并发能力，减小Tomcat的压力.
</code></pre><h2 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h2><pre><code>1. 多环境：开发环境、测试环境、预发布环境、生产环境...  不同环境使用不同的配置，如数据库配置;
2. 多环境切换有很多方式，以 spring.profiles.active 为例
    1. 创建 resources/config 目录，管理SpringBoot的配置文件，注意：config目录名是固定的;
    2. 在 config 中创建 application.properties、application-dev.properties、application-test.properties
    3. application-dev.properties
        db.url=dev.com
    4. application-test.properties
        db.url=test.com
    5. application.properties
        db=local.com
        # 指定使用哪个profile，如果不指定，默认使用当前文件中的配置
        spring.profiles.active=test  # 使用 application-test 中的配置 db.url=test.com
3. 映射到Spring IoC容器中的Java类属性上
    @Value(&quot;${db.url}&quot;)
    private String url;  //test.com
</code></pre><h2 id="打包与容器"><a href="#打包与容器" class="headerlink" title="打包与容器"></a>打包与容器</h2><pre><code>1. SpringBoot项目打成jar包
    1. pom.xml 配置Maven插件
    &lt;packaging&gt;jar&lt;/packaging&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
    2. 打开右侧Maven面板 --&gt; Lifecycle --&gt; 双击执行 install --&gt; 在target目录下生成xxx.jar
    3. 如果没有添加插件，执行 java -jar xxx.jar 命令运行jar包时，会报错：no main manifest attribute
2. SpringBoot项目打成war包
    1. 修改打包方式：&lt;packaging&gt;war&lt;/packaging&gt;
    2. 配置打包的项目名称，也就是项目的虚拟目录名
        &lt;build&gt;
            &lt;finalName&gt;boottest&lt;/finalName&gt;
            &lt;plugins&gt;
                &lt;plugin&gt;
                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
                &lt;/plugin&gt;
            &lt;/plugins&gt;
        &lt;/build&gt;
    3. 修改启动类
    @SpringBootApplication
    public class BootTestApplication extends SpringBootServletInitializer {
        protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
            return builder.sources(BootTestApplication.class);
        }
        public static void main(String[] args) {
            SpringApplication.run(BootTestApplication.class, args);
        }
    }
    4. 执行Lifecycle --&gt; clean，然后执行 install 命令，在target目录下生成 xxx.war
    5. 把 xxx.war 放在 Tomcat/webapps 目录中，启动Tomcat服务器，xxx.war自动解压;
    6. 访问：http://localhost:8080/boottest/xxx
3. SpringBoot默认使用Tomcat容器启动，也可以配置成其他容器
    1. 去除spring-boot-starter-web中集成的Tomcat
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
    2. 配置为jetty容器
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;
        &lt;/dependency&gt;
    3. 配置为undertow容器
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.undertow&lt;/groupId&gt;
            &lt;artifactId&gt;undertow.core&lt;/artifactId&gt;
            &lt;version&gt;1.3.24.Final&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.undertow&lt;/groupId&gt;
            &lt;artifactId&gt;undertow.servlet&lt;/artifactId&gt;
            &lt;version&gt;1.3.24.Final&lt;/version&gt;
        &lt;/dependency&gt;
4. 使用JMeter测试各个容器的性能;
</code></pre><h3 id="部署到阿里云"><a href="#部署到阿里云" class="headerlink" title="部署到阿里云"></a>部署到阿里云</h3><pre><code>1. winscp、secureCRT、FileZilla：远程连接Linux的工具，可视化操作
2. 在Linux上安装JDK
    1. cd /usr/local/  --&gt; mkdir software --&gt; 下载JDK8压缩包、解压、重命名为jdk8
    2. 配置环境变量：vim /etc/profile，在尾部插入以下内容
    export JAVA_HOME=/usr/local/software/jdk8
    export PATH=$PATH:$JAVA_HOME/bin
    export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
    export JAVA_HOME PATH CLASSPATH
    3. 让配置立刻生效：source /etc/profile
    4. 测试：java -version
3. 入门级：把SpringBoot项目部署到Linux云服务器上，要开放对应的端口号;
    1. 去除对生产环境没用的依赖，如热部署spring-boot-starter-test，测试spring-boot-starter-test
    2. 打成jar包，并上传到Linux服务器上 /usr/local/software/app/
    3. 启动：java -jar xxx.jar
4. 守护进程的方式启动：nohup java -jar xxx.jar &amp;   ---&gt; 生成启动日志文件nohup.out
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/03/26/模块化与私服/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/26/模块化与私服/" itemprop="url">模块化与私服</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-26T00:00:00+08:00">
                2016-03-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="拆分与聚合"><a href="#拆分与聚合" class="headerlink" title="拆分与聚合"></a>拆分与聚合</h2><pre><code>1. 拆分：把一个完整的Maven工程拆成独立的模块，如Dao模块、Service模块、Controller(Web)模块、Utils模块;
2. 模块之间的关系：
    1. 模块之间是平级的，需要建立依赖关系，才能引用对方的功能;
    2. Service模块引用Dao模块的坐标，Controller模块引用Service模块的坐标;
    3. 如果想引用另一个Maven工程，则需要把工程打包发布到本地仓库中，再其坐标即可建立依赖关系;
3. 父工程：New Project --&gt; 不使用Maven骨架，只需保留一个pom.xml，其他的文件和目录都可以删除掉;
    1. 把公共的jar包依赖放在父工程中，供所有的子工程使用;
    2. 在 pom.xml 中配置JDK的编译版本，Tomcat7插件;
    3. 打包方式：pom
        &lt;packaging&gt;pom&lt;/packaging&gt;
    4. &lt;dependencyManagement&gt; 管理的依赖和插件不会传递给子工程，但能够统一管理它们的版本号
        &lt;properties&gt;
            &lt;mysql.version&gt;8.0.16&lt;/mysql.version&gt;
        &lt;/properties&gt;
        &lt;dependencyManagement&gt;
            &lt;dependencies&gt;
                &lt;dependency&gt;
                    &lt;groupId&gt;mysql&lt;/groupId&gt;
                    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
                    &lt;version&gt;${mysql.version}&lt;/version&gt;
                &lt;/dependency&gt;
            &lt;/dependencies&gt;
        &lt;/dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;!-- 这些依赖会直接传递给子工程 --&gt;
        &lt;/dependencies&gt;
    5. 在子工程中引入依赖 mysql-connector-java 时，无需再指定版本节点&lt;version&gt;
4. 子工程：右击父工程 --&gt; New Module --&gt; 创建Maven项目
    1. Dao模块和Service模块都不使用骨架，Web模块使用web骨架;
    2. 子工程的 pom.xml 中，会有一个 &lt;parent&gt;，表示继承的父工程;
    3. 父工程的 pom.xml 中，会多出一个 &lt;modules&gt;，列出拥有的子模块;
    4. 依赖包的作用域(scope)默认是compile，父工程的依赖包传递给子工程的过程中，scope为test的依赖可能丢失;
    5. 比如父工程引入了junit(test)，子工程可能无法使用，这种情况下，通常会在子工程中再加入junit依赖即可;
5. Dao模块：resources/spring/applicationContext-dao.xml，只配置Dao层相关
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;
            http://www.springframework.org/schema/beans
            https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

        &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
            &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
            &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;cn.ssm.domain&quot; /&gt;
        &lt;/bean&gt;

        &lt;bean id=&quot;mapperScanner&quot; class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
            &lt;property name=&quot;basePackage&quot; value=&quot;cn.ssm.dao&quot; /&gt;
        &lt;/bean&gt;

        &lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt;
        &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
            &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot; /&gt;
            &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot; /&gt;
            &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot; /&gt;
            &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;
        &lt;/bean&gt;
    &lt;/beans&gt;
6. Service模块
    1. resources/spring/applicationContext-service.xml，只配置Service层相关
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
        xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;
            http://www.springframework.org/schema/beans
            https://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            https://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/tx
            https://www.springframework.org/schema/tx/spring-tx.xsd
            http://www.springframework.org/schema/aop
            https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

        &lt;context:component-scan base-package=&quot;cn.ssm.service&quot; /&gt;
        &lt;bean id=&quot;manager&quot; 
                class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
            &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
        &lt;/bean&gt;
        &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;manager&quot;&gt;
            &lt;tx:attributes&gt;
                &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt;
                &lt;tx:method name=&quot;*&quot; isolation=&quot;DEFAULT&quot; /&gt;
            &lt;/tx:attributes&gt;
        &lt;/tx:advice&gt;
        &lt;aop:config&gt;
            &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* cn.ssm.service.impl.*.*(..))&quot; /&gt;
        &lt;/aop:config&gt;
    &lt;/beans&gt;
    2. pom.xml：引入Dao模块的坐标
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;cn.ssm&lt;/groupId&gt;
                &lt;artifactId&gt;ssmdao&lt;/artifactId&gt;
                &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
7. Web模块
    1. springmvc.xml、web.xml 都和未拆分前相同;
    2. Spring的配置文件：resources/applicationContext.xml，把Dao和Service的部分合并到一起;
        &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
        &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
            xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
            xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
            &lt;!-- 导入Dao部分和Service部分的Spring配置文件 --&gt;
            &lt;import resource=&quot;classpath:spring/applicationContext-dao.xml&quot;/&gt;
            &lt;import resource=&quot;classpath:spring/applicationContext-service.xml&quot;/&gt;
        &lt;/beans&gt;
    3. pom.xml：引入Service模块的坐标
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;cn.ssm&lt;/groupId&gt;
                &lt;artifactId&gt;ssmservice&lt;/artifactId&gt;
                &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    4. 删除 pom.xml 中默认生成的JDK版本相关的&lt;properties&gt;，使用父工程中配置的JDK版本;
    5. 默认也生成了的&lt;build&gt;，也可以删除，父工程中已经配置了Tomcat7插件;
</code></pre><h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><pre><code>1. log4j.properties 放在 Web模块/resources 目录中，启动项目;
2. 方式一：打开右侧的Maven面板 --&gt; 展开父工程的Plugins --&gt; 双击 tomcat7:run 启动;
3. 配置本地的Tomcat，启动服务器，运行项目;
4. 方式三：选择 Web 工程的 tomcat7:run
    1. Maven项目在运行时会扫描 pom.xml，如果本地仓库没有引入的依赖，则从中央仓库下载，再找不到就报错;
    2. Web工程中引入了Service工程的坐标，但Service工程是本地项目，并没有发布到本地仓库，所以运行失败;
    3. 因此要把Service工程发布到本地仓库，但Service工程又引入了Dao工程的坐标，所以只能去发布父工程;
    4. 在右侧的Maven面板上，双击父工程的Lifecycle -&gt; install，等待安装成功;
    5. 启动Web工程的 tomcat7:run，运行项目;
</code></pre><h2 id="私服"><a href="#私服" class="headerlink" title="私服"></a>私服</h2><h3 id="搭建私服-windows"><a href="#搭建私服-windows" class="headerlink" title="搭建私服(windows)"></a>搭建私服(windows)</h3><pre><code>1. 使用专门的Maven仓库管理软件来搭建私服，比如：Apache Archiva，Artifactory，Sonatype Nexus
2. 选择Sonatype Nexus，下载开源版的Nexus压缩包，解压后有两个目录：应用程序目录，私服仓库目录(sonatype-work);
3. 以管理员模式启动cmd窗口，进入应用程序目录，执行bin目录下的 nexus.bat 命令;
    1. 安装、卸载、运行：nexus.bat install，nexus.bat uninstall，nexus.bat start
    2. 查看启动后的服务：右击计算机 -&gt; 管理 -&gt; 服务和应用程序 -&gt; 服务，在列表中查找 nexus;
4. nuxus的全局配置文件：conf/nexus.properties，默认使用的端口号是8081;
5. 启动图形化界面时，确保8081端口未被占用：http://localhost:8081/nexus
    1. 默认用户名和密码：admin，admin123
    2. 左侧导航栏：点击Repositories --&gt; 浏览仓库，查看仓库信息、地址;
    3. Add添加仓库，选择仓库类型：Hosted、Proxy、Virtual，还可以创建仓库组;
6. 创建不同的仓库，管理不同的依赖包
    1. 存放测试包的仓库Snapshots(hosted)，发布包的仓库Releases(hosted);
    2. 第三方包的仓库3rd party(hosted)，中央仓库的代理仓库Central(proxy);
    3. 创建仓库组，把已有的仓库按顺序添加到组中，在本地仓库在私服中查找依赖包时，就能按照仓库的顺序查找，
    最后由代理仓库转到中央仓库中去查找;
</code></pre><h3 id="发布私服"><a href="#发布私服" class="headerlink" title="发布私服"></a>发布私服</h3><pre><code>1. Maven的 settings.xml，配置私服仓库的信息
    &lt;servers&gt;
        &lt;server&gt;
            &lt;id&gt;releases&lt;/id&gt;  ===&gt;指定私服仓库的ID
            &lt;username&gt;admin&lt;/username&gt;  ===&gt;私服的用户名密码
            &lt;password&gt;admin123&lt;/password&gt;
        &lt;/server&gt;
        &lt;server&gt;
            &lt;id&gt;snapshots&lt;/id&gt;  ===&gt;指定私服仓库的ID
            &lt;username&gt;admin&lt;/username&gt;
            &lt;password&gt;admin123&lt;/password&gt;
        &lt;/server&gt;
    &lt;/servers&gt;
2. 要发布哪个项目/模块，就配置它的 pom.xml
    &lt;distributionManagement&gt;
        &lt;!-- 配置发布的仓库ID和地址 --&gt;
        &lt;repository&gt;  ===&gt;正式版的配置，明确发布到存放正式包的仓库
            &lt;id&gt;releases&lt;/id&gt;  ===&gt;此ID必须在 settings.xml 中已经配置过了
            &lt;url&gt;http://localhost:8081/nexus/content/repositories/releases/&lt;/url&gt;
        &lt;/repository&gt;
        &lt;snapshotRepository&gt;
            &lt;id&gt;snapshots&lt;/id&gt;  ===&gt;测试版的配置，明确发布到存放测试包的仓库
            &lt;url&gt;http://localhost:8081/nexus/content/repositories/snapshots/&lt;/url&gt;
        &lt;/snapshotRepository&gt;
    &lt;/distributionManagement&gt;
    1. 执行Lifecycle --&gt; deploy
    2. 执行前面的生命周期时，其后面的生命周期也会执行，所以 install 命令的执行，会把项目/模块安装到本地仓库;
</code></pre><h3 id="从私服下载jar"><a href="#从私服下载jar" class="headerlink" title="从私服下载jar"></a>从私服下载jar</h3><pre><code>Maven的 settings.xml
    &lt;profiles&gt;
        &lt;profile&gt; 
            &lt;id&gt;dev&lt;/id&gt;  ===&gt;profile的id
            &lt;repositories&gt;
                &lt;repository&gt;  ==&gt;仓库id，repositories可以配置多个仓库，保证id不重复
                    &lt;id&gt;nexus&lt;/id&gt;  ==&gt;仓库地址，即nexus仓库组的地址
                    &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt;
                    &lt;releases&gt;
                        &lt;enabled&gt;true&lt;/enabled&gt; ==&gt;是否下载releases构件
                    &lt;/releases&gt;
                    &lt;snapshots&gt;
                        &lt;enabled&gt;true&lt;/enabled&gt;  ==&gt;是否下载snapshots构件
                    &lt;/snapshots&gt;
                &lt;/repository&gt;
            &lt;/repositories&gt;
            &lt;pluginRepositories&gt;  ==&gt;插件仓库，Maven的运行依赖插件，也需要从私服下载插件
                &lt;pluginRepository&gt; ==&gt;插件仓库的id不允许重复，否则后者会覆盖前者
                    &lt;id&gt;public&lt;/id&gt;  ==&gt;配置为仓库组，仓库组的id
                    &lt;name&gt;Public Repositories&lt;/name&gt;  ==&gt;仓库组的名字
                    &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt;  ==&gt;仓库组的地址
                &lt;/pluginRepository&gt;
            &lt;/pluginRepositories&gt;
        &lt;/profile&gt;
    &lt;/profiles&gt;
    &lt;activeProfiles&gt;
        &lt;activeProfile&gt;dev&lt;/activeProfile&gt;  ==&gt;激活id=dev的profile
    &lt;/activeProfiles&gt;
</code></pre><h3 id="按照第三方jar包"><a href="#按照第三方jar包" class="headerlink" title="按照第三方jar包"></a>按照第三方jar包</h3><pre><code>1. 把第三方jar包安装到本地仓库，如fastjson.jar
    1. 查看fastjson.jar的坐标：groupId、artifactId、version;
    2. 进入fastjson.jar所在的目录，执行命令:
    mvn install:install-file -DgroupId=com.alibaba -DartifactId=fastjson -Dversion=1.1.37 
    -Dfile=fastjson-1.1.37.jar -Dpackaging=jar
    3. 如果不在fastjson.jar的目录，则需要指定绝对路径： -Dfile=D:\download\fastjson-1.1.37.jar
2. 把第三方jar包安装到私服
    1. 在Maven的 settings.xml 中，添加存放第三方jar包的仓库信息
        &lt;server&gt;
            &lt;id&gt;thirdparty&lt;/id&gt;
            &lt;username&gt;admin&lt;/username&gt;
            &lt;password&gt;admin123&lt;/password&gt;
        &lt;/server&gt;
    2. 进入jar所在目录
        mvn deploy:deploy-file -DgroupId=com.alibaba -DartifactId=fastjson -Dversion=1.1.37 
        -Dfile=fastjson-1.1.37.jar -Dpackaging=jar  -DrepositoryId=thirdparty 
        -Durl=http://localhost:8081/nexus/content/repositories/thirdparty/
        1. -Durl：私服的仓库地址;
        2. -DrepositoryId：私服的仓库ID;
    3. 如果不在jar包所在目录，-Dfile=jar包的绝对路径;
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">大麦田怪圈</p>
              <p class="site-description motion-element" itemprop="description">敢做就能赢！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">60</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大麦田怪圈</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
