<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="敢做就能赢！">
<meta property="og:type" content="website">
<meta property="og:title" content="大麦田程序猿">
<meta property="og:url" content="http://hellomyshadow.github.io/page/4/index.html">
<meta property="og:site_name" content="大麦田程序猿">
<meta property="og:description" content="敢做就能赢！">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="大麦田程序猿">
<meta name="twitter:description" content="敢做就能赢！">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hellomyshadow.github.io/page/4/">





  <title>大麦田程序猿</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大麦田程序猿</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/05/01/SpringCloud/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/01/SpringCloud/" itemprop="url">SpringCloud</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-01T00:00:00+08:00">
                2016-05-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><pre><code>1. 集中式架构
    用户 --&gt; [商品管理&lt;-&gt;订单管理&lt;-&gt;用户管理&lt;-&gt;购物车管理&lt;-&gt;权限管理&lt;-&gt;内容管理] --&gt; 数据库
    1. 代码耦合、开发维护困难;  无法针对性优化不同模块;
    2. 无法水平扩展;  单点容错率底，并发能力差;
2. 垂直拆分
    用户 --&gt; [用户中心、搜索系统、后台管理、认证中心] --&gt; 数据库
    1. 系统拆分实现了流量分担，解决了并发问题;
    2. 各个模块独立，可以针对性优化不同模块;
    3. 方便水平扩展，负载均衡，容错率提供;
    4. 缺点：系统间相互独立，会造成很多重复开发工作，影响开发相率;
3. 分布式服务
    1. 当垂直应用越来越多时，应用之间的交互不可避免，那么就将核心业务提取出来，作为独立的服务，逐渐形成稳定的服务中心，
    使前端应用能更快地响应多变地市场需求;
    2. 关键在于：提高业务复用及整合的分布式调用;
</code></pre><p><img src="//hellomyshadow.github.io/2016/05/01/SpringCloud/分布式服务.jpg" alt="分布式服务"></p>
<pre><code>    1. 优点：抽取了基础服务，系统间相互调用，提高了代码复用和开发效率;
    2. 缺点：系统间耦合度变高，调用关系错综复杂，难以维护;
4. 流动计算框架(SOA)，面向服务的架构，服务治理
    1. 当服务越来越多，容量的评估、小服务资源的浪费等问题逐渐显现，此时需要增加一个调度中心，基于访问压力实时管理集群容量，
    提高集群利用率;
    2. 关键在于，提高机器利用率的资源和治理中心(SOA)
</code></pre><p><img src="//hellomyshadow.github.io/2016/05/01/SpringCloud/SOA.jpg" alt="SOA"></p>
<pre><code>1. 服务注册中心：实现服务自动注册和发现，无需手动记录服务地址;
2. 服务自动订阅：服务列表自动推送，服务调用透明化，无需关心依赖关系;
3. 动态监控服务状态的监控报告，手动控制服务状态;
4. 缺点：
    1. 服务间会有依赖关系，一旦某个环节出错，会影响较大;
    2. 服务关系复杂，运维、测试部署困难，不符合DevOps思想;
</code></pre><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><pre><code>1. 微服务看起来与SOA类似，也是服务，都是对系统进行拆分，但还是有一些差别的;
</code></pre><p><img src="//hellomyshadow.github.io/2016/05/01/SpringCloud/微服务架构.jpg" alt="微服务架构"></p>
<pre><code>2. 微服务的特点：
    1. 单一职责：微服务中每一个服务都对应唯一的业务能力，做到单一职责；
    2. 微：服务拆分的粒度很小，比如一个用户管理就可以作为一个服务，每个服务虽小，但&quot;五脏俱全&quot;；
    3. 面向服务：每个服务都要对外暴露Rest风格的服务接口，外界不关心服务的技术实现，从而做到与平台和语言无关，
    也不限定使用的技术，只要提供Rest的接口即可;
    4. 自治：服务间相互独立，互不干扰;
        1. 团队独立：每个服务都是一个独立的开发团队，人数不能过多;
        2. 技术独立：因为是面向服务，只需要提供Rest接口，无关使用什么技术实现;
        3. 前后端分离：采用前后端分离开发，提供统一的Rest接口，后台不再为PC、移动端开发不同接口;
        4. 数据库分离：每个服务都使用自己的数据源;
        5. 部署独立：服务间虽有调用，但要做到服务重启不影响其他服务，有利于持续集成和持续交付，每个服务都是独立的组件，
        可复用，可替换，降低耦合，易维护;
3. 服务拆分的临界点是非常模糊的，需要对架构非常了解，拥有丰富的经验，具体业务具体分析。
</code></pre><h2 id="服务调用方式"><a href="#服务调用方式" class="headerlink" title="服务调用方式"></a>服务调用方式</h2><pre><code>1. 无论是微服务还是SOA，都面临着服务间的远程调用问题，常见的两种远程调用方式：RPC、HTTP
2. RPC：Remote Produce Call，远程过程调用，类似的还有RMI
    1. 自定义数据格式，基于原生TCP通信，速度快，效率高;
    2. 早期的WebService，还有当前热门的Dubbo，都是RPC的典型代表;
3. HTTP：一种网络传输协议，规定了数据传输的格式
    1. 缺点：消息封装臃肿，相对于RPC，传输速度会慢一些;
    2. 优势：对服务的提供和调用方没有任何技术限定，自由灵活，更符合微服务的理念;
    3. 现在热门的Rest风格，就可以通过HTTP协议来实现;
4. 如果完全采用Java技术栈，Dubbo作为微服务架构是一个不错的选择;
5. 如果技术栈多样化，而且比较青睐Spring家族，那么SpringCloud搭建微服务是不二之选;
</code></pre><h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2><pre><code>1. Java代码间相互调用的主流HTTP客户端：HttpURLConnection(JDK)、HttpClient(Apache)、OKHttp... 但它们的API各不相同;
2. Spring提供了一个模板工具类 RestTemplate ，基于HTTP客户端的封装，并且实现了对象的JSON的序列化和反序列化;
3. RestTemplate抽象了HTTP客户端的类型，目前常用的 HttpURLConnection(默认方式)、HttpClient、OKHttp 都支持;
    1. 在SpringBoot项目中，引入web启动器：spring-boot-starter-web
    2. 在启动器类中，注册 RestTemplate
        @Bean
        public RestTemplate getRestTemplate() {
            return new RestTemplate();
        }
    3. 通过 RestTemplate 去请求另一个工程(端口号9999)，获取JSON数据并封装到POJO对象中
        @Autowired
        private RestTemplate rest;
        @Test
        public void test() {
            User user = rest.getForObject(&quot;http:localhost:9999/user/11&quot;, User.class);
        }
4. SpringCloud
    1. SpringCloud是实现微服务的一种架构方式，背后是整个Spring全家桶;
    2. SpringCloud可以和Spring的各个框架无缝整合，完全支持SpringBoot的开发模式;
    3. Spring最擅长的就是集成，它其实是把世界上最好的框架集成到自己的项目中;
    4. SpringCloud也是整合现在非常流行的一些技术，实现 配置管理、服务发现、智能路由、负载均衡、熔断器、控制总线、集群状态...
    5. 主要涉及的组件包括：Eureka(注册中心)、Zuui(服务网关)、Ribbon(负载均衡)、Feign(服务调用)、Hystix(熔断器)
    6. 这些组件大都来自Netflix公司，它是做在线视频的公司，流量和压力非常大，所以早期SpringCloud都是采用Netflix的框架;
5. SpringCloud的版本号没有采用数字，而是A、B、C...开头的单词，据说是伦敦地铁站的名字;
    1. Angle.RELEASE：2015.3
    2. Brixton.RELEASE：2016.5
    3. Camden.RELEASE：2016.9
    4. Dalston.RELEASE：2017.4
    5. Edgware.RELEASE：2017.11，基于SpringBoot1.5以下
    6. Finchley.RELEASE：2018.6，基于SpringBoot2.0
6. SpringBoot
    1. SpringBoot1.5.0-RELEASE：2016.4
    1. SpringBoot2.0.0-RELEASE：2018.3
7. SpringCloud Finchley.RELEASE 中部分重要组件
</code></pre><p><img src="//hellomyshadow.github.io/2016/05/01/SpringCloud/SpringCloud.jpg" alt="SpringCloud"></p>
<h2 id="微服务的环境准备"><a href="#微服务的环境准备" class="headerlink" title="微服务的环境准备"></a>微服务的环境准备</h2><pre><code>1. SpringCloud对版本的要求极其严格，版本冲突会带来很多意想不到的问题;
2. SpringCloud Finchley.RELEASE 搭建微服务时，SpringBoot版本选择v2.0.x，不能是v2.1.x;
3. 为了操作方便，不为每个服务创建独立的工程，而是创建Maven的聚合工程;
4. 创建一个父工程，打包方式为pom，统一管理依赖版本;
    &lt;packaging&gt;pom&lt;/packaging&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.0.4.RELEASE&lt;/version&gt;
    &lt;/parent&gt;
    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;java.version&gt;1.8&lt;/java.version&gt;
        &lt;spring-cloud.version&gt;Finchley.SR1&lt;/spring-cloud.version&gt;  ==&gt;兼容spring-boot2.0.x
        &lt;mapper.starter.version&gt;2.1.5&lt;/mapper.starter.version&gt;
        &lt;mysql.version&gt;8.0.16&lt;/mysql.version&gt;
    &lt;/properties&gt;
    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
                &lt;version&gt;${spring-cloud.version}&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;
                &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;
                &lt;version&gt;${mapper.starter.version}&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;mysql&lt;/groupId&gt;
                &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
                &lt;version&gt;${mysql.version}&lt;/version&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;version&gt;1.18.8&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
                &lt;!-- &lt;version&gt;2.0.4.RELEASE&lt;/version&gt; --&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
5. spring-cloud-dependencies：SpringCloud版本管理的pom，它管理了SpringCloud所有组件的版本，在引入这些组件时，
    不要再指定版本号;
    1. SpringCloud-Finchley.xx 只兼容 SpringBoot-v2.0.x
    2. SpringCloud-Greenwich.xx 可以支持 SpringBoot-v2.1.x
6. 创建子工程userservice，作为服务提供方，端口号8081
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;version&gt;2.0.4.RELEASE&lt;/version&gt;  --&gt;版本号与SpringBoot保持一致
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;
    &lt;/dependency&gt;
    1. application.yml
        server:
            port: 8081
        spring:
            datasource:
                driver-class-name: com.mysql.cj.jdbc.Driver
                url: jdbc:mysql:///db_cloud?serverTimezone=Asia/Shanghai
                username: root
                password: 123456
        mybatis:
            type-aliases-package: cn.cloud.pojo
            impl: org.apache.ibatis.logging.stdout.StdOutImpl
    2. POJO对象
        @Table(name=&quot;tb_user&quot;)
        @Data
        public class User {
            @Id
            @KeySql(useGeneratedKeys = true)
            private Long id;
            ...
        }
    3. Mapper接口
        public interface UserMapper extends Mapper&lt;User&gt; { }
    4. Service层
        @Service
        public class UserService {
            @Autowired
            private UserMapper mapper;

            public User findById(Long id) {
                return mapper.selectByPrimaryKey(id);
            }
        }
    5. Web层
        @RestController
        @RequestMapping(&quot;user&quot;)
        public class UserController {
            @Autowired
            private UserService service;

            @GetMapping(&quot;/{id}&quot;)
            public User findById(@PathVariable(&quot;id&quot;) Long id) {
                return service.findById(id);
            }
        }
    6. 启动类
        @SpringBootApplication
        @MapperScan(&quot;cn.cloud.mapper&quot;)
        public class UserApplication {
            public static void main(String[] args) {
                SpringApplication.run(UserApplication.class, args);
            }
        }
7. 创建子工程consumerservice，作为服务的消费方，端口号8080
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;version&gt;2.0.4.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    1. POJO对象
        @Data
        public class User {
            private Long id;
            ......
        }
    2. Web层
        @RestController
        @RequestMapping(&quot;consumer&quot;)
        public class ConsumerController {
            @Autowired
            private RestTemplate rest;

            @GetMapping(&quot;{id}&quot;)
            public User findById(@PathVariable(&quot;id&quot;) Long id) {
                //访问服务提供者，获取数据
                String url = &quot;http://localhost:8081/user/&quot; + id;
                User user = rest.getForObject(url, User.class);
                return user;
            }
        }
    3. 启动类
        @SpringBootApplication
        public class ConsumerApplication {
            @Bean
            public RestTemplate getRestTemplate() {
                return new RestTemplate();
            }
            public static void main(String[] args) {
                SpringApplication.run(ConsumerApplication.class, args);
            }
        }
8. 启动两个服务，点击右下角的提示：Run Dashboard -&gt; Show run ... -&gt; 弹出 Run Dashboard 窗口，便于管理服务;
    http://localhost:8081/user/9  --&gt; 测试服务的提供方
    http://localhost:8080/consumer/9  --&gt; 测试服务的消费方
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/04/10/Redis高级/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/10/Redis高级/" itemprop="url">Redis高级</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-10T00:00:00+08:00">
                2016-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><pre><code>1. Redis是一种基于C语言开发的NoSQL数据库，代码量只有3万多行，内存级别的读写，而且提供了持久化功能；
2. Redis与Memcache
    1. 它们都是非常流行的两种NoSQL数据库，都能用于服务器端的数据缓存；
    2. 实现方式：Redis是单线程，Memcache是多线程；
    3. 存储方式：Redis支持数据持久化和主从备份，数据更安全；Memcache的数据只存储在内存中，没有持久化功能；
    4. Redis除了基本的 k-v 结构，还支持多种其他复杂结构、事务等高级功能，它已经不仅仅是一个缓存服务；
    5. Memcache只支持基本的 k-v 结构，功能相对单一；
    6. 可用性：Redis支持主从复制、数据分片、哨兵监控；Memcache没有分片功能，需要从客户端支持。
3. 安装
    cd /usr/local/
    wget http://download.redis.io/releases/redis-5.0.4.tar.gz
    tar -zxvf /redis-5.0.4.tar.gz
    cd redis-5.0.4
    make &amp;&amp; make install
</code></pre><h2 id="redis-conf"><a href="#redis-conf" class="headerlink" title="redis.conf"></a>redis.conf</h2><pre><code>1. Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程
    daemonize no
2. 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件
    pidfile /var/run/redis.pid
3. Redis监听端口，默认为6379
    port 6379
4. 绑定的主机地址
    bind 127.0.0.1
5. 当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能
    timeout 300
6. 设置数据库的数量，默认为16，编号0-15，默认操作是 0 号数据库
    databases 16
    1. 虽然分了16个数据库，但其实只是逻辑划分，并不是物理地把硬盘容量分成16份;
    2. 某号数据库存储了数据之后，才会分配容量，所以完全可以把所有的数据都存储在0号数据库;
7. RDB方式的持久化，默认方式
    save 900 1
    save 300 10
    save 60 10000
8. 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩;
    rdbcompression yes
    1. 如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大.
9. 指定本地数据库文件名，默认值为dump.rdb
    dbfilename dump.rdb
10. 指定本地数据库存放目录，默认就是当前目录
    dir ./
11. 当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步
    slaveof &lt;masterip&gt; &lt;masterport&gt;
12. 当master服务设置了密码保护时，slav服务连接master的密码
    masterauth &lt;master-password&gt;
13. 设置Redis连接密码，如果配置了密码，客户端在连接Redis时需要通过AUTH &lt;password&gt;命令提供密码，默认关闭
    requirepass foobared
    1. 登录时提供密码：redis-cli -h IP地址 -p 端口号 -a 密码
    2. 在登录时不提供密码，通过 auth 命令验证密码
        redis-cli -h IP地址 -p 端口号
        &gt;&gt; auth 密码
14. 设置同一时间最大客户端连接数，默认无限制;
    maxclients 128
    1. Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数;
    2. 如果设置 maxclients 0，表示不作限制;
    3. 当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息.
15. 指定Redis最大内存限制
    maxmemory &lt;bytes&gt;
    1. Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key;
    2. 如果这种方式处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作;
    3. Redis新的 vm 机制会把 Key 存放内存，Value 存放在 swap 区.
16. AOF方式的持久化，默认关闭
    appendonly no
    appendfilename appendonly.aof
    appendfsync everysec  # no  always  everysec
17. 指定包含的其它配置文件
    include /path/to/local.conf
    1. 在同一主机上，多个Redis实例可以使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件.
</code></pre><h3 id="远程访问"><a href="#远程访问" class="headerlink" title="远程访问"></a>远程访问</h3><pre><code>1. Redis默认不允许远程访问，修改配置文件：
    1. bind 127.0.0.1 # 注释掉 或者 改为本机的IP地址
    2. protected-mode no  # 如果不设置密码，则关闭保护模式
    3. deamonize yes  # 后台启动运行Redis
2. Redis数据库由一个整数索引标识，而不是一个具体的数据库名称，默认操作的数据库是0号;
    1. select 数据库索引：切换数据库;
    2. move key 数据库索引：移动key到指定数据库;
    3. flushdb：清空当前数据库的key;
    4. flushall：清空所有数据库的key.
</code></pre><h3 id="数据淘汰策略"><a href="#数据淘汰策略" class="headerlink" title="数据淘汰策略"></a>数据淘汰策略</h3><pre><code>1. Redis脚本：Redis使用 Lua 解释器来执行脚本，Redis2.6通过内嵌支持 Lua 环境，执行脚本的常用命令为 EVAL
2. Redis数据淘汰策略
    1. Redis官方的警告：当内存不足时，Redis会根据配置的缓存策略淘汰部分Key，以保证写入成功;
    2. 当无淘汰策略 或者没有找到合适的key时，Redis直接返回 Out of Memory 错误;
    3. 在配置文件 redis.conf 中，允许设置的最大缓存大小：maxmemory 512G
3. Redis提供的数据淘汰策略
    1. volatile-lru：从已设置过期时间的数据集中，挑选最近最少使用的数据淘汰;
    2. volatile-lfu：从已设置过期的key中，淘汰一段时间内使用次数最少的;
    3. volatile-ttl：从已设置过期时间的数据集中，淘汰最近将要过期的数据;
    4. volatile-random：从已设置过期时间的数据集中，随机选择淘汰的数据;
    5. allkeys-lru：从数据集中，淘汰最近最少使用的数据;
    6. allkeys-lfu：从所有key中，淘汰一段时间内使用次数最少的;
    7. allkeys-random：从数据集中，随机选择淘汰的数据;
    8. no-enviction：不采用任何淘汰策略，默认配置.
4. 在平时使用时，应尽量主动设置/更新key的过期时间，主动剔除不活跃的旧数据，有助于提升查询性能.
</code></pre><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><pre><code>1. RDB：默认持久化方案，当满足一定条件时，Redis会自动将内存中的数据全部持久到硬盘文件中;
    1. 在配置文件redis.conf中配置RDB的条件：save (time) (count)
    2. 当满足在time(秒)时间内，至少进行了count次修改后，触发持久化条件，进行RDB快照
2. 默认配置(三者是或的关系)
    save 900 1  # 15分钟内，有至少1个键被更改，则触发RDB快照
    save 300 10  # 5分钟内，有至少10个键被更改
    save 60 10000  # 1分钟内，至少有10000个键被更改
3. 以快照的方式写入到二进制文件中，默认文件名：dump.rdb
    dbfilename dump.rdb  #本地数据库文件
    dir  ./  #本地数据库的存放路径，./ 表示当前目录
4. 快照：保存数据、还原数据极快，适用于灾难性备份;
5. 触发快照的条件，除了配置文件中配置的RDB快照，在服务器正常关闭时，shutdown，也会触发快照;
2. RDB的流程：
    1. Redis使用fork函数来复制一份当前进程(父进程)的副本(子进程);
    2. 父进程继续接收并处理请求，子进程开始把内存中的数据写入硬盘中的临时文件;
    3. 子进程写完后，会使用临时文件替代旧的RDB文件;
</code></pre><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><pre><code>1. AOF：把每一条服务端接收到的写命令都记录下来，每隔一定时间，写入硬盘的AOF文件中;
    1. 当服务器重启后，重新执行这些命令，恢复数据;
    appendonly yes  # 开启AOF
    2. 每收到写命令时，都会记录到文件中，默认文件名：appendonly.aof
2. 这种方式没有RDB快照的限制，适用于Redis意外宕机的数据恢复;
3. AOF的缺点也很明显，占用较大的内存，所以Redis的默认持久化策略是RDB
4. AOF写入的频率：同步策略三选一
    appendfsync always  # 每次都同步(最安全但最慢)
    appendfsync everysec  # 每秒同步(默认)
    appendfsync no  # 不主动同步，由操作系统来决定(最快但不安全)
    1. 默认情况下，文件会先写入到系统的缓存中，系统每30s同步一次，才会真正写入到硬盘;
    2. 如果在这30s内，服务器宕机，那么数据也会丢失;
  5. AOF文件重写
      1. 当记录命令过多时，必然会出现对同一个key的多次写操作，此时只需要记录最后一条即可，前面的记录都毫无意义;
      2. 因此，当满足一定条件时，Redis会对AOF文件进行重写，移除对同一个key的多次操作命令，只保留最后一条;
    auto-aof-rewrite-percentage 100
    1. 当前的AOF文件大小超过上一次重写时的AOF文件大小的百分之多少时，会再次进行重写;
    2. 如果之前没有重写过，则以启动时的AOF文件大小为依据;
    auto-aof-rewrite-min-size 64mb
    1. 限制允许重写的最小AOF文件大小，通常在AOF文件很小的时候、即使其中有些冗余的命令，也是可以忽略的;
</code></pre><h2 id="高级命令"><a href="#高级命令" class="headerlink" title="高级命令"></a>高级命令</h2><pre><code>1. 通配符：*
    1. keys *：所有的键;
    2. keys list*：以 list 开头的所有键;
2. 过期时间
    1. expire [key] [time]：为一个已经存在的key设置过期时间;
    2. ttl [key]：查看一个key的剩余过期时间，-2 表示已经过期了，-1 表示没有设置过期时间;
    3. persist [key]：取消过期时间;
3. move [key] [数据库编号]：把key移动到指定的数据库;
4. rename [key] [newkey]：对key重命名
5. dbsize：查看当前数据库的key数量
6. info：查看Redis的详细信息
7. flushdb、flushall：清空当前数据库、清空所有数据库
8. config get *：查看 redis.conf 的所有配置项
</code></pre><h2 id="订阅发布"><a href="#订阅发布" class="headerlink" title="订阅发布"></a>订阅发布</h2><pre><code>1. Redis的发布订阅是一种消息通信模式：发送者发送消息，订阅者接收消息，客户端可以订阅任意数量的频道;
2. 订阅频道
    1. subscribe 频道1 频道2 ... : 订阅指定的一个或多个频道;
    2. psubscribe 模式1 模式2... : 订阅一个或多个符合指定模式的频道;
3. 发布频道
    publish 频道1 消息
4. 退订频道
    1. unsubscribe 频道1 频道2 ...
    2. punsubscribe 模式1 模式2 ...
5. 比如：客户端1、2 订阅频道cctv5，客户端3 向频道cctv5 发布消息，客户端1、2 就会受到订阅的消息;
6. 应用：构建实时消息系统，如普通的即时聊天、群聊等功能；
    1. 在一个博客网站，有100个粉丝订阅了AA，当AA发布新文章时，就可以推送消息给这100个粉丝;
    2. 微信公众号模式;
</code></pre><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><pre><code>1. Redis事务可以一次执行多个命令，按顺序串行化执行，且执行过程中不许加塞;
    1. 批量操作在发送 EXEC 命令前被放入队列缓存;
    2. 收到 EXEC 命令后，进入事务执行，事务中任何命令执行失败，其余命令依然被执行;
    3. 在事务执行过程中，其他客户端提交的命令请求不会插入到事务执行序列中;
    4. 总的来说，Redis会将一个事务中的所有命令序列化，然后按顺序执行，且不允许出现加塞行为.
2. 事务经历的三个阶段：开启事务 --&gt; 命令入列 --&gt; 执行事务;
3. A向B转账
    multi  #开启事务，以后的命令会依次进入到序列中
    get account:a
    get account:b
    decrby account:a 50  #A减50
    incrby account:b 50  #B加50
    exec  #执行事务
4. discard：取消事务，放弃队列中的所有命令；开启了事务，但不想执行 exec 命令时，可执行 discard 命令取消事务;
5. 错误处理：
    1. 如果队列中的某个命令出现错误，比如操作的key不存在，属于逻辑业务的错误，那么这条命令不再执行，
    而其他命令仍照常执行，而且不会回滚;
    2. 但如果某个命令出现报告错误(语法错误)，比如输入的命令不存在，Redis会立即报错，那么Redis会取消事务，
    所有命令都不会执行;
6. watch/unwatch
    1. 当两个事务同时操作同一个key时，可能会导致数据的不一致;
    2. watch key key ... : 监视key，在开启事务之后、执行事务之前，这个key被其他命令改动了，
    那么当前事务将会被打断，并回滚;
    3. unwatch：取消对所有key的监视;
    4. 如果在执行 watch 命令之后，只要执行了 exec 或 discard 命令，watch会自动取消，无需再执行 unwatch 命令.
7. 应用场景：
    1. 一组命令必须同时执行，或者都不执行;
    2. 保证一组命令在执行过程中不被其他命令插入;
    3. 商品秒杀活动、转账;
</code></pre><h2 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h2><pre><code>1. 缓存穿透
    1. 查询一个不存在数据时，缓存中没有，就需要从数据库中查询，查不到数据就不写入缓存中，导致每次请求
    这个不存在的数据时，都要到数据库中去查询，造成缓存穿透;
    2. 解决方式：持久层查询不到数据时，就缓存一个空结果(空字符串)，每次查询时先判断缓存中是否存在key，
    如果有，则直接返回空值，表示此数据不存在，否则就去查询数据库;
    3. 另外，持久层 insert 此数据时，及时清除查询的key，或者设置空结果的缓存时间;
2. 缓存雪崩
    1. 如果缓存集中在一段时间内失效，发生大量的缓存穿透，所有的查询都落在数据库上，造成缓存雪崩;
    2. 缓存雪崩没有完美的解决方案，应分析用户行为，尽量将缓存失效时间均匀分布;
    3. 大多数系统设计者会考虑加锁/分布式锁，或者队列的方式来保证单线程/进程去写缓存，从而避免失效时
    大量的并发请求落在数据库上;
3. 热点key
    1. 某个key访问非常频繁，当key失效时，将会有大量线程来构建缓存，导致负载增加，系统崩溃;
    2. 解决方案：
        1. 使用锁，单机使用synchronized、lock等，分布式使用分布式锁;
        2. 不设置缓存过期时间，而是在对应的value里设置一个时间，如果检测到超过了这个时间，则异步更新缓存;
        3. 在value里设置一个比过期时间t0小的过期时间t1，当t1过期时，延长t1，并更新缓存;
        4. 设置标签缓存，并设置过期时间，标签缓存过期后，异步更新实际缓存;
4. 缓存预热：在项目即将发布上线之前，清空Redis数据库，然后由开发者把所有的功能调试一遍，
   这样Redis中就有了一些缓存数据，然后再发布项目，这样做也是为了避免大量用户同时去查询MySQL数据库了;
</code></pre><h3 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h3><pre><code>1. 数据一致性：Redis缓存与MySQL中的数据要保证一致性;
2. 实时同步：适用于对一致性要求比较高的业务;
    1. 缓存中不存在，则去数据库查询，并保存到缓存中;
    2. 如果数据库中的数据修改了，缓存也要修改;
3. 在SpringBoot中，采用注解的方式来完成 if-else 的工作
    1. @Cacheable：查询时使用，Long类型需要转为String类型，否则会抛出异常;
    2. @CachePut：更新时使用，此注解一定会从数据库中查询数据;
    3. @CacheEvict：删除时使用;
    4. @Caching：组合用法;
4. 异步队列：对于并发程度较高的情况，则采用异步消息队列的方式同步;
5. 阿里的同步工具canal：模拟MySQL slave和master(主从)的同步机制，监控DB bitlog的日志更新来触发缓存的更新;
6. 采用UDF自定义函数的方式：面向MySQL的API进行编程，利用触发器进行缓存同步，UDF主要由C/C++实现;
</code></pre><h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h2><pre><code>1. 在实际项目中，一般不会只是用一台Redis
    1. 从结构上来说，单个Redis服务器会发生单点故障，并且一台服务器处理所有的请求负载，压力较大;
    2. 从容量上来说，单个Redis服务器的内存容量有限，就算容量为256G，也不能都用作Redis存储内存，
    单台Redis最大使用内存不应超过20G;
2. 高并发的指标：响应时间、吞吐量、每秒查询率QPS、并发用户...
3. 在方法论中，提高系统并发能力的方式主要有两种：垂直扩展、水平扩展
    1. 垂直扩展：提升单机的处理能力，包括增强单机硬件性能、提升单机架构性能;
    2. 水平扩展：增加服务器数量，线性扩充系统性能;
</code></pre><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><pre><code>1. 一个Redis服务有多个复制品，这个服务称为Master，其他复制品称为Slaves;
2. 在Redis主从模式中，一台主库可以有多个从库，但一个从库只能有一个主库，从库还可以连接到其他从库;
3. 主从复制不会阻塞Master和Slaves，在同步数据时，它们可以继续处理Client的请求;
4. 主从复制实现了数据备份，读写分离;
5. 单机主从复制(一台机器，多个Redis服务)，集群主从复制;
    1. A、B、C三个服务器，A作为Master，B、C作为Slave
    2. A [redis.conf]
        bind 192.168.11.8  #使用本机地址，不能使用回环地址
    3. B [redis.conf]
        bind 192.168.11.12
        slaveof 192.168.1.11 6379  #配置Master的IP和端口号
    4. C [redis.conf]
        bind 192.168.11.34
        slaveof 192.168.1.11 6379  #配置Master的IP和端口号
    5. 启动三台服务器上的Redis服务
6. redis-cli 登录某个Redis，通过 info 命令可以查看当前Redis的信息
7. Slave不支持写命令(set)，只能读(get)，否则会报错：(error) READONLY ... read only slave.
</code></pre><h2 id="集群：Redis-Cluster"><a href="#集群：Redis-Cluster" class="headerlink" title="集群：Redis-Cluster"></a>集群：Redis-Cluster</h2><pre><code>1. Redis搭建集群的方案有多种，Redis3.0之前大多采用哨兵模式、主从复制、分片技术;
2. 从Redis3.0开始支持 redis-cluster 集群，至少需要 3(Master)+3(Slave) 才能搭建集群;
</code></pre><h3 id="去中心化"><a href="#去中心化" class="headerlink" title="去中心化"></a>去中心化</h3><pre><code>1. Redis-Cluster采用去中心化结构，每个节点都保存数据和整个集群状态，每个节点都和其他所有节点连接;
2. 所有节点彼此互联(PING-PONG机制)，内部使用二进制协议优化传输速度和带宽;
3. 节点的fail是通过集群中超过半数的节点检测失效时才生效;
4. 客户端与Redis节点直连，不需要中间Proxy层，客户端只需要连接集群中的任意一个节点即可;
5. Redis-Cluster把所有的物理节点映射到 0-16383 slot上，Cluster负责维护;
6. Redis集群预分配 16384 个哈希槽，在Redis集群中放置一个 key-value 时，Redis先对key使用 crc16 算法
   计算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，
   Redis会根据节点数量大致均等地将哈希槽映射到不同的节点上;
</code></pre><h3 id="容错性"><a href="#容错性" class="headerlink" title="容错性"></a>容错性</h3><pre><code>1. 投票机制：由集群中所有的Master参与，如果半数以上的Master节点与当前Master节点通信超时，则认为当前Master节点挂掉;
2. 如果集群中的某个Master挂掉，且它没有Slave，则集群进入fail状态，也可以认为集群的Slot映射 0-16383 不完整时进入fail状态;
3. 如果集群超过半数以上的Master挂掉，无论是否有Slave，集群都进入fail状态.
</code></pre><h3 id="节点分配"><a href="#节点分配" class="headerlink" title="节点分配"></a>节点分配</h3><pre><code>1. 三个主节点分别是A、B、C，它们可以是一台机器上的三个端口，也可以是三台不同的服务器;
2. 采用哈希槽的方式来分配 16384 个Slot时，三个节点分别承担的Slot区间：A[0-5460]，B[5461-10922]，C[10923-16383]
3. 新增一个主节点D，Cluster会从各个主节点的前面各取一部分Slot到 D 上;
    1. A 覆盖 [1365-5460]，B 覆盖 [6827-10922]，C 覆盖 [12288-16383]
    2. D 覆盖 [0-1364，5461-6826，10923-12287]
4. Redis-Cluster的节点分配体现了去中心化思想，不会去优待任何节点;
</code></pre><h3 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h3><pre><code>1. 集群中至少应该有奇数个节点，同时每个节点至少有1个备份节点，主节点、备份节点由 Redis-Cluster 确定;
2. 真集群 - 至少6台机器，假集群 - 一台机器中存在6个Redis服务;
[- 使用一台机器模拟：ubuntu、redis-v5.0.4、一台机器模拟 -]
1. 创建Redis节点安装目录(集群目录)
    mkdir /usr/local/redis_cluster
2. 在 redis_cluster 目录下，创建6个文件夹：7001-7006，分别代表6个节点
    mkdir 7001，mkdir 7002，mkdir 7003，mkdir 7004，mkdir 7005，mkdir 7006
3. 把 redis.conf 分别拷贝到这6个目录下，修改这些目录下的redis.conf，以7001为例
    bind 192.168.13.22  # 直接注释掉，或者使用本机IP，不能使用回环地址(必配)
    port  7001  # 绑定端口号，分别对应7001-7006，以区分Redis服务(必配)
    protected-mode no  #如果不设置密码，则关闭保护模式(必配)
    daemonize  yes  # redis后台运行(守护进程的方式)

    dir ./   # 确保数据文件在各自的目录下，/usr/local/redis_cluster/7001/

    pidfile  /var/run/redis_7001.pid  # 修改PID进程文件名(必配)
    logfile  /usr/local/redis_cluster/7001/redis.log  #日志文件名

    cluster-enabled  yes  # 开启集群(必配)
    cluster-config-file  nodes_7001.conf  # 集群节点的配置文件(必配)
    cluster-node-timeout  15000  #集群节点的超时时间

    apppendonly yes  #开启AOF持久化
4. 启动各个节点
    1. 在编译安装Redis的目录中，有一个src目录，分别拷贝到 7001-7006 目录中;
    2. 分别进入 7001-7006 目录下，使用 sudo src/redis-server ./redis.conf 命令启动当前的Redis服务;  
    3. 当然，也可以不拷贝src目录，使用同一个 redis-server 命令，指定不同的配置文件，启动6个Redis服务;
    4. 切记：启动时一定要有权限，因为设置后台运行之后，如果没有权限，它不会提示！
    5. 查看启动的服务：ps -ef | grep -i redis
5. 客户端连接/断开节点，测试单个Redis服务
    1. 连接：src/redis-cli -p 7001
    2. 停止：src/redis-cli -p 7001 shutdown  //正常关闭，数据会自动保存
    3. kill -9 PID  //非正常关闭，断电，数据容易丢失
</code></pre><h4 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h4><pre><code>1. Redis-v5.0以下版本
    1. 依赖 Ruby 环境
        yum -y install ruby ruby-devel rubygems rpm-build   #安装Ruby
        gem install redis  # gem是ruby的一个工具包，可能会报错，要求Ruby版本为2.2.2以上
     或：
        yum install ruby
        yum install rubygems
        gem install redis
    2. src目录下命令 redis-trib.rb
        1. 注释 bind
        redis-trib.rb create --replicas 1 127.0.0.1:7001 ... 127.0.0.1:7006
        2. bind 192.168.13.22
        redis-trib.rb create --replicas 1 192.168.13.22:7001 ... 192.168.13.22:7006
    3. --replicas  1  表示自动为每一个master节点分配一个slave节点，按照一定规则生成 3个master 3个slave
2. 创建集群：Redis5.0+
    1. 从 Redis5.0 开始，创建集群不再使用 redis-trib.rb，而是使用C语言实现的 redis-cli 命令;
        redis-cli --cluster create 127.0.0.1:7001 ... 127.0.0.1:7006 --cluster-replicas 1

        ===&gt; Can I set the above configuration?   yes
        [OK] All 16384 slots covered.  ===&gt; 集群创建成功
    2. 默认情况下，前三个会被创建为Master节点，后三个会被创建为Slave节点，且1-4，2-5，3-6的主从配置;
    3. 在分配 Slot 时，只分配给Master，因为 Slave 不支持写命令，只负责读数据;
3. 常见报错
    Node 127.0.0.1:7001 is not empty. Either the node already knows other nodes
    1. 逐个连接Redis服务，清空数据库：flushall
5. 关闭集群时，需要逐个关闭集群中的节点;
    redis-cli -c -h IP -p PORT shutdown
6. 重启集群时，不再需要执行创建集群的命令，开启所有Redis服务即可.
</code></pre><h4 id="访问集群"><a href="#访问集群" class="headerlink" title="访问集群"></a>访问集群</h4><pre><code>    redis-cli -c -h IP -p PORT -a Password  # -c表示连接redis集群
1. 登录Redis集群中的任意一个节点
    redis-cli -c -h 127.0.0.1 -p 7001  ==&gt; 没有设置密码，不需要使用 -a
2. 登录之后的命令
    1. info：查看当前Redis服务的详细信息;
    2. info replication：只查看replication，当前节点的身份、状态等信息;
    3. cluster nodes：查看当前集群中的所有节点，及其主从关系;
        7ffc63c7283a05b799d553002bf1d14ef413a655 127.0.0.1:7004@17004 slave 9e191422······
        9e1914220a6300e63fe1532ebdfe50c0d7f28e0b 127.0.0.1:7002@17002 master - 0 155······
        ······
    4. 第一列表示Redis节点的ID值，且此ID将被Redis实例永久使用，以便于在集群中唯一标识一个Redis节点;
    5. 每个节点都会记录其他节点的ID，因为IP或端口号可能发生变化，而ID在整个生命周期内是不会变的;
3. Redis Cluster采用去中心化、去中间件的设计，即集群中的每个节点都是平等的，都保存各自的数据和整个集群的状态;
    1. 每个节点都和其他节点连接，而且这些连接保持活跃，保证了只需要连接集群中的任意节点，就可以获取到其他节点的数据;
    2. 在某个主节点中写入数据时，并不是一定会把数据存储该节点中，它会考虑整个集群环境，有时会重定向到其他主节点;
        登录7001 --&gt; set name Java --&gt; Redirected to slot [xxxx] located at 127.0.0.1:7002
        登录7002 或者 其从节点7005 --&gt; keys * --&gt; name
    3. 在读数据时，Redis Cluster 会在整个集群中查找，数据被存储在哪个 Slot 中，则重定向到该Slot所属的节点;
        登录7001，keys * --&gt; 空的，但执行 get name --&gt; 重定向到7002 --&gt; Java
4. 如果是外部访问，需要开放 7001-7006 端口，并重启防火墙;
5. Java使用 Jedis 访问Redis集群
    //在nodes中指定每个节点的地址
    Set&lt;HostAndPort&gt; nodes = new HashSet&lt;&gt;();
    nodes.add(new HostAndPort(&quot;127.0.0.1&quot;, 7001));
    ......
    nodes.add(new HostAndPort(&quot;127.0.0.1&quot;, 7006));
    //创建一个JedisCluster对象，在系统中是单例的
    JedisCluster cluster = new JedisCluster(nodes);
    cluster.set(&quot;name&quot;, &quot;Hello World&quot;);
    cluster.set(&quot;value&quot;, &quot;100&quot;);
    String name = cluster.get(&quot;name&quot;);
    String value = cluster.get(&quot;value&quot;);
    //系统关闭时关闭JedisCluster
    cluster.close();
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/04/09/RabbitMQ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/09/RabbitMQ/" itemprop="url">RabbitMQ</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-09T00:00:00+08:00">
                2016-04-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><pre><code>1. 消息队列是典型的 生产者、消费者 模型，简称MQ;
2. MQ是消息通信的模型，并发的具体实现，目前实现MQ的两种主流方式是：AMQP、JMS
3. AMQP：高级消息队列协议，一个进程间传递异步消息的应用层协议，为面向消息的中间件设计；
4. JMS：由Sun公司早期提出的消息标准，为Java应用提供统一的消息操作，与JDBC担任类似的角色；
5. AMQP与JMS
    1. JMS定义了统一的接口，规范消息操作；AMQP是通过协议来统一数据交互的格式；
    2. JMS限定了必须使用Java语言；AMQP只是一种协议，实现方式是跨语言的；
    3. JMS规定了两种消息模型，而AMQP的消息模型更加丰富。
6. 常见的MQ
    1. ActiveMQ：Apache，基于JMS；
    2. RabbitMQ：采用Erlang语言开发，基于AMQP，可靠性、稳定性好；
    3. RocketMQ：阿里巴巴，基于JMS，目前交给Apache；
    4. Kafka：分布式消息系统，高吞吐量。
</code></pre><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><pre><code>1. RabbitMQ最初起源于金融系统，用于在分布式系统中存储、转发消息；
    1. 可靠性：RabbitMQ使用诸如持久化、传输确认、发布确认等机制来保证可靠性；
    2. 灵活的路由：在消息进入队列之前，通过 Exchange 来路由消息；
    3. 消息集群：多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker；
    4. 高可用：队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下仍然可用；
    5. 多种协议：RabbitMQ支持多种消息队列协议，比如 STOMP、MQTT...
    6. 多语言客户端：RabbitMQ几乎支持所有常用语言，比如Java、.NET、Ruby...
    7. 管理界面：RabbitMQ提供了一个易用的用户界面，可以监控和管理消息Broker；
    8. 追踪机制：如果消息异常，RabbitMQ提供了消息跟踪机制，从而查找出原因；
    9. 插件机制：RabbitMQ提供了许多插件，可以从多方面进行扩展，也可以自定义插件。
2. 安装RabbitMQ，启动服务，配置环境和用户、权限...
3. Web管理平台的默认端口号是15672，使用配置的用户去登录管理平台：http://localhost:15672
    1. 创建虚拟主机
        Admin --&gt; Virtual Hosts --&gt; Add virtual host --&gt; 输入Name，如/test
        Admin --&gt; Users --&gt; 选择一个用户 --&gt; Permissions
    2. Current permissions：当前拥有的虚拟主机；
    3. Set permission：为用户添加虚拟主机。
4. RabbitMQ是一个消息的代理者(Message Broker)，负责接收消息并传递消息，传递二进制数据。
</code></pre><h2 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h2><pre><code>1. RabbitMQ提供了6种消息模型，但第6种其实属于RPC(远程服务调用)，并不算是MQ；
    https://www.rabbitmq.com/getstarted.html
2. 搭建环境(两种方式)
    1. 创建SpringBoot项目进行测试，引入启动器：spring-boot-starter-amqp
    2. 创建普通的Maven Java项目，引入依赖：spring-rabbit、slf4j-nop
</code></pre><h3 id="模型一：Hello-World"><a href="#模型一：Hello-World" class="headerlink" title="模型一：Hello World"></a>模型一：Hello World</h3><pre><code>1. 模型：Producer --&gt; MQ --&gt; Consumer，单个生产者和单个消费者
2. 创建连接的工具类
    public class ConnectionUtil {
        public static Connection getConnection() throws IOException, TimeoutException {
            //定义连接工厂
            ConnectionFactory factory = new ConnectionFactory();
            //设置服务地址和端口
            factory.setHost(&quot;192.168.103.30&quot;);
            //Web管理端的默认端口号是15672，访问服务的默认端口号是5672
            factory.setPort(5672);
            //设置账号信息：虚拟主机及其对应的用户名、密码
            factory.setVirtualHost(&quot;/techsel&quot;); //虚拟主机
            factory.setUsername(&quot;java&quot;);  //用户名
            factory.setPassword(&quot;123456&quot;);  //密码
            //通过工厂获取连接
            return factory.newConnection();
        }
    }
3. 生产者
    public class Send {
        //队列名称
        private static final String QUEUE_NAME = &quot;simple_queue&quot;;

        public static void main(String[] args) throws IOException, TimeoutException {
            //创建连接，在Web管理平台：Connections 上会多一条连接信息
            Connection conn = ConnectionUtil.getConnection();
            //创建通道，在Web管理平台：Channels 上会多一条通道信息
            Channel channel = conn.createChannel();
            //声明队列: 设置队列名称, ...
            channel.queueDeclare(QUEUE_NAME, false, false, false, null);
            //消息内容
            String message = &quot;Hello RabbitMQ&quot;;
            //向指定的队列中发送消息，在Web管理平台：Queues 上可以查看消息通道及其详细信息
            channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());
            //关闭通道和连接
            channel.close();
            conn.close();
        }
    }
4. 消费者
    public class Recv {
        //队列名称：与生产者声明的队列名称一致
        private static final String QUEUE_NAME = &quot;simple_queue&quot;;

        public static void main(String[] args) throws IOException, TimeoutException {
            Connection conn = ConnectionUtil.getConnection();
            Channel channel = conn.createChannel();
            //声明队列
            channel.queueDeclare(QUEUE_NAME, false, false, false, null);
            //定义队列的消费者
            DefaultConsumer consumer = new DefaultConsumer(channel){
                //消费的回调方法：消费者会一致阻塞，只要MQ中一有消息，就回调此方法，进行消费
                public void handleDelivery(String consumerTag, Envelope envelope, 
                    AMQP.BasicProperties properties, byte[] body) throws IOException {
                    //消费消息: body
                    String message = new String(body);
                    System.out.println(&quot;消费者：&quot; + message);
                }
            };
            //监听队列：绑定消息队列和消费者，参数2表示：是否自动进行消息确认(手动/自动ACK)
            channel.basicConsume(QUEUE_NAME, true, consumer);
        }
    }
5. 启动消费者，监听队列，等待消费消息；再启动生产者，生产消息；在Web管理平台上跟踪连接、通道、消息;
</code></pre><h3 id="消费者的消息确认机制"><a href="#消费者的消息确认机制" class="headerlink" title="消费者的消息确认机制"></a>消费者的消息确认机制</h3><pre><code>1. 消息确认机制：Acknowlege，当消费者获取消息之后，会向RabbitMQ发送回执ACK，告知消息已经被接收;
2. RabbitMQ收到回执的ACK后，就会立即删除消息;
3. 回执ACK有两种情况：自动ACK、手动ACK
    1. 自动ACK：消息一旦被接收，消费者自动发送ACK;
        channel.basicConsume(QUEUE_NAME, true, consumer);
    2. 手动ACK：消息接收后，不发送ACK，去手动调用;
        channel.basicConsume(QUEUE_NAME, false, consumer);
4. 在自动回执ACK时，回调方法 handleDelivery() 尚未开始执行，但消息已经从MQ中删除了，一旦回调方法中
   发生了异常，消息就找不回来了，所以就需要 手动ACK 的方案，确保一些重要的消息不会丢失；
5. 手动ACK：等待处理逻辑执行完成，再手动回执ACK，从而避免消息的丢失；
    public void handleDelivery(...) {
        String message = new String(body);
        int i = 1/0;  //发生逻辑错误
        //手动回执ACK
        channel.basicAck(envelope.getDeliveryTag(), false);
    }
    1. 因为发生了逻辑错误，没有手动回执ACK，消息会回滚MQ中，然后再分发给其他消费者，保证消息不会被删除;
    2. 但是，因为当前消费者没有ACK，在没有断开重连之前，MQ不会再把消息分发给它，所以如果没有其他消费者，
    就可能造成消息堆积，从而影响MQ的速度.
</code></pre><h3 id="模型二：Work-queues"><a href="#模型二：Work-queues" class="headerlink" title="模型二：Work queues"></a>模型二：Work queues</h3><pre><code>1. 如果消息处理比较耗时，生产消息的速度远远大于消费消息的速度，那么就可能造成消息堆积;
2. 模型：Producer --&gt; MQ --&gt; Consumer1、Consumer2，让多个消费者绑定到一个队列上，共同消费队列的消息;
3. 生产者发送消息
    for (int i=0; i&lt;100; i++) {
        String message = &quot;Hello RabbitMQ : &quot; + i;
        channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());
        Thread.sleep(i * 2);  //休眠一段时间，让消费者去消费消息
    }
4. 消费者消费消息：创建两个消费者，绑定同一个队列
    1. 消费者性能相同，则消费能力相同
        public void handleDelivery(...) {  ---&gt;消费者-1的回调方法
            String message = new String(body);
            System.out.println(&quot;消费者111：&quot; + message);
            //使用手动ACK
            channel.basicAck(envelope.getDeliveryTag(), false);
        }
        public void handleDelivery(...) {  ---&gt;消费者-2的回调方法
            String message = new String(body);
            System.out.println(&quot;消费者222：&quot; + message);
            //使用手动ACK
            channel.basicAck(envelope.getDeliveryTag(), false);
        }
    2. 消费者性能不同，消费者-1的机器配置较差
        public void handleDelivery(...) {  ---&gt;消费者-2的回调方法
            String message = new String(body);
            Thread.sleep(500);  ---&gt; 模拟消费者-2的性能较差，处理消息速度慢
            System.out.println(&quot;消费者222：&quot; + message);
        }
5. 对比结果可知：无论消费者的性能是否相同，它们处理消息的数量总是相同的；
6. 也就是说，不管消费者是否已经消费完消息(发送回执ACK)，MQ总是平均分配消息给每个消费者；
7. 让MQ不要平分消息给消费者，让性能好的消费者多消费，性能差的消费者少消费;
    1. 在每个消息者中，设置 Channel 每次同时只能处理1条消息，在没有回执ACK时，不要再分配消息
        channel.basicQos(1);
</code></pre><h3 id="模型三：Publish-Subscribe"><a href="#模型三：Publish-Subscribe" class="headerlink" title="模型三：Publish/Subscribe"></a>模型三：Publish/Subscribe</h3><pre><code>1. 模型3、4、5其实是类似的，都是订阅模型，在生产者和MQ之间增加了一层交换器exchange;
2. 生产者永远不会把消息直接发给MQ，实际上，生产者也不关心消息是否会被发送给MQ;
3. 生产者只负责把消息发给交换器，由交换器去决定是把消息传递给所有MQ，还是特定的MQ，亦或者是丢弃消息;
4. 交换器处理消息的方式，取决于不同的交换类型：direct、topic、headers、fanout，其中headers不常用;
5. 模型三称为订阅/发布模型，也称为广播，属于交换类型fanout
    Producer --&gt; X --&gt; MQ1-&gt;Consumer1、MQ2-&gt;Consumer2
6. 生产者
    1. 不再直接声明队列，而是声明交换器，并指定交换类型为fanout
    private static final String EXCHANGE_NAME = &quot;fanout_exchange&quot;;
    //声明交换器
    channel.exchangeDeclare(EXCHANGE_NAME, ExchangeTypes.FANOUT);
    2. 发布消息到交换器
    String message = &quot;Hello RabbitMQ&quot;;
    channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, message.getBytes());
    3. 在Web管理平台的 Exchanges 上，可以查看创建的交换器.
7. 消费者
    private static final String EXCHANGE_NAME = &quot;fanout_exchange&quot;;
    1. 消费者1、2 使用不同的队列：
        QUEUE_NAME = &quot;fanout_queue_1&quot;;
        QUEUE_NAME = &quot;fanout_queue_2&quot;;
    2. 声明队列之后，把队列绑定到交换器上，其实就是订阅消息
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);
        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;);
8. 启动消费者1、2，再启动生产者，两个消费者都会收到消息.
</code></pre><h3 id="模型四：Routing"><a href="#模型四：Routing" class="headerlink" title="模型四：Routing"></a>模型四：Routing</h3><pre><code>1. 设置交换类型为direct，与模型三不同的是：它可以订阅不同的消息类型(Routingkey)，实现定向发布;
2. 生产者
    1. 声明交换器
    channel.exchangeDeclare(EXCHANGE_NAME, ExchangeTypes.DIRECT);
    2. 在发送消息时，指定消息的类型
    channel.basicPublish(EXCHANGE_NAME, &quot;delete&quot;, null, message.getBytes());
3. 消费者：在绑定队列到交换器时，指定监听的消息类型；
    1. 消费者-1：监听2种消息类型
    channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;insert&quot;);
    channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;delete&quot;);
    2. 消费者-2：只关心1种消息类型
    channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;delete&quot;);
4. 生产者发送消息类型delete时，消费者-1、2都会收到消息；发送消息类型insert时，只有消费者-1能收到.
</code></pre><h3 id="模型五：Topics"><a href="#模型五：Topics" class="headerlink" title="模型五：Topics"></a>模型五：Topics</h3><pre><code>1. 设置交换类型为topic，与模型四不同的是，它可以使用通配符;
2. 消息类型通常都是一个或多个单词组成，单词之间以 . 分割，如item.insert
3. 通配符的类型和规则
    1. #：匹配一个或多个词，如audit.# 可以匹配 audit.irs.corp、audit.del
    2. *：只能匹配一个词，如audit.* 只能匹配 audit.del、audit.ins
4. 生产者
    channel.exchangeDeclare(EXCHANGE_NAME, ExchangeTypes.TOPIC);
    channel.basicPublish(EXCHANGE_NAME, &quot;intem.delete&quot;, null, message.getBytes());
5. 消费者
    channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;item.*&quot;);
</code></pre><h3 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h3><pre><code>1. 手动回执ACK的方式并不能完全解决消息丢失的问题，比如MQ服务器宕机了;
2. 虽然集群MQ全部宕机的几率很小，但宕机总会导致消息的丢失，这就需要消息的持久化;
3. RabbitMQ默认不会持久化消息，重启RabbitMQ服务，会发现交换器、队列、消息统统丢失了;
    1. 交换器的持久化：生产者声明交换器时，设置第三个参数为true
    channel.exchangeDeclare(EXCHANGE_NAME, ExchangeTypes.TOPIC, true);
    2. 队列的持久化：消费者声明队列时，设置第二个参数为true
    channel.queueDeclare(QUEUE_NAME, true, false, false, null);
4. 消息持久化：生产者发送消息时，设置消息参数BasicProperties
    1. BasicProperties的构造方法特别多，所以它提供了枚举类型MessageProperties，封装了常用设置;
    2. 是否持久化的区别在于：BasicProperties构造方法上的参数deliveryMode，2表示启用持久化;
    3. 默认枚举值BASIC，持久化的枚举值：PERSISTENT_TEXT_PLAIN(文本类型)、PERSISTENT_BASIC(二进制数据流)
    //发送的是字符串，则可以使用文本类型
    channel.basicPublish(EXCHANGE_NAME, &quot;item.delete&quot;, MessageProperties.PERSISTENT_TEXT_PLAIN,
        message.getBytes());
5. 生产者确认机制
    1. 手动回执解决了消费者丢失消息，持久化解决了RabbitMQ丢失消息，但生产者在发送消息到MQ时，也可能发送失败;
    2. 消费者确认机制：消费者收到消息，向MQ发送回执ACK;
    3. 生产者确认机制：MQ收到消息，向生产者发送确认回执;
    4. 在生产者中，开启生产者确认;
        Channel channel = conn.createChannel();
        channel.confirmSelect();
    5. 通过生产者确认的相关API，处理消息回执;
        channel.addConfirmListener(...);  //监听器
        channel.waitForConfirms([long]);  //等待机制
        channel.waitForConfirmsOrDie([long]);  //等待机制
6. 解决消息丢失
    1. 消费者确认机制(ACK)
    2. 持久化
    3. 可靠消息服务：在发送消息前，将消息持久化到数据库，并记录状态
    4. 生产者确认机制
7. 消息发送失败的重试问题：可能导致消息的重复性
    1. 因为网络等原因，导致消息发送时间特别长，但仍发送成功，由于发送时间超时，生产者又发送了一次，导致消息重复;
    2. 在金融方面，消息的重复性可能导致灾难性问题，此时就需要保证消息处理方的幂等性;
    3. 幂等性：同一个接口被重复执行时，其结果应该是一致的;
    4. 有些接口天生就是幂等的，如查询接口；有些接口就不是幂等的，如新增、删除、修改;
    5. 要保证幂等性，就应该在接口中加入一些特殊的标识，以判断重复性操作，通常是在一定时间内去判断.
</code></pre><h2 id="SpringBoot整合RabbitMQ"><a href="#SpringBoot整合RabbitMQ" class="headerlink" title="SpringBoot整合RabbitMQ"></a>SpringBoot整合RabbitMQ</h2><pre><code>1. 创建SpringBoot的项目，引入AMQP的启动器：spring-boot-starter-amqp
2. spring-rabbit 与 spring-amqp
    1. spring-amqp 是对AMQP协议的抽象实现;
    2. spring-rabbit 是对协议的具体实现，也是目前的唯一实现，底层使用的就是RabbitMQ.
3. 在配置文件 application.yml 中，配置RabbitMQ的连接信息
    spring:
        rabbitmq:
            host: 192.168.103.30
            username: java
            password: 123456
            virtual-host: /techsel
4. Spring也为AMQP提供了Template：AmqpTemplate
    1. 向交换器发送消息
        @RunWith(SpringRunner.class)
        @SpringBootTest
        public class StartApplicationTests {
            @Autowired
            private AmqpTemplate amqp;

            @Test
            public void contextLoads() {
                String msg = &quot;Hello SpringBoot&quot;;
                amqp.convertAndSend(&quot;boot_exchange&quot;, &quot;item.insert&quot;, msg);
            }
        }
    2. 向MQ中直接发送消息
        amqp.convertAndSend(&quot;boot_queue&quot;, msg);
    3. 底层借助JDK自动对消息进行序列化和反序列化.
5. 从MQ中消费消息
    @Component
    public class Listener {
        @RabbitListener(queues = &quot;boot_queue&quot;)
        public void listen(String msg) {
            System.out.println(&quot;消费者：&quot; + msg);
        }
    }
    1. 一旦监听器中发生异常，消息默认回滚到MQ中;
    2. 对于不希望消息回滚的操作，如发送验证码短信，则使用try-catch捕获异常.
6. 如果监听的队列不存在，就会报错，那么就应该自动创建不存在的队列和交换器，并把队列绑定到交换器;
    @RabbitListener(bindings = @QueueBinding(
        value = @Queue(value = &quot;spring_queue&quot;, durable = &quot;true&quot;), --&gt;声明队列，并持久化
        exchange = @Exchange(
            value = &quot;spring_exchange&quot;,
            ignoreDeclarationExceptions = &quot;true&quot;, --&gt;忽略声明的错误
            type = ExchangeTypes.TOPIC), --&gt;声明交换器，默认就是持久化
        key = {&quot;#.#&quot;}))  --&gt;绑定队列到交换器，&quot;#.#&quot;表示监听一切消息
    public void listen(String msg) {
        System.out.println(&quot;消费者：&quot; + msg);
    }
7. 在实际开发中，可能还会配置更多参数
    spring:
        rabbitmq:
            host: 192.168.103.30
            username: java
            password: 123456
            virtual-host: /techsel
            template:  # 设置AmqpTemplate
                retry: # 发送失败的重试机制
                    enabled: true  # 开启
                    initial-interval: 10000ms  # 重试周期10s(第一次等待10s后再重新发送)
                    max-interval: 30000ms  # 最大重试周期，超过30s，则不再重试
                    multiplier: 2  # 每次重试的基数
                exchange: ly.item.change # 设置默认交换机
            publisher-confirms: true  #开启生产者确认机制
    1. 第一次重试等待10s，第二次重试等待2*10s，第三次等待2*2*10s，已经超过了最大重试周期30s，则不再重试;
    2. 在发送消息时，如果不指定交换机，则使用默认交换机ly.item.change，而不是队列
        amqp.convertAndSend(&quot;item.insert&quot;, msg); //item.insert是消息类型，而不再是队列名称
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/04/05/SpringBoot响应式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/05/SpringBoot响应式/" itemprop="url">SpringBoot响应式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-05T00:00:00+08:00">
                2016-04-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h2><pre><code>1. SpringBoot2.x底层使用Spring5，开始支持响应式编程，Spring又依赖于Reactor
2. 响应式依赖于事件驱动，异步非阻塞，观察者模式;
3. 响应式编程与传统编程的技术对比
</code></pre><p><img src="//hellomyshadow.github.io/2016/04/05/SpringBoot响应式/响应式.png" alt="响应式"></p>
<pre><code>4. 响应式编程的整个链路都不能阻塞，包括数据库访问，比如Redis已经提供了响应式编程的启动器;
</code></pre><h2 id="Spring-WebFlux"><a href="#Spring-WebFlux" class="headerlink" title="Spring WebFlux"></a>Spring WebFlux</h2><pre><code>1. Spring WebFlux 是Spring5.0引进的一个响应式Web框架，通过Reactor项目实现 Reactive Streams 规范;
2. 与SpringMVC不同，Spring WebFlux不需要Servlet API，完全异步非阻塞，事件驱动，流;
3. Flux、Mono
    1. Mono：包含 0 或 1 个元素的异步序列，单一对象，比如根据ID去Redis中查询唯一的用户，Mono&lt;User&gt;
    2. Flux：包含 - 到 N 个元素的异步序列，数据列表对象，比如在Redis中查询一组用户，Flux&lt;User&gt;
    3. Mono 和 Flux 之间可以进行转换;
4. Spring WebFlux有两种风格：基于功能、基于注解
    1. 基于注解的方式非常接近于SpringMVC模型
    @RestController 
    @RequestMapping(&quot;/users&quot;)
    public class UserController {
        @GetMapping(&quot;/{user}&quot;)
        public Mono&lt;User&gt; getUser(@PathVariable Long user) {
            ...
        }
        @GetMapping(&quot;/{user}/customers&quot;)
        public Flux &lt;Customer&gt; getUserCustomers(@PathVariable Long user) {
            ...
        }
        @DeleteMapping(&quot;/{user}&quot;)
        public Mono &lt;User&gt; deleteUser(@PathVariable Long user) {
            ...
        }
    }
    2. 基于功能：路由配置与请求的实际处理逻辑是分开的
    @Configuration
    public class RoutingConfiguration {
        @Bean
        public RouterFunction &lt;ServerResponse&gt; monoRouterFunction（UserHandler userHandler）{
            return route(GET(&quot;/{user}&quot;).and(accept(APPLICATION_JSON))，userHandler :: getUser)
                .andRoute(GET(&quot;/{user}/customers&quot;)
                .and(accept(APPLICATION_JSON))，userHandler :: getUserCustomers)
                .andRoute(DELETE(&quot;/{user}&quot;).and(accept(APPLICATION_JSON))，userHandler :: deleteUser);
        }
    }
    @Component
    public class UserHandler {
        public Mono &lt;ServerResponse&gt; getUser(ServerRequest request) {
            ...
        }
        public Mono &lt;ServerResponse&gt; getUserCustomers(ServerRequest request) {
            ...
        }
        public Mono &lt;ServerResponse&gt; deleteUser(ServerRequest request) {
            ...
        }
    }
5. Spring WebFlux应用不严格依赖于Servlet API，因此不能作为 war 文件部署，也不能使用 src/main/webapp 目录;
6. 除了REST Web服务，Spring WebFlux还提供了动态HTML，支持各种模板引擎：Thymeleaf、FreeMarker...
</code></pre><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><pre><code>1. 创建SpringBoot项目
    1. WebFlux的启动器：spring-boot-starter-webflux
    2. 如果同时存在spring-boot-starter-web，则会优先使用SpringMVC模式，而不是Spring WebFlux
2. WebFlux中，请求和响应对象也不再是ServletRequest和ServletResponse，而是ServerRequest和ServerResponse
3. 创建基于注解的Controller
    @RestController 
    @RequestMapping(&quot;/api&quot;)
    public class TestController {
        @GetMapping(&quot;/test&quot;)
        public Mono&lt;String&gt; test() {
            return Mono.just(&quot;Hello WebFlux&quot;);
        }
    }
4. 启动：默认容器Netty 8080端口，Netty started on port(s): 8080
    http://localhost:8080/api/test  ==&gt; Hello WebFlux
5. 创建User
    public class User {
        private String id;
        private String name;
        ......
    }
6. 创建Service，模拟CURD
    @Service
    public class UserService {
        private static final Map&lt;String, User&gt; dataMap = new HashMap&lt;&gt;();
        static {
            dataMap.put(&quot;1&quot;, new User(&quot;1&quot;, &quot;Java&quot;));
            dataMap.put(&quot;2&quot;, new User(&quot;2&quot;, &quot;Python&quot;));
            dataMap.put(&quot;3&quot;, new User(&quot;3&quot;, &quot;Node&quot;));
            dataMap.put(&quot;4&quot;, new User(&quot;4&quot;, &quot;Node&quot;));
        }
        public Flux&lt;User&gt; getList() {
            Collection&lt;User&gt; list = dataMap.values();
            //把 Collection 转为一个异步序列
            return Flux.fromIterable(list);
        }
        public Mono&lt;User&gt; getById(String id) {
            return Mono.justOrEmpty(dataMap.get(id));
        }
        public Mono&lt;User&gt; delById(String id) {
            return Mono.justOrEmpty(dataMap.remove(id));
        }
    }
7. Controller方法
    @Autowired
    private UserService service;

    @GetMapping(&quot;/find&quot;)
    public Mono&lt;User&gt; findById(String id) {
        return service.getById(id);
    }

    @GetMapping(&quot;/list&quot;)
    public Flux&lt;User&gt; getList() {
        return service.getList();
    }

    http://localhost:8080/api/find?id=2  ==&gt; {&quot;id&quot;: &quot;2&quot;, &quot;name&quot;: &quot;Python&quot;}
8. 模拟耗时的查询一组用户时，每查询到一个就响应一个，而不是等待全部查询结束之后再响应
    @GetMapping(value = &quot;/list&quot;, produces = MediaType.APPLICATION_STREAM_JSON_VALUE)
    public Flux&lt;String&gt; getList() {
        //每条数据延迟2s再响应
        return service.getList().delayElements(Duration.ofSeconds(2));
    }
    http://localhost:8080/api/list  ==&gt; 不考虑网络延迟，每隔2s收到一条数据
    1. produces=MediaType.APPLICATION_STREAM_JSON_VALUE 必须声明响应类型是流;
    2. 如果不声明为流数据，则会等查询到所有数据之后，转为JSON字符串，然后再响应给前端;
</code></pre><h3 id="响应式客户端"><a href="#响应式客户端" class="headerlink" title="响应式客户端"></a>响应式客户端</h3><pre><code>1. WebFlux的客户端WebClient，响应式客户端;
2. 在测试类中使用
    @Test
    public void testBase() {
        Mono&lt;String&gt; body = WebClient.create().get()
            .uri(&quot;http://localhost:8080/api/find?id=2&quot;)
            .accept(MediaType.APPLICATION_JSON)
            .retrieve().bodyToMono(String.class);
        System.out.println(body.block());
    }
    @Test
    public void testPlace() {
        Mono&lt;String&gt; body = WebClient.create().get()
            .uri(&quot;http://localhost:8080/api/find?id={id}&quot;, 2)  //支持占位符
            .accept(MediaType.APPLICATION_JSON)
            .retrieve().bodyToMono(String.class);
    }
</code></pre><h2 id="服务端推送技术"><a href="#服务端推送技术" class="headerlink" title="服务端推送技术"></a>服务端推送技术</h2><pre><code>1. 客户端轮询：AJAX定时拉取数据;
2. WebSocket：全双工通信，基于TCP协议，Socket.IO是基于WebSocket的框架，屏蔽了底层细节，使用更方便;
3. SSE：Server Send Event，HTML5新标准，用于从服务端实时推送数据到浏览器，本质上是一个HTTP长连接;
</code></pre><h3 id="SSE"><a href="#SSE" class="headerlink" title="SSE"></a>SSE</h3><pre><code>1. 服务端
    1. 引入依赖：spring-boot-starter-webflux
    @RestController 
    @RequestMapping(&quot;/sse&quot;)
    public class TestController {
        //数据类型必须设置为event-stream
        @RequestMapping(value = &quot;/test&quot;, produces = &quot;text/event-stream;charset=UTF-8&quot;)
        public String test() {
            Thread.sleep(2000); //模拟业务处理
            return &quot;Hello SSE : &quot; + Math.random();
        }
    }
    2. 在静态资源目录下创建index.html
    &lt;script type=&quot;text/javascript&quot;&gt;
        var source = new EventSource(&quot;sse/test&quot;);
        source.onmessage = function(evt) {
            console.log(evt.data);
        }
    &lt;/script&gt;
2. 客户端：必须支持SSE
    http://localhost:8080/index.html  //大约每2s收到一条消息，本质上是HTTP长连接，所以仍是发起请求
</code></pre><h2 id="Actuator"><a href="#Actuator" class="headerlink" title="Actuator"></a>Actuator</h2><pre><code>1. Actuator：用于监控和管理生产环境的组件，启动器为spring-boot-starter-actuator
2. 启动SpringBoot项目，出于安全考虑，默认只开启了三个端点
    1. http://localhost:8080/actuator  --&gt; 查看可用的端点
    2. http://localhost:8080/actuator/health  --&gt; {&quot;status&quot;: &quot;UP&quot;}  UP 表示应用启动且状态正常
    3. http://localhost:8080/actuator/info  --&gt; 查看详细信息，{} 表示无信息
    4. 对于SpringBoot2.0之前的版本，端点路径上不带 /actuator
3. 在配置文件中，设置开启的监控端点
    1. 开启所有端点
        management.endpoints.web.exposure.include=*
    2. 启动项目时，控制台上会列出可访问的端点，比如/actuator/env，/actuator/metrics ...
    3. 有些端点会暴露敏感信息，比如 /actuator/env 就会暴露应用端口号、数据库连接信息、系统信息...
        management.endpoints.web.exposure.include=metrics  #开启某一个
        management.endpoints.web.exposure.exclude=metrics  #关闭某一个
4. 常用的端点
    /actuator/health  --&gt; 应用健康指标
    /actuator/metrics  --&gt; 应用的基本指标列表
    /actuator/metrics/{name}  --&gt; 某个具体的指标
    /actuator/env  --&gt; 显示来自Spring的ConfigurableEnvironment的属性
5. SpringBoot Admin：可视化的监控管理;
6. 还可以自己开发脚本进行监控;
</code></pre><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><pre><code>1. 浏览器的同源策略：同源是指域名/IP、协议、端口都相同，不同源的客户端脚本在没有被明确授权的情况下，不能读写对方的资源;
2. 主域名和子域名之间也是跨域，cookie也无法访问;
3. 同源策略限制的行为：
    1. Cookie、LocalStorage 和 IndexDB 无法读取;
    2. DOM 和 JS对象无法获得;
    3. AJAX 请求不能发送.
4. 注意：
    1. 浏览器并没有限制跨站请求的发起，而是拦截了返回结果，比如CRSF跨站攻击原理，无论是否跨域，请求已经发给了服务器;
    2. 但是，有些浏览器不允许从HTTPS跨域访问HTTP，如Chrome和Firefox，它们会拦截请求的发出.
5. 解决跨域问题的方案有很多：
    1. 通过jsonp跨域
    2. document.domain + iframe跨域
    3. location.hash + iframe
    4. window.name + iframe跨域
    5. postMessage跨域
    6. 跨域资源共享(CORS)
    7. 前端通过Nginx解决跨域问题
    8. nodejs中间件代理跨域
    9. WebSocket协议跨域
6. SpringMVC解决跨域问题：JSONP、CORS、WebSocket
7. WebSocket是一种通信协议，使用ws://(非加密)和wss://(加密)作为协议前缀;
    1. 在2008年诞生，2011年成为国际标准，所有浏览器都已经支持了;
    2. WebSocket属于服务器推送技术的一种，可以保持长链接，服务器和客户端都可以主动向对方推送/发送信息;
    3. WebSocket协议不实行同源政策，只要服务器支持，就可以进行跨源通信;
</code></pre><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><pre><code>1. CORS是一个W3C标准，称为跨域资源共享;
2. CORS需要浏览器和服务器同时支持;
    1. 所有浏览器都支持该功能，IE浏览器不能低于IE10;
    2. 整个CORS通信过程都是浏览器自动完成，不需要用户参与;
    3. 对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样;
    4. 浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时甚至还会多出一次附加的请求，但用户不会有感觉;
    5. 实现CORS通信的关键是服务器，只要服务器实现了CORS接口，就可以跨源通信.
3. CORS与JSONP相比：
    1. JSONP只能实现GET请求，而CORS支持所有类型的HTTP请求;
    2. 使用CORS，开发者仍可以使用普通的AJAX发起请求和获得数据，比起JSONP有更好的错误处理;
    3. JSONP主要被老浏览器支持，它们往往不支持CORS，而绝大多数现代浏览器都已经支持了CORS.
4. SpringMVC4.2开始，支持使用 @CrossOrigin 解决跨域问题;
    1. @CrossOrigin 可以注解在控制器类/方法上，默认允许在@RequestMapping中指定的所有源和HTTP方法;
    2. value、origins属性：允许可访问的域列表;
    3. maxAge属性：准备响应前的缓存持续的最大时间(s);
    4. allowedHeaders、exposedHeaders、methods、allowCredentials
5. 在控制器方法上使用 @CrossOrigin 时，可能出现一些附带问题;
    1. @RequestMapping 中需要声明 method 属性，否则 @CrossOrigin 失效;
    2. Session失效：AJAX中需要添加 xhrFields:{withCredentials:true}，以保证Session的一致性;
    3. withCredentials:true 表示对附带身份凭证的请求，服务器不得设置 Access-Control-Allow-Origin=&quot;&quot;,
    因为请求头中携带了Cookie，如果Access-Control-Allow-Origin=&quot;&quot;，请求将会失败;
    而设置 Access-Control-Allow-Origin=&quot;http://foo.example&quot;，则会请求成功;
    其次服务器需要设置 Access-Control-Allow-Credentials:true，否则响应内容不会返回给客户端;
6. 如果控制器类和方法上都是用了@CrossOrigin，Spring会合并这两个注解中设置的属性.
7. 对于不支持 @CrossOrigin 的版本，可以在Filter中拦截此请求，手动添加允许跨域的请求头;
    setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);
8. SpringMVC的XML配置文件中，全局配置CORS
    &lt;mvc:cors&gt;
        &lt;mvc:mapping path=&quot;/**&quot; /&gt;
    &lt;/mvc:cors&gt;
    1. 更加细粒度的配置：
    &lt;mvc:cors&gt;
        &lt;mvc:mapping path=&quot;/api/**&quot;
            allowed-origins=&quot;http://domain1.com, http://domain2.com&quot;
            allowed-methods=&quot;GET, PUT&quot;
            allowed-headers=&quot;header1, header2, header3&quot;
            exposed-headers=&quot;header4, header5&quot; allow-credentials=&quot;false&quot;
            max-age=&quot;3600&quot; /&gt;
        &lt;mvc:mapping path=&quot;/resources/**&quot; allowed-origins=&quot;http://domain1.com&quot; /&gt;
    &lt;/mvc:cors&gt;
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/04/03/SpringBoot整合/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/03/SpringBoot整合/" itemprop="url">SpringBoot整合</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-03T00:00:00+08:00">
                2016-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="整合MyBatis"><a href="#整合MyBatis" class="headerlink" title="整合MyBatis"></a>整合MyBatis</h2><pre><code>1. mybatis的启动器，第三方框架的启动器通常不是以 spring- 开头;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
        &lt;version&gt;2.0.1&lt;/version&gt;
    &lt;/dependency&gt;
2. MySQL的连接驱动
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;8.0.16&lt;/version&gt;
    &lt;/dependency&gt;
3. 创建配置文件 resources/application.properties，配置数据库连接信息(覆盖默认配置)
    spring.datasource.driverClassName=com.mysql.cj.jdbc.Driver
    spring.datasource.url=jdbc:mysql://host:port/database?serverTimezone=Asia/Shanghai
    spring.datasource.username=root
    spring.datasource.password=123456
4. 实体类(POJO)：cn.boot.pojo.User
    public class User {
        private Integer id;  //尽量使用包装类型
        private String username;
        private String password;
        ... //getter、setter
    }
5. Dao层：cn.boot.mapper.IUserMapper，Mybatis的两个注解 @Mapper、@MapperScan
    @Mapper
    @Repository
    public interface IUserMapper {
        List&lt;User&gt; findAll();
    }
    1. @Mapper：修饰在Dao层接口上，为其生成实现类;
    2. @MapperScan：修饰在引导类上，指定Mapper接口所在的包，为包下的所有接口生成实现类;
        @SpringBootApplication
        @MapperScan(basePackages={&quot;cn.boot.mapper&quot;})
        public class BootdemoApplication {
             ...
        }
    3. 在使用 @Autowired 注入Dao时，IDE会报错，但能运行，在Dao层接口上注解 @Repository 可以消除错误.
6. 建立POJO与Dao的映射关系
    1. 映射配置文件的方式：resources/mapper/IUserMapper.xml
        &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
        &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
                &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
        &lt;mapper namespace=&quot;cn.boot.mapper.IUserMapper&quot;&gt;
            &lt;select id=&quot;findAll&quot; resultType=&quot;user&quot;&gt;
                select * from user
            &lt;/select&gt;
        &lt;/mapper&gt;
    2. 注解的方式
        @Mapper
        public interface IUserMapper {
            @Select(&quot;select * from user&quot;)
            List&lt;User&gt; findAll();
        }
7. 在 application.properties 中配置Mybatis的信息
    # 开启驼峰扫描
    mybatis.configuration.map-underscore-to-camel-case: true
    # 配置POJO别名的扫描包
    mybatis.type-aliases-package=cn.boot.pojo
    # 加载Mybatis的映射文件(如果使用映射配置文件的方式)
    mybatis.mapper-locations=classpath:mapper/*Mapper.xml
    # 在控制台打印生成的SQL语句
    mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl
8. 在Controller中，使用 @Autowired 注入Dao(Mapper)对象
    @Slf4j
    @RestController
    public class QuickController {
        @Autowired
        private IUserMapper userMapper;

        @RequestMapping(&quot;/test&quot;)
        public String test() {
            List&lt;User&gt; users = userMapper.findAll();
            return &quot;Hello SpringBoot&quot;;
        }
    }
</code></pre><h3 id="通用Mapper"><a href="#通用Mapper" class="headerlink" title="通用Mapper"></a>通用Mapper</h3><pre><code>1. 通用Mapper：一款中国人自己开发的框架，基于Mybatis，只支持单表的CRUD;
    1. 在单表的CURD中，其SQL语句的性能通常是固定的，不像多表的SQL语句那样、有很大的优化余地;
    2. 所以在单表操作时，完全可以为Dao层的方法自动生成SQL语句，这就是通用Mapper的作用.
2. 通用Mapper的启动器：mapper-spring-boot-starter
    1. 启动器中已经引入了 spring-boot-starter、spring-boot-starter-jdbc、mybatis、mybatis-spring
    2. 所以不能再引入 mybatis-spring-boot-starter、spring-boot-starter-jdbc
    3. 而且，通用Mapper 默认开启驼峰匹配，无需在 application.yaml 中手动开启;
    4. 在 application.yaml 中，选择使用Spring的默认连接池，配置数据库连接的4大参数.
    spring:
        datasource:
            ...... # driver-class-name、url、username、password
    mybatis:
        type-aliases-package: cn.boot.pojo
        configuration:
            log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
3. Dao层接口需要继承 Mapper 接口，泛型为实体类
    public interface UserMapper extends Mapper&lt;User&gt; {
        //Mapper中已经提供了常用的CRUD方法
    }
    1. 通用Mapper底层利用Mybatis的拦截器，动态生成SQL语句，并做了SQL缓存，所以性能很好;
    2. @MapperScan、@Mapper 要使用通用Mapper包下的注解，不能再使用Mybatis包下的了.
4. 在启动类上注解通用Mapper的 @MapperScan , 声明扫描Mapper/Dao层接口所在的包
    @SpringBootApplication
    @MapperScan(&quot;cn.boot.mapper&quot;)
    public class StartQuickBoot {
        ...
    }
5. 实体类相关
    1. 通用Mapper默认会使用实体类名作为数据库表名，@Table(name=&quot;表名&quot;) 用于指定数据库表名;
    2. @Id 注解在属性上，指定主键;
    3. 对于自增长的主键，还需要使用 @KeySql(userGeneratedKeys=true) 注解;
    4. 如果实体类的某个属性不作为数据库的字段，则使用 @Transient 注解;
    @Data
    @Table(name=&quot;tl_user&quot;)
    public class User {
        @Id
        @KeySql(userGeneratedKeys=true)
        private Integer id;  //自增长的主键
        private String username;
        @Transient
        private String remark;  //额外的属性
    }
6. Service层：使用 @Transactional 注解引入事务;
    @Service
    public class UserService {
        @Autowired
        private UserMapper mapper;

        public User findById(Integer id) {
            return mapper.selectByPrimaryKey(id);
        }
        @Transactional
        public void insertUser(User user) {  //插入数据时使用事务
            mapper.insert(user);
        }
    }
7. Controller层
    @Autowired
    private UserService service;  //注入Service对象

    @GetMapping(&quot;/{id}&quot;)
    public User test(@PathVariable(&quot;id&quot;) Integer id) {
        log.debug(&quot;test service: {}&quot;, id);
        return service.findById(id);
    }
</code></pre><h2 id="集成Spring-Data-JPA"><a href="#集成Spring-Data-JPA" class="headerlink" title="集成Spring Data JPA"></a>集成Spring Data JPA</h2><pre><code>1. 引入起步依赖：spring-boot-starter-data-jpa
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
    &lt;/dependency&gt;
2. 引入MySQL连接驱动：
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;8.0.16&lt;/version&gt;
    &lt;/dependency&gt;
3. application.properties
    # MySQL连接信息
    spring.datasource.driverClassName=com.mysql.cj.jdbc.Driver
    spring.datasource.url=jdbc:mysql:...
    spring.datasource.username=root
    spring.datasource.password=123456
    # JPA的配置信息
    spring.jpa.database=MySQL
    spring.jpa.show-sql=true
    spring.jpa.generate-ddl=true
    spring.jpa.hibernate.ddl-auto=update
    spring.jpa.hibernate.naming_strategy=org.hibernate.cfg.ImprovedNamingStrategy
4. 创建POJO
    @Entity  --&gt;javax.persistence.Entity
    public class User {
        @Id
        @GeneratedValue(strategy=GenerationType.IDENTITY)
        private Long id;  //使用包装类型
        private String username;
        private String password;
        ... //getter、setter
    }
5. Dao层接口：cn.boot.repository.UserRepository
    public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
        List&lt;User&gt; findAll();
    }
6. 使用junit测试：测试失败，等学了JPA再说吧
    @RunWith(SpringRunner.class)
    @SpringBootTest(classes=引导类.class)
    public class TestIbatis {
        @Autowired
        private UserRepository userRepository;  //注入Repository对象

        @Test
        public void test() {
            List&lt;User&gt; users = userRepository.findAll();
        }
    }
7. JDK9环境可能报异常：JAXBException，是因为缺少依赖;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;
        &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;
        &lt;version&gt;2.3.1&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><pre><code>1. Redis官方推荐的Java客户端有很多，常用的有Jedis、Redisson...
2. 其中，Redisson基于Redis实现了很多常用的结构，甚至还有分布式锁和同步器;
3. Spring对Redis做了集成，SpringDataRedis，最初是基于Jedis，Spring5.0开始转向响应式编程，
   所以 SpringDataRedis 重新采用一套响应式编程实现，性能比Jedis更高;
4. SpringDataRedis属于Spring Data的一部分，也为Redis提供了一个Template对象：RedisTemplate
</code></pre><h3 id="整合Redis"><a href="#整合Redis" class="headerlink" title="整合Redis"></a>整合Redis</h3><pre><code>1. Redis的启动器：spring-boot-starter-data-redis
2. 在 application.yml 中，配置Redis的连接信息
    spring:
        redis:
            host: 192.168.103.30
            port: 6379  # 默认6379
            database: 0  # 配置Redis的数据库编号，默认就是0
            timeout: 3000  # 连接超时时间3s
            pool:  #连接池
                max-idle=200 #最大空闲连接，默认值8
                min-idle=200 #最小空闲连接，默认值0
                max-active=2000 #最大连接实例，设置为-1，表示不做限制
                max-wait=1000 #等待可用连接的超时时间，默认值-1，表示永不超时
3. 在测试类中，注入 RedisTemplate 对象，操作Redis数据库
    @Autowired
    private RedisTemplate redis;

    @Test
    public void contest() {

    }
4. redis.opsForValue()、opsForList()、opsForSet()、opsForZSet()、opsForHash() 对应Redis中的5种数据结构，
   封装到不同的 Operations 对象中;
    1. 字符串操作对象：ValueOperations ops = redis.opsForValue();
    2. opsForXXX() 在获取Operations对象时做了单例优化，可以不创建Operations对象的变量;
5. redis.boundXXXOps(key)：以绑定key的方式创建 Operations 对象，后续操作不需要再指定key
</code></pre><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><pre><code>1. RedisTemplate 其实是带有泛型的：RedisTemplate&lt;K, V&gt;，分别代表Key、Value的类型;
2. 虽然Redis的key和value通常都是字符串类型：RedisTemplate&lt;String, String&gt;，但底层存储时仍是二进制字节;
3. 泛型的 K、V 可以指定任意类型，RedisTemplate自动把这些类型转为字节进行存储，因为默认使用JDK的序列化工具;
4. 在命令行上查看时，Redis不会转换JDK序列化的结果，可读性很差，所以通常把对象转为JSON字符串，然后存储到Redis中;
5. 考虑到这种转换会很频繁，所以Spring提供了RedisTemplate的子类：SpringRedisTemplate，它的序列化工具不再是JDK，
   而是string.getBytes()，在命令行上查看时，Redis能够自动再转为字符串;
6. 当然RedisTemplate也允许自定义序列化工具。
7. 短信验证码的发送
    1. 把发送事件推送到RabbitMQ中，由消费者调用短信的API;
    2. 短信发送成功后，使用Redis记录下当前手机号，key=sms:phone:手机号，value=当前时间戳，并设置过期时间;
    3. 每次收到发送短信的消息时，先从Redis中获取手机号，如果没有或者时间已经超过了1分钟，则发送，否则不发送，
    避免短信服务的限流;
</code></pre><h2 id="LogBack"><a href="#LogBack" class="headerlink" title="LogBack"></a>LogBack</h2><pre><code>1. 常用的日志组件：slf4j、log4j、logback、common-logging...
2. logback：基于log4j，不能单独使用，一般配合slf4j使用;
3. logback当前分为3个模块：logback-core(基础核心模块)、logback-classic、logback-access
    1. Logger：日志记录器;
    2. Appender：指定日志输出的目的地，控制台、文件;
    3. Layout：日志布局，格式化日志信息的输出;
5. 日志级别：debug &lt; info &lt; warn &lt; error
6. 在线工具：https://logback.qos.ch/translator/，把log4j.properties转为logback.xml
    ===========log4j.properties示例===========
    ### 设置###
    log4j.rootLogger = debug,stdout,D,E
    ### 输出信息到控制抬 ###
    log4j.appender.stdout = org.apache.log4j.ConsoleAppender
    log4j.appender.stdout.Target = System.out
    log4j.appender.stdout.layout = org.apache.log4j.PatternLayout
    log4j.appender.stdout.layout.ConversionPattern = [%-5p] %d{yyyy-MM-dd HH:mm:ss,SSS} method:%l%n%m%n
    ### 输出DEBUG 级别以上的日志到=D://logs/error.log ###
    log4j.appender.D = org.apache.log4j.DailyRollingFileAppender
    log4j.appender.D.File = D://logs/log.log
    log4j.appender.D.Append = true
    log4j.appender.D.Threshold = DEBUG
    log4j.appender.D.layout = org.apache.log4j.PatternLayout
    log4j.appender.D.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n
    ### 输出ERROR 级别以上的日志到=D://logs/error.log ###
    log4j.appender.E = org.apache.log4j.DailyRollingFileAppender
    log4j.appender.E.File =E://logs/error.log
    log4j.appender.E.Append = true
    log4j.appender.E.Threshold = ERROR
    log4j.appender.E.layout = org.apache.log4j.PatternLayout
    log4j.appender.E.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n
</code></pre><h3 id="SpringBoot整合logback"><a href="#SpringBoot整合logback" class="headerlink" title="SpringBoot整合logback"></a>SpringBoot整合logback</h3><pre><code>1. Web启动器spring-boot-starter-web 中已经包含了 logback 的相关依赖;
2. 创建 resources/logback-spring.xml
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
    &lt;configuration&gt;
        &lt;appender name=&quot;consoleApp&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
            &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;
                &lt;pattern&gt;
                    %date{yyyy-MM-dd HH:mm:ss.SSS} %-5level[%thread]%logger{56}.%method:%L -%msg%n
                &lt;/pattern&gt;
            &lt;/layout&gt;
        &lt;/appender&gt;
        &lt;appender name=&quot;fileInfoApp&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
            &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;
                &lt;level&gt;ERROR&lt;/level&gt;
                &lt;onMatch&gt;DENY&lt;/onMatch&gt;
                &lt;onMismatch&gt;ACCEPT&lt;/onMismatch&gt;
            &lt;/filter&gt;
            &lt;encoder&gt;
                &lt;pattern&gt;
                    %date{yyyy-MM-dd HH:mm:ss.SSS} %-5level[%thread]%logger{56}.%method:%L -%msg%n
                &lt;/pattern&gt;
            &lt;/encoder&gt;
            &lt;!-- 滚动策略 --&gt;
            &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
                &lt;!-- 输出到文件的路径 --&gt;
                &lt;fileNamePattern&gt;app_log/log/app.info.%d.log&lt;/fileNamePattern&gt;
            &lt;/rollingPolicy&gt;
        &lt;/appender&gt;
        &lt;appender name=&quot;fileErrorApp&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
            &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;
                &lt;level&gt;ERROR&lt;/level&gt;
            &lt;/filter&gt;
            &lt;encoder&gt;
                &lt;pattern&gt;
                    %date{yyyy-MM-dd HH:mm:ss.SSS} %-5level[%thread]%logger{56}.%method:%L -%msg%n
                &lt;/pattern&gt;
            &lt;/encoder&gt;
            &lt;!-- 设置滚动策略 --&gt;
            &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
                &lt;!-- 输出到文件的路径 --&gt;
                &lt;fileNamePattern&gt;app_log/log/app.err.%d.log&lt;/fileNamePattern&gt;
                &lt;!-- 控制保留的归档文件的最大数量，超出数量就删除旧文件，假设设置每个月滚动，
                    且&lt;maxHistory&gt; 是1，则只保存最近1个月的文件，删除之前的旧文件 --&gt;
                &lt;MaxHistory&gt;1&lt;/MaxHistory&gt;
            &lt;/rollingPolicy&gt;
        &lt;/appender&gt;
        &lt;!-- 控制总的输出级别：level=&quot;INFO&quot; 表示只输出大于等于INFO级别的日志，不会有DEBUG日志 --&gt;
        &lt;root level=&quot;INFO&quot;&gt;  
            &lt;appender-ref ref=&quot;consoleApp&quot;/&gt;
            &lt;appender-ref ref=&quot;fileInfoApp&quot;/&gt;
            &lt;appender-ref ref=&quot;fileErrorApp&quot;/&gt;
        &lt;/root&gt;
    &lt;/configuration&gt;
3. 日志输出
    @GetMapping(&quot;log&quot;)
    public String testLog() {
        log.debug(&quot;this is debug level&quot;);
        log.info(&quot;this is info level&quot;);
        log.warn(&quot;this is warn level&quot;);
        log.error(&quot;this is error level&quot;);
    }
    http://localhost:8080/user/log
4. 在项目目录下生成 app_log/log 目录，其中包含日志文件 app.info.xx.log、app.err.xx.log
5. 日志文件不仅包括 log 打印的，还有大于INFO级别的系统日志;
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/04/02/SpringBoot进阶/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/02/SpringBoot进阶/" itemprop="url">SpringBoot进阶</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-02T00:00:00+08:00">
                2016-04-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="SpringMVC新增注解"><a href="#SpringMVC新增注解" class="headerlink" title="SpringMVC新增注解"></a>SpringMVC新增注解</h2><pre><code>1. Spring4.3中引进了 @GetMapping、@PostMapping、@PutMapping、@DeleteMapping、@PatchMapping
    1. @GetMapping 等效于 @RequestMapping(method=RequestMethod.GET);
    2. @PostMapping 是 @RequestMapping(method=RequestMethod.POST) 的缩写;
2. @RestController：相当于 @ResponseBody + @Controller 的组合;
    @RestController
    @RequestMapping(&quot;/user&quot;)
    public class RestController {
        @GetMapping(&quot;/getList&quot;)
        public List&lt;User&gt; getList() {
            List&lt;User&gt; us = dao.findAll();
            return us;
        }
    }
    1. @RestController 的方法都只能返回String、Object、Json等实体对象;
    2. SpringBoot已经引入了jackson, 返回的对象会被jackson转为JSON字符串，写入响应体中;
    3. 如果想要跳转页面，则用 ModelAndView 封装;
    @GetMapping(&quot;/index&quot;)
    public ModelAndView toIndex() {
        ModelAndView mv = new ModelAndView(&quot;index&quot;);
        return mv;
    }
</code></pre><h2 id="lombok"><a href="#lombok" class="headerlink" title="lombok"></a>lombok</h2><pre><code>    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;version&gt;1.18.6&lt;/version&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
1. @Data：注解在Java类上，在编译期自动生成getter、setter... 源码中没有变化，只存在于编译生成的class文件中;
2. @Slf4j：等效于在Java类中创建Logger对象的属性 log=LoggerFactory.getLogger(类名.class);
3. 但是IDEA并不能自动识别 @Slf4j 提供的变量log，需要安装插件 Settings -&gt; Plugins -&gt; 搜索Lombok
</code></pre><h2 id="Jackson"><a href="#Jackson" class="headerlink" title="Jackson"></a>Jackson</h2><pre><code>1. 常用的JSON框架序列化JSON的性能：Jackson &gt; fastJson &gt; Gson &gt; Json-lib，各有所长，时间换空间、空间换时间;
2. web启动器默认集成了Jackson
    1. @JsonIgnore：指定忽略的字段，不返回给前端;
    2. @JsonFormat(pattern=&quot;yyyy-MM-dd hh:mm:ss&quot;, locale=&quot;zh&quot;, timezone=&quot;GMT+8&quot;)：指定日期格式化;
    3. @JsonInclude(Include.NON_NULL)：空字段不返回;
    4. @JsonProperty：指定别名，隐藏真实的字段名;
    @Data
    public class User {
        @JsonInclude(Include.NON_NULL)
        private Integer id;

        @JsonIgnore
        private String name;

        @JsonProperty(&quot;abcd&quot;)
        private String password;

        @JsonFormat(pattern=&quot;yyyy-MM-dd hh:mm:ss&quot;, locale=&quot;zh&quot;, timezone=&quot;GMT+8&quot;)
        private Date birthday;
    }
3. Controller方法
    @RestController
    public class UserController {
        @GetMapping(&quot;/test&quot;)
        public Object test() {
            User user = new User();
            user.setName(&quot;Java&quot;);
            user.setName(&quot;123456&quot;);
            user.setBirthday(new Date())
            return user;  //发送给前端的JSON：{ &quot;abcd&quot;: &quot;123456&quot;, &quot;birthday&quot;: &quot;2019-05-12 07:50:31&quot; }
        }
    }
</code></pre><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><pre><code>1. @EnableScheduling：注解在启动类上，自动扫描，开启定时任务;
2. @Scheduled：注解在任务方法上;
    @Slf4j
    @Component  --&gt;定时任务类必须加入Spring IoC容器才能被扫描
    public class TestTask {
        @Scheduled(fixedRate=2000)  --&gt;每隔2s执行一次
        public void test() {
            log.info(&quot;当前时间：{}&quot;, new Date());
        }
    }
    1. corn：定时任务表达式，比如 cron=&quot;*/1 * * * * *&quot; 表示每秒执行一次，可以使用在线工具生成corn表达式;
    2. fixedRate：上次开始执行后，xx毫秒后再执行;
        @Scheduled(fixedRate=2000)
        public void test() {
            Thread.sleep(4000);   ---&gt;任务执行时间大于fixedRate，那么每隔 4s 执行一次
        }
    3. fixedDelay：上次任务结束之后，延迟xx毫秒再执行；
        @Scheduled(fixedDelay=2000)
        public void test() {
            Thread.sleep(4000);  --&gt; 任务执行时间4s + 延迟时间2s = 6s  --&gt;每隔6s执行一次
        }
    4. fixedRateString、fixedDelayString：字符串形式，可以把延迟时间配置在SpringBoot的配置文件中;
</code></pre><h2 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h2><pre><code>1. @EnableAsync：注解在启动类上，扫描异步任务的注解;
2. @Component：注解在任务类上，加入Spring IoC容器，不能把任务方法写在Controller类中;
3. @Async：注解在任务类或任务方法上，注解在任务类上时，它所有的方法都是异步任务;
    @Slf4j
    @Component
    public class AsyncTask {
        @Async
        public void task1() throws InterruptedException {
            long begin = System.currentTimeMillis();
            Thread.sleep(1000);
            long end = System.currentTimeMillis();
            log.info(&quot;任务-1: {}&quot;, (end-begin));
        }
    }
4. 调用异步任务，不会阻塞主线程
    @Autowired
    private AsyncTask t;

    @GetMapping(&quot;/task&quot;)
    public String task() {
        t.task1();
        return &quot;hello Task!&quot;;  --&gt;响应给前端，不会等待异步任务执行完成
    }
5. 获取异步任务的返回值
    @Async
    public Future&lt;String&gt; task2() throws InterruptedException {
        long begin = System.currentTimeMillis();
        Thread.sleep(2000);
        long end = System.currentTimeMillis();
        log.info(&quot;任务-2: {}&quot;, (end-begin));
        return new AsyncResult&lt;String&gt;(&quot;task2&quot;);
    }
    @Async
    public Future&lt;String&gt; task3() throws InterruptedException {
        long begin = System.currentTimeMillis();
        Thread.sleep(3000);
        long end = System.currentTimeMillis();
        log.info(&quot;任务-3: {}&quot;, (end-begin));
        return new AsyncResult&lt;String&gt;(&quot;task3&quot;);  //返回异步任务执行的结果
    }

    @GetMapping(&quot;/task1&quot;)
    public String task1() {
        Future&lt;String&gt; task2 = t.task2();//执行异步任务
        Future&lt;String&gt; task3 = t.task3();
        for(;;) {
            if(task2.isDone() &amp;&amp; task3.isDone()) { //检查异步任务是否全部执行完成
                break;
            }
        }  ---&gt; 大约耗时：3000，异步任务是同时执行的，所以耗时时间就是执行时间最长的一个异步任务
    }
    @GetMapping(&quot;/task2&quot;)
    public String task2() {
        long begin = System.currentTimeMillis();
        Future&lt;String&gt; task2 = t.task2();
        Future&lt;String&gt; task3 = t.task3();
        String res4 = task4.get();
        String res5 = task5.get();  //阻塞等待获取异步任务的结果
        long end = System.currentTimeMillis();
        System.out.println(&quot;耗时: &quot; + (end-begin)); //大约耗时：3000
    }
</code></pre><h2 id="全局异常"><a href="#全局异常" class="headerlink" title="全局异常"></a>全局异常</h2><pre><code>1. @ControllerAdvice：注解在类上，声明为异常捕获类;
2. @RestControllerAdvice：组合注解，@ControllerAdvice + @ResponseBody
3. @ExceptionHandler(value=Exception.class)：注解在异常处理的方法上，value属性指定捕获的异常;
    @ControllerAdvice
    public class CustomExtHandler {
        @ExceptionHandler(value=Exception.class)  --&gt;Exception表示捕获所有异常
        @ResponseBody
        Object handleException(Exception e, HttpServletRequest request) {
            Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
            map.put(&quot;code&quot;, 100);
            map.put(&quot;msg&quot;, e.getMessage());
            map.put(&quot;url&quot;, request.getRequestURL());
            return map;  //当应用程序中发生了异常时，响应给前台的数据
        }
    }
    1. 在Controller中抛出异常
        @GetMapping(&quot;/ply&quot;)
        public String home() {
            int i = 1/0;  -----&gt; 抛出异常
            ......
        }
    2. http://localhost:8080/ply  --&gt; { &quot;code&quot;: 100, &quot;msg&quot;: &quot;...&quot;, &quot;url&quot;: &quot;...&quot; }
4. 自定义异常，跳转到友好界面(引入依赖thymeleaf)
    1. 自定义异常
        public class PageException extends RuntimeException {
            public PageException(String code, String msg) {
                this.code = code;
                this.msg = msg;
            }
            ......
        }
    2. 在 CustomExtHandler 中追加一个新的处理方法，精确捕获自定义异常
        @ExceptionHandler(value = PageException.class)
        @ResponseBody
        Object handleException(PageException e) {
            ModelAndView mav = new ModelAndView();
            mav.setViewName(&quot;error.html&quot;);
            mav.addObject(&quot;msg&quot;, e.getMsg());
            return mav;
        }
    3. 在Controller中抛出自定义异常
        @GetMapping(&quot;/ply&quot;)
        public String home() {
            throw new PageException(&quot;102&quot;, &quot;错误异常&quot;);
        }
</code></pre><h2 id="Servlet3-0"><a href="#Servlet3-0" class="headerlink" title="Servlet3.0"></a>Servlet3.0</h2><pre><code>1. 在SpringBoot项目中，可以使用Servlet3.0的注解开发Filter、Listener、甚至原生Servlet;
2. @ServletComponentScan：注解在启动类上，进行扫描Servlet3.0的注解;
    @ServletComponentScan
    @SpringBootApplication
    public class BootTestApplication {
        ...
    }
3. 过滤器：@WebFilter
    1. Filter在服务器启动时加载，服务器关闭时销毁，SpringBoot启动时默认加载4个Filter
    characterEncodingFilter -&gt; hiddenHttpMethodFilter -&gt; httpPutFormContentFilter -&gt; requestContextFilter
    2. 使用Servlet3.0的注解自定义Filter时，避免和默认的Filter优先级相同，否则会冲突;
    3. 自定义的Filter 必须实现Filter接口，并注解 @WebFilter，用于配置过滤规则，并加入Spring容器;
    @WebFilter(urlPatterns = &quot;/api/*&quot;, filterName = &quot;loginFilter&quot;)
    public class LoginFilter implements Filter {
        init()、destroy()
        public void doFilter(ServletRequest servReq, ServletResponse servResp, FilterChain chain) {
            HttpServletRequest req = (HttpServletRequest)servReq;
            HttpServletResponse resp = (HttpServletResponse)servResp;
            String username = req.getParameter(&quot;username&quot;);
            if(&quot;admin&quot;.equals(username)) {
                chain.doFilter(servletRequest, servletResponse);
            } else {
                resp.sendRedirect(&quot;/error.html&quot;);
            }
        }
    }
4. 自定义原生Servlet：@WebServlet
    @WebServlet(name=&quot;userServlet&quot;, urlPatterns = &quot;/test/user&quot;)
    public class UserServlet extends HttpServlet {
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp) {
            resp.getWriter().print(&quot;user servlet&quot;);
            resp.getWriter().flush();
            resp.getWriter().close();
        }
    }
5. 自定义原生Listener：@WebListener
    1. 常用监听器：ServletContextListener、HttpSessionListener、ServletRequestListener
    2. ServletContextListener：服务器启动时初始化，常用于一些资源的加载;
    3. ServletRequestListener：一次请求，请求到达则初始化，响应结束则销毁;
    @WebListener
    public class RequestListener implements ServletRequestListener {
        public void requestDestroyed(ServletRequestEvent servletRequestEvent) {
            System.out.println(&quot;RequestListener requestDestroyed&quot;);
        }
        public void requestInitialized(ServletRequestEvent servletRequestEvent) {
            System.out.println(&quot;RequestListener requestInitialized&quot;);
        }
    }
</code></pre><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><pre><code>    public class LoginIntercepter implements HandlerInterceptor {
        preHandle()   --&gt;调用Controller方法之前
        postHandle()  --&gt;Controller方法调用之后，视图渲染之前，如果Controller方法出现异常，则不会执行
        afterCompletion()  --&gt;不管是否有异常，都会执行，常用于资源清理
    }
1. SpringBoot规定：
    1. 如果要保留SpringBoot的一些默认MVC特征，同时又想自定义一些MVC配置，如拦截器、格式化器、视图控制器、
    消息转发器... 就必须实现WebMvcConfigurer，并使用 @Configuration，但一定不能使用 @EnableWebMvc;
    2. 如果想要完全自定义SpringMVC，不保留默认的一切MVC特征，则使用 @Configuration 和 @EnableWebMvc;
2. SpringBoot2.0的拦截器与v2.0之前的配置方式是不同的
    1. 旧版本：extends WebMvcConfigurerAdapter
    @Configuration
    public class OldCusWebMvcConfigurer extends WebMvcConfigurerAdapter {
        public void addInterceptors(InterceptorRegistry registry) {
            //配置拦截器和拦截规则，Ant风格的路径匹配
            registry.addInterceptor(new LoginIntercepter()).addPathPatterns(&quot;/api2/*/**&quot;);
        }
    }
    2. 新版本：implements WebMvcConfigurer
    @Configuration
    public class CusWebMvcConfigurer implements WebMvcConfigurer {
        //配置拦截器和拦截规则
        registry.addInterceptor(new LoginIntercepter())
            .addPathPatterns(&quot;/api2/*/**&quot;)  ----&gt;拦截的资源访问
            .excludePathPatterns(&quot;/api2/xxx/**&quot;);  --&gt;某些不需要拦截的资源访问

        registry.addInterceptor(new LoginIntercepter()).addPathPatterns(&quot;/api2/*/**&quot;);
    }
    3. 配置多个拦截器时，拦截器的执行顺序与配置顺序相同;
3. 拦截器与过滤器
    1. 过滤器依赖于Servlet容器(Web应用)，基于函数回调；而拦截器则不依赖，基于Java的反射机制(AOP)；
    2. 拦截器中可以注入Spring IoC容器的所有Bean对象，实现业务逻辑的调用，而过滤器则不行；
    3. 执行顺序
        Filter --&gt; 拦截器 --&gt; action执行 --&gt; 拦截器 --&gt; 过滤器
</code></pre><h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><pre><code>1. DBCP是一款老牌的JDBC连接池，出自Apache;
2. cp30与Druid都是连接池，一个JDBC组件，速度都差不多;
    1. Hibernate默认使用c3p0;
    2. Druid可以监控每一条SQL语句的执行性能，从而优化SQL语句.
3. 速度最快的JDBC连接池是HikariCP(追光者)，Spring默认内置了HikariCP;
4. Spring提供的JDBC启动器：spring-boot-starter-jdbc，SpringBoot默认集成，无需手动引入;
5. 连接池只是一个JDBC组件，还需要配置数据库驱动，如MySQL的驱动依赖：mysql-connector-java
6. 在 application.yml 中，配置Spring启动器中的默认连接池：连接数据库的4大参数;
    spring:
        datasource:
            driver-class-name: com.mysql.cj.jdbc.Driver
            url: jdbc:mysql://host:port/database?serverTimezone=Asia/Shanghai
            username: root
            password: 123456
7. 默认使用的连接池是HikariCP，如果想使用其他连接池，如阿里的druid
    1. 引入druid的依赖，配置spring.datasource.type=com.zaxxer.hikari.HikariDataSource
    spring:
        datasource:
            type: com.alibaba.druid.pool.DruidDataSource
            ...... # driver-class-name、url、username、password
</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><pre><code>1. Junit的起步依赖：spring-boot-starter-test
2. 在test目录下创建测试类
    @RunWith(SpringRunner.class)
    @SpringBootTest(classes=引导类.class)
    public class TestClient {
        @Autowired
        private IUserMapper userMapper;  //注入Mapper对象

        @Test
        public void test() {
            List&lt;User&gt; users = userMapper.findAll();
        }
    }
3. MockMvc：模拟 SpringMVC 的客户端请求
    @AutoConfigureMockMvc   ----&gt;MockMvc的注解
    @RunWith(SpringRunner.class)
    @SpringBootTest(classes={启动类.class})
    public class TestClient {
        @Autowired
        private MockMvc mvc;

        @Test
        public void test() {
            MvcResult res = mvc.perform(MockMvcRequestBuilders.get(&quot;/ply&quot;))
                .andExpect(MockMvcResultMatchers.status().isOk()).andReturn();  //发起get请求
            String str = res.getResponse().getContentAsString();  //获取请求的内容
        }
    }
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/04/01/SpringBoot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/01/SpringBoot/" itemprop="url">SpringBoot</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-01T00:00:00+08:00">
                2016-04-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="SpringBoot与Spring"><a href="#SpringBoot与Spring" class="headerlink" title="SpringBoot与Spring"></a>SpringBoot与Spring</h2><pre><code>1. Spring的优点：Spring是JavaEE的轻量级框架，通过依赖注入和面向切面编程，用简单的POJO实现EJB的功能;
2. Spring的缺点：虽然Spring的组件代码是轻量级的，但是它的配置文件却是重量级的;
    1. Spring2.5引入基于注解的组件扫描，也是为了消除大量针对应用程序自身组件的XML配置;
    2. Spring3.0引入了基于Java的配置，这是一种类型安全的、可重构的配置方式，可以替代XML;
    3. 除了配置会消耗大量的开发时间，项目的依赖管理也是很麻烦的，版本选择困难，容易冲突.
3. Spring注解的发展
    1. Spring1.0时代因为JDK1.5刚出来，注解开发尚未盛行，所以一切Spring配置皆是XML格式;
    2. Spring2.0时代引入了注解开发，但并未完善，因此并未完全替代XML;
    3. Spring3.0时代的注解已经非常完善了，因此Spring推荐使用注解(Java配置)代替XML.
4. SpringBoot解决了Spring的缺点，基于约定优先于配置，开发者只需要关心逻辑业务的代码编写;
    1. 开箱即用，没有代码生成，也无需XML配置，通过修改默认值来满足特定的需求;
    2. 提供了一些大型项目中常见的非功能性的特性，如嵌入式服务器、安全、指标、健康检测、外部配置...
    3. SpringBoot不是对Spring功能上的增强，而是提供一种基于Spring的快速开发方式.
5. SpringBoot的核心功能
    1. 起步依赖：本质上是一个Maven项目对象模型(POM)，定义了对其他库的传递依赖;
    1. 简单来说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认功能.
    2. 自动配置：SpringBoot的自动配置是一个运行时(应用程序启动时)的过程;
    2. 考虑了众多因素，才决定Spring配置应该用哪个、不应该用哪个，此过程也是Spring自动完成的。
6. 在SpringBoot中，默认采用Servlet3.0，它可以完全使用注解取代web.xml了，所以SpringBoot没有了web.xml;
</code></pre><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><pre><code>1. SpringBoot2.x的依赖环境和版本
    1. JDK8+，因为SpringBoot2.x底层是Spring Framework5
    2. Maven3.2+，Gradle4+
2. 创建一个普通Java项目的Maven工程，添加继承SpringBoot的起步依赖spring-boot-starter-parent
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.1.4.RELEASE&lt;/version&gt;
    &lt;/parent&gt;
    1. spring-boot-starter-parent 中管理了很多其他依赖的版本，所以 &lt;dependencies&gt; 中引入这些的依赖时，
    尽量不要配置它们的版本号，沿用 spring-boot-starter-parent 中的版本号;
    2. Spring对版本的要求比较严格，很多问题都是因为版本不匹配所致.
3. SpringBoot要集成SpringMVC、进行Web/Controller的开发时，只需要导入web的启动器即可;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;!-- 无需指定版本号(如果无法自动配置，则拷贝spring-boot-starter-parent中的版本号) --&gt;
    &lt;/dependency&gt;
4. 创建一个普通类，使用 @SpringBootApplication 声明为一个SpringBoot的引导类(引导应用程序的入口);
    1. 在 main() 中运行引导类：SpringApplication.run(引导类.class, 可选参数);
    @SpringBootApplication
    public class StartSpringBoot {
        public static void main(String[] args) {
            SpringApplication.run(StartSpringBoot.class, args);
        }
    }
5. SpringBoot中内置有Tomcat插件，直接运行 main()，在控制台提示Tomcat启动信息：
    Tomcat started on port(s): 8080 (http) with context path &apos;&apos;
    1. context path &apos;&apos;：表示web应用的名称(虚拟项目名)为空字符串，访问 http://localhost:8080/ ;
    2. 当前没有编写任何页面，所以展示的是 Error Page，但表示已经启动成功了;
6. 无需任何配置，就可以直接编写Controller层
    @Controller
    public class QuickController {
        @RequestMapping(&quot;/test&quot;)
        @ResponseBody
        public String test() {
            return &quot;Hello SpringBoot&quot;;
        }
    }    ---&gt;http://localhost:8080/test  ---&gt; Hello SpringBoot
7. IDEA快速创建SpringBoot工程
    New Project -&gt; Spring Initializr -&gt; Next -&gt; 设置项目信息 -&gt; Next -&gt; 手动选择依赖 -&gt; Finish
</code></pre><h2 id="SpringBoot的原理"><a href="#SpringBoot的原理" class="headerlink" title="SpringBoot的原理"></a>SpringBoot的原理</h2><pre><code>1. 起步依赖
    1. 所有的SpringBoot工程都必须继承 spring-boot-starter-parent，它会对依赖的版本进行管理;
    2. SpringBoot项目引入的依赖往往都是starter，它是一个工具集合，里面包含了很多常用的依赖，便于版本管理;
    3. 比如spring-boot-starter-web，包含了诸如spring-webmvc、spring-web、Tomcat、jackson ...
    4. 第三方框架要对接SpringBoot项目，必须提供起步依赖(启动器)，Spring的官方启动器通常以 spring- 开头;
2. 自动配置
    1. @SpringBootApplication是组合注解：@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan
    2. @SpringBootConfiguration 其实就是 @Configuration，所以引导类也就是一个配置类;
    3. @EnableAutoConfiguration 是自动配置的核心注解，@Import({AutoConfigurationImportSelector.class})
    4. AutoConfigurationImportSelector 中就是自动配置的核心源码;
    5. @ComponentScan：配置扫描的包，默认就会扫描引导类所在包下的所有注解.
</code></pre><h2 id="SpringBoot的配置文件"><a href="#SpringBoot的配置文件" class="headerlink" title="SpringBoot的配置文件"></a>SpringBoot的配置文件</h2><pre><code>1. SpringBoot是基于约定的，所以很多配置都是默认值;
2. 在需要自定义配置时，根据启动器提供的key名，在SpringBoot的配置文件中指定value值即可;
3. spring-boot-starter-parent 会自动加载 resources 目录下的三类配置文件;
    1. application*.yml、application*.yaml、application*.properties;
    2. 加载顺序：yml --&gt; yaml --&gt; properties，当有相同的key名配置时，properties中的优先级最高.
4. 创建 resources/application.properties，实现一些个性化配置;
    server.port=9090    # 配置Tomcat启动的端口号，默认是8080
    server.servlet.context-path=/demo    # 配置web应用虚拟目录名，默认是空字符串
5. YML一种新型配置文件，也是一种标记语言，有两种扩展名：.yml、.yaml
    1. YML文件格式是由YAML编写的，YAML是一种能够被电脑识别的数据序列化格式，且易读性强，以数据为核心，比XML更简洁;
    2. YML文件与脚本语言的交互性强，可以被支持YAML库的编程语言程序导入，如C/C++、Python、Java、C#、PHP、Ruby...
</code></pre><h3 id="yml配置文件"><a href="#yml配置文件" class="headerlink" title="yml配置文件"></a>yml配置文件</h3><pre><code>1. 普通数据
    1. key: value
    2. key和value之间必须有一个空格：name: Jack
2. 对象数据/Map数据
    1. 形式一：缩进形式
        key:
            key1: value1
            key2: value2
    2. key1、key2前面的空格个数不限定，相同缩进代表同一级别;
        person:
            name: Java
            age: 20
    3. 形式二：行内形式
        key: {key1: value1,key2: value2}
3. 数组、List、Set
    1. 存放普通字符串
        key:
            - value1
            - value2
        key: [value1,value2]
    2. 存放对象
        key:
            - key11: value11
              key12: value12
            - key22: value22
              key23: value23
        key: [{key11: value11,key12: value12}, {key22: value22,key23: value23}]
4. resources/application.yaml
    1. 自定义SpringMVC的默认配置
        server:
            port: 8888    # 配置服务器的端口号
            servlet:
                path: &quot;*.do&quot;    # 访问映射路径，默认是&quot;/&quot;，会影响所有的请求路径
    2. Log4j相关
        logging:    # 日志配置(log4j相关的依赖已经被集成)
            level:    # 控制日志级别，是一个Map集合
                cn.boot: debug    # cn.boot包下的日志级别为debug
                org.springframework: debug
</code></pre><h3 id="属性映射"><a href="#属性映射" class="headerlink" title="属性映射"></a>属性映射</h3><pre><code>1. 配置文件被加载后，其中的键-值将会被存放到Spring IoC容器中，那么就可以映射到Spring管理的Bean对象中;
2. application.yml
    jdbc:
        driverClassName: com.mysql.cj.jdbc.Driver
        url: jdbc:mysql://host:port/database?serverTimezone=Asia/Shanghai
        username: root
        password： 123456
3. @Value 的映射：指定配置文件的key名，映射到Spring IoC管理的对象属性上，适合数据量较小的情况;
    @Component
    public class JdbcConf {
        @Value(&quot;${jdbc.driverClassName}&quot;)
        private String driverClassName;

        @Value(&quot;${jdbc.url}&quot;)
        private String url;

        @Value(&quot;${jdbc.username}&quot;)
        private String username;

        @Value(&quot;${jdbc.password}&quot;)
        private String password;
    }
4. @ConfigurationProperties：把配置文件中的键值数据映射到当前Java类的属性上;
    @ConfigurationProperties(prefix=&quot;jdbc&quot;)
    public class JdbcConf {
        private String driverClassName;
        private String url;
        private String username;
        private String password;
    }
    1. prefix属性：声明配置文件中的字段前缀，自动映射到Java类的同名属性上;
    2. 使用 @ConfigurationProperties 时，还需要引入其执行器;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
    3. 先在Bean中定义需要的属性，然后在配置文件中配置时，执行器就会提示可配置的属性.
5. @EnableConfigurationProperties：使用 @ConfigurationProperties 注解的Java类;
    @Configuration
    @EnableConfigurationProperties(JdbcConf.class)
    public class TestConfigure {
        @Autowired
        private JdbcConf jdbc;  //1. @Autowired的方式注入JdbcConf对象

        public TestConfigure(JdbcConf jdbc) { //2.构造方法的方式注入JdbcConf对象

        }
        @Bean
        public DataSource getDataSource(JdbcConf prop) {  //3.方法参数的方式注入
            //阿里的druid
            DruidDataSource ds = new DruidDataSource();
            ds.setDriverClassName(prop.getDriverClassName());
            ds.setUrl(prop.getUrl());
            ds.setUsername(prop.getUsername());
            ds.setPassword(prop.getPassword());
            return ds;
        }
    }
6. 如果只有一个Bean对象使用JDBC的连接信息，还可以优雅地映射配置文件中的键-值
    @Configuration
    public class JdbcConfig {
        @Bean
        @ConfigurationProperties(prefix=&quot;jdbc&quot;)
        public DataSource getDataSource(JdbcProperties prop) {
            return new DruidDataSource();
        }
    }
    1. 这种方式不再需要映射配置类JdbcConf，直接在对应Bean对象上使用 @ConfigurationProperties;
    2. DruidDataSource对象中有同名属性：driverClassName、url、username、password，从而实现映射;
</code></pre><h3 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h3><pre><code>1. ResourceProperties中定义了静态资源的查找方向
    classpath:/META-INF/resources/ --&gt;classpath:/resources/ --&gt;classpath:/static/ --&gt;classpath:/public/
2. 注意：classpath 指的就是 src/main/resources 目录，这4个目录都在 src/main/resources 目录下;
3. 这些静态资源目录不受Controller管控，可以直接被访问，用于放入图片、CSS、JS、HTML等静态资源;
4. 创建 resources/static/index.html，访问：localhost:8080/index.html
5. 在配置文件 application.yml 中，可以加入自定义的静态资源目录：
    spring:
        resources:
            static-locations:
                - classpath:/META-INF/resources/
                - classpath:/resources/
                - classpath:/static/
                - classpath:/public/
                - classpath:/abc/
</code></pre><h2 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h2><pre><code>1. 添加起步依赖
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
    &lt;/dependency&gt;
2. IDEA默认不支持热部署，需要设置
    1. Settings --&gt; Compiler --&gt; 勾选 Build project automatically
    2. Ctrl+Shift+Alt+/ --&gt; Registry --&gt; 勾选 compiler.automake.allow.when.app.running
3. 每次修改了Controller层之后，等待服务器重启，刷新浏览器页面;
4. 在配置文件 application.properties  中，配置不被热部署的文件
    spring.devtools.restart.exclude=static/**, application.properties
5. 通过触发器，手动控制热部署
    1. 创建 resources/trigger.txt，添加内容 verion=1
    2. 配置触发器
        spring.devtools.restart.trigger-file=trigger.txt
    3. 需要热部署时，修改触发器：version=2，保存文件即触发热加载部署;
</code></pre><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><pre><code>1. SpringBoot项目中，使用 MultipartFile 对象接收上传的文件时，控制文件的大小;
    1. 在启动类中注册 MultipartConfigElement，设置文件大小
    @Bean
    public MultipartConfigElement getMultipartConfigElement() {
        MultipartConfigFactory factory = new MultipartConfigElement();
        factory.setMaxFileSize(&quot;10240KB&quot;);  //单个文件最大10240KB
        factory.setMaxRequestSize(&quot;102400KB&quot;);  //总上传数据最大102400KB
        return factory.createMultipartConfig();
    }
2. 文件服务器：fastdfs，阿里云oss，nginx搭建一个简单的文件服务器;
3. 上传过程操作的是磁盘的绝对路径，打成了jar包之后，无法直接访问磁盘目录，需要把目录加入静态资源目录列表中;
    images-path=D:\report\
    spring.resources.static-locations=classpath:/META-INF/resources/, ... , file:${images-path}
</code></pre><h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><pre><code>1. 主流的JavaWeb模板引擎：JSP、Velocity、Freemarker、Thymeleaf
    1. JSP：动态网页技术，JavaWeb官方推荐，支持EL、JSTL表达式，本质上也是一个Servlet，占用JVM内存;
    2. Freemarker：文件一般保存为 xxx.ftl，严格依赖MVC模式，不依赖Servlet容器(不占用JVM内存)，内建函数;
    3. Thymeleaf：SpringBoot主推，轻量级模板引擎，后缀名就是.html，浏览器可以直接访问;
2. Thymeleaf不推荐在页面中做复杂的逻辑业务，因为解析DOM/XML会占用较大的内存;
3. Thymeleaf的启动器：spring-boot-starter-thymeleaf
    spring.thymeleaf.cache=false #是否缓存
    spring.thymeleaf.mode=HTML5
    spring.thymeleaf.encoding=UTF-8  #编码
    spring.thymeleaf.content-type=text/html  #类型
    spring.thymeleaf.suffix=.html  #文件后缀名
    spring.thymeleaf.prefix=classpath:/templates/  #前缀：存放路径
4. 创建 resources/templates/user/info.html
        @GetMapping(&quot;info&quot;)
        public String info() {
            return &quot;user/info&quot;;  ---&gt;渲染resources/templates/user/info.html
        }
5. resources/templates 目录不是静态资源目录，需要放在静态资源列表中才能直接访问
    spring.resources.static-locations = classpath:/META-INF/resources/, ... ,classpath:/templates/
6. 页面静态化
    1. Thymeleaf不仅可以把渲染结果写入Response，还可以写到本地文件中，从而实现页面静态化;
    2. 页面静态化：把动态渲染的HTML页面变成静态内容保存，比如部署在Nginx中;
    3. 以后的用户请求到来时，直接访问静态页面，不再经过服务的渲染，从而大大提高并发能力，减小Tomcat的压力.
</code></pre><h2 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h2><pre><code>1. 多环境：开发环境、测试环境、预发布环境、生产环境...  不同环境使用不同的配置，如数据库配置;
2. 多环境切换有很多方式，以 spring.profiles.active 为例
    1. 创建 resources/config 目录，管理SpringBoot的配置文件，注意：config目录名是固定的;
    2. 在 config 中创建 application.properties、application-dev.properties、application-test.properties
    3. application-dev.properties
        db.url=dev.com
    4. application-test.properties
        db.url=test.com
    5. application.properties
        db=local.com
        # 指定使用哪个profile，如果不指定，默认使用当前文件中的配置
        spring.profiles.active=test  # 使用 application-test 中的配置 db.url=test.com
3. 映射到Spring IoC容器中的Java类属性上
    @Value(&quot;${db.url}&quot;)
    private String url;  //test.com
</code></pre><h2 id="打包与容器"><a href="#打包与容器" class="headerlink" title="打包与容器"></a>打包与容器</h2><pre><code>1. SpringBoot项目打成jar包
    1. pom.xml 配置Maven插件
    &lt;packaging&gt;jar&lt;/packaging&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
    2. 打开右侧Maven面板 --&gt; Lifecycle --&gt; 双击执行 install --&gt; 在target目录下生成xxx.jar
    3. 如果没有添加插件，执行 java -jar xxx.jar 命令运行jar包时，会报错：no main manifest attribute
2. SpringBoot项目打成war包
    1. 修改打包方式：&lt;packaging&gt;war&lt;/packaging&gt;
    2. 配置打包的项目名称，也就是项目的虚拟目录名
        &lt;build&gt;
            &lt;finalName&gt;boottest&lt;/finalName&gt;
            &lt;plugins&gt;
                &lt;plugin&gt;
                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
                &lt;/plugin&gt;
            &lt;/plugins&gt;
        &lt;/build&gt;
    3. 修改启动类
    @SpringBootApplication
    public class BootTestApplication extends SpringBootServletInitializer {
        protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
            return builder.sources(BootTestApplication.class);
        }
        public static void main(String[] args) {
            SpringApplication.run(BootTestApplication.class, args);
        }
    }
    4. 执行Lifecycle --&gt; clean，然后执行 install 命令，在target目录下生成 xxx.war
    5. 把 xxx.war 放在 Tomcat/webapps 目录中，启动Tomcat服务器，xxx.war自动解压;
    6. 访问：http://localhost:8080/boottest/xxx
3. SpringBoot默认使用Tomcat容器启动，也可以配置成其他容器
    1. 去除spring-boot-starter-web中集成的Tomcat
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
    2. 配置为jetty容器
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;
        &lt;/dependency&gt;
    3. 配置为undertow容器
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.undertow&lt;/groupId&gt;
            &lt;artifactId&gt;undertow.core&lt;/artifactId&gt;
            &lt;version&gt;1.3.24.Final&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.undertow&lt;/groupId&gt;
            &lt;artifactId&gt;undertow.servlet&lt;/artifactId&gt;
            &lt;version&gt;1.3.24.Final&lt;/version&gt;
        &lt;/dependency&gt;
4. 使用JMeter测试各个容器的性能;
</code></pre><h3 id="部署到阿里云"><a href="#部署到阿里云" class="headerlink" title="部署到阿里云"></a>部署到阿里云</h3><pre><code>1. winscp、secureCRT、FileZilla：远程连接Linux的工具，可视化操作
2. 在Linux上安装JDK
    1. cd /usr/local/  --&gt; mkdir software --&gt; 下载JDK8压缩包、解压、重命名为jdk8
    2. 配置环境变量：vim /etc/profile，在尾部插入以下内容
    export JAVA_HOME=/usr/local/software/jdk8
    export PATH=$PATH:$JAVA_HOME/bin
    export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
    export JAVA_HOME PATH CLASSPATH
    3. 让配置立刻生效：source /etc/profile
    4. 测试：java -version
3. 入门级：把SpringBoot项目部署到Linux云服务器上，要开放对应的端口号;
    1. 去除对生产环境没用的依赖，如热部署spring-boot-starter-test，测试spring-boot-starter-test
    2. 打成jar包，并上传到Linux服务器上 /usr/local/software/app/
    3. 启动：java -jar xxx.jar
4. 守护进程的方式启动：nohup java -jar xxx.jar &amp;   ---&gt; 生成启动日志文件nohup.out
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/03/26/模块化与私服/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/26/模块化与私服/" itemprop="url">模块化与私服</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-26T00:00:00+08:00">
                2016-03-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="拆分与聚合"><a href="#拆分与聚合" class="headerlink" title="拆分与聚合"></a>拆分与聚合</h2><pre><code>1. 拆分：把一个完整的Maven工程拆成独立的模块，如Dao模块、Service模块、Controller(Web)模块、Utils模块;
2. 模块之间的关系：
    1. 模块之间是平级的，需要建立依赖关系，才能引用对方的功能;
    2. Service模块引用Dao模块的坐标，Controller模块引用Service模块的坐标;
    3. 如果想引用另一个Maven工程，则需要把工程打包发布到本地仓库中，再其坐标即可建立依赖关系;
3. 父工程：New Project --&gt; 不使用Maven骨架，只需保留一个pom.xml，其他的文件和目录都可以删除掉;
    1. 把公共的jar包依赖放在父工程中，供所有的子工程使用;
    2. 在 pom.xml 中配置JDK的编译版本，Tomcat7插件;
    3. 打包方式：pom
        &lt;packaging&gt;pom&lt;/packaging&gt;
    4. &lt;dependencyManagement&gt; 管理的依赖和插件不会传递给子工程，但能够统一管理它们的版本号
        &lt;properties&gt;
            &lt;mysql.version&gt;8.0.16&lt;/mysql.version&gt;
        &lt;/properties&gt;
        &lt;dependencyManagement&gt;
            &lt;dependencies&gt;
                &lt;dependency&gt;
                    &lt;groupId&gt;mysql&lt;/groupId&gt;
                    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
                    &lt;version&gt;${mysql.version}&lt;/version&gt;
                &lt;/dependency&gt;
            &lt;/dependencies&gt;
        &lt;/dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;!-- 这些依赖会直接传递给子工程 --&gt;
        &lt;/dependencies&gt;
    5. 在子工程中引入依赖 mysql-connector-java 时，无需再指定版本节点&lt;version&gt;
4. 子工程：右击父工程 --&gt; New Module --&gt; 创建Maven项目
    1. Dao模块和Service模块都不使用骨架，Web模块使用web骨架;
    2. 子工程的 pom.xml 中，会有一个 &lt;parent&gt;，表示继承的父工程;
    3. 父工程的 pom.xml 中，会多出一个 &lt;modules&gt;，列出拥有的子模块;
    4. 依赖包的作用域(scope)默认是compile，父工程的依赖包传递给子工程的过程中，scope为test的依赖可能丢失;
    5. 比如父工程引入了junit(test)，子工程可能无法使用，这种情况下，通常会在子工程中再加入junit依赖即可;
5. Dao模块：resources/spring/applicationContext-dao.xml，只配置Dao层相关
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;
            http://www.springframework.org/schema/beans
            https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

        &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
            &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
            &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;cn.ssm.domain&quot; /&gt;
        &lt;/bean&gt;

        &lt;bean id=&quot;mapperScanner&quot; class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
            &lt;property name=&quot;basePackage&quot; value=&quot;cn.ssm.dao&quot; /&gt;
        &lt;/bean&gt;

        &lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt;
        &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
            &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot; /&gt;
            &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot; /&gt;
            &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot; /&gt;
            &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;
        &lt;/bean&gt;
    &lt;/beans&gt;
6. Service模块
    1. resources/spring/applicationContext-service.xml，只配置Service层相关
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
        xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;
            http://www.springframework.org/schema/beans
            https://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            https://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/tx
            https://www.springframework.org/schema/tx/spring-tx.xsd
            http://www.springframework.org/schema/aop
            https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

        &lt;context:component-scan base-package=&quot;cn.ssm.service&quot; /&gt;
        &lt;bean id=&quot;manager&quot; 
                class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
            &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
        &lt;/bean&gt;
        &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;manager&quot;&gt;
            &lt;tx:attributes&gt;
                &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt;
                &lt;tx:method name=&quot;*&quot; isolation=&quot;DEFAULT&quot; /&gt;
            &lt;/tx:attributes&gt;
        &lt;/tx:advice&gt;
        &lt;aop:config&gt;
            &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* cn.ssm.service.impl.*.*(..))&quot; /&gt;
        &lt;/aop:config&gt;
    &lt;/beans&gt;
    2. pom.xml：引入Dao模块的坐标
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;cn.ssm&lt;/groupId&gt;
                &lt;artifactId&gt;ssmdao&lt;/artifactId&gt;
                &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
7. Web模块
    1. springmvc.xml、web.xml 都和未拆分前相同;
    2. Spring的配置文件：resources/applicationContext.xml，把Dao和Service的部分合并到一起;
        &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
        &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
            xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
            xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
            &lt;!-- 导入Dao部分和Service部分的Spring配置文件 --&gt;
            &lt;import resource=&quot;classpath:spring/applicationContext-dao.xml&quot;/&gt;
            &lt;import resource=&quot;classpath:spring/applicationContext-service.xml&quot;/&gt;
        &lt;/beans&gt;
    3. pom.xml：引入Service模块的坐标
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;cn.ssm&lt;/groupId&gt;
                &lt;artifactId&gt;ssmservice&lt;/artifactId&gt;
                &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    4. 删除 pom.xml 中默认生成的JDK版本相关的&lt;properties&gt;，使用父工程中配置的JDK版本;
    5. 默认也生成了的&lt;build&gt;，也可以删除，父工程中已经配置了Tomcat7插件;
</code></pre><h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><pre><code>1. log4j.properties 放在 Web模块/resources 目录中，启动项目;
2. 方式一：打开右侧的Maven面板 --&gt; 展开父工程的Plugins --&gt; 双击 tomcat7:run 启动;
3. 配置本地的Tomcat，启动服务器，运行项目;
4. 方式三：选择 Web 工程的 tomcat7:run
    1. Maven项目在运行时会扫描 pom.xml，如果本地仓库没有引入的依赖，则从中央仓库下载，再找不到就报错;
    2. Web工程中引入了Service工程的坐标，但Service工程是本地项目，并没有发布到本地仓库，所以运行失败;
    3. 因此要把Service工程发布到本地仓库，但Service工程又引入了Dao工程的坐标，所以只能去发布父工程;
    4. 在右侧的Maven面板上，双击父工程的Lifecycle -&gt; install，等待安装成功;
    5. 启动Web工程的 tomcat7:run，运行项目;
</code></pre><h2 id="私服"><a href="#私服" class="headerlink" title="私服"></a>私服</h2><h3 id="搭建私服-windows"><a href="#搭建私服-windows" class="headerlink" title="搭建私服(windows)"></a>搭建私服(windows)</h3><pre><code>1. 使用专门的Maven仓库管理软件来搭建私服，比如：Apache Archiva，Artifactory，Sonatype Nexus
2. 选择Sonatype Nexus，下载开源版的Nexus压缩包，解压后有两个目录：应用程序目录，私服仓库目录(sonatype-work);
3. 以管理员模式启动cmd窗口，进入应用程序目录，执行bin目录下的 nexus.bat 命令;
    1. 安装、卸载、运行：nexus.bat install，nexus.bat uninstall，nexus.bat start
    2. 查看启动后的服务：右击计算机 -&gt; 管理 -&gt; 服务和应用程序 -&gt; 服务，在列表中查找 nexus;
4. nuxus的全局配置文件：conf/nexus.properties，默认使用的端口号是8081;
5. 启动图形化界面时，确保8081端口未被占用：http://localhost:8081/nexus
    1. 默认用户名和密码：admin，admin123
    2. 左侧导航栏：点击Repositories --&gt; 浏览仓库，查看仓库信息、地址;
    3. Add添加仓库，选择仓库类型：Hosted、Proxy、Virtual，还可以创建仓库组;
6. 创建不同的仓库，管理不同的依赖包
    1. 存放测试包的仓库Snapshots(hosted)，发布包的仓库Releases(hosted);
    2. 第三方包的仓库3rd party(hosted)，中央仓库的代理仓库Central(proxy);
    3. 创建仓库组，把已有的仓库按顺序添加到组中，在本地仓库在私服中查找依赖包时，就能按照仓库的顺序查找，
    最后由代理仓库转到中央仓库中去查找;
</code></pre><h3 id="发布私服"><a href="#发布私服" class="headerlink" title="发布私服"></a>发布私服</h3><pre><code>1. Maven的 settings.xml，配置私服仓库的信息
    &lt;servers&gt;
        &lt;server&gt;
            &lt;id&gt;releases&lt;/id&gt;  ===&gt;指定私服仓库的ID
            &lt;username&gt;admin&lt;/username&gt;  ===&gt;私服的用户名密码
            &lt;password&gt;admin123&lt;/password&gt;
        &lt;/server&gt;
        &lt;server&gt;
            &lt;id&gt;snapshots&lt;/id&gt;  ===&gt;指定私服仓库的ID
            &lt;username&gt;admin&lt;/username&gt;
            &lt;password&gt;admin123&lt;/password&gt;
        &lt;/server&gt;
    &lt;/servers&gt;
2. 要发布哪个项目/模块，就配置它的 pom.xml
    &lt;distributionManagement&gt;
        &lt;!-- 配置发布的仓库ID和地址 --&gt;
        &lt;repository&gt;  ===&gt;正式版的配置，明确发布到存放正式包的仓库
            &lt;id&gt;releases&lt;/id&gt;  ===&gt;此ID必须在 settings.xml 中已经配置过了
            &lt;url&gt;http://localhost:8081/nexus/content/repositories/releases/&lt;/url&gt;
        &lt;/repository&gt;
        &lt;snapshotRepository&gt;
            &lt;id&gt;snapshots&lt;/id&gt;  ===&gt;测试版的配置，明确发布到存放测试包的仓库
            &lt;url&gt;http://localhost:8081/nexus/content/repositories/snapshots/&lt;/url&gt;
        &lt;/snapshotRepository&gt;
    &lt;/distributionManagement&gt;
    1. 执行Lifecycle --&gt; deploy
    2. 执行前面的生命周期时，其后面的生命周期也会执行，所以 install 命令的执行，会把项目/模块安装到本地仓库;
</code></pre><h3 id="从私服下载jar"><a href="#从私服下载jar" class="headerlink" title="从私服下载jar"></a>从私服下载jar</h3><pre><code>Maven的 settings.xml
    &lt;profiles&gt;
        &lt;profile&gt; 
            &lt;id&gt;dev&lt;/id&gt;  ===&gt;profile的id
            &lt;repositories&gt;
                &lt;repository&gt;  ==&gt;仓库id，repositories可以配置多个仓库，保证id不重复
                    &lt;id&gt;nexus&lt;/id&gt;  ==&gt;仓库地址，即nexus仓库组的地址
                    &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt;
                    &lt;releases&gt;
                        &lt;enabled&gt;true&lt;/enabled&gt; ==&gt;是否下载releases构件
                    &lt;/releases&gt;
                    &lt;snapshots&gt;
                        &lt;enabled&gt;true&lt;/enabled&gt;  ==&gt;是否下载snapshots构件
                    &lt;/snapshots&gt;
                &lt;/repository&gt;
            &lt;/repositories&gt;
            &lt;pluginRepositories&gt;  ==&gt;插件仓库，Maven的运行依赖插件，也需要从私服下载插件
                &lt;pluginRepository&gt; ==&gt;插件仓库的id不允许重复，否则后者会覆盖前者
                    &lt;id&gt;public&lt;/id&gt;  ==&gt;配置为仓库组，仓库组的id
                    &lt;name&gt;Public Repositories&lt;/name&gt;  ==&gt;仓库组的名字
                    &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt;  ==&gt;仓库组的地址
                &lt;/pluginRepository&gt;
            &lt;/pluginRepositories&gt;
        &lt;/profile&gt;
    &lt;/profiles&gt;
    &lt;activeProfiles&gt;
        &lt;activeProfile&gt;dev&lt;/activeProfile&gt;  ==&gt;激活id=dev的profile
    &lt;/activeProfiles&gt;
</code></pre><h3 id="按照第三方jar包"><a href="#按照第三方jar包" class="headerlink" title="按照第三方jar包"></a>按照第三方jar包</h3><pre><code>1. 把第三方jar包安装到本地仓库，如fastjson.jar
    1. 查看fastjson.jar的坐标：groupId、artifactId、version;
    2. 进入fastjson.jar所在的目录，执行命令:
    mvn install:install-file -DgroupId=com.alibaba -DartifactId=fastjson -Dversion=1.1.37 
    -Dfile=fastjson-1.1.37.jar -Dpackaging=jar
    3. 如果不在fastjson.jar的目录，则需要指定绝对路径： -Dfile=D:\download\fastjson-1.1.37.jar
2. 把第三方jar包安装到私服
    1. 在Maven的 settings.xml 中，添加存放第三方jar包的仓库信息
        &lt;server&gt;
            &lt;id&gt;thirdparty&lt;/id&gt;
            &lt;username&gt;admin&lt;/username&gt;
            &lt;password&gt;admin123&lt;/password&gt;
        &lt;/server&gt;
    2. 进入jar所在目录
        mvn deploy:deploy-file -DgroupId=com.alibaba -DartifactId=fastjson -Dversion=1.1.37 
        -Dfile=fastjson-1.1.37.jar -Dpackaging=jar  -DrepositoryId=thirdparty 
        -Durl=http://localhost:8081/nexus/content/repositories/thirdparty/
        1. -Durl：私服的仓库地址;
        2. -DrepositoryId：私服的仓库ID;
    3. 如果不在jar包所在目录，-Dfile=jar包的绝对路径;
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/03/25/SSM整合/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/25/SSM整合/" itemprop="url">SSM整合</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-25T00:00:00+08:00">
                2016-03-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><pre><code>1. 表现层SpringMVC，业务层Spring，持久层MyBatis，整合方向就是用Spring框架去整合另外两个框架;
2. 使用Maven的Web骨架，创建一个Web项目;
3. pom.xml
    1. 配置JDK的运行编译版本，以及jar包的版本锁定
        &lt;properties&gt;
            &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
            &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
            &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
            &lt;spring.version&gt;5.1.6.RELEASE&lt;/spring.version&gt;
        &lt;/properties&gt;
    2. 配置Tomcat7插件
        &lt;build&gt;
            &lt;plugins&gt;
                &lt;plugin&gt;
                    &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;
                    &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;
                    &lt;version&gt;2.2&lt;/version&gt;
                &lt;/plugin&gt;
            &lt;/plugins&gt;
        &lt;/build&gt;
4. 相关依赖
    1. aspectjweaver、spring-aop、spring-context、spring-context-support、spring-web
    2. spring-orm、spring-beans、spring-core、spring-webmvc、spring-tx、spring-test(test)
    3. junit(test)、mysql-connector-jave、servlet-api(provided)、jsp-api(provided)、jstl
    4. log4j、slf4j-api、slf4j-log4j12、jackson-databind、jackson-core、jackson-annotations
    5. mybatis、mybatis-spring、c3p0(type:jar，scope:compile)、druid(两套连接池，根据需要选择)
    6. spring-security-web、spring-security-config、spring-security-core、spring-security-taglibs
5. 基本结构
    1. 实体类：cn.ssm.domain.User
        public class User implements Serializable {
            private Integer id;
            private String name;
            private Double money;
            ...... //setter、getter
        }
    2. Dao层：cn.ssm.dao.IUserDao
        public interface IUserDao {
            List&lt;User&gt; findAll();
            User findById(Integer id);
        }
    3. Service层：
        cn.ssm.service.IUserService
        cn.ssm.service.impl.UserServiceImpl
    4. Controller层：cn.ssm.controller.UserController
6. 配置文件(resources目录)
    1. Spring：applicationContext.xml
    2. SpringMVC：springmvc.xml
    3. 数据库配置信息：db.properties
        jdbc.driver=com.mysql.cj.jdbc.Driver
        jdbc.url=jdbc:mysql:///db_mybatis?serverTimezone=Asia/Shanghai
        jdbc.username=root
        jdbc.password=123456
</code></pre><h2 id="Spring整合MyBatis"><a href="#Spring整合MyBatis" class="headerlink" title="Spring整合MyBatis"></a>Spring整合MyBatis</h2><pre><code>1. 借助 mybatis-spring 包中的对象，把Mybatis的相关配置转移到Spring的配置文件中;
    1. SqlSessionFactoryBean: SqlSessionFactory的工厂对象;
        1. dataSource属性: 配置连接池;
        2. typeAliasesPackage属性: 扫描实体类(POJO)的所在包，为POJO配置别名;
    2. MapperScannerConfigurer: 扫描Dao层的包，为所有Dao接口提供代理对象;
2. Spring的配置文件：applicationContext.xml
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
        xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;
            http://www.springframework.org/schema/beans
            https://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            https://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/tx
            https://www.springframework.org/schema/tx/spring-tx.xsd
            http://www.springframework.org/schema/aop
            https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
        &lt;!-- Dao层使用映射配置文件的方式，那么只扫描service包 --&gt;
        &lt;context:component-scan base-package=&quot;cn.ssm.service&quot; /&gt;
        &lt;!-- SqlSessionFactory的工厂对象 --&gt;
        &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
            &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
            &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;cn.ssm.domain&quot; /&gt;
        &lt;/bean&gt;
        &lt;!-- 为所有Dao接口提供代理对象 --&gt;
        &lt;bean id=&quot;mapperScanner&quot; class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
            &lt;property name=&quot;basePackage&quot; value=&quot;cn.ssm.dao&quot; /&gt;
        &lt;/bean&gt;
        &lt;!-- 事务管理器 --&gt;
        &lt;bean id=&quot;manager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
            &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
        &lt;/bean&gt;
        &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;manager&quot;&gt;
            &lt;tx:attributes&gt;
                &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt;
                &lt;tx:method name=&quot;*&quot; isolation=&quot;DEFAULT&quot; /&gt;
            &lt;/tx:attributes&gt;
        &lt;/tx:advice&gt;
        &lt;aop:config&gt;
            &lt;!--切入点表达式--&gt;
            &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* cn.ssm.service.impl.*.*(..))&quot; /&gt;
        &lt;/aop:config&gt;
        &lt;!-- c3p0连接池：引入数据库配置信息的文件db.properties --&gt;
        &lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt;
        &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
            &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot; /&gt;
            &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot; /&gt;
            &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot; /&gt;
            &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;
        &lt;/bean&gt;
    &lt;/beans&gt;
3. Dao的映射配置文件
    1. 文件路径和名称与Dao接口保持一致，如cn.ssm.dao.IUserDao -&gt; resources/cn/ssm/dao/IUserDao.xml;
    2. IUserDao.xml
        &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
        &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
                &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
        &lt;mapper namespace=&quot;cn.ssm.dao.IUserDao&quot;&gt;
            &lt;select id=&quot;findAll&quot; resultType=&quot;user&quot;&gt;
                select * from users
            &lt;/select&gt;
            &lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt;
                select * from users where id=#{id}
            &lt;/select&gt;
        &lt;/mapper&gt;
4. Dao层使用注解开发
    1. Spring配置文件中，配置注解扫描包(扫描service包和dao包)，有两种方式
        1. 直接配置要扫描的包
        &lt;context:component-scan base-package=&quot;cn.ssm.dao&quot; /&gt;
        &lt;context:component-scan base-package=&quot;cn.ssm.service&quot; /&gt;
        2. 扫描指定包下的注解时，忽略 @Controller 注解
    &lt;context:component-scan base-package=&quot;cn.ssm&quot;&gt;
        &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;
    &lt;/context:component-scan&gt;
    2. SQL语句的注解
        public interface IUserDao {
            @Select(&quot;select * from users&quot;)
            List&lt;User&gt; findAll();

            @Select(&quot;select * from users where id=#{id}&quot;)
            User findById(Integer id);
        }
5. Service层使用注解开发，注入Dao对象
    @Service(&quot;userService&quot;)
    public class UserServiceImpl implements IUserService {
        @Autowired
        private IUserDao dao;

        public List&lt;User&gt; findAll() {
            return dao.findAll();
        }
    }
6. 测试
    @RunWith(SpringJUnit4ClassRunner.class)
    @ContextConfiguration(locations=&quot;classpath:applicationContext.xml&quot;)
    public class TestService {
        @Autowired
        private IUserService service;

        @Test
        public void testFindAll() {
            List&lt;User&gt; users = service.findAll();
        }
    }
</code></pre><h2 id="Spring整合SpringMVC"><a href="#Spring整合SpringMVC" class="headerlink" title="Spring整合SpringMVC"></a>Spring整合SpringMVC</h2><pre><code>1. SpringMVC的配置文件：resources/springmvc.xml
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;
            http://www.springframework.org/schema/beans
            https://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/mvc
            https://www.springframework.org/schema/mvc/spring-mvc.xsd
            http://www.springframework.org/schema/context
            https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
        &lt;!-- 开启注解扫描，只扫描controller包 --&gt;
        &lt;context:component-scan base-package=&quot;cn.ssm.controller&quot; /&gt;
        &lt;!--视图解析器--&gt;
        &lt;bean id=&quot;internalResourceViewResolver&quot; 
                class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
            &lt;property name=&quot;prefix&quot; value=&quot;/pages/&quot; /&gt;
            &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
        &lt;/bean&gt;
        &lt;!--处理静态资源--&gt;
        &lt;mvc:default-servlet-handler /&gt;
        &lt;!-- 开启SpringMVC的注解支持，并注册处理器映射器和处理器适配器 --&gt;
        &lt;mvc:annotation-driven /&gt;
    &lt;/beans&gt;
2. 开启注解扫描的两种方式
    1. 直接配置要扫描的包;
    2. 配置扫描的注解类型，只去扫描 @Controller 注解;
    &lt;context:component-scan base-package=&quot;cn.ssm&quot;&gt;
        &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;
    &lt;/context:component-scan&gt;
3. 在 webapp 目录中，分别创建存放JSP页面的 pages 目录，存放静态资源的 css、images、js 目录;
4. web.xml
    &lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee
            http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;
        version=&quot;3.0&quot;&gt;
        &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;
        &lt;!--配置Spring的核心监听器，重新指定Spring配置文件的路径，加载Spring的配置文件--&gt;
        &lt;listener&gt;
            &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
        &lt;/listener&gt;
        &lt;context-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/context-param&gt;
        &lt;!--编码过滤器，解决中文乱码--&gt;
        &lt;filter&gt;
            &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
            &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
            &lt;init-param&gt;
                &lt;param-name&gt;encoding&lt;/param-name&gt;
                &lt;param-value&gt;UTF-8&lt;/param-value&gt;
            &lt;/init-param&gt;
        &lt;/filter&gt;
        &lt;filter-mapping&gt;
            &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
            &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
        &lt;/filter-mapping&gt;
        &lt;!--前端控制器：SpringMVC的核心Servlet，在服务器启动时就创建并初始化，加载SpringMVC的配置文件--&gt;
        &lt;servlet&gt;
            &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
            &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
            &lt;init-param&gt;
                &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
                &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;
            &lt;/init-param&gt;
            &lt;!-- 在服务器启动时，就创建并初始化核心Servlet --&gt;
            &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
        &lt;/servlet&gt;
        &lt;servlet-mapping&gt;
            &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
            &lt;url-pattern&gt;/&lt;/url-pattern&gt;
        &lt;/servlet-mapping&gt;
    &lt;/web-app&gt;
5. Controller层
    @Controller
    @RequestMapping(&quot;/hello&quot;)
    public class HelloController {
        @Autowired
        private IUserService service;  //注入Service对象

        @RequestMapping(&quot;/test&quot;)
        @ResponseBody
        public String testHello() {
            List&lt;User&gt; users = service.findUserAll();
            return users;
        }
    }
6. 运行项目
    1. 右侧Maven面板 --&gt; 展开项目/Plugins/tomcat7 --&gt; 双击 tomcat7:run 运行项目;
    2. 配置本地的Tomcat，添加项目，启动Tomcat;
7. 如果使用了log4j，还需要把 log4j.properties 放在 resources 目录中
    # Set root category priority to INFO and its only appender to CONSOLE.
    #log4j.rootCategory=INFO, CONSOLE            debug   info   warn error fatal
    log4j.rootCategory=debug, CONSOLE, LOGFILE
    # Set the enterprise logger category to FATAL and its only appender to CONSOLE.
    log4j.logger.org.apache.axis.enterprise=FATAL, CONSOLE
    # CONSOLE is set to be a ConsoleAppender using a PatternLayout.
    log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender
    log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout
    log4j.appender.CONSOLE.layout.ConversionPattern=%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\n
    # LOGFILE is set to be a File appender using a PatternLayout.
    log4j.appender.LOGFILE=org.apache.log4j.FileAppender
    log4j.appender.LOGFILE.File=d:\axis.log
    log4j.appender.LOGFILE.Append=true
    log4j.appender.LOGFILE.layout=org.apache.log4j.PatternLayout
    log4j.appender.LOGFILE.layout.ConversionPattern=%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\n
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/03/16/SpringMVC进阶/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/16/SpringMVC进阶/" itemprop="url">SpringMVC进阶</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-16T00:00:00+08:00">
                2016-03-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="控制器方法的返回值"><a href="#控制器方法的返回值" class="headerlink" title="控制器方法的返回值"></a>控制器方法的返回值</h2><pre><code>1. resources/springmvc.xml：配置的视图解析器
    &lt;bean id=&quot;internalResourceViewResolver&quot; 
        class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/pages/&quot; /&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;
2. String
    @RequestMapping(&quot;/test&quot;)
    public String testStr(Model model) {
        User user = new User();  user.setName(&quot;JavaEE&quot;);  user.setAge(20);
        model.addAttribute(&quot;user&quot;, user);
        return &quot;test&quot;;
    }
    1. 返回的字符串默认作为逻辑视图名，通过视图解析器解析为物理视图的真实地址;
    2. 物理视图的真实地址：webapp/pages/test.jsp，渲染页面并响应给客户端;
    3. Model默认把数据存入Request域中，在 test.jsp 中获取这些数据;
        &lt;div&gt;${user.name}&lt;/div&gt; &lt;div&gt;${user.age}&lt;/div&gt;
3. void
    1. 控制器方法没有返回值时，默认以URL的最后一级作为视图名去查找JSP文件;
    2. 使用Servlet API手动转发/重定向时，SpringMVC的视图解析器不会再介入，所以要声明完整的路径名;
    @RequestMapping(path=&quot;/hello&quot;)
    public void test(HttpServletRequest req, HttpServletResponse res) {
        //手动转发到test.jsp
        req.getRequestDispatcher(&quot;/pages/test.jsp&quot;).forward(req, res);
        //手动重定向到index.jsp
        req.sendRedirect(req.getContextPath() + &quot;/index.jsp&quot;);
    }
4. 响应流数据
    @RequestMapping(path=&quot;/hello&quot;)
    public void test(HttpServletRequest req, HttpServletResponse res) {
        res.setCharacterEncoding(&quot;UTF-8&quot;);
        res.setContentType(&quot;text/html;charset=UTF-8&quot;);
        res.getWriter().print(&quot;你好，Java&quot;);
    }
5. ModelAndView
    1. SpringMVC提供的对象，用于封装Model和视图名;
        @RequestMapping(path=&quot;/hello&quot;)
        public ModelAndView test() {
            ModelAndView mv = new ModelAndView();
            User user = new User();  user.setName(&quot;JavaEE&quot;);  user.setAge(20);
            mv.addObject(&quot;user&quot;, user);  //存入数据
            mv.setViewName(&quot;test&quot;);  //指定视图名
            return mv;
        }
    2. 控制器方法返回字符串时，底层其实也是用 ModelAndView 进行封装.
6. 请求转发和重定向的关键字
    1. 控制器方法在返回字符串时，默认使用的就是请求转发;
    2. 转发的关键字：forward;  重定向的关键字：redirect;
        @RequestMapping(path=&quot;/hello&quot;)
        public String test() {
            return &quot;forward:/pages/test.jsp&quot;;  //转发到test.jsp
            return &quot;redirect:/index.jsp&quot;;  //重定向到index.jsp
        }
</code></pre><h3 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h3><pre><code>1. 控制器方法的返回值默认会解析为跳转路径，@ResponseBody修饰之后，返回值不会再交给视图解析器，
   而是被直接写入响应体中;
    @RequestMapping(&quot;/test&quot;)
    @ResponseBody
    public String test() {
        return &quot;Hello SpringBoot&quot;;  //返回的字符串直接响应给客户端
    }
2. 控制器方法返回对象时，通过 HttpMessageConverter 接口转为指定格式的数据，如JSON、XML;
3. SpringMVC默认使用MappingJacksonHttpMessageConverter对JSON数据进行转换;
4. 引入转换格式的依赖包jackson
    jackson-databind、jackson-core、jackson-annotations
5. 在JSP页面发送一个AJAX请求，参数为JSON格式
    public class User {
        private String username;  private String password;
        ......//setter、getter
    }
    $.ajax({
        url: &quot;user/getList&quot;,
        type: &quot;post&quot;,
        dataType: &quot;json&quot;,
        data: &apos;{&quot;username&quot;: &quot;Jack&quot;, &quot;password&quot;: &quot;123&quot;}&apos;,
        success: data=&gt;{ ... }
    });
    @RequestMapping(path=&quot;/getList&quot;)
    public @ResponseBody User test(@RequestBody User user) {
        String username = user.getUsername();
        String password = user.getPassword();
        ... //操作数据库
        User u = new User();
        ......  //封装一个新的User对象并返回
        return u;
    }
    1. @RequestBody：获取请求体的内容，SpringMVC会把JSON格式的请求体封装到User对象中;
    2. @ResponseBody：将返回的对象作为响应体，并转为JSON数据，响应给客户端.
</code></pre><h2 id="静态资源的处理"><a href="#静态资源的处理" class="headerlink" title="静态资源的处理"></a>静态资源的处理</h2><pre><code>1. 访问静态资源时，不需要经过前端控制器和过滤器，直接响应即可;
2. 使用Servlet来处理静态资源：web.xml 中配置名称为 default 的&lt;servlet&gt;标签;
    1. 处理 webapp/css 目录中的静态资源：以 /css/ 开头的URL;
        &lt;servlet-mapping&gt;
            &lt;servlet-name&gt;default&lt;/servlet-name&gt;
            &lt;url-pattern&gt;/css/*&lt;/url-pattern&gt;
        &lt;/servlet-mapping&gt;
    2. 处理后缀名为 .css、.js 的静态资源;
        &lt;servlet-mapping&gt;
            &lt;servlet-name&gt;default&lt;/servlet-name&gt;
            &lt;url-pattern&gt;*.css&lt;/url-pattern&gt;
        &lt;/servlet-mapping&gt;
        &lt;servlet-mapping&gt;
            &lt;servlet-name&gt;default&lt;/servlet-name&gt;
            &lt;url-pattern&gt;*.js&lt;/url-pattern&gt;
        &lt;/servlet-mapping&gt;
3. 在SpringMVC的配置文件springmvc.xml 中，使用 &lt;mvc:resources&gt; 标签配置静态资源的访问;
    &lt;mvc:annotation-driven /&gt;
    &lt;mvc:resources location=&quot;/css/&quot; mapping=&quot;/css/**&quot; /&gt;
    &lt;mvc:resources location=&quot;/images/&quot; mapping=&quot;/images/**&quot; /&gt;
    &lt;mvc:resources location=&quot;/js/&quot; mapping=&quot;/js/**&quot; /&gt;
    1. location属性：指定目录文件的路径，如 /css/ 表示 webapp/css 目录;
    2. mapping属性：匹配的请求路径，如 /css/** 表示匹配以 /css 开头的所有URL;
4. 更简便的配置方式
    &lt;mvc:default-servlet-handler /&gt;
    1. 它会在SpringMVC上下文中定义一个DefaultServletHttpRequestHandler，筛选URL;
    2. 如果发现静态资源，则交给名称为 default 的Servlet;
</code></pre><h3 id="SpringMVC的路径匹配模式"><a href="#SpringMVC的路径匹配模式" class="headerlink" title="SpringMVC的路径匹配模式"></a>SpringMVC的路径匹配模式</h3><pre><code>1. Spring MVC中的路径匹配模式，使用的是Apache Ant的样式路径，有三种通配符：?、*、**
    1. /*：拦截所有目录，不包含子目录;
    2. /**：拦截所有目录及其子目录.
2. ?：匹配任何单字符;
    1. /user/a?bc：能够匹配/user/axbc、/user/aXbc，但不包括/user/abc;
3. *：匹配 n&gt;=0 个字符，只能匹配一级目录，不能匹配子目录;
    1. /user/*：匹配 /user/、 /user/abc，但不能匹配 /user/abc/123;
    2. /app/*.jsp：匹配app目录下的所有 .jsp 文件.
4. **：匹配 n&gt;=0 个目录;
    1. /user/**：匹配以 /user 开头的所有URL;
    2. /**/example：匹配 /example、 /app/example、 /app/foo/example...
    3. /app/**/dir/file.：匹配 /app/dir/file.jsp、 /app/foo/dir/file.html ...
5. /**/*.jsp：匹配任何目录下的所有 .jsp 文件;
6. 所以，以 mvc 为命名空间的标签，在设置路径时，都遵循此路径匹配模式.
</code></pre><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><pre><code>1. 必要前提
    1. form表单的 enctype(表单请求正文的类型) 属性值为 multipart/form-data;
    2. method 必须是 POST;
    3. 提供一个文件选择域：&lt;input type=&quot;file&quot; /&gt;
2. 文件上传的依赖包：commons-fileupload、commons-io
    &lt;form action=&quot;user/fileupload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
        &lt;input type=&quot;file&quot; name=&quot;upload&quot; /&gt;
        &lt;input type=&quot;submit&quot; value=&quot;上传&quot; /&gt;
    &lt;/form&gt;
3. 传统上传方式
    @RequestMapping(path=&quot;/fileupload&quot;)
    public String uploadFile(HttpServletRequest req) {
        //获取上传目录的绝对路径
        String path = req.getSession().getServletContext().getRealPath(&quot;/uploads/&quot;);
        File file = new File(path);
        if(!file.exists()) {
            file.mkdirs();  //目录不存在则创建
        }
        DiskFileItemFactory factory = new DiskFileItemFactory();
        ServletFileUpload upload = new ServletFileUpload(factory);
        List&lt;FileItem&gt; items = upload.parseRequest(req);  //解析request
        for(FileItem item: items) {
            if(item.isFormField()) {
                //item只是一个普通的表单项
            } else {
                //item是一个上传文件项
                String filename = item.getName();  //获取文件名
                String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);
                filename = uuid + &quot;_&quot; + filename;  //不重复的文件名
                item.write(new File(path, filename));  //完成文件上传
                item.delete();  //删除生成的临时文件
            }
        }
        return &quot;success&quot;;
    }
</code></pre><h3 id="SpringMVC处理文件上传"><a href="#SpringMVC处理文件上传" class="headerlink" title="SpringMVC处理文件上传"></a>SpringMVC处理文件上传</h3><pre><code>1. 前端控制器接收到文件上传的请求时，会调用文件解析器，由文件解析器处理此请求;
2. 文件解析器会将处理结果封装到MultipartFile对象中，并将返回给前端控制器;
3. 前端控制器将上传文件对象MultipartFile，再传给对应的控制器方法;
4. 在配置文件 springmvc.xml 中配置文件解析器，其id值是固定的：multipartResolver
    &lt;bean id=&quot;multipartResolver&quot; 
        class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
        &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot; /&gt;  ==&gt;最大上传文件
    &lt;/bean&gt;
5. 上传标签的name属性值为upload，方法参数MultipartFile的变量名也必须为upload;
    @RequestMapping(path=&quot;/fileupload&quot;)
    public String uploadFile(HttpServletRequest req, MultipartFile upload) {
        //获取其他参数
        String xxx = req.getParameter(&quot;xxx&quot;);

        //获取上传目录的绝对路径
        String path = req.getSession().getServletContext().getRealPath(&quot;/uploads/&quot;);
        File file = new File(path);
        if(!file.exists()) {
            file.mkdirs();  //目录不存在则创建
        }
        String filename = upload.getOriginalFilename();  //获取文件名
        String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);
        filename = uuid + &quot;_&quot; + filename;  //不重复的文件名
        upload.transferTo(new File(path, filename));  //完成文件上传
        return &quot;success&quot;;
    }
</code></pre><h3 id="跨服务器的文件上传"><a href="#跨服务器的文件上传" class="headerlink" title="跨服务器的文件上传"></a>跨服务器的文件上传</h3><pre><code>1. 实际开发中，可能会有很多负责不同功能的服务器
    1. 应用服务器：负责部署处理业务的应用;
    2. 数据库服务器：数据持久化;
    3. 缓存和消息服务器：负责处理高并发访问的缓存和消息;
    4. 文件服务器：负责存储用户上传的文件;
2. 注意：这并不是服务器集群;
3. 实现跨服务器的依赖：jersey-core、jersey-client
    @RequestMapping(path=&quot;/fileupload&quot;)
    public String uploadFile(MultipartFile upload) {
        String filename = upload.getOriginalFilename();  //获取文件名
        String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);
        filename = uuid + &quot;_&quot; + filename;  //不重复的文件名
        //文件服务器的上传URL，一定有uploads目录
        String fileServer = &quot;http://localhost:9090/uploads/&quot;;
        //创建客户端对象
        Client client = Client.create();
        //与文件服务器建立连接
        WebResource web = client.resource(fileServer + filename);
        //上传文件
        web.put(upload.getBytes());
        return &quot;success&quot;;
    }
</code></pre><h2 id="异常处理器"><a href="#异常处理器" class="headerlink" title="异常处理器"></a>异常处理器</h2><pre><code>1. 控制器方法在处理业务发生异常时，会向上抛出，最终由前端控制器查找异常处理器，如果没有则抛给浏览器;
2. 使用异常处理器的目的是，当发生异常时，由异常处理器响应给用户一个友好页面；
3. 自定义异常类
    public class SysException extends Exception {
        private String message;  //存储提示信息
        //getter、setter
        public SysException(String message) {
            this.message = message;
        }
    }
4. 抛出异常
    @RequestMapping(path=&quot;/except&quot;)
    public String test() throws SysException {
        try {
            int i = 10/0;  //发生异常
        } catch(Exception e) {
            throw new SysException(&quot;保存用户失败！&quot;);
        }
        return &quot;success&quot;;
    }
5. 异常处理器：实现接口HandlerExceptionResolver
    public class SysExceptionResolver implements HandlerExceptionResolver {
        public ModelAndView resolveException(HttpServletRequest req, 
                HttpServletResponse res, Object handler, Exception ex) {
            SysException e = null;
            if(ex instanceof SysException) {
                e = (SysException) ex;
            } else {
                e = new SysException(&quot;不好意思，系统维护中~&quot;);
            }
            ModelAndView mv = new ModelAndView();
            mv.addObject(&quot;errorMsg&quot;, e.getMessage());  //向Request域存入提示信息
            mv.setViewName(&quot;error&quot;);  //跳转到自定义的错误页error.jsp
            return mv;
        }
    }
6. 在配置文件 springmvc.xml 中，配置异常处理器
    &lt;bean id=&quot;sysExceptionResolver&quot; class=&quot;cn.test.exception.SysExceptionResolver&quot;&gt;&lt;/bean&gt;
</code></pre><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><pre><code>1. SpringMVC的处理器拦截器类似于Servlet中的过滤器，用于对处理器进行预处理和后处理;
    1. 预处理和后处理类似于Koa的洋葱图；
    2. 请求到达 --&gt; 执行拦截器放行前的代码(预处理) --&gt; 放行到控制器方法 --&gt; 
    执行拦截器放行后的代码 --&gt; 响应结果
2. 拦截器链：将拦截器按照一定的顺序连接成一条链，在访问被拦截的方法/属性时，拦截器就会按顺序被调用;
3. 过滤器与拦截器
    1. 过滤器是Servlet规范中的一部分，拦截器是SpringMVC框架提供的；
    2. 过滤器在 url-pattern 中配置了 /* 之后，可以拦截所有要访问的资源；
    3. 拦截器只会拦截访问的控制器方法，如果是JSP、HTML、CSS、image、JS资源，是不会被拦截的。
4. 拦截器也是AOP思想的具体应用，自定义拦截器必须实现接口HandlerInterceptor
5. JDK1.8对接口做了增强，方法可以不是抽象的，所以在实现HandlerInterceptor时，并不强制实现此接口方法;
    public class MyInterceptor implements HandlerInterceptor {
        // preHandle()、postHandle()、afterCompletion()
    }
6. 在配置文件 springmvc.xml 中，配置拦截器：&lt;mvc:interceptors&gt;
    &lt;mvc:interceptors&gt;
        &lt;mvc:interceptor&gt;
            &lt;mvc:mapping path=&quot;/user/*&quot; /&gt;
            &lt;!-- &lt;mvc:exclude-mapping path=&quot;&quot;&gt; --&gt;
            &lt;bean class=&quot;cn.test.interceptor.MyInterceptor&quot; /&gt;
        &lt;/mvc:interceptor&gt;
    &lt;/mvc:interceptors&gt;
    1. 每一组 &lt;mvc:interceptor&gt; 标签，表示一个拦截器，标签的顺序决定了拦截器的调用顺序;
    2. &lt;mvc:mapping&gt;：配置拦截的控制器方法;
    3. &lt;mvc:exclude-mapping&gt;：配置不拦截的控制器方法;
    4. path 属性：指定URL，也就是控制器方法.
</code></pre><h3 id="拦截器方法"><a href="#拦截器方法" class="headerlink" title="拦截器方法"></a>拦截器方法</h3><pre><code>1. preHandle()：预处理方法
    public boolean preHandle(HttpServletRequest req, HttpServletResponse res, 
        Object handler) {
        return true;
    }
    1. 在控制器方法执行之前执行，返回true表示放行，执行下一个拦截器，如果没有了，则执行控制器方法;
    2. 返回false表示不放行，可以使用req对象和res对象自行处理请求与响应.
    public boolean preHandle(HttpServletRequest req, HttpServletResponse res, 
        Object handler) {
        req.getRequestDispatcher(&quot;/pages/error.jsp&quot;).forward(req, res); //转发到error.jsp
        return false;  //不放行
    }
2. postHandle()：后处理方法
    @RequestMapping(path=&quot;/test&quot;)
    public String test() {
        ....
        return &quot;success&quot;;
    }
    public void postHandle(HttpServletRequest req, HttpServletResponse res, 
        Object handler， ModelAndView mv) {
    }
    1. 在控制器方法执行完之后，执行success.jsp之前，执行postHandle();
    public void postHandle(HttpServletRequest req, HttpServletResponse res, 
        Object handler, ModelAndView mv) {
        req.getRequestDispatcher(&quot;/pages/error.jsp&quot;).forward(req, res);
    }
    2. 虽然postHandle()自行请求转发给error.jsp，但控制器方法的 success.jsp 仍会执行，
    响应给浏览器也是 error.jsp.
3. afterCompletion()：控制器方法的 success.jsp 执行完之后，才会执行;
    public void afterCompletion(HttpServletRequest req, HttpServletResponse res, 
        Object handler， Exception ex) {
    }
4. 当配置了多组拦截器时(都放行)
    @Controller
    @RequestMapping(path = &quot;/user&quot;)
    public class HelloController {
        @RequestMapping(path=&quot;/test&quot;)
        public String test() {
            ....
            return &quot;success&quot;;
        }
    }
    &lt;mvc:interceptors&gt;
        &lt;mvc:interceptor&gt;
            &lt;mvc:mapping path=&quot;/user/*&quot; /&gt;
            &lt;bean class=&quot;cn.test.interceptor.MyInterceptor&quot; /&gt;
        &lt;/mvc:interceptor&gt;
        &lt;mvc:interceptor&gt;
            &lt;mvc:mapping path=&quot;/**&quot; /&gt;
            &lt;bean class=&quot;cn.test.interceptor.TestInterceptor&quot; /&gt;
        &lt;/mvc:interceptor&gt;
    &lt;/mvc:interceptors&gt;
    &lt;a href=&quot;user/test&quot;&gt;to test&lt;/a&gt;
1. 执行顺序：
    MyInterceptor.preHandle() --&gt; TestInterceptor.preHandle() --&gt; HelloController.test()
    --&gt; TestInterceptor.postHandle() --&gt; MyInterceptor.postHandle() --&gt; success.jsp --&gt; 
    TestInterceptor.afterCompletion() --&gt; MyInterceptor.afterCompletion()
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">大麦田怪圈</p>
              <p class="site-description motion-element" itemprop="description">敢做就能赢！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">58</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大麦田怪圈</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
