<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="敢做就能赢！">
<meta property="og:type" content="website">
<meta property="og:title" content="大麦田程序猿">
<meta property="og:url" content="http://hellomyshadow.github.io/page/4/index.html">
<meta property="og:site_name" content="大麦田程序猿">
<meta property="og:description" content="敢做就能赢！">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="大麦田程序猿">
<meta name="twitter:description" content="敢做就能赢！">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hellomyshadow.github.io/page/4/">





  <title>大麦田程序猿</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大麦田程序猿</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/03/11/Spring5新特性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/11/Spring5新特性/" itemprop="url">Spring5新特性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-11T00:00:00+08:00">
                2016-03-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>1. Spring5.0在2017年9月发布了GA(通用)版本，基于JDK8，兼容JDK9，但JDK8以下版本无法使用;
    1. Tomcat版本要求最低8.5，使用JDK8构建工程，可以降版编译，但不能使用JDK8-构建工程;
    2. 随着JDK和Tomcat的更新，相应的IDE也要更新.
2. JDK8的更新
    1. 反射增强：大量创建对象、给对象的属性设置值、反射创建对象...的速度都大大加快;
    2. @NotNull、@Nullable
        1. 显示表明可为空的参数/返回值，实现在编译期处理空值，避免在运行期抛出Null异常;
    3. 日志记录
        1. Spring5.0新增Commons Logging桥接模块的封装，称为spring-jcl，并不是标准的CL;
        2. 当然，无需任何额外的桥接，新版本也会对Log4j2.x、SLF4J、JUL进行自动检测.
3. 核心容器的更新
    1. Spring5.0支持候选组件索引作为类路径扫描的替代方法;
    2. 从索引读取实体而不是扫描类路径，对小于200个类的小型项目没有明显差异，但对大型项目影响较大;
    3. 加载组建索引的耗费是廉价的，所以随着类的数量增长，启动时间仍可以维持一个常数;
    4. 对于Spring项目的开发者而言，应用程序的启动时间将被大大缩减.
4. 支持Kotlin：一种支持函数式编程的面向对象语言，运行在JVM之上，但运行环境又不仅限于JVM;
5. 响应式编程风格
    1. spring-webflux：支持响应式HTTP和WebSocket客户端;
    2. spring-webflux中包含两种独立的服务端编程模型;
        1. 基于注解：使用 @Controller 以及 SpringMVC的一些注解;
        2. 使用Java8 lambda表达式的函数式风格的路由和处理.
6. 支持JUnit5：JUnit5 = JUnit Platform + JUnit Jupiter + JUnit Vintage
7. 依赖类库的更新
    1. 不再支持的类库：Portlet、Velocity、JasperReports、XMLBeans、JDO、Guava
    2. 新支持的类库：Jackson2.6+、EhCache2.1+/3.0GA、Hibernate5.0+、JDBC4.0+、XmlUnit2.x+、
    OkHttp3.x+、Netty4.1+
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/03/09/Spring事务控制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/09/Spring事务控制/" itemprop="url">Spring事务控制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-09T00:00:00+08:00">
                2016-03-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h2><pre><code>1. JdbcTemplate是Spring提供的一个对象，对原始JDBC的一层简单封装；
    1. 操作关系型数据库：JdbcTemplate、HibernateTemplate
    2. 操作NoSQL数据库：RedisTemplate
    3. 操作消息队列：JmsTemplate
</code></pre><p><img src="//hellomyshadow.github.io/2016/03/09/Spring事务控制/持久层.jpg" alt="持久层"></p>
<pre><code>2. JdbcTemplate的依赖包：spring-jdbc，除此之外，还有事务相关的依赖：spring-tx
    spring-context、spring-jdbc、spring-tx、mysql-connector-java
3. JdbcTemplate的简单使用
    1. 实体类Account
        public class Account {
            private int id;  private String name;  private float money;
            //setter、getter
        }
    2. Spring的内置数据源DriverManagerDataSource
        DriverManagerDataSource ds = new DriverManagerDataSource();
        ds.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;);
        ds.setUrl(&quot;jdbc:mysql://...&quot;);  ds.setUsername(&quot;root&quot;);  ds.setPassword(&quot;123456&quot;);
        JdbcTemplate jt = new JdbcTemplate();
        jt.setDataSource(ds);
        jt.execute(&quot;insert into account(name, money) values(&apos;Java&apos;, 1000)&quot;);
4. JdbcTemplate的CRUD
    1. 插入一条数据
        jt.update(&quot;insert into account(name, money) values(?, ?)&quot;, &apos;AAA&apos;, 1000);
    2. 修改/删除
        jt.update(&quot;update/delete ...&quot;, ...);
    3. 查询
        jt.query(String sql, Object[] args, RowMapper&lt;T&gt; rowMapper); //通用方式
        jt.query(String sql, RowMapper&lt;T&gt; rowMapper, Object... args); //JDK1.5+
    4. RowMapper：接口，泛型就是实体类，其方法 mapRow() 用于把数据封装到实体类对象中
        class AccountRowMapper implements RowMapper&lt;Account&gt; {
            public Account mapRow(ResultSet rs, int rowNum) {
                Account account = new Account();
                account.setId(rs.getInt(&quot;id&quot;));
                account.setName(rs.getString(&quot;name&quot;));
                account.setMoney(rs.getFloat(&quot;money&quot;));
                return account;
            }
        }
    List&lt;Account&gt; ats = jt.query(&quot;select * from account where money&gt;?&quot;, new AccountRowMapper(), 100f);
    5. Spring也提供了RowMapper的实现类：BeanPropertyRowMapper
    jt.query(&quot;select * from account&quot;, new BeanPropertyRowMapper&lt;Account&gt;(Account.class));
5. 聚合函数
Integer count = jt.queryForObject(&quot;select count(id) from account where money&gt;?&quot;, Integer.class, 100f);
</code></pre><h3 id="基于Spring-IoC"><a href="#基于Spring-IoC" class="headerlink" title="基于Spring IoC"></a>基于Spring IoC</h3><pre><code>1. Dao层的接口及其实现类：IAccountDao、AccountDaoImpl
    public class AccountDaoImpl implements IAccountDao {
        private JdbcTemplate jt;
        ......//setter、CRUD
    }
2. IoC配置文件bean.xml
    &lt;bean id=&quot;accountDao&quot; class=&quot;cn.test.dao.impl.AccountDaoImpl&quot;&gt;
        &lt;property name=&quot;jt&quot; ref=&quot;jt&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;jt&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;ds&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;ds&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://...&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
3. 直接使用Dao层操作数据库
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
    IAccountDao dao = ac.getBean(&quot;accountDao&quot;, IAccountDao.class);
</code></pre><h3 id="JdbcDaoSupport"><a href="#JdbcDaoSupport" class="headerlink" title="JdbcDaoSupport"></a>JdbcDaoSupport</h3><pre><code>1. 如果有多个Dao，那么每个Dao中都会有属性JdbcTemplate及其setter，需要抽取其中的重复代码
    1. 定义一个Dao层的父类JdbcDaoSupport
        public class JdbcDaoSupport {
            private JdbcTemplate jdbcTemplate;
            //创建无参的JdbcTemplate对象
            public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {
                this.jdbcTemplate = jdbcTemplate;
            }
            public JdbcTemplate getJdbcTemplate() {
                return this.jdbcTemplate;
            }
            //创建带参DataSource的JdbcTemplate对象
            public void setDataSource(DataSource dataSource) {
                if(this.jdbcTemplate == null) {
                    this.jdbcTemplate = this.createJdbcTemplate(dataSource);
                }
                this.jdbcTemplate = jdbcTemplate;
            }
            private JdbcTemplate createJdbcTemplate(DataSource dataSource) {
                return new JdbcTemplate(dataSource);
            }
        }
    2. Dao层继承JdbcDaoSupport
        public class AccountDaoImpl extends JdbcDaoSupport implements IAccountDao {
            public List&lt;Account&gt; findAll() {
                return supper.getJdbcTemplate().query(&quot;select * from account&quot;, ...);
            }
            ......//CRUD
        }
    3. 在为 AccountDaoImpl 注入数据时，可以选择使用无参的JdbcTemplate还是有参的JdbcTemplate
        &lt;bean id=&quot;accountDao&quot; class=&quot;cn.test.dao.impl.AccountDaoImpl&quot;&gt;
            &lt;!-- 使用无参的JdbcTemplate对象 --&gt;
            &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jt&quot;&gt;&lt;/property&gt;
            &lt;!-- 使用有参DataSource的JdbcTemplate对象，二选一 --&gt;
            &lt;property name=&quot;dataSource&quot; ref=&quot;ds&quot;&gt;&lt;/property&gt;
        &lt;/bean&gt;
        ......// jt、ds
2. 另外，Spring提供了一个JdbcDaoSupport，功能和XML注入方式都与自定义的JdbcDaoSupport类似;
3. JdbcDaoSupport是Spring的内置类，一旦Dao层继承它，那么在Service层使用Dao对象时，就只能用配置文件的方式
   实现注入，而不能再使用 @Autowired 注入 Dao 了。
</code></pre><h2 id="注解AOP实现事务"><a href="#注解AOP实现事务" class="headerlink" title="注解AOP实现事务"></a>注解AOP实现事务</h2><pre><code>1. 连接的工具类
    @Commonent(&quot;connUtils&quot;)
    public class ConnectionUtils {
        private ThreadLocal&lt;Connection&gt; tl = new ThreadLocal&lt;&gt;();
        @Autowired
        private DataSource dataSource;

        public Connection getThreadConn() {
            Connection conn = tl.get();
            if(conn == null) { //从数据源中获取一个连接，并存入连接池
                conn = dataSource.getConnection();
                tl.set(conn);
            }
            return conn;
        }
        public void removeConn() {
            tl.remove();  // 移除ThreadLocal中当前线程的连接
        }
    }
2. 事务管理的工具类，声明为切面类
    @Commonent(&quot;manager&quot;)
    @Aspect
    public class TransactionManager {
        @Autowired
        private ConnectionUtils connUtils;
        @Pointcut(&quot;execution(* it.bank.service.impl.*.*(..))&quot;)
        private void pt1() {}
        @Before(&quot;pt1()&quot;)
        public void beginTransaction() {  //开启手动提交事务
            connUtils.getThreadConn().setAutoCommit(false);
        }
        @AfterReturning(&quot;pt1()&quot;)
        public void commit() {  //手动提交事务
            connUtils.getThreadConn().commit();
        }
        @AfterThrowing(&quot;pt1()&quot;)
        public void rollback() {  //回滚
            connUtils.getThreadConn().rollback();
        }
        @After(&quot;pt1()&quot;)
        public void release() {  //释放连接，并还给连接池
            connUtils.getThreadConn().close();
            connUtils.removeConn();
        }
    }
3. 但是在AOP注解中，通知方法的执行顺序有致命问题：Before --&gt; After --&gt; AfterReturning
    1. 最终通知优先于后置通知执行，导致连接已经被关闭了，事务无法正确提交！
    2. 连接关闭并还给连接池后，提交时又会从连接池中获取一个新的连接，但此连接又没有开启过事务，导致提交异常。
4. 使用环绕通知
    @Commonent(&quot;manager&quot;)
    @Aspect
    public class TransactionManager {
        @Autowired
        private ConnectionUtils connUtils;
        @Pointcut(&quot;execution(* it.bank.service.impl.*.*(..))&quot;)
        private void pt1() {}

        public void beginTransaction() { ... }
        public void commit() { ... }
        public void rollback() { ... }
        public void release() { ... }

        @Around(&quot;pt1()&quot;)
        public Object aroundPrint(ProceedingJoinPoint pjp) {
            Object rtValue = null;
            try {
                Object[] args = pjp.getArgs();  //1.获取切入点方法执行所需的参数
                this.beginTransaction();  //2.开启事务
                rtValue = pjp.proceed(args);  //3.明确调用切入点方法
                this.commit();  //4.提交事务
                return rtValue;  //5.返回结果
            } catch(Throwable t) {
                this.rollback();
                throw new RuntimeException(t);
            } finally {
                this.release();
            }
        }
    }
</code></pre><h2 id="Spring的事务控制"><a href="#Spring的事务控制" class="headerlink" title="Spring的事务控制"></a>Spring的事务控制</h2><pre><code>1. TransactionManager是自定义的事务管理，Spring也有自己的事务控制；
    1. JavaEE体系进行分层开发时，事务控制位于业务层，Spring提供了业务层的事务控制方案；
    2. Spring提供了一组事务控制的接口，这些API就在spring-tx中；
    3. Spring的事务控制都是基于AOP的，它既可以使用编程式实现，也可以使用配置实现。
2. 相关依赖：spring-context、spring-jdbc、spring-tx、mysql-connector-java、aspectjweaver
</code></pre><h3 id="事务控制的API"><a href="#事务控制的API" class="headerlink" title="事务控制的API"></a>事务控制的API</h3><pre><code>1. PlatformTransactionManager：提供事务操作的接口
    1. getTransaction(TransactionDefinition d)：获取事务的状态信息;
    2. commit(TransactionStatus status)：提交事务;
    3. rollback(TransactionStatus status)：回滚事务;
    4. 实现类：DataSourceTransactionManager、HibernateTransactionManager;
    5. DataSourceTransactionManager：用于Spring JDBC 或 iBatis;
    6. HibernateTransactionManager：用于hibernate.
2. TransactionDefinition：事务的定义信息
    1. getName()：获取事务的名称;
    2. getIsolationLevel()：获取事务的隔离级别;
    3. getPropagationBehavior()：获取事务的传播行为;
    4. 传播行为：何时才需要事务(增删改)，何时不需要事务(查询);
    5. getTimeout()：事务的超时时间，提交和回滚何时过期，可以配置为永不过期;
    6. isReadOnly()：事务是否只读，读写型事务(增删改)、只读型事务(查询);
3. 事务的隔离级别
    1. ISOLATION_DEFAULT：使用数据库的默认隔离级别;
    2. ISOLATION_READ_UNCOMMITTED：读未提交;
    3. ISOLATION_READ_COMMITTED：读已提交，Oracle的默认级别;
    4. ISOLATION_REPEATABLE_READ：不可重读，MySQL的默认隔离级别;
    5. ISOLATION_SERIALIZABLE：最高级别.
4. 事务的传播行为
    1. REQUIRED：默认值，如果当前没有事务，则新建一个，如果已存在一个事务，则加入到该事务中;
    2. SUPPORTS：支持当前事务，如果当前没有事务，则以非事务的方式执行(有就用，没有就不用);
    3. MANDATORY、REQUERS_NEW、NOT_SUPPORTED、NEVER、NESTED
5. 超时时间：以秒为单位，默认值-1，表示没有超时限制;
6. TransactionStatus：描述某个时间点上事务对象的状态信息;
    1. flush()：刷新事务;
    2. hasSavepoint()：是否存在存储点，将一个事务按步提交，如果某一步失败，只回滚到这一步前，而不是从头开始;
    3. isCompleted()：事务是否完成;
    4. isNewTransaction()：当前事务是不是一个新事务;
    5. isRollbackOnly()：事务是否回滚;
    6. setRollbackOnly()：设置事务回滚;
</code></pre><h3 id="声明式事务控制"><a href="#声明式事务控制" class="headerlink" title="声明式事务控制"></a>声明式事务控制</h3><pre><code>1. Dao层：IAccountDao、AccountDaoImpl(继承Spring的JdbcDaoSupport)
2. Service层：IAccountService、AccountServiceImpl
    public class AccountServiceImpl implements IAccountService {
        private IAccountDao dao; //setter
        public Account findById(int id) {
            return dao.findById(id);
        }
        public void transfer(String sourceName, String targetName, Float money) {
            Account source = dao.findByName(sourceName);
            Account target = dao.findByName(targetName);
            source.setMoney(source.getMoney() - money);
            target.setMoney(target.getMoney() + money);
            //更新数据库
            dao.updateAccount(source);
            int i = 1/0;  //发生异常，不再向下执行
            dao.updateAccount(target);
        }
    }
3. bean.xml：加入事务、AOP的约束
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
        xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
        xsi:schemaLocation=&quot;
            http://www.springframework.org/schema/beans
            https://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/tx
            https://www.springframework.org/schema/tx/spring-tx.xsd
            http://www.springframework.org/schema/aop
            https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
        &lt;bean id=&quot;accountService&quot; class=&quot;cn.test.service.impl.AccountServiceImpl&quot;&gt;
            &lt;property name=&quot;dao&quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt;
        &lt;/bean&gt;
        &lt;bean id=&quot;accountDao&quot; class=&quot;cn.test.dao.impl.AccountDaoImpl&quot;&gt;
            &lt;property name=&quot;dataSource&quot; ref=&quot;ds&quot;&gt;&lt;/property&gt;
        &lt;/bean&gt;
        &lt;bean id=&quot;ds&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
            ......
        &lt;/bean&gt;
4. 配置事务管理器：DataSourceTransactionManager
    &lt;bean id=&quot;manager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;ds&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
5. &lt;tx:advice&gt;：配置事务通知，关联事务管理器;
    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;manager&quot;&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name=&quot;transfer&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;
    1. id属性：此事务通知的唯一标识;
    2. transaction-manager：指定事务管理器的id，关联事务通知与事务管理器.
6. &lt;tx:method&gt;：配置事务管理的方法;
    1. name属性：用于指定方法名，支持正则通配符*
        1. name=&quot;find*&quot;：匹配以 find 开头的方法;
        2. 配置多个&lt;tx:method&gt;，为不同的方法设置不同的参数，name的范围越小，优先级越高;
        &lt;tx:method name=&quot;transfer&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&gt;
        &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt;
        3. 查询方法以 find 开头，设置为只读，且不使用事务.
    2. propagation：配置事务的传播行为;
        1. REQUIRED：默认值，表示一定会有事务，用于增删改;
        2. SUPPORTS：用于查询方法，通知数据库没必要加锁(事务)，提高效率.
    3. isolation：配置隔离级别，默认值DEFAULT，表示使用数据库的默认隔离级别;
    4. read-only：指定事务是否只读，默认为false，表示读写，只有查询方法才能设置为true;
    5. timeout：事务的超时时间，以秒为单位，默认值为-1，表示永不超时;
    6. rollback-for：指定一个异常，当产生该异常时，事务回滚，产生其他异常时，事务不会滚;
    7. no-rollback-for：与 rollback-for 相反，发生指定的异常时不回滚，发生其他异常时回滚;
    8. rollback-for 和 no-rollback-for 都没有默认值，不指定异常时，表示任何异常都回滚.
7. 配置AOP：建立事务通知与切入点表达式的关系
    &lt;aop:config&gt;
        &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* cn.test.service.impl.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;
        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:advisor&gt;
    &lt;/aop:config&gt;
    1. advice-ref：关联事务通知的id;
    2. pointcut-ref：关联切入点表达式的id.
8. 测试
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
    IAccountService service = ac.getBean(&quot;accountService&quot;, IAccountService.class);
    service.transfer(&quot;AAA&quot;, &quot;BBB&quot;, 100f);
</code></pre><h4 id="注解的声明式事务控制"><a href="#注解的声明式事务控制" class="headerlink" title="注解的声明式事务控制"></a>注解的声明式事务控制</h4><pre><code>1. bean.xml：加入AOP、事务、context的约束，开启Spring对注解事务的支持
    &lt;beans aop、tx、context...相关约束&gt;
        &lt;!-- Spring创建IoC容器时要扫描的包 --&gt;
        &lt;context:component-scan base-package=&quot;cn.test&quot;&gt;&lt;/context:component-scan&gt;
        &lt;bean id=&quot;jt&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
            &lt;property name=&quot;dataSource&quot; ref=&quot;ds&quot;&gt;&lt;/property&gt;
        &lt;/bean&gt;
        &lt;bean id=&quot;ds&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
            ......
        &lt;/bean&gt;
        &lt;!-- 配置事务管理器 --&gt;
        &lt;bean id=&quot;manager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
            &lt;property name=&quot;dataSource&quot; ref=&quot;ds&quot;&gt;&lt;/property&gt;
        &lt;/bean&gt;
        &lt;!-- 开启Spring支持注解事务 --&gt;
        &lt;tx:annotation-driven transaction-manager=&quot;manager&quot;&gt;&lt;/tx:annotation-driven&gt;
    &lt;/beans&gt;
2. Dao层不再继承Spring的JdbcDaoSupport
    @Repository(&quot;accountDao&quot;)
    public class AccountDaoImpl implements IAccountDao {
        @Autowired
        private JdbcTemplate jt;
        ......
    }
3. 在Service层，在需要事务控制的类/方法上使用 @Transactional，并配置事务的相关属性;
    @Service(&quot;accountService&quot;)
    @Transactional(propagation=Propagation.SUPPORTS, readOnly=true)  --&gt;对所有方法有效
    public class AccountServiceImpl implements IAccountService {
        @Autowired
        private IAccountDao dao;

        public Account findById(int id) { ... }

        @Transactional(propagation=Propagation.REQUIRED, readOnly=false) --&gt;单独配置
        public void transfer(String sourceName, String targetName, Float money) { ... }
    }
4.     测试
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
    IAccountService service = ac.getBean(&quot;accountService&quot;, IAccountService.class);
    service.transfer(&quot;AAA&quot;, &quot;BBB&quot;, 100f);
</code></pre><h4 id="纯注解取代XML"><a href="#纯注解取代XML" class="headerlink" title="纯注解取代XML"></a>纯注解取代XML</h4><pre><code>在java目录下创建包config，存放配置类;
1. resources/jdbcConf.properties：数据库的连接信息
    jdbc.driver=com.mysql.cj.jdbc.Driver
    jdbc.url=jdbc:mysql://...
    jdbc.username=root
    jdbc.password=123456
2. JDBC相关的配置类
    public class JdbcConfig {
        @Value(&quot;${jdbc.driver}&quot;)
        private String driver;
        ......//url、username、password

        @Bean(name=&quot;jt&quot;)
        public JdbcTemplate createJdbcTemplate(DataSource ds) {
            return new JdbcTemplate(ds);
        }
        @Bean(name=&quot;ds&quot;)
        public DataSource createDataSource() {
            DriverManagerDataSource ds = new DriverManagerDataSource();
            ds.setDriverClassName(driver);
            ds.setUrl(url);
            ds.setUsername(username);
            ds.setPassword(password);
            return ds;
        }
    }
3. 事务管理器相关的配置类
    public class TransactionConfig {
        @Bean(name=&quot;manager&quot;)
        public PlatformTransactionManager createTransactionManager(DataSource ds) {
            return new DataSourceTransactionManager(ds);
        }
    }
4. @EnableTransactionManagement：开启Spring支持注解事务
5. 主配置类SpringConfiguration
    @Configuration
    @ComponentScan(&quot;cn.test&quot;)
    @Import({JdbcConfig.class, TransactionConfig.class})
    @PropertySource(&quot;jdbcConf.properties&quot;)
    @EnableTransactionManagement
    public class SpringConfiguration { }
6. 测试
    ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class);
    IAccountService service = ac.getBean(&quot;accountService&quot;, IAccountService.class);
    service.transfer(&quot;AAA&quot;, &quot;BBB&quot;, 100f);
</code></pre><h3 id="编程式事务控制"><a href="#编程式事务控制" class="headerlink" title="编程式事务控制"></a>编程式事务控制</h3><pre><code>1. bean.xml：配置Dao、Service、DataSource、事务管理器DataSourceTransactionManager
2. 除此之外，还需要使用事务模板对象TransactionTemplate，所以也要配置;
    &lt;bean id=&quot;transactionTemplate&quot; class=&quot;org.springframework.transaction.support.TransactionTemplate&quot;&gt;
        &lt;property name=&quot;transactionManager&quot; ref=&quot;manager&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
3. 在Service中使用TransactionTemplate
    public class AccountServiceImpl implements IAccountService {
        private IAccountDao dao;
        private TransactionTemplate transactionTemplate;
        ......//setter

        public Account findById(int id) {
            return transactionTemplate.execute(new TransactionCallback&lt;Account&gt;() {
                public Account doInTransaction(TransactionStatus status) {
                    return dao.findById(id);
                }
            });
        }
        public void transfer(String sourceName, String targetName, Float money) {
            transactionTemplate.execute(new TransactionCallback&lt;Object&gt;() {
                public Object doInTransaction(TransactionStatus status) {
                    Account source = dao.findByName(sourceName);
                    Account target = dao.findByName(targetName);
                    source.setMoney(source.getMoney() - money);
                    target.setMoney(target.getMoney() + money);
                    dao.updateAccount(source);
                    int i = 1/0;  //发生异常，不再向下执行
                    dao.updateAccount(target);
                    return null;
                }
            });
        }
    }
    4. 每一个需要事务管理的方法里都要使用TransactionTemplate去管理，增加了大量的重复代码。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/03/08/Spring与AOP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/08/Spring与AOP/" itemprop="url">Spring与AOP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-08T00:00:00+08:00">
                2016-03-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><pre><code>1. AOP：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护；
    1. 简单来说：在运行期，利用动态代理技术，在不修改源码的情况下，对已有方法进行增强；
    2. AOP是OOP的延续，是函数式编程的一种衍生范型；
    3. 利用AOP可以分离业务逻辑的各个部分，从而降低耦合，提高程序的可重用性和开发效率。
2. Joinpoint：连接点，指那些被拦截的点，在Spring中就是被拦截的方法，因为Spring只支持方法类型的连接点；
3. Pointcut：切入点，在被拦截的方法中，只有被增强的方法才称为切入点；
4. Advice：通知/增强，拦截到Joinpoint之后要做的事情；
    1. 分类：前置通知、后置通知、异常通知、最终通知、环绕通知；
    public IAccountService getAccountService() {
        return (IAccountService) Proxy.newProxyInstance(
        service.getClass().getClassLoader(), service.getClass().getInterfaces(), 
        new InvocationHandler(){
            public Object invoke(Object proxy, Method method, Object[] args)  {
                object rtValue = null;
                try {
                    manager.beginTransaction();
                    rtValue = method.invoke(service, args);
                    manager.commit();
                    return rtValue;
                } catch(Exception e) {  ---&gt;异常通知
                    manager.rollback();
                    throw new RuntimeException(e);
                } finally {  ---&gt;最终通知
                    manager.release();
                }
            }
        });
    }
    2. 整个 invoke() 部分称为环绕通知，其中有明确的切入点方法调用：method.invoke(service, args);
    3. method.invoke(service, args); 之前的代码称为前置通知，后面的代码称为后置通知.
5. Introduction：引介，一种特殊的通知，在不修改类代码的情况下，可以在运行期动态地为类添加属性/方法；
6. Target：代理的目标对象；
7. Weaving：织入，把增强应用到目标对象，来创建新代理对象的过程；
    1. Spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入.
8. Proxy：一个类被AOP织入增强后，就产生一个代理类；
9. Aspect：切面，是切入点和通知/引介的结合。
</code></pre><h3 id="Spring的AOP"><a href="#Spring的AOP" class="headerlink" title="Spring的AOP"></a>Spring的AOP</h3><pre><code>1. 添加依赖：spring-context、aspectjweaver(解析切入点表达式)
2. 业务层Service
    public class AccountServiceImpl implements IAccountService {
        public void save() {  //无参无返回值
            System.out.println(&quot;save&quot;);
        }
        public void update(int i) { //有参无返回值
            System.out.println(&quot;update&quot;);
        }
        public int delete() {  //无参有返回值
            System.out.println(&quot;delete&quot;);
        }
    }
3. 提供一个记录日志的工具类，存放公共代码
    public class Logger {
        public void print() {
            //在切入点方法执行之前，执行此通知方法
            System.out.println(&quot;print&quot;);
        }
    }
4. Spring的配置文件 resources/bean.xml，添加AOP约束
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
        &lt;bean id=&quot;accountService&quot; class=&quot;cn.test.service.impl.AccountServiceImpl&quot;&gt;&lt;/bean&gt;
        &lt;bean id=&quot;logger&quot; class=&quot;cn.test.utils.Logger&quot;&gt;&lt;/bean&gt;
        &lt;!-- 配置AOP --&gt;
        &lt;aop:config&gt;
            &lt;!-- 配置切面 --&gt;
            &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt;
                &lt;!-- 配置通知类型，并建立通知方法与切入点方法的关联 --&gt;
                &lt;aop:before method=&quot;print&quot; pointcut=&quot;切入点表达式&quot;&gt;&lt;/aop:before&gt;
            &lt;/aop:aspect&gt;
        &lt;/aop:config&gt;
    &lt;/beans&gt;
    1. &lt;aop:config&gt;：开始AOP的配置;
    2. &lt;aop:aspect&gt;：配置切面;
        1. id属性：切面的唯一标识;
        2. ref属性：指定通知类bean的id，此时的通知类就是Logger
    3. &lt;aop:before&gt;：配置前置通知，也就是执行Logger.print()
        1. method属性：指定执行的通知方法;
        2. pointcut属性：指定切入点表达式，表示对业务层中的哪些方法增强;
        3. pointcut-ref属性：引用外部的切入点表达式标签&lt;aop:pointcut&gt;
        4. 只增强 AccountServiceImpl.save();
    pointcut=&quot;execution(public void cn.test.service.impl.AccountServiceImpl.save())&quot;
5. 开始执行
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
    IAccountService service = ac.getBean(&quot;accountService&quot;, IAccountService.class);
    service.save();  //print --&gt; save
    service.delete();  //delete，没有增强
6. 切入点表达式：execution(表达式)
    1. 表达式的标准格式：访问修饰符 返回值 包名.类名.方法名(参数列表)
    2. 访问修饰符可省略；
    3. 返回值使用通配符*，表示任意返回值；
    4. 包名使用通配符*，表示任意通配符，但有几级包，就需要写几个*.
        * *.*.*.*.AccountServiceImpl.save()
    5. 包名可以使用 .. , 表示当前包及其子包
        * *..AccountServiceImpl.save()
    6. 类名和方法名都可以使用 * 来实现通配：* *..*.*()
    7. 参数列表
        1. 基本类型直接用类型名，如int
        2. 引用类型则需要指明全类名，如java.lang.String
        3. 使用通配符*，匹配方法上的任意类型，但方法上必须有参数才可匹配;
        4. 使用 .. , 表示匹配方法上的任意多个、任意类型的参数，也可以没有参数.
    8. 由此可知，全通配的写法：* *..*.*(..)，匹配所有类的所有方法；
    9. 当然，一般也只会匹配业务层的所有方法：* cn.test.service.impl.*.*(..)
</code></pre><h2 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h2><pre><code>1. 通知方法
    public class Logger {
        public void beforePrint() { //前置通知
            System.out.println(&quot;before print&quot;);
        }
        public void afterPrint() { //后置通知
            System.out.println(&quot;after print&quot;);
        }
        public void catchPrint() { //异常通知
            System.out.println(&quot;catch print&quot;);
        }
        public void finalPrint() { //最终通知
            System.out.println(&quot;final print&quot;);
        }
        public void aroundPrint() { //环绕通知
            System.out.println(&quot;around print&quot;);
        }
    }
2. 配置四种常用通知
    1. 前置通知：切入点方法执行之前执行;
    &lt;aop:before method=&quot;beforePrint&quot; 
        pointcut=&quot;execution(* cn.test.service.impl.*.*(..))&quot;&gt;&lt;/aop:before&gt;
    2. 后置通知：切入点方法正常执行之后执行;
    &lt;aop:after-returning method=&quot;afterPrint&quot; 
        pointcut=&quot;execution(* cn.test.service.impl.*.*(..))&quot;&gt;&lt;/aop:after-returning&gt;
    3. 异常通知：切入点方法执行产生异常之后执行;
    &lt;aop:after-throwing method=&quot;catchPrint&quot; 
        pointcut=&quot;execution(* cn.test.service.impl.*.*(..))&quot;&gt;&lt;/aop:after-throwing&gt;
    4. 最终通知：不管切入点方法是否正常执行，都会在最后执行;
    &lt;aop:after method=&quot;finalPrint&quot; 
        pointcut=&quot;execution(* cn.test.service.impl.*.*(..))&quot;&gt;&lt;/aop:after&gt;
    5. 后置通知与异常通知始终只会执行一个.
3. &lt;aop:pointcut&gt;：单独配置切入点表达式
    1. id属性：此表达式的唯一id;
    2. expression属性：定义切入点表达式;
    &lt;aop:pointcut id=&quot;pt1&quot; 
        expression=&quot;execution(* it.aop.service.impl.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;
    &lt;aop:before method=&quot;beforePrint&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:before&gt;
    3. &lt;aop:pointcut&gt; 配置为 &lt;aop:aspect&gt; 的子标签时，只对当前切面有效;
    4. 配置为 &lt;aop:aspect&gt; 的兄弟标签时，必须配置在 &lt;aop:aspect&gt; 之前，对所有切面都有效.
</code></pre><h3 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h3><pre><code>&lt;aop:config&gt;
    &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* it.aop.service.impl.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;
    &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt;
        &lt;aop:around method=&quot;aroundPrint&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:before&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
1. invoke() 也称为环绕通知，所以一旦配置了&lt;aop:around&gt;，切入点方法不再执行，只执行了通知方法；
2. ProceedingJoinPoint：Spring提供的接口，它的 proceed() 用于明确调用切入点方法；
3. ProceedingJoinPoint可以作为环绕通知方法的参数，Spring会在运行期为此接口提供实现类；
    public Object aroundPrint(ProceedingJoinPoint pjp) {
        Object rtValue = null;
        try {
            //1.获取切入点方法执行所需的参数
            Object[] args = pjp.getArgs();
            //2.明确调用切入点方法
            rtValue = pjp.proceed(args);
            return rtValue;
        } catch(Throwable t) { //Exception拦不住此异常
            throw new RuntimeException(t);
        } finally {

        }
    }
    1. pjp.proceed(args); 之前的代码称为前置通知，之后的代码称为后置通知;
    2. catch部分称为异常通知，finally部分称为最终通知.
4. Spring的环绕通知，其实就是为了提供一种可以在代码中手动控制增强方法何时执行的方式；
5. 因为环绕通知与其他四种通知有关联性，如果同时配置这5种通知，会出现调用顺序的错乱；
6. 所以如果配置了环绕通知，就不要再配置其他四种通知，而是在环绕通知方法中手动调用其他四种通知方法。
</code></pre><h2 id="Spring的注解AOP"><a href="#Spring的注解AOP" class="headerlink" title="Spring的注解AOP"></a>Spring的注解AOP</h2><pre><code>1. 在配置文件 bean.xml 中添加aop和context的约束、创建容器时扫描的包、开启AOP注解支持
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
        &lt;!-- Spring创建IoC容器时要扫描的包 --&gt;
        &lt;context:component-scan base-package=&quot;cn.test&quot;&gt;&lt;/context:component-scan&gt;
        &lt;!-- 开启Spring的注解AOP支持 --&gt;
        &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;
    &lt;/beans&gt;
2. 业务层Service
    @Service(&quot;accountService&quot;)
    public class AccountServiceImpl implements IAccountService {
        ......
    }
3. @Aspect：声明当前类是一个切面类
    1. @Pointcut：用在方法上，定义切入点表达式；
    2. @Before、@AfterReturning、@AfterThrowing、@After：分别声明4种通知；
        @Component(&quot;logger&quot;)
        @Aspect
        public class Logger {
            @Pointcut(&quot;execution(* it.aop.service.impl.*.*(..))&quot;)
            private void pt1() {}

            @Before(&quot;pt1()&quot;)
            public void beforePrint() { ... }

            @AfterReturning(&quot;pt1()&quot;)
            public void afterPrint() { ... }

            @AfterThrowing(&quot;pt1()&quot;)
            public void catchPrint() { ... }

            @After(&quot;pt1()&quot;)
            public void finalPrint() { ... }
        }
    3. @Around：声明环绕通知，不要与其他四种通知的注解一起使用，调用顺序会错乱；
    4. 通知注解的value属性用于指定切入点表达式，必须是调用方法的形式：pt1()
4. 使用注解类取代配置文件：@EnableAspectJAutoProxy 声明支持AOP注解
    @Configuration
    @ComponentScan(basePackages=&quot;cn.test&quot;)
    @EnableAspectJAutoProxy
    public class SpringConfiguration { }
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/03/07/Spring与动态代理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/07/Spring与动态代理/" itemprop="url">Spring与动态代理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-07T00:00:00+08:00">
                2016-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="事务问题"><a href="#事务问题" class="headerlink" title="事务问题"></a>事务问题</h2><pre><code>public class Account {  //账户实体类
    private int id;
    private String name;
    private double money;
    //setter、getter
}
public AccountServiceImpl implements IAccountService {
    private IAccountDao dao;
    ...... //CRUD
    public void transfer(String sourceName, String targetName, float money) {
        //sourceName向targetName转向金额money
        Account source = dao.findByName(sourceName);
        Account target = dao.findByName(targetName);
        source.setMoney(source.getMoney() - money);
        target.setMoney(target.getMoney() + money);
        //更新数据库
        dao.updateAccount(source);
        int i = 1/0;  //发生异常，不再向下执行
        dao.updateAccount(target);
    }
}
1. 因为发生了异常，导致源账户的金额虽然变化了，但目标账户的金额并没有增加，根本原因在于事务
   没有回滚；
2. QueryRunner 的配置：
&lt;bean id=&quot;runner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot; scope=&quot;prototype&quot;&gt;
    &lt;constructor-arg name=&quot;ds&quot; ref=&quot;dataSource&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
    1. QueryRunner是多例的，每次数据库操作都会获取一个新连接，一个独立的新事务，操作成功之后，
    事务自动提交；
    2. 所以，所以发生异常时，没有一个总的事务控制，数据也就不会回滚。
3. 使用ThreadLocal把Connection和当前线程绑定，从而使一个线程只有一个能控制事务的对象；
    1. 当前的所有数据控制都在持久层，应该转到业务层上；
    2. 创建连接的工具类
        public class ConnectionUtils {
            private ThreadLocal&lt;Connection&gt; tl = new ThreadLocal&lt;&gt;();
            private DataSource dataSource;
            ...... //DataSource的setter
            public Connection getThreadConn() {
                Connection conn = tl.get();
                if(conn == null) { //从数据源中获取一个连接，并存入连接池
                    conn = dataSource.getConnection();
                    tl.set(conn);
                }
                return conn;
            }
            public void removeConn() {
                // 移除ThreadLocal中当前线程的连接
                tl.remove();
            }
        }
    3. 事务管理的工具类
        public class TransactionManager {
            private ConnectionUtils connUtils;
            ......//setter
            public void beginTransaction() {
                //开启事务，修改为手动提交
                connUtils.getThreadConn().setAutoCommit(false);
            }
            public void commit() {  //手动提交事务
                connUtils.getThreadConn().commit();
            }
            public void rollback() {  //回滚
                connUtils.getThreadConn().rollback();
            }
            public void release() {
                //释放连接，并还给连接池
                connUtils.getThreadConn().close();
                connUtils.removeConn();
            }
        }
4. 在Service中控制事务
    public AccountServiceImpl implements IAccountService {
        private IAccountDao dao;
        private TransactionManager manager;
        ......//setter
        public List&lt;Account&gt; findAll() {
            try {
                manager.beginTransaction(); //开启事务
                List&lt;Account&gt; accounts = dao.findAll();
                manager.commit(); //提交事务
                return accounts;
            } catch(Exception e) {
                manager.rollback(); //回滚
                throw new RuntimeExcepion(e);
            } finally {
                manager.release(); //释放连接
            }
        }
        ...... //带有事务的CRUD
        public void transfer(String sourceName, String targetName, float money) {
            //sourceName向targetName转向金额money
            try {
                manager.beginTransaction(); //开启事务
                Account source = dao.findByName(sourceName);
                Account target = dao.findByName(targetName);
                source.setMoney(source.getMoney() - money);
                target.setMoney(target.getMoney() + money);
                //更新数据库
                dao.updateAccount(source);
                int i = 1/0;  //发生异常，不再向下执行
                dao.updateAccount(target);
                manager.commit(); //提交事务
            } catch(Exception e) {
                manager.rollback(); //回滚
                throw new RuntimeExcepion(e);
            } finally {
                manager.release(); //释放连接
            }
        }
    }
5. 不为QueryRunner的构造方法提供DataSource，也就不注入连接
    &lt;bean id=&quot;runner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot; 
        scope=&quot;prototype&quot;&gt;&lt;/bean&gt;
6. 在Dao层，为QueryRunner手动提供Connection连接
    public AccountDaoImpl implements IAccountDao {
        private QueryRunner runner;
        private ConnectionUtils connUtils;
        ......//setter
        public List&lt;Account&gt; findAll() {
            //Connection对象作为第一个参数，表示手动提供连接对象
            return runner.query(connUtils.getThreadConn(), ......);
        }
        ......
    }
7. 在 bean.xml 中配置ConnectionUtils和TransactionManager;
    &lt;bean id=&quot;accountDao&quot; class=&quot;it.bank.dao.impl.AccountDaoImpl&quot;&gt;
        &lt;property name=&quot;runner&quot; ref=&quot;runner&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;connUtils&quot; ref=&quot;connUtils&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;accountService&quot; class=&quot;it.bank.service.impl.AccountServiceImpl&quot;&gt;
        &lt;property name=&quot;dao&quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;manager&quot; ref=&quot;manager&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;connUtils&quot; class=&quot;it.bank.utils.ConnectUtils&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;manager&quot; class=&quot;it.bank.utils.TransactionManager&quot;&gt;
        &lt;property name=&quot;connUtils&quot; ref=&quot;connUtils&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    ...... //runner、dataSource
</code></pre><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><pre><code>1. 虽然解决了事务控制，但是类与类之间存在较强的依赖关系，方法名的改变，可能导致毁灭性打击；
2. 动态代理：不同于装饰者模式，不需要实现创建类，而是随用随加载，通过字节码动态创建对象；
    1. 作用：不修改源码的基础上，对方法增强；
    2. 分类：基于接口的动态代理，基于子类的动态代理。
</code></pre><h3 id="基于接口的动态代理"><a href="#基于接口的动态代理" class="headerlink" title="基于接口的动态代理"></a>基于接口的动态代理</h3><pre><code>1. 创建代理对象的要求：被代理的类最少实现一个接口，否则不能使用；
    Proxy.newProxyInstance(ClassLoader, Class[], InvocationHandler)
2. ClassLoader：类加载器，用于加载代理对象的字节码，和被代理对象使用相同的类加载器；
    被代理对象.getClass().getClassLoader()
3. Class[]：字节码数组，用于让代理对象和被代理对象具有相同的方法；
    被代理对象.getClass().getInterfaces()
4. InvocationHandler：用于提供增强的代码，定义代理的方式，一般都是此接口的匿名内部类；
    new InvocationHandler() {
        public Object invoke(Object proxy, Method method, Object[] args) {
            //默认方式，相当于没有任何增强
            return method.invoke(被代理对象, args);
        }
    }
    1. 执行被代理对象的任何接口方法时，都会经过invoke();
    2. proxy：代理对象的引用;
    3. method：当前执行的方法;
    4. args：当前执行方法所需的参数;
    5. invoke()的返回值，将作为被代理对象的方法的返回值.
5. 生产商Producer，生产商的准则IProducer(代理商对生产商的要求)
    public interface IProducer {
        void sale(float money);
        void after(float money);
    }
    public class Producer implements IProducer {
        public void sale(float money) {  //销售
            System.out.println(&quot;生产商销售产品，拿到钱：&quot; + money);
        }
        public void after(float money) {  //售后
            System.out.println(&quot;生产商提供售后，拿到钱：&quot; + money);
        }
    }
6. 消费者Client
    final Producer p = new Producer();
    1. 创建动态代理
    IProducer proxyProducer = (IProducer)Proxy.newProxyInstance(
            p.getClass().getClassLoader(), p.getClass().getInterfaces(), 
        new InvocationHandler() {
            public Object invoke(Object proxy, Method method, Object[] args) {
                Object leftMoney = null;
                Float money = (Float)args[0];
                if(&quot;sale&quot;.equals(method.getName())) {
                    //购买时，代理商提取20%的回扣
                    leftMoney = method.invoke(p, money*0.8f);
                }
                return leftMoney;
            }
        });
    2. 消费者通过代理对象实现购买与服务
    proxyProducer.sale(10000f);  //生产商销售产品，拿到钱：8000
</code></pre><h3 id="基于子类的动态代理"><a href="#基于子类的动态代理" class="headerlink" title="基于子类的动态代理"></a>基于子类的动态代理</h3><pre><code>1. 为一个普通的类创建动态代理：
    1. 被代理的类不能是最终类(final class XXX)，因为它不能再创建子类；
    2. 借助第三方cglib库，Enhancer.create()
    &lt;dependency&gt;
        &lt;groupId&gt;cglib&lt;/groupId&gt;
        &lt;artifactId&gt;cglib&lt;/artifactId&gt;
        &lt;version&gt;3.2.10&lt;/version&gt;
    &lt;/dependency&gt;
2. Enhancer.create(Class, Callback)
    1. Class：被代理对象的字节码；
    2. Callback：提供增强的代码，通常使用其子类，如MethodInterceptor
3. 生产商Producer
    public class Producer {
        public void sale(float money) {  //销售
            System.out.println(&quot;生产商销售产品，拿到钱：&quot; + money);
        }
        public void after(float money) {  //售后
            System.out.println(&quot;生产商提供售后，拿到钱：&quot; + money);
        }
    }
4. 消费者Client
    final Producer p = new Producer();
    1. 创建代理对象
    Producer proxyProducer = (Producer)Enhancer.create(p.getClass(), 
        new MethodInterceptor() {
            public Object intercept(Object proxy, Method method, Object[] args, 
                MethodProxy methodProxy) throws Throwable {
                Object leftMoney = null;
                Float money = (Float)args[0];
                if(&quot;sale&quot;.equals(method.getName())) {
                    leftMoney = method.invoke(p, money*0.8f);
                }
                return leftMoney;
            }
        });
    2. 执行被代理对象的方法时，也都会经过intercept()
    3. methodProxy：当前执行方法的代理对象.
</code></pre><h3 id="动态代理控制事务"><a href="#动态代理控制事务" class="headerlink" title="动态代理控制事务"></a>动态代理控制事务</h3><pre><code>1. 分离Service中控制事务的部分，交给代理对象去控制事务;
    public AccountServiceImpl implements IAccountService {
        private IAccountDao dao;
        ......//setter
        public List&lt;Account&gt; findAll() {
            return dao.findAll();
        }
        public Account findByName(String name) {
            return dao.findByName(name);
        }
        public void update(Account account) {
            dao.update(account);
        }
        ......
    }
2. 创建Service的代理对象的工厂
    public class BeanFactory {
        private IAccountService service;
        private TransactionManager manager;
        ......//setter
        public IAccountService getAccountService() {
            return (IAccountService) Proxy.newProxyInstance(
            service.getClass().getClassLoader(), service.getClass().getInterfaces(), 
            new InvocationHandler(){
                public Object invoke(Object proxy, Method method, Object[] args)  {
                    object rtValue = null;
                    try { //增强方法: 在执行Service的方法时, 加入事务
                        manager.beginTransaction();
                        rtValue = method.invoke(service, args);
                        manager.commit();
                        return rtValue;
                    } catch(Exception e) {
                        manager.rollback();
                        throw new RuntimeException(e);
                    } finally {
                        manager.release();
                    }
                }
            });
        }
    }
3. 在 bean.xml 中，修改&lt;bean&gt;的关系，并配置工厂类BeanFactory
    &lt;bean id=&quot;proxyService&quot; factory-bean=&quot;beanFactory&quot; factory-method=&quot;getAccountService&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;beanFactory&quot; class=&quot;it.bank.factory.BeanFactory&quot;&gt;
        &lt;property name=&quot;service&quot; ref=&quot;accountService&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;manager&quot; ref=&quot;connUtils&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;accountService&quot; class=&quot;it.bank.service.impl.AccountServiceImpl&quot;&gt;
        &lt;property name=&quot;dao&quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    ...... //accountDao、connUtils、manager、runner、dataSource
    1. 此时的容器中，有两个类型相同的bean对象：proxyService、accountService
    2. 那么在注入使用时，需要明确指定使用代理对象创建的Service Bean对象
        @Autowired
        @Qualifier(&quot;proxyService&quot;)
        private IAccountService service;
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/03/06/Spring注解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/06/Spring注解/" itemprop="url">Spring注解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-06T00:00:00+08:00">
                2016-03-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="IoC注解"><a href="#IoC注解" class="headerlink" title="IoC注解"></a>IoC注解</h2><pre><code>1. @Component：创建对象，&lt;bean&gt;标签的功能，把类对象存入Spring容器中
    @Component(&quot;userService&quot;)  ---&gt;@Component(value=&quot;userService&quot;)
    public class UserServiceImpl implements IUserService {
        ......
    }
    1. value属性就是Bean对象的id，如果直接使用 @Component，而不指定value，则默认id为
    首字母小写的类名userServiceImpl;
    2. 在配置文件 bean.xml 中导入context命名空间和约束，并告知Spring扫描哪个包下的注解
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
        &lt;!-- 告知Spring在创建容器时要扫描的包 --&gt;
        &lt;context:component-scan base-package=&quot;项目的包名&quot;&gt;&lt;/context:component-scan&gt;
    &lt;/beans&gt;
    3. 通过注解创建对象
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
    IUserService us = (IUserService)ac.getBean(&quot;userService&quot;);
2. Spring为了三层架构更加清晰, 还有三个与 Component 功能相同的衍生注解
    1. Controller：一般用于表现层；
    2. Service：一般用于表现层；
    3. Repository：一般用在持久层。
3. Scope：指定Bean对象的作用范围，同&lt;bean&gt;上的scope属性；
    1. value属性：指定取值范围;
    2. 常用取值：singleton、prototype.
4. 生命周期相关
    1. PreDestroy：指定销毁方法，&lt;bean&gt;上的destroy-method;
    2. PostConstruct：指定初始化方法，&lt;bean&gt;上的init-method;
        @Component(&quot;userService&quot;)
        @Scope(&quot;prototype&quot;)  --------&gt;指定为多例
        public class UserServiceImpl implements IUserService {
            @PostConstruct
            public void init() {
                ......//Bean的初始化
            }
            @PreDestroy
            public void destroy() {
                ......//Bean的销毁
            }
        }
</code></pre><h3 id="注入数据的注解"><a href="#注入数据的注解" class="headerlink" title="注入数据的注解"></a>注入数据的注解</h3><pre><code>1. Autowired：自动按照类型注入；
    1. 只要容器中有唯一的一个Bean对象与要注入的变量类型匹配，就可以注入成功；
    2. 可以用在变量上，也可以用在方法上；
    @Repository(&quot;userDao&quot;)
    public class UserDaoImpl implements IUserDao {
        public void saveUser() { ... }
    }
    @Service(&quot;userService&quot;)
    public class UserServiceImpl implements IUserService {
        @Autowired
        private IUserDao dao;
        public void saveUser() {
            dao.saveUser();
        }
    }
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
    //指定getBean()的第二个参数，则不需要再强转类型
    IUserService us = ac.getBean(&quot;userService&quot;, IUserService.class);
    us.saveUser();  //内部可以调用Dao对象的方法，dao不再是null
    3. 如果IoC有多个匹配的Bean对象，Spring会取出这些Bean对象的id，然后使用变量名与这些id
    进行匹配，有则匹配，否则报错；
        @Repository(&quot;userDao1&quot;)
        public class UserDao1Impl implements IUserDao {
            public void saveUser() { ... }
        }
        @Repository(&quot;userDao2&quot;)
        public class UserDao2Impl implements IUserDao {
            public void saveUser() { ... }
        }
        @Service(&quot;userService&quot;)
        public class UserServiceImpl implements IUserService {
            @Autowired
            private IUserDao userDao2;  //与 UserDao2Impl 相匹配
            ......
        }
    4. 不再需要setter
2. Qualifier：在按照类中注入的基础上，再按照名称注入；
    1. 在给类成员注入时，不能单独使用; 但给方法参数注入时，可以单独使用;
    2. 属性value：指定注入Bean对象的id;
    @Service(&quot;userService&quot;)
    public class UserServiceImpl implements IUserService {
        @Autowired
        @Qualifier(&quot;userDao2&quot;)  --&gt; 注入 UserDao2Impl 对象
        private IUserDao dao;
        ......
    }
3. Resource：直接按照Bean的id注入，且可以单独使用，属性name用于指定注入Bean的id
    @Resource(name=&quot;userDao2&quot;)
    private IUserDao dao;
4. 这三种注解都只能注入Bean类型的数据，不能注入基本数据类型，且集合类型只能使用XML实现注入;
5. Value：用于注入基本数据类型，属性value用于指定数据的值；
    1. 它可以使用Spring的SpEL(Spring的EL表达式);
    2. SpEL的写法：${表达式}，虽然与JSP的EL表达式写法相同，但出现的位置并不相同；
</code></pre><h2 id="Spring整合数据库操作"><a href="#Spring整合数据库操作" class="headerlink" title="Spring整合数据库操作"></a>Spring整合数据库操作</h2><pre><code>1. Dbutils：由Apache提供，主要封装了JDBC，简化Dao层的操作，又不会影响性能；
    1. 三个核心类：DbUtils、QueryRunner、ResultSetHandle
    2. DbUtils：连接数据库对象，控制连接，jdbc辅助方法的集合类，线程安全；
    3. QueryRunner：SQL语句的操作对象，线程安全；
        1. QueryRunner()：无参构造，创建一个与数据库无关的QueryRunner对象，需要提供一个
        Connection对象，它可以手动控制事务;
            Connection.setAutoCommit(false); //设置手动管理事务
            Connection.commit(); //手动提交事务
        2. QueryRunner(DataSource ds)：有参构造，创建一个与数据库关联的对象，不需要提供
        Connection对象，自动管理事务;
        3. DataSource：数据库连接池对象，由c3p0提供;
        4. update()：用于执行DDL(create、alter、drop);
        5. query()：用于执行DML(insert、update、delete);
        6. batch()：执行批处理.
    4. ResultSetHandle：封装数据的策略对象，将封装结果集中的数据转换到另一个对象。
2. c3p0：连接池，为了提高应用程序与数据库之间的访问效率，简单易用、连接复用、连接管理;
3. 引入依赖：spring-context、commons-dbutils、c3p0、mysql-connector-java
4. 持久层、业务层
    1. 实体类：com.test.domain.User
        public class User {
            //id、name、age
        }
    2. 持久层Dao：com.test.dao.IUserDao
        public interface IUserDao {
            //CRUD
        }
        public class UserDaoImpl implements IUserDao {
            private QueryRunner runner;
            //setter
            public List&lt;User&gt; findAll() { //查询所有
                return runner.query(&quot;select * from user&quot;, 
                            new BeanListHandler&lt;User&gt;(User.class));
            }
            public List&lt;User&gt; findById(int id) { //查询一个
                return runner.query(&quot;select * from user where id=?&quot;, 
                                    new BeanHandler&lt;User&gt;(User.class), id);
            }
            public void save(User u) { //保存
                runner.update(&quot;insert into user(name, age) values(?, ?)&quot;, 
                                                    u.getName(), u.getAge());
            }
            public void update(User u) { //更新
                runner.update(&quot;update user set name=?,age=? where id=?&quot;, 
                                        u.getName(), u.getAge(), u.getId());
            }
            public void delete(int id) { //删除
                runner.update(&quot;delete from user where id=?&quot;, id);
            }
        }
3. 业务层Service：com.test.service.IUserService
    public interface IUserService { ...... }
    public class UserServiceImpl implements IUserService {
        private IUserDao dao;
        //setter
        ......
    }
4. 配置Spring：resources/bean.xml
    &lt;bean id=&quot;userService&quot; class=&quot;com.test.service.impl.UserServiceImpl&quot;&gt;
        &lt;property name=&quot;dao&quot; ref=&quot;userDao&quot;&gt;&lt;property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.test.dao.impl.UserDaoImpl&quot;&gt;
        &lt;property name=&quot;runner&quot; ref=&quot;runner&quot;&gt;&lt;property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;runner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot; scope=&quot;prototype&quot;&gt;
        &lt;constructor-arg name=&quot;ds&quot; ref=&quot;dataSource&quot;&gt;&lt;/constructor-arg&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
        &lt;!-- 链接数据库的信息 --&gt;
        &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:......&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    1. QueryRunner设置为多例对象，避免多线程之间相互干扰;
    2. 开始使用：
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
    IUserService service = ac.getBean(&quot;userService&quot;, IUserService.class);
    List&lt;User&gt; us = service.findAll(); //查询所有
6. 修改为注解配置
    1. 在 bean.xml 的约束中，增加context的命名空间；
    2. 移除UserServiceImpl和UserDaoImpl的&lt;bean&gt;，告知Spring创建容器时要扫描的包；
    &lt;context:component-scan base-package=&quot;com.test&quot;&gt;&lt;/context:component-scan&gt;
    &lt;bean id=&quot;runner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot; scope=&quot;prototype&quot;&gt;
        &lt;constructor-arg name=&quot;ds&quot; ref=&quot;dataSource&quot;&gt;&lt;/constructor-arg&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
        ...... &lt;!-- 链接数据库的信息 --&gt;
    &lt;/bean&gt;
    3. 为 UserServiceImpl和UserDaoImpl 添加注解，并移除其中的setter.
        @Repository(&quot;userDao&quot;)
        public class UserDaoImpl implements IUserDao {
            @Autowired
            private QueryRunner runner;
            ......
        }
        @Service(&quot;userService&quot;)
        public class UserServiceImpl implements IUserService {
            @Autowired
            private IUserDao dao;
            ......
        }
</code></pre><h3 id="Spring新注解"><a href="#Spring新注解" class="headerlink" title="Spring新注解"></a>Spring新注解</h3><pre><code>1. Configuration：声明一个类为配置类，用于取代配置文件 bean.xml;
2. ComponentScan：指定创建容器时要扫描的包;
    1. value属性和basePackages属性的作用相同，都是指定包名;
    2. 此注解的功能等同于 bean.xml 中的 &lt;context:component-scan&gt;
3. Bean：把当前方法的返回值作为bean对象，存入Spring的IoC容器中;
    1. name属性：指定bean的id，不显式声明id时，默认为当前方法名;
    2. 此注解可以取代&lt;bean id=&quot;runner&quot; ···&gt; 和 &lt;bean id=&quot;dataSource&quot; ···&gt;
    3. @Scope：指定bean对象的作用范围;
        @Configuration
        @ComponentScan(basePackages=&quot;com.test&quot;)
        public class SpringConfiguration {
            @Bean(name=&quot;runner&quot;)
            @Scope(&quot;prototype&quot;)
            public QueryRunner createQueryRunner(DataSource dataSource) {
                return new QueryRunner(dataSource);
            }
            @Bean(name=&quot;dataSource&quot;)
            public DataSource createDataSource() {
                ComboPooledDataSource ds = new ComboPooledDataSource();
                ds.setDriverClass(&quot;com.mysql.cj.jdbc.Driver&quot;);
                ds.setJdbcUrl(&quot;jdbc:mysql:......&quot;);
                ds.setUser(&quot;root&quot;);
                ds.setPassword(&quot;123456&quot;);
                return ds;
            }
        }
    4. 在使用注解配置方法时，如果方法上有参数(也是bean对象)，Spring会去容器中查找有没有
    与此参数对应的bean对象，查找方式与Autowired相同;
        1. 如果有且只有一个匹配的bean对象，则匹配成功;
        2. 如果有多个匹配的bean对象，则根据参数名与bean的id进行匹配.
    5. 另外，方法的参数上可以单独使用 @Qualifier，明确指定要匹配的bean对象;
    @Bean(name=&quot;runner&quot;)
    @Scope(&quot;prototype&quot;)
    public QueryRunner createQueryRunner(@Qualifier(&quot;ds2&quot;) DataSource dataSource) {
        return new QueryRunner(dataSource);
    }
    @Bean(name=&quot;ds1&quot;)
    public DataSource createDataSource() { ... }

    @Bean(name=&quot;ds2&quot;)
    public DataSource createDataSource() { ... }
    6. @Qualifier(&quot;ds2&quot;) 指定去匹配 @Bean(name=&quot;ds2&quot;) 的方法.
4. 使用 AnnotationConfigApplicationContext 加载配置类，获取bean对象
    ApplicationContext ac = 
        new AnnotationConfigApplicationContext(SpringConfiguration.class);
    IUserService service = ac.getBean(&quot;userService&quot;, IUserService.class);
</code></pre><h3 id="分解注解类"><a href="#分解注解类" class="headerlink" title="分解注解类"></a>分解注解类</h3><pre><code>1. 为了便于管理，一个主配置类可以分为多个子配置类，如把JDBC相关的配置放在 JdbcConf类 中;
    @Configuration
    public class JdbcConf {   //全类名为config.JdbcConf
        @Bean(name=&quot;runner&quot;)
        @Scope(&quot;prototype&quot;)
        public QueryRunner createQueryRunner(DataSource ds) { ... }
        @Bean(name=&quot;ds&quot;)
        public DataSource createDataSource() { ... }
    }
2. 在主配置类中声明要扫描的包，包括子配置文件所在的包
    @Configuration
    @ComponentScan({&quot;com.test&quot;, &quot;config&quot;})
    public class SpringConfiguration { }
3. 在创建ApplicationContext对象时，如果直接把配置类作为参数，则可省略 @Configuration，
   也不需要扫描配置类所在的包；
    public class JdbcConf { ... }

    @ComponentScan({&quot;com.test&quot;})
    public class SpringConfiguration { }

    ApplicationContext ac = new AnnotationConfigApplicationContext(
                                    SpringConfiguration.class, JdbcConf.class);
4. Import：导入其他的配置类
    1. 被导入的配置类上可以使用 @Configuration，也可以不声明它所在的包;
    public class JdbcConf { ... }

    @ComponentScan({&quot;com.test&quot;})
    @Import(JdbcConf.class)
    public class SpringConfiguration { }

    ApplicationContext ac = 
            new AnnotationConfigApplicationContext(SpringConfiguration.class);
    2. 此时，SpringConfiguration称为父配置类，JdbcConf称为子配置类
5. PropertySource：加载properties文件;
    1. value属性：指定文件的名称和路径;
    2. classpath关键字：表示类路径下;
        resources/spring/conf/jdbc.properties ---&gt; 
                    @PropertySource(&quot;classpath:spring/conf/jdbc.properties&quot;)
6. 抽取出数据库连接的信息
    1. 在resources目录下创建 jdbcConf.properties
        jdbc.driver = com.mysql.cj.jdbc.Driver
        jdbc.url = jdbc:mysql:......
        jdbc.user = root
        jdbc.password = 123456
    2. 在主配置文件上使用 PropertySource 注解引入properties文件
        @ComponentScan({&quot;com.test&quot;})
        @Import(JdbcConf.class)
        @PropertySource(&quot;classpath:jdbcConf.properties&quot;)
        public class SpringConfiguration { }
    3. 在子配置类JdbcConf 中使用Spring的EL表达式，获取properties中的key-value值
        public class JdbcConf {
            @Value(&quot;${jdbc.driver}&quot;)
            private String driver;

            @Value(&quot;${jdbc.url}&quot;)
            private String url;

            @Value(&quot;${jdbc.user}&quot;)
            private String user;

            @Value(&quot;${jdbc.password}&quot;)
            private String password;

            @Bean(name=&quot;dataSource&quot;)
            public DataSource createDataSource() {
                ComboPooledDataSource ds = new ComboPooledDataSource();
                ds.setDriverClass(driver);
                ds.setJdbcUrl(url);
                ds.setUser(user);
                ds.setPassword(password);
                return ds;
            }
            ......
        }
</code></pre><h2 id="Spring整合Junit"><a href="#Spring整合Junit" class="headerlink" title="Spring整合Junit"></a>Spring整合Junit</h2><pre><code>1. Junit单元测试中没有直接提供main()，是因为它集成了一个main()
    1. Junit会判断测试类中有哪些方法上使用了 @Test;
    2. Junit main()只会执行有 @Test 的方法.
2. Junit并不关心Spring框架;
    1. 在执行测试方法时，Junit也不会关心Spring的配置文件/配置类，更不会创建IoC容器;
    2. 没有IoC容器，在测试类中使用 @Autowired，也无法实现注入.
3. spring-test：Spring整合junit测试框架; 加入依赖：spring-test、junit
4. @RunWith：Junit提供的注解，把 main() 替换成Spring提供的;
5. @ContextConfiguration：告知Spring的运行器，创建IoC容器使用的是XML还是注解，并指定其位置;
    1. locations属性：指定XML文件的位置，使用classpath关键字，表示在类路径下;
        @ContextConfiguration(locations=&quot;classpath:bean.xml&quot;)
    2. classes属性：指定注解类所在的位置；
    @RunWith(SpringJUnit4ClassRunner.class)
    @ContextConfiguration(classes=SpringConfiguration.class)
    public class UserTest {
        @Autowired
        private IUserService service;

        @Test
        public void testFindAll() {
            List&lt;User&gt; us = service.findAll();
        }
    }
6. 另外，Spring5.x版本时，junit的版本必须为4.12+
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/03/05/Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/05/Spring/" itemprop="url">Spring</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-05T00:00:00+08:00">
                2016-03-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><pre><code>1. Spring是分层的JavaSE/EE应用full-stack(全栈)轻量级开源框架;
    1. 目的是解决企业级应用开发的复杂性，简化Java开发，适用于任何Java应用;
    2. Spring的成功来源于理念，而不是技术本身，以IoC(控制反转)和AOP(面向切面编程)为核心;
    3. 优势：.
2. 发展历程
    1. 1997年IBM提出了EJB的思想，1998年SUN制定并开发EJB1.0;
    2. Spring之父Rod Johnson，2002年阐述了J2EE使用EJB开发设计的优点及解决方案;
    3. 2004年Rod Johnson阐述了J2EE不使用EJB的解决方案，也就是Spring的雏形；
    4. 2017年9月发布了Spring的最新版Spring5.0通用版(GA).
3. 优势：低侵入/低耦合、声明式事务管理、无缝集成其他框架、降低Java开发难度
    1. 解耦：IoC容器可以将对象间的依赖关系交由Spring控制，降低耦合，专注于上层应用；
    2. AOP编程：Spring的AOP功能让许多传统OOP难以实现的功能，更加容易；
    3. 声明式事务管理：使用配置文件取代单调烦闷的事物管理；
    4. 方便程序的测试：可以用非容器依赖的编程方式，实现几乎所有的测试工作；
    5. 方便集成各种优秀的框架，提供直接支持，降低框架的使用难度；
    6. Spring对JavaEE API进行了一层简单的封装，但却大为降低了API的使用难度。
4. Spring Framework Runtime 体系结构
</code></pre><p><img src="//hellomyshadow.github.io/2016/03/05/Spring/framework.jpg" alt="Spring"></p>
<pre><code>1. Core Container：核心容器，Spring的IoC容器，其他部分的运行必须依赖于核心容器；
2. 核心容器的上面一层是AOP相关的部分；
3. Data Access：持久层解决方案；
4. Test：单元测试，也依赖于核心容器才能运行。
</code></pre><h2 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h2><pre><code>1. 耦合：程序间的依赖关系，包括类之间的依赖、方法间的依赖；
2. 解耦：降低程序间的依赖关系，应做到编译期不依赖，运行时才依赖；
</code></pre><h3 id="类之间的依赖"><a href="#类之间的依赖" class="headerlink" title="类之间的依赖"></a>类之间的依赖</h3><pre><code>1. 以装载数据库的驱动为例
    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);
    DriverManager.registerDriver(new com.mysql.cj.jdbc.Driver());
    1. 这两种方式都可以装载驱动，但第一种装载是通过字符串，第二种需要使用具体的类；
    2. 如果当前没有MySQL的相关依赖包，那么第二种在运行时就会报错，这就是类之间的依赖；
    3. 而且，如果切换成装载Oracle驱动，仍需要去修改全限定类名的字符串。
2. 解耦的思路
    1. 使用反射来创建对象，避免使用 new 关键字；
    2. 通过读取配置文件来获取类的全限定类名。
</code></pre><h3 id="工厂模式解耦"><a href="#工厂模式解耦" class="headerlink" title="工厂模式解耦"></a>工厂模式解耦</h3><pre><code>1. 非解耦的持久层Dao与业务层Service
    1. Dao接口及其实现类
        public interface IUserDao {
            void save(User u);
        }
        public class UserDaoImpl implements IUserDao {
            public void save(User u) {
                //连接数据库，插入一条记录
            }
        }
    2. Service接口及其实现类
        public interface IUserService {
            void save(User u);
        }
        public class UserServiceImpl implements IUserService {
            private IUserDao dao = new UserDaoImpl();
            public void save(User u) {
                ......//before
                dao.save(u);  //调用Dao的方法
                ......//after
            }
        }
    3. App调用Service
        IUserService service = new UserServiceImpl();
        service.save(new User());
2. 工厂模式解耦
    1. 在resource目录下创建配置文件，如bean.properties，配置Dao与Service的实现类；
        userService = it.demo.cn.service.impl.UserServiceImpl
        userDao = it.demo.cn.dao.impl.UserDaoImpl
    2. Bean工厂：用于反射创建/生产Service和Dao的对象；
        public class BeanFactory {
            private static Properties prop;
            static {
                try {
                    prop = new Properties();
                    //使用类加载器获取resources目录下的文件
                    InputStream is = BeanFactory.class.getClassLoader()
                                    .getResourceAsStream(&quot;bean.properties&quot;);
                    prop.load(is);
                } catch (Exception e) {
                    throw new ExceptionInInitializerError(&quot;初始化配置文件失败！&quot;);
                }
            }
            public static Object getBean(String beanName) {
                //根据Bean的名称获取Bean对象
                String beanPath = prop.getProperty(beanName);
                Object bean = Class.forName(beanPath).newInstance();
                return bean;
            }
        }
    3. 通过Bean工厂创建Dao对象和Service对象
        public class UserServiceImpl implements IUserService {
            private IUserDao dao = (IUserDao) BeanFactory.getBean(&quot;userDao&quot;);
            public void save(User u) {
                dao.save(u);
            }
        }
    IUserService service = (IUserService) BeanFactory.getBean(&quot;userService&quot;);
    service.save(new User());
3. 但是，这种方式并不能保证Dao和Service对象的单例，需要在Bean工厂中增加一个Map结构的容器，
   存储Dao和Service的对象；
    public class BeanFactory {
        private static Properties prop;
        private static Map&lt;String, Object&gt; beans;  //Map结构的容器
        static {
            try {
                prop = new Properties();
                InputStream is = BeanFactory.class.getClassLoader()
                                .getResourceAsStream(&quot;bean.properties&quot;);
                prop.load(is);
                beans = new HashMap&lt;String, Object&gt;();  //实例化容器
                Enumeration keys = prop.keys();  //取出配置文件中的所有key
                while (keys.hasMoreElements()) {
                    //事先创建好配置文件中的对象，存入容器，作为单例对象使用
                    String k = keys.nextElement().toString();
                    String beanPath = prop.getProperty(k);
                    Object val = Class.forName(beanPath).newInstance();
                    beans.put(k, val);
                }
            } catch (Exception e) {
                throw new ExceptionInInitializerError(&quot;初始化配置文件失败！&quot;);
            }
        }
        public static Object getBean(String beanName) {
            //直接返回容器中的Bean对象
            return beans.get(beanName);
        }
    }
</code></pre><h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><pre><code>private IUserDao dao = new UserDaoImpl(); 与
private IUserDao dao = (IUserDao) BeanFactory.getBean(&quot;userDao&quot;);
-----------------------------------------------------------------
IUserService service = new UserServiceImpl(); 与
IUserService service = (IUserService) BeanFactory.getBean(&quot;userService&quot;);
1. 与new创建对象相比，通过Bean工厂创建对象，切断了App与资源(Dao/Service)的直接联系，
   交由Bean工厂控制资源、提供资源，这就是IoC;
2. 之所以称为IoC，而不叫降低解耦，是因为把对象控制的权力交给了工厂(框架)，控制反转不再是
   面向对象编程的专业术语;
3. IoC包括依赖注入(DI)和依赖查找(DL);
4. IoC的作用：消减计算机程序的耦合，并不能完全消除.
</code></pre><h3 id="Spring的IoC"><a href="#Spring的IoC" class="headerlink" title="Spring的IoC"></a>Spring的IoC</h3><pre><code>1. 添加Spring的IoC依赖
    &lt;packaging&gt;jar&lt;/packaging&gt;  ---&gt;项目的打包方式为jar
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.1.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
2. 在resources目录下创建配置文件，bean.xml
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
        &lt;!--把对象的创建交给Spring来管理--&gt;
        &lt;bean id=&quot;userService&quot; class=&quot;cn.test.service.impl.UserServiceImpl&quot;&gt;&lt;/bean&gt;
        &lt;bean id=&quot;userDao&quot; class=&quot;cn.test.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;
    &lt;/beans&gt;
3. 获取Spring的IoC核心容器，根据id获取对象
    //1. 解析配置文件，获取核心容器对象
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
    //2. 根据id获取Bean对象
    IUserDao dao = (IUserDao) ac.getBean(&quot;userDao&quot;);
    IUserService service = ac.getBean(&quot;userService&quot;, IUserService.class);
4. ApplicationContext的三个常用实现类
    1. ClassPathXmlApplicationContext：加载类路径下的配置文件，配置文件必须在类路径下;
    2. FileSystemXmlApplicationContext：加载磁盘任意路径下的配置文件，必须有访问权限;
        new ClassPathXmlApplicationContext(&quot;D:\\workplace\\test\\bean.xml&quot;);
    3. AnnotationConfigApplicationContext：用于读取注解类创建的容器.
        new AnnotationConfigApplicationContext(XXXConfig.class);
5. Spring中，ApplicationContext与BeanFactory的区别
    1. ApplicationContext：它在构建核心容器时，会立即创建Bean对象，即一旦读取完配置文件，
    立即创建文件中配置的对象；
    2. BeanFactory：它是顶层接口，采用延迟加载的方式创建Bean对象，即在根据id获取对象时，
    才真正的创建Bean对象；
        Resource res = new ClassPathResource(&quot;bean.xml&quot;);
        BeanFactory factory = new XmlBeanFactory(res);
        IUserDao dao = (IUserDao) factory.getBean(&quot;userDao&quot;);
    3. ApplicationContext适用于单例对象，BeanFactory适用于多例对象。
</code></pre><h3 id="Spring对Bean的管理"><a href="#Spring对Bean的管理" class="headerlink" title="Spring对Bean的管理"></a>Spring对Bean的管理</h3><pre><code>1. 创建Bean的三种方式
    1. 使用默认构造函数创建，&lt;bean&gt;上只有id和class属性，此时类中必须要有默认构造函数，
    否则无法创建Bean对象;
    &lt;bean id=&quot;userService&quot; class=&quot;cn.test.service.impl.UserServiceImpl&quot;&gt;&lt;/bean&gt;
    2. 使用普通工厂中的方法创建Bean对象，并存入Spring的IoC容器;
        public class ServiceFactory {  //工厂类
            public IUserService getUserService() {
                return new UserServiceImpl();
            }
        }
    &lt;bean id=&quot;servFac&quot; class=&quot;cn.test.factory.ServiceFactory&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;userService&quot; factory-bean=&quot;servFac&quot; -----&gt;&gt;引用id为servFac的&lt;bean&gt;
                            factory-method=&quot;getUserService&quot;&gt;&lt;/bean&gt;
        //创建Bean对象
        IUserService service = (IUserService) ac.getBean(&quot;userService&quot;);
    3. 使用工厂中的静态方法创建对象
        public class ServiceFactory {  //工厂类
            public static IUserService getUserService() {
                return new UserServiceImpl();
            }
        }
    &lt;bean id=&quot;userService&quot; class=&quot;cn.test.service.factory.ServiceFactory&quot; 
                                    factory-method=&quot;getUserService&quot;&gt;&lt;/bean&gt;
    //创建Bean对象
    IUserService service = (IUserService) ac.getBean(&quot;userService&quot;);
2. Bean的作用范围
    1. Bean对象默认就是单例的;
        IUserService us1 = (IUserService) ac.getBean(&quot;userService&quot;);
        IUserService us2 = (IUserService) ac.getBean(&quot;userService&quot;);
        us1==us2;  --&gt;true
    2. &lt;bean&gt;的 scope 属性：用于指定bean的作用范围;
        1. singleton：默认值，单例;
        2. prototype：多例，每次 getBean() 时，Spring就会创建一个新的对象;
        3. request：作用于web应用的请求范围;
        4. session：作用于web应用的会话范围;
        5. global-session：作用于集群环境的全局会话范围，如果不是集群，等效于session.
3. Bean的生命周期
    &lt;bean id=&quot;userService&quot; class=&quot;cn.test.service.impl.UserServiceImpl&quot; 
        init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt;&lt;/bean&gt;
    1. init-method=&quot;init&quot;：指定Bean对象的初始化方法，UserServiceImpl.init();
    2. destory-method=&quot;destroy&quot;：指定Bean对象的销毁方法，UserServiceImpl.destory();  
    3. 单例对象：随着容器的创建而创建，随着容器的消亡而消亡;
        //1. 获取核心容器对象：执行 UserServiceImpl.init()
        ClassPathXmlApplicationContext ac = 
                new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
        //2. 根据id获取Bean对象
        IUserService service = (IUserService) ac.getBean(&quot;userService&quot;);
        //3. 手动销毁容器：执行 UserServiceImpl.destroy()
        ac.close();
    4. 多例对象：scope=&quot;prototype&quot;，每次使用对象时由Spring创建，但Spring无法控制销毁，
    只能由Java垃圾回收器销毁.
</code></pre><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><pre><code>1. IoC降低了程序间的耦合(依赖关系)，一个类需要引用另一个类对象时，我们只需要在Spring的
   配置文件中说明两个类的依赖关系，交由Spring去维护这种依赖关系，这就是依赖注入;
2. 能注入的数据：基本类型、Bean对象(在配置文件中或者注解配置过的bean)、复杂/集合类型;
3. 注入的三种方式：使用构造函数、setter、注解
</code></pre><h4 id="构造函数注入"><a href="#构造函数注入" class="headerlink" title="构造函数注入"></a>构造函数注入</h4><pre><code>public class UserServiceImpl implements IUserService {
    private String name;  //基本类型
    private int age;
    private Date birthday;  //对象
    private IUserDao dao;
    public UserServiceImpl(String name, int age, Date birthday, IUserDao dao){
        this.name = name;  this.age = age;
        this.birthday = birthday;  this.dao = dao;
    }
}
1. 使用&lt;bean&gt;的子标签 &lt;constructor-arg&gt;，相关属性：
    1. type：注入数据的类型，也就是构造函数上的某个参数类型;
    2. index: 参数的索引位置，从 0 开始;
    3. name：参数名称;
    4. value：参数值，提供基本数据类型的数据;
    5. ref：参数值，引用另一个&lt;bean&gt;对象的数据;
    &lt;bean id=&quot;userService&quot; class=&quot;cn.test.service.impl.UserServiceImpl&quot;&gt;
        &lt;constructor-arg name=&quot;name&quot; value=&quot;Java&quot;&gt;&lt;constructor-arg&gt;
        &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;constructor-arg&gt;
        &lt;constructor-arg name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;constructor-arg&gt;
        &lt;constructor-arg name=&quot;dao&quot; ref=&quot;userDao&quot;&gt;&lt;/constructor-arg&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;cn.test.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;
2. 弊端：这种方式只能匹配一个固定的构造函数，改变了Bean对象的实例化方式，在创建对象时，
   即使用不到这些数据，也必须提供，否则Spring无法创建对象.
</code></pre><h4 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h4><pre><code>public class UserServiceImpl implements IUserService {
    private String name;  //基本类型
    private int age;
    private Date birthday;  //对象
    private IUserDao dao;
    //setter是必须的，可以没有getter
}
1. 使用&lt;bean&gt;的子标签 &lt;property&gt;，相关属性：
    1. name：setter的方法名，取set后的字母、并把首字母转为小写;
        age--&gt;setUserAge()--&gt;userAge，
    2. value、ref
    &lt;bean id=&quot;userService&quot; class=&quot;cn.test.service.impl.UserServiceImpl&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;Java&quot;&gt;&lt;property&gt;
        &lt;property name=&quot;age&quot; value=&quot;20&quot;&gt;&lt;property&gt;
        &lt;property name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;property&gt;
        &lt;property name=&quot;dao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;cn.test.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;
2. 这种方式解决了构造函数注入的弊端，创建对象时没有明确的限制，直接使用默认构造函数;
3. 弊端：如果某个成员必须有值(构造函数被重载，存在有参构造函数)，获取对象时可能没有配置
   此成员的setter，导致此成员没有值.
</code></pre><h4 id="复杂类型-集合对象的注入"><a href="#复杂类型-集合对象的注入" class="headerlink" title="复杂类型/集合对象的注入"></a>复杂类型/集合对象的注入</h4><pre><code>public class UserServiceImpl implements IUserService {
    private String[] myArr;  //数组
    private List&lt;String&gt; myList;  //List集合
    private Set&lt;String&gt; mySet;  //Set集合
    private Map&lt;String, String&gt; myMap;  //Map集合
    private Properties myProp;  //Properties
    //setter是必须的
}
1. 使用&lt;property&gt;的子标签
    &lt;bean id=&quot;userService&quot; class=&quot;cn.test.service.impl.UserServiceImpl&quot;&gt;
        &lt;property name=&quot;myArr&quot;&gt;
            &lt;array&gt;
                &lt;value&gt;AAA&lt;/value&gt;
                &lt;value&gt;BBB&lt;/value&gt;
            &lt;/array&gt;
        &lt;property&gt;
        &lt;property name=&quot;myList&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;AAA&lt;/value&gt;
                &lt;value&gt;BBB&lt;/value&gt;
            &lt;/list&gt;
        &lt;property&gt;
        &lt;property name=&quot;mySet&quot;&gt;
            &lt;set&gt;
                &lt;value&gt;AAA&lt;/value&gt;
                &lt;value&gt;BBB&lt;/value&gt;
            &lt;/set&gt;
        &lt;property&gt;
        &lt;property name=&quot;myMap&quot;&gt;
            &lt;map&gt;
                &lt;!-- 两种配置key-value的方式 --&gt;
                &lt;entry key=&quot;testA&quot; value=&quot;AAA&quot;&gt;&lt;/entry&gt;
                &lt;entry key=&quot;testB&quot;&gt;
                    &lt;value&gt;BBB&lt;/value&gt;
                &lt;/entry&gt;
            &lt;/map&gt;
        &lt;property&gt;
        &lt;property name=&quot;myProp&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;testA&quot;&gt;AAA&lt;/prop&gt;
                &lt;prop key=&quot;testB&quot;&gt;BBB&lt;/prop&gt;
            &lt;/props&gt;
        &lt;property&gt;
    &lt;/bean&gt;
2. 结构相同，标签是可以互换的，list、array、set是一类，map、props是一类。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/03/02/Mybatis进阶/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/02/Mybatis进阶/" itemprop="url">Mybatis进阶</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-02T00:00:00+08:00">
                2016-03-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h2><pre><code>事物的四大特性：ACID
1. A：原子性，要么全部被执行，要么全部不执行；
2. C：一致性，事务的执行使数据库从一种正确状态转换成另外一种正确状态；
3. I：隔离性，在事务正确提交之前，它可能的结果不应该显示给其他事务；
4. D：持久性，事务正确提交之后，即使有了其他故障，其结果也永远保存在数据库中。
</code></pre><h3 id="并发下的事务"><a href="#并发下的事务" class="headerlink" title="并发下的事务"></a>并发下的事务</h3><pre><code>1. 事务A和事务B操纵的是同一个资源，它们都有若干个子事务，在高并发的情况下，会出现各种问题；
2. 主要有五种问题：第一类丢失更新、第二类丢失更新、脏读、不可重复读、幻读；
3. 脏读：事务A读到了事务B还没有提交的数据；
    1. 账户余额1000元，事务A开启事务，此时切换到事务B，事务B开启事务--&gt;取走100元
    2. 此时又切换回事务A，因为事务B并没有提交，事务A读取的仍是1000元，这就是脏读
4. 不可重复读：在同一个事务里读取了两次某个数据，结果不一致；
    1. 事务A开启事务--&gt;查出账户余额为1000元
    2. 此时切换到事务B，事务B开启事务--&gt;取走100元--&gt;提交，账户余额变为900元
    3. 此时又切换回事务A，事务A再查一次的账户余额为900元
    4. 那么对于事务A，在同一个事务内两次读取的数据不一致，这就是不可重复读。
5. 幻读：在同一个事务里的操作中发现了未被操作的数据；
    1. 事务A开启事务--&gt;修改所有学生当天签到状况为false
    2. 此时切换到事务B，事务B开启事务--&gt;插入了一条学生数据
    3. 此时又切换回事务A，事务A提交时发现了一条自己没有修改过的数据，这就是幻读。
    4. 幻读出现的前提：并发的事务中有事务发生了插入、删除操作。
6. 事务隔离级别就是为了解决这几种问题。
</code></pre><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><pre><code>1. 事务隔离级别越高，在并发下产生的问题就越少，但同时付出的性能消耗也越大，因此很多时候必须
   在并发性和性能之间做一个权衡；
2. 设立事务隔离级别的目的：为了让不同的项目可以根据自己的并发情况，选择合适的事务隔离级别；
   对于在事务隔离级别之外会产生的并发问题，在代码中做补偿；
3. 事务隔离级别有4种，但是像Spring会提供5种；
1. DEFAULT：默认隔离级别
    1. Spring配置事务时，将 isolation 设置为 DEFAULT，则使用数据库的默认事务隔离级别；
    2. 每种数据库支持的事务隔离级别是不一样的。
2. READ_UNCOMMITTED：读未提交
    1. 能够读取到没有被提交的数据，所以无法解决脏读、不可重复读、幻读，很少使用；
3. READ_COMMITED：读已提交
    1. 能够读到那些已经提交的数据，所以能防止脏读，但是无法限制不可重复读和幻读；
    2. 此级别下，写数据只会锁住相应的行。
4. REPEATABLE_READ：重复读取
    1. 在数据读出来之后加锁，类似 select * from XXX for update，明确数据读取出来就是为了
    更新用的，所以要加一把锁，防止别人修改它；
    2. 读取了一条数据，这个事务不结束，其他事务就不可以修改这条记录，解决了脏读、不可重复读的
    问题，但无法解决幻读的问题。
5. SERLALIZABLE：串行化，加锁读，最高的事务隔离级别
    1. 不管多少事务，必须执行完一个事务的所有子事务之后，才可以执行下一个事务的所有子事务，
    这样就解决了脏读、不可重复读和幻读的问题了；
    2. 此级别下，读写数据都会锁住整张表。
1. 虽然隔离级别越高，越能保证数据的完整性和一致性，但对并发性能的影响也越大；
2. 一般情况下会设置为READ_COMMITED，此时避免了脏读，并发性也还不错，之后再通过其他手段解决
   不可重复读和幻读的问题；
3. MySQL的事务隔离级别
    1. 对于MySql，其默认事务级别是REPEATABLE_READ，虽然定义上无法解决幻读的问题，但MySql
    使用了一种 Next key-lock 的算法来实现REPEATABLE_READ，这种算法能够解决幻读问题；
    2. Next key-lock算法：在进行查询时，不仅会锁住当前操作的记录，也会将查询所涉及到的范围
    锁住，其他事务如果想要在此范围内进行数据操作，那么就会被阻塞，因而MySql在此级别下就已经
    具备了Serializable级别的事务隔离性。
    3. 查看事务隔离级别
        select @@tx_isolation;  --&gt;旧版MySQL
        select @@transaction_isolation;  --&gt;旧版MySQL
        show variables like &apos;transaction_isolation&apos;;
    4. 开启一个事务：start transaction;
    5. 回滚当前事务：rollback;
    6. 提交当前事务：commit;
4. MySQL设置当前会话的事务隔离级别：SET session TRANSACTION ISOLATION LEVEL 隔离级别
    1. 隔离级别：Read uncommitted、Read committed、Repeatable read、Serializable
    2. 对于 Mybatis getSqlSession()，只针对本次拿到的Session有效；
    3. 对于CMD命令行，只在本次窗口有效。
5. MySQL设置全局事务隔离级别：SET global TRANSACTION ISOLATION LEVEL 隔离级别
    1. 隔离级别：Read uncommitted、Read committed、Repeatable read、Serializable
    2. 修改了全局的事务隔离级别，那么对此后所有的会话都有效，当前已经存在的会话则不受影响.
</code></pre><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><pre><code>1. 表与表之间的关系：一对一、一对多、多对多
2. 新创建一张表account，外键字段uid 关联user表的主键id
3. 创建表account的实体类
    public class Account implements Serializable {
        private int id;  //主键
        private int uid;  //外键，关联user表的主键id
        private double money;
        // getter、setter
    }
4. 同理，新建Dao接口：com.test.dao.IAccountDao
    public interface IAccountDao {
        List&lt;Account&gt; findAll();
    }
5. 在主配置文件 SqlMapConfig.xml 配置 &lt;typeAliases&gt; 和 &lt;mappers&gt;
    &lt;typeAliases&gt;
        &lt;package name=&quot;com.test.domain&quot; /&gt;
    &lt;/typeAliases&gt;
    ......
    &lt;mappers&gt;
        &lt;package name=&quot;com.test.dao&quot;&gt;&lt;/package&gt;
    &lt;/mappers&gt;
6. 创建 resources/com/test/dao/IAccountDao.xml
    &lt;mapper namespace=&quot;com.test.dao.IAccountDao&quot;&gt;
        &lt;select id=&quot;findAll&quot; resultType=&quot;com.test.domain.Account&quot;&gt;
            select * from account
        &lt;/select&gt;
    &lt;/mapper&gt;
</code></pre><h3 id="一对一查询"><a href="#一对一查询" class="headerlink" title="一对一查询"></a>一对一查询</h3><pre><code>1. account表--&gt;user表：一对一的关系
2. 查询account的所有字段，只查询user表的username字段
    1. 新增一个实体类AccountUser，继承自Account
        public class AccountUser extends Account {
            private String username;  //user表的字段
            //getter、setter
        }
    2. 在 IAccountDao 接口中新增方法：List&lt;AccountUser&gt; findAccount();
    3. 在 IAccountDao.xml 中配置SQL语句
        &lt;select id=&quot;findAccount&quot; resultType=&quot;accountuser&quot;&gt;
            select u.username, a.* from account a, user u where u.id=a.uid
        &lt;/select&gt;
3. 但是，这并不是常用的方式，而是将 从表(user) 的实体类封装到 主表(account) 的实体类中
    public class Account implements Serializable {
        private User user;  //从表user的实体类属性
        ......
    }
4. 在 IAccountDao.xml 使用 &lt;resultMap&gt; 配置一对一的关系映射
    &lt;resultMap id=&quot;accountUserMap&quot; type=&quot;account&quot;&gt;
        &lt;id property=&quot;id&quot; column=&quot;aid&quot; /&gt;
        &lt;result property=&quot;uid&quot; column=&quot;uid&quot; /&gt;
        &lt;result property=&quot;money&quot; column=&quot;money&quot; /&gt;
        &lt;!-- 一对一的映射关系，配置封装User的属性 --&gt;
        &lt;association property=&quot;user&quot; column=&quot;uid&quot; javaType=&quot;user&quot;&gt;
            &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
            &lt;result property=&quot;username&quot; column=&quot;username&quot; /&gt;
        &lt;/association&gt;
    &lt;/resultMap&gt;
    &lt;select id=&quot;findAll&quot; resultMap=&quot;accountUserMap&quot;&gt;
        &lt;!-- 查询出两张表的所有字段，并对account表的id属性重命名为aid--&gt;
        select u.*, a.id as aid, a.uid, a.money from account a, user u 
         where u.id=a.uid
        同
        select u.*, a.id as aid, a.uid, a.money from account a 
         left join user u on u.id=a.uid
    &lt;/select&gt;
    1. &lt;resultMap&gt; 上的 type属性 使用的是实体类的别名；
    2. 如果查询结果中包含两张表的同名字段，则必须对其中一个字段做重命名，如account表的主键
    字段(id--&gt;aid)，否则查询结果会出现错误；
    3. SQL语句上重命名了account表的主键字段，所以对应&lt;id&gt;上的column属性也为aid.
5. &lt;association&gt;标签用于配置一对一的映射关系
    1. 属性column：主表account的外键字段;
    2. 属性property：实体类Account 中封装从表实体类User的对象属性user;
    3. 属性javaType：声明从表实体类User的全类名，也可以使用实体类的别名;
    4. 标签内配置的是从表(user)字段与实体类(User)属性的映射关系.
6. 连接查询与子查询
    1. 表的连接查询都可以替换为子查询，但不是所有的子查询都可以替换为表连接查询；
    2. 数据库对连接查询做了优化，而子查询是多次查询，效率较低，但胜在方便灵活。
</code></pre><h3 id="一对多查询"><a href="#一对多查询" class="headerlink" title="一对多查询"></a>一对多查询</h3><pre><code>1. user表--&gt;account表：一对多的关系
2. 在实体类User 中增加实体类Account 的集合
    public class User implements Serializable {
        private List&lt;Account&gt; accounts;  //从表user的实体类集合属性
        ......
    }
3. 在 IUserDao.xml 中配置 &lt;resultMap&gt;
    &lt;resultMap id=&quot;userAccountMap&quot; type=&quot;user&quot;&gt;
        &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
        &lt;result property=&quot;username&quot; column=&quot;username&quot; /&gt;
        &lt;!-- 配置User对象中的实体类集合 --&gt;
        &lt;collection property=&quot;accounts&quot; ofType=&quot;account&quot;&gt;
            &lt;id property=&quot;id&quot; column=&quot;aid&quot; /&gt;
            &lt;result property=&quot;uid&quot; column=&quot;uid&quot; /&gt;
            &lt;result property=&quot;money&quot; column=&quot;money&quot; /&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;
    &lt;select id=&quot;findAll&quot; resultMap=&quot;userAccountMap&quot;&gt;
        select u.*, a.id as aid, a.uid, a.money from user u 
         left join account a on u.id=a.uid
    &lt;/select&gt;
4. &lt;collection&gt;标签用于配置一对多的关系映射
    1. 属性ofType：从表account的实体类，也可以使用别名；
    2. 属性property：实体类User 中封装从表实体类Account的集合属性accounts;
    3. 同理，涉及到两张表的同名字段，要在SQL语句上对字段重命名(id--&gt;aid)
</code></pre><h3 id="多对多查询"><a href="#多对多查询" class="headerlink" title="多对多查询"></a>多对多查询</h3><pre><code>1. 对于存在多对多关系的两张表，需要引入中间表(也叫做连接表)
    1. 中间表包含两个实体表的主键，作为外键，建立两张表的联系；
    2. 中间表的主键，可以使用两个外键作为联合主键，不必新增一个专门的主键字段；
    3. 中间表也可以有普通字段，此时为了逻辑清晰，则增加一个主键字段。
2. 角色表role与用户表user具有多对多的关系，同时新建一张中间表user_role
    create table user_role(
        uid int,
        rid int,
        foreign key(uid) references user(id),
        foreign key(rid) references role(id),
        primary key(uid,rid));  -------------&gt;两个外键作为联合主键
3. 用户表user和角色表role的实体类中，包含对方的对象集合
    public class User implements Serializable {
        private int id;
        private String username;
        private List&lt;Role&gt; roles;
        //getter、setter
    }

    public class Role implements Serializable {
        private int id;
        private String rolename;
        private List&lt;User&gt; users;
        //getter、setter
    }
4. 查询角色表role时，关联对应的用户表user
    1. 角色表的Dao接口：IRoleDao
        public interface IRoleDao {
            List&lt;Role&gt; findAll();
        }
    2. 角色表的映射配置文件 IRoleDao.xml
        &lt;resultMap id=&quot;roleUserMap&quot; type=&quot;role&quot;&gt;
            &lt;id property=&quot;id&quot; column=&quot;rid&quot; /&gt;  ---&gt;SQL语句上重命名了同名字段
            &lt;result property=&quot;rolename&quot; column=&quot;role_name&quot; /&gt;
            &lt;!-- 配置Role对象中的实体类集合 --&gt;
            &lt;collection property=&quot;users&quot; ofType=&quot;user&quot;&gt;
                &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
                &lt;result property=&quot;username&quot; column=&quot;username&quot; /&gt;
            &lt;/collection&gt;
        &lt;/resultMap&gt;
        &lt;select id=&quot;findAll&quot; resultMap=&quot;roleUserMap&quot;&gt;
            select u.*, r.id as rid, r.role_name from role r 
             left outer join user_role ur on r.id=ur.rid 
             left outer join user u on u.id=ur.uid
        &lt;/select&gt;
5. 查询用户表时，关联对应的角色表数据，IuserDao接口、IUserDao.xml 中的配置同理.
</code></pre><h2 id="JNDI"><a href="#JNDI" class="headerlink" title="JNDI"></a>JNDI</h2><pre><code>1. JNDI：Java Naming and Directory Interface，SUN公司提供的一套标准的命名系统接口；
2. JNDI也属于JavaEE技术，目的是模仿Windows系统中的注册表，在服务器中注册数据源；
3. 注册表其实是Map结构，key存放的是路径+名称
4. Tomcat服务器启动时，也准备了一个这样的Map结构，Key是字符串(路径+名称)，Value是Object
    1. 路径的directory是固定的，name是可以自定义的；
    2. value中存放的内容通过配置文件的方式指定。
</code></pre><h3 id="JavaWeb项目与JNDI"><a href="#JavaWeb项目与JNDI" class="headerlink" title="JavaWeb项目与JNDI"></a>JavaWeb项目与JNDI</h3><pre><code>1. 在JavaWeb项目中使用JNDI，必须在 webapp 目录下创建 META-INF 目录
    1. 在 META-INF 目录下创建配置文件context.xml
        &lt;Context&gt;
            &lt;Resource
                name=&quot;jdbc/test_ibatis&quot; type=&quot;javax.sql.DataSource&quot; 
                auth=&quot;Container&quot; 
                maxActive=&quot;20&quot;
                maxWait=&quot;10000&quot;
                maxIdle=&quot;5&quot;
                username=&quot;root&quot;
                password=&quot;123456&quot;
                driverClassName=&quot;com.mysql.jdbc.Driver&quot;
                url=&quot;jdbc:mysql://localhost:3306/db_mybatis&quot;
            /&gt;
        &lt;/Context&gt;
    2. name：Map结构中key路径的名称部分;
    3. type：value中存储的对象;
    4. auth：指定提供者，Container表示容器，此时指Tomcat;
    5. maxActive：最大活动连接;
    6. maxWait：最大等待时长;
    7. maxIdle：最大空闲数;
    8. 属性username、password、driverClassName、url：数据库的连接信息.
2. 主配置文件 SqlMapConfig.xml
    &lt;dataSource type=&quot;JNDI&quot;&gt;
        &lt;property name=&quot;data_source&quot; value=&quot;java:comp/env/jdbc/test_ibatis&quot; /&gt;
    &lt;/dataSource&gt;
    1. java:comp/env/jdbc 就是key路径中固定的directory部分;
    2. context.xml中已经包含了数据库的连接信息，不需要再额外配置。
3. 使用Mybatis操作数据库时，必须经过Tomcat，所以只能在Servlet/JSP中使用，测试模块中不能使用.
</code></pre><h2 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h2><pre><code>1. 延迟加载：在真正使用数据时才发起查询，不用的时候就不查询，这就是按需加载，亦或懒加载；
    1. 一对多，多对多：通常采用延迟加载；
    2. 多对一，一对一：通常采用默认的立即加载。
2. 一对一的延迟加载：表account--&gt;表user
    1. 在主配置文件 SqlMapConfig.xml 中开启延迟加载
    &lt;configuration&gt;
        &lt;settings&gt;
            &lt;!-- 延迟加载的全局开关 --&gt;
            &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot; /&gt;
            &lt;!-- 大于Mybatis3.4.1的默认值为false，表示按需加载每个属性 --&gt;
            &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot; /&gt;
        &lt;/settings&gt;
    &lt;/configuration&gt;
    2. IUserDao接口 与 IUserDao.xml
        //根据主键 id 查询user表
        User findById(int id);
        &lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt;
            select * from user where id=#{uid}
        &lt;/select&gt;
    3. IAccountDao.xml：配置 &lt;association&gt; 上的 select属性
        &lt;resultMap id=&quot;accountUserMap&quot; type=&quot;account&quot;&gt;
            &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
            &lt;result property=&quot;uid&quot; column=&quot;uid&quot; /&gt;
            &lt;result property=&quot;money&quot; column=&quot;money&quot; /&gt;
            &lt;association property=&quot;user&quot; column=&quot;uid&quot; javaType=&quot;user&quot; 
                    select=&quot;com.test.dao.IUserDao.findById&quot;&gt;&lt;/association&gt;
        &lt;/resultMap&gt;
        &lt;select id=&quot;findAll&quot; resultMap=&quot;accountUserMap&quot;&gt;
            select * from account  ---&gt;不能再使用连接查询，否则延迟加载是无效的
        &lt;/select&gt;
    4. IUserDao.findById() 接收参数是&lt;association&gt;上的column属性，所以不能省略此属性。
3. 一对多的延迟加载：表user--&gt;表account
    1. IAccountDao接口 与 IAccountDao.xml
        //根据外键 uid 去查询account表
        List&lt;Account&gt; findByUid(int uid);
        &lt;select id=&quot;findByUid&quot; parameterType=&quot;int&quot; resultType=&quot;account&quot;&gt;
            select * from account where uid=#{uid}
        &lt;/select&gt;
    2. IUserDao.xml：配置 &lt;collection&gt; 上的select属性
    &lt;resultMap id=&quot;userAccountMap&quot; type=&quot;user&quot;&gt;
        &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
        &lt;result property=&quot;username&quot; column=&quot;username&quot; /&gt;
        &lt;collection property=&quot;accounts&quot; ofType=&quot;account&quot; 
            select=&quot;com.test.dao.IAccountDao.findByUid&quot; column=&quot;id&quot;&gt;&lt;/collection&gt;
    &lt;/resultMap&gt;
    &lt;select id=&quot;findAll&quot; resultMap=&quot;userAccountMap&quot;&gt;
        select * from user  ---&gt;不能再使用连接查询
    &lt;/select&gt;
</code></pre><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><pre><code>1. 缓存就是存在于内存中的数据，减少与数据库的交互次数，提高执行效率；
2. 适用于缓存的数据：经常查询的，且不经常改变的，数据的正确与否对最终结果影响不大的；
3. 一级缓存：SqlSession对象的缓存，无需特殊配置
    1. 每个SqlSession对象会提供一块独有的Map结构的区域，缓存查询的结果；
    User u1 = dao.findById(2);  User u2 = dao.findById(2); //连续两次查询同一条数据
    u1==u2;  --&gt; true
    2. 手动清空一级缓存：session.clearCache();
    3. 为了保证数据的一致性，当发生数据的插入/更新/删除，或者调用SqlSession的commit()、
    close()等方法时，会立即清空当前SqlSession的一级缓存，让后续的SQL重新查询数据库。
4. 二级缓存：SqlSessionFactory对象的缓存
    1. 由同一个SqlSessionFactory创建的所有SqlSession对象，共享二级缓存；
    2. 在主配置文件 SqlMapConfig.xml 中开启全局缓存，默认就是开启的
        &lt;settings&gt;
            &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot; /&gt;
        &lt;/settings&gt;
    3. 在映射配置文件 IUserDao.xml 中开启user的二级缓存
        &lt;cache /&gt;
        &lt;select id=&quot;findById&quot; resultType=&quot;user&quot; useCache=&quot;true&quot;&gt;
            select * from user where id=#{uid}
        &lt;/select&gt;
5. 二级缓存中存储的是散装数据，当使用二级缓存数据时，这些数据会封装成一个新的User对象，
   所以比较两次查询的结果时，返回false.
</code></pre><h2 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h2><pre><code>1. Mybatis的注解开发：针对的是Dao的映射配置文件，目的是省略映射配置文件
2. CRUD的对应注解：@Insert、@Select、@Update、@Delete，在Dao接口的方法上使用
3. 使用注解时，如果resources目录下还存在映射配置文件，不管是否使用了此配置文件，都会报错；
4. 单表的CRUD：IUserDao接口
    1. 查询：@Select
        @Select(&quot;select * from user&quot;)
        List&lt;User&gt; findAll();

        @Select(&quot;select * from user where name like #{username}&quot;)  或
        @Select(&quot;select * from user where name like &apos;%${value}%&apos;&quot;)
        List&lt;User&gt; findByName(String username);

        @Select(&quot;select count(id) from user&quot;)
        int findTotal();
    2. 插入：@Insert
        @Insert(&quot;insert into user(name, age) values(#{username}, #{age})&quot;)
        void saveUser(User u);
    3. 更新：@Update
        @Update(&quot;update user set name=#{username}, age=#{age} where id=#{id}&quot;)
        void updateUser(User u);
    4. 删除：@Delete
        @Delete(&quot;delete from user where id=#{id}&quot;)
        void deleteUser(int id);
5. 实体类的属性名与表字段名不匹配：id--&gt;uId，name--&gt;username
    @Select(&quot;select * from user&quot;)
    @Results(id=&quot;userMap&quot;, value={
        @Result(id=true, column=&quot;id&quot;, property=&quot;uId&quot;),
        @Result(column=&quot;name&quot;, property=&quot;username&quot;)
    })
    List&lt;User&gt; findAll();

    @Select(&quot;select * from user where id=#{id}&quot;)
    @ResultMap(value={&quot;userMap&quot;})  --&gt;复用id命名的@Results，支持多个
    User findById(int id);
</code></pre><h3 id="多表的CRUD"><a href="#多表的CRUD" class="headerlink" title="多表的CRUD"></a>多表的CRUD</h3><pre><code>1. 一对一：表account--&gt;表user
    1. IAccountDao接口
    @Select(&quot;select * from account&quot;)
    @Results(id=&quot;accountMap&quot;, value={
        @Result(id=true, column=&quot;id&quot;, property=&quot;id&quot;),
        @Result(column=&quot;uid&quot;, property=&quot;uid&quot;),
        @Result(column=&quot;money&quot;, property=&quot;money&quot;),
        @Result(column=&quot;uid&quot;, property=&quot;user&quot;, one=@One(
            select=&quot;com.test.dao.IUserDao.findById&quot;, fetchType=FetchType.EAGER
        ))
    })
    List&lt;Account&gt; findAll();
    2. @One 用于一对一的关联查询，调用 IUserDao.findById()，接收参数为uid;
    3. select属性用于指定要调用的全限定方法名，fetchType属性用于配置加载的时机;
    4. FetchType有3个属性：LAZY(懒加载)、EAGER(立即加载)、DEFAULT.
2. 一对多：表user--&gt;表account，
    @Select(&quot;select * from user&quot;)
    @Results(id=&quot;userMap&quot;, value={
        @Result(id=true, column=&quot;id&quot;, property=&quot;uId&quot;),
        @Result(column=&quot;name&quot;, property=&quot;username&quot;),
        @Result(column=&quot;id&quot;, property=&quot;accounts&quot;, many=@Many(
            select=&quot;com.test.dao.IAccountDao.findByUid&quot;, fetchType=FetchType.LAZY
        ))
    })
    List&lt;User&gt; findAll();
3. 配置二级缓存
    1. 在主配置文件 SqlMapConfig.xml 中开启缓存;
    2. 在Dao接口上使用注解@CacheNamespace
    @CacheNamespace(blocking = true)
    public interface IUserDao { ... }
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/03/01/Mybatis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/01/Mybatis/" itemprop="url">Mybatis</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-01T00:00:00+08:00">
                2016-03-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><pre><code>1. 框架是软件开发中的一套解决方案，不同的框架解决不同的问题，Mybatis解决的是持久层问题
2. 三层结构
    1. 表现层：用于展示数据，如SpringMVC:MVC框架
    2. 业务层：处理业务需求
    3. 持久层，和数据库交互，如Mybatis:持久层框架
    4. Spring：Ioc(控制反转)、AOP(面向切面编程)，不属于任何一层。
3. 持久层技术的解决方案
    1. JDBC技术：Connection、PreparedStatement、ResultSet，JDBC是规范；
    2. Spring的JdbcTemplate：Spring中对JDBC的简单封装；
    3. Apache的DBUtils：类似于String的JdbcTemplate，都只是工具类；
    4. 它们都不能从根本上提高开发效率，这就是 Mybatis 框架的意义所在。
</code></pre><h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><pre><code>1. Mybatis：基于Java的持久层框架，内部封装了JDBC，开发者只需要关心SQL语句本身即可；
    1. Mybatis通过XML或注解的方式配置各种Statement，映射成最终要执行的SQL语句；
    2. 采用ORM思想解决实体和数据库映射的问题，将执行SQL返回的结果映射成Java对象。
2. 使用Maven工程搭建Mybatis环境
3. 添加依赖
    &lt;dependency&gt;  -------------------------&gt;Mybatis
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
        &lt;version&gt;3.4.5&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;  -------------------------&gt;MySQL
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;5.1.6&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><pre><code>1. 创建实体类，实现Serializable接口
    public class User implements Serializable {
        private String name;
        private int age;
        //getter、setter
    }
2. 创建数据库操作的Dao接口：com.test.dao.IUserDao
    public interface IUserDao {
        List&lt;User&gt; findAll();  //查询所有
    }
3. 在resources目录下创建一个XML文件：SqlMapConfig.xml，作为Mybatis的主配置文件
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;   ==&gt;约束
    &lt;configuration&gt;
        &lt;!-- 配置环境 --&gt;
        &lt;environments default=&quot;mysql&quot;&gt;  ==&gt;default属性值可任意取名字
            &lt;!-- 配置MySQL的环境 --&gt;
            &lt;environment id=&quot;mysql&quot;&gt;  ====&gt;此id属性值与父节点的default一致
                &lt;!-- 配置事物的类型 --&gt;
                &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;
                &lt;!-- 配置数据源：连接池，有三种 --&gt;
                &lt;dataSource type=&quot;POOLED&quot;&gt;
                    &lt;!-- 配置连接数据库的基本信息，5.0和6.0的驱动、URL是不同的 --&gt;
                    &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;
                    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/db_mybatis&quot;/&gt;
                    &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;
                    &lt;property name=&quot;password&quot; value=&quot;123456&quot; /&gt;
                &lt;/dataSource&gt;
            &lt;/environment&gt;
        &lt;/environments&gt;
        &lt;!-- 指定Dao的映射配置文件 --&gt;
        &lt;mappers&gt;
            &lt;mapper resource=&quot;com/test/dao/IUserDao.xml&quot;/&gt;  =&gt;指向resources目录
        &lt;/mappers&gt;
    &lt;/configuration&gt;
4. 映射配置文件是每个Dao的独立配置文件，创建resources/com/test/dao/IUserDao.xml
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
    &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
                    &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
    &lt;mapper namespace=&quot;com.test.dao.IUserDao&quot;&gt;  ==&gt;namespace指定对应Dao的全类名
        &lt;!-- 配置IUserDao中的方法findAll，必须指定查询的实体类 --&gt;
        &lt;select id=&quot;findAll&quot; resultType=&quot;com.test.domain.User&quot;&gt;
            select * from user  ---&gt;findAll()执行的SQL语句
        &lt;/select&gt;
    &lt;/mapper&gt;
    1. resultType属性指定 findAll() 的返回值类型，每条数据封装在实体类User对象中；
    2. Mybatis把持久层的操作接口名称和映射文件称为Mapper，所以IUserDao也通常命名为IUserMapper
5. 开始使用Mybatis操作数据库
    1. 获取配置文件路径的两种方式：类加载器、ServletContext的getRealPath()
        // 读取主配置文件
        InputStream is = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);
    2. 构建者模式：创建SqlSessionFactory工厂
        SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
        SqlSessionFactory factory = builder.build(is);
    3. 工厂模式
        SqlSession session = factory.openSession(); //使用工厂生产SqlSession对象
    4. 代理模式：使用SqlSession创建Dao接口的代理对象
        IUserDao dao = session.getMapper(IUserDao.class);
        // 使用代理对象执行方法，获取SQL语句的结果
        List&lt;User&gt; users = dao.findAll();
    5. 释放资源
        session.close();  is.close();
6. 把映射配置文件改为注解实现
    1. 删除映射配置文件 resources/com/test/dao/IUserDao.xml
    2. 在接口IUserDao的方法findAll()上使用注解
        @Select(&quot;select * from user&quot;)
        List&lt;User&gt; findAll();
    3. 更改主配置文件SqlMapConfig.xml中的&lt;mappers&gt;，指定Dao接口
        &lt;mappers&gt;
            &lt;mapper class=&quot;com.test.dao.IUserDao&quot; /&gt;
        &lt;/mappers&gt;
</code></pre><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><pre><code>1. 插入一条数据
    1. 在接口 IUserDao 中添加插入数据的方法：void saveUser(User user);
    2. 在 IUserDao.xml 中配置插入的SQL语句
        &lt;insert id=&quot;saveUser&quot; parameterType=&quot;com.test.domain.User&quot;&gt;
            insert into user(name, age) values(#{name}, #{age})
        &lt;/insert&gt;
    3. parameterType属性用于指定 saveUser() 的参数类型；
    4. #{prop}：用于取出参数对象 User 中的属性值；
    5. 执行插入时，必须手动提交事务，否则数据会回滚，但自增长的ID又会被占用；
        User u = new User();  u.setName(&quot;Java&quot;);  u.setAge(20);
        dao.saveUser(u);
        session.commit();  //手动提交事务
    6. 自动提交事物的SqlSession对象
        SqlSession session = factory.openSession(true);
2. 更新数据
    void updateUser(User user);
    &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.test.domain.User&quot;&gt;
        update user set name=#{name},age=#{age} where id=#{id}
    &lt;/update&gt;
    User u = new User();  u.setId(2);  u.setName(&quot;Python&quot;);  u.setAge(30);
    dao.updateUser(u);  session.commit();
3. 删除数据
    void deleteUser(int id);
    &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;java.lang.Integer&quot;&gt;
        delete from user where id=#{id}
    &lt;/delete&gt;
    dao.deleteUser(3);  session.commit();
    1. parameterType 的参数类型不是实体类，#{id} 中的 id 只是占位符，可以任意名称；
    2. java.lang.Integer、int、INT 是等效的，都可以表示 int 类型。
4. 聚合函数
    int findTotal();
    &lt;select id=&quot;findTotal&quot; resultType=&quot;int&quot;&gt;
        select count(id) from user
    &lt;/select&gt;
    int count = dao.findTotal();
5. 模糊查询
    List&lt;User&gt; findByName(String name);
    &lt;select id=&quot;findByName&quot; resultType=&quot;com.test.domain.User&quot; parameterType=&quot;string&quot;&gt;
        select * from user where name like #{un}
    &lt;/select&gt;
    List&lt;User&gt; us = dao.findByName(&quot;%tho%&quot;);
    1. 模糊查询的特殊符号(%、_...)在传递参数时，手动指定需要的符号，Mybatis会采用安全的
    预处理方式加入参数：select * from user where name like ?
    2. 由Mybatis的源码可知，还有一种配置可以在SQL语句中指定模糊查询的符号：
        &lt;select id=&quot;findByName&quot; ...&gt;
            select * from user where name like &apos;%${value}%&apos;
        &lt;/select&gt;
        List&lt;User&gt; us = dao.findByName(&quot;tho&quot;);
    3. ${value} 中的 value 是固定的，由Mybatis的源码绑定，但这种方式采用的是字符串拼接，
    所以是不安全的：select * from user where name like %tho%
6. 插入数据时，返回新增用户的主键ID
    &lt;insert id=&quot;saveUser&quot; parameterType=&quot;com.test.domain.User&quot;&gt;
        &lt;selectKey keyProperty=&quot;id&quot; keyColumn=&quot;id&quot; resultType=&quot;int&quot; order=&quot;AFTER&quot;&gt;
            select last_insert_id();
        &lt;/selectKey&gt;
        insert into user(name, age) values(#{name}, #{age})
    &lt;/insert&gt;
    User u = new User();  u.setName(&quot;Java&quot;);  u.setAge(20);
    dao.saveUser(u);  session.commit();
    int id = u.getId(); //新插入数据的ID字段值
    1. order=&quot;AFTER&quot; 表示在执行插入之后，再执行此SQL语句select last_insert_id();
    2. resultType=&quot;int&quot; 声明主键的类型；
    3. keyColumn=&quot;id&quot; 声明数据库中的主键字段名；
    4. keyProperty=&quot;id&quot; 声明实体类中对应的主键属性名；
    5. 插入成功之后，对象类对象 的 id 属性值为数据库中真实的 id 值。
</code></pre><h2 id="parameterType"><a href="#parameterType" class="headerlink" title="parameterType"></a>parameterType</h2><pre><code>1. OGNL：Object Graphic Navigation Language，对象图导航语言
    1. OGNL 的作用：通过对象的取值方法来获取属性值，写法上省略了getter方法；
    2. 比如：获取一个实体类User的属性值时
        1. 在类中的写法：user.getName()
        2. OGNL表达式的写法：user.name
    3. parameterType 为POJO对象(实体类)时，Mybatis使用 OGNL表达式 来解析对象的属性值，
    所以 #{} 或 ${} 中可以省略getter方法；
    4. 同时，parameterType 已经指明了属性所属的实体类，所以不需要声明对象#{user.name}，
    而是直接使用属性名#{name}
2. parameterType 为POJO(实体类)的包装对象
    1. 有时候查询条件可能由多个实体类组成，那么就需要把不同的实体类包装成一个对象；
    2. 创建包装对象QueryVo
        public class QueryVo {
            private User user;  //包装实体类User
            //getter、setter
        }
    3. 在接口 IUserDao 中新增方法：List&lt;User&gt; findByVo(QueryVo vo);
    4. 在 IUserDao.xml 中配置SQL语句
    &lt;select id=&quot;findByVo&quot;
        parameterType=&quot;com.test.domain.QueryVo&quot; resultType=&quot;com.test.domain.User&quot;&gt;
        select * from user where name like #{user.name}
    &lt;/select&gt;
    5. 执行 findByVo()
        QueryVo vo = new QueryVo();
        User u = new User();  u.setName(&quot;%tho%&quot;);
        vo.setUser(u);
        List&lt;User&gt; us = dao.findByVo(vo);
</code></pre><h2 id="resultType"><a href="#resultType" class="headerlink" title="resultType"></a>resultType</h2><pre><code>1. MySQL数据库在Windows系统下不区分字段名与属性名的大小写；
    1. 比如：数据库表中的字段名为username，而实体类中的属性名为userName
    2. 在执行 findAll() 时，仍然可以把username的字段值映射给userName属性。
2. 当实体类中的属性名与表中的字段名不匹配时：id--uId，userName--name，userAge--age
    1. 在查询所有时，使用SQL语句的别名
        &lt;select id=&quot;findAll&quot; resultType=&quot;com.test.domain.User&quot;&gt;
            select id as uId, name as userName, age as userAge from user
        &lt;/select&gt;
    2. 在插入时，指定属性名
    &lt;insert id=&quot;saveUser&quot; parameterType=&quot;com.test.domain.User&quot;&gt;
        &lt;selectKey keyProperty=&quot;uId&quot; keyColumn=&quot;id&quot; resultType=&quot;int&quot; order=&quot;AFTER&quot;&gt;
            select last_insert_id();
        &lt;/selectKey&gt;
        insert into user(name, age) values(#{userName}, #{userAge})
    &lt;/insert&gt;
3. 在Mybatis中，提供了一种没有使用别名高效、但能提高开发效率的方式
    1. 使用 &lt;resultMap&gt; 配置属性名与字段名的映射关系
    &lt;mapper namespace=&quot;com.test.dao.IUserDao&quot;&gt;
        &lt;resultMap id=&quot;userMap&quot; type=&quot;com.test.domain.User&quot;&gt;
            &lt;id property=&quot;uId&quot; column=&quot;id&quot;&gt;&lt;/id&gt;  ===&gt;主键字段
            &lt;result property=&quot;userName&quot; column=&quot;name&quot;&gt;&lt;/result&gt;  ==&gt;非主键字段
            &lt;result property=&quot;userAge&quot; column=&quot;age&quot;&gt;&lt;/result&gt;
        &lt;/resultMap&gt;

        &lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt;
            select * from user
        &lt;/select&gt;

        &lt;select id=&quot;findByVo&quot; parameterType=&quot;com.test.domain.QueryVo&quot; resultType=&quot;userMap&quot;&gt;
            select * from user where name like #{user.userName}
        &lt;/select&gt;
    &lt;/mapper&gt;
    2. &lt;resultMap&gt; 的 id 属性为 resultMap 的唯一标识，type 属性为实体类的全类名；
    3. &lt;select&gt;的 resultType 属性值为实体类时，改为 resultMap=&quot;userMap&quot;.
</code></pre><h2 id="更多配置"><a href="#更多配置" class="headerlink" title="更多配置"></a>更多配置</h2><pre><code>1. Mybatis也支持自定义Dao的实现类，SqlSession对象中提供了数据库操作的API
    public class UserDaoImpl implements IUserDao {
        private SqlSessionFactory factory;

        public UserDaoImpl(SqlSessionFactory factory) {
            this.factory = factory;
        }

        public List&lt;User&gt; findAll() {  //查询所有
            SqlSession sess = factory.openSession();
            List&lt;User&gt; us = sess.selectList(&quot;com.test.dao.IUserDao.findAll&quot;);
            sess.close();
            return us;
        }

        public void saveUser(User u) {  //插入一条数据
            SqlSession sess = factory.openSession();
            sess.insert(&quot;com.test.dao.IUserDao.saveUser&quot;, u);
            sess.commit();
            sess.close();
        }
        ......
    }
</code></pre><h3 id="properties标签"><a href="#properties标签" class="headerlink" title="properties标签"></a>properties标签</h3><pre><code>1. 在主配置文件 SqlMapConfig.xml 中，使用 &lt;properties&gt; 抽取数据库的连接信息
    &lt;properties&gt;
        &lt;!-- 配置JDBC的连接信息 --&gt;
        &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/db_mybatis&quot; /&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;
        &lt;property name=&quot;password&quot; value=&quot;123456&quot; /&gt;
    &lt;/properties&gt;
    &lt;environments default=&quot;mysql&quot;&gt;
        &lt;environment id=&quot;mysql&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;transactionManager&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;!-- 引用 &lt;properties&gt; 标签中配置的信息 --&gt;
                &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot; /&gt;
                &lt;property name=&quot;url&quot; value=&quot;${url}&quot; /&gt;
                &lt;property name=&quot;username&quot; value=&quot;${username}&quot; /&gt;
                &lt;property name=&quot;password&quot; value=&quot;${password}&quot; /&gt;
        ......
2. 除了在标签内配置，&lt;properties&gt;标签还可以引用外部的配置文件
    1. 在resources目录下创建 jdbcConf.properties，保存数据库的连接信息
        jdbc.driver=com.mysql.jdbc.Driver
        jdbc.url=jdbc:mysql://localhost:3306/db_mybatis
        jdbc.user=root
        jdbc.password=123456
    2. 引入resources/jdbcConf.properties，并使用其中的配置信息
        &lt;properties resource=&quot;jdbcConf.properties&quot;&gt;&lt;/properties&gt;
        ......
        &lt;dataSource type=&quot;POOLED&quot;&gt;
            &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot; /&gt;
            &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;
            &lt;property name=&quot;username&quot; value=&quot;${jdbc.user}&quot; /&gt;
            &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;
3. &lt;properties&gt; 除了 resource 属性可以引入外部文件，还有 url 属性
    1. resource 属性值是类路径的形式，因为 jdbcConf.properties 和 SqlMapConfig.xml
    在同一目录，所以不用写包名；
    2. url 属性值是统一资源定位符，因为是本地文件，所以使用file协议
    url=&quot;file:///D:/workplace/testibatis/src/main/resources/jdbcConf.properties&quot;
    3. SqlMapConfig.xml 中的 &lt;mapper&gt; 标签用于引用Dao的映射配置文件，它也有 url 属性，
    也是统一资源定位符，使用方式与 &lt;properties&gt; 上的 url 属性是相同的。
</code></pre><h3 id="typeAliases标签"><a href="#typeAliases标签" class="headerlink" title="typeAliases标签"></a>typeAliases标签</h3><pre><code>1. 在使用 parameterType 属性声明基本类型时，不需要区分大小写，int 和 INT、Int、inT 都是
   等效的，但自定义的实体类却不行，这是因为它把常用基本类型都注册了别名；
2. 在 SqlMapConfig.xml 中，使用 &lt;typeAliases&gt; 标签可以为自定义的实体类配置别名
    &lt;configuration&gt;
        &lt;typeAliases&gt;
            &lt;typeAlias type=&quot;com.test.domain.User&quot; alias=&quot;user&quot; /&gt;
        &lt;/typeAliases&gt;
        ......
    1. type属性指定实体类的全类名，alias属性自定义别名；
    2. 指定了别名之后，就不再区分大小写了
        &lt;insert id=&quot;saveUser&quot; parameterType=&quot;user&quot;&gt;
        &lt;insert id=&quot;saveUser&quot; parameterType=&quot;USER&quot;&gt;
    3. &lt;resultMap&gt;标签上的 type属性也可以使用实体类的别名：type=&quot;user&quot;
3. 但是，如果实体类过多时，使用 &lt;typeAlias&gt; 配置别名也会很繁琐；
    1. &lt;typeAliases&gt; 还支持配置实体类所在的包名
        &lt;typeAliases&gt;
            &lt;package name=&quot;com.test.domain&quot; /&gt;
        &lt;/typeAliases&gt;
    2. 配置了实体类的包名之后，实体类的类名就是别名，不再区分大小写.
4. SqlMapConfig.xml 中的 &lt;mappers&gt; 也有一个子标签为 &lt;package&gt;，用于指定dao接口的包名
    &lt;mappers&gt;
        &lt;package name=&quot;com.test.dao&quot;&gt;&lt;/package&gt;  ==&gt;无需再配置&lt;mapper&gt;标签
    &lt;/mappers&gt;
</code></pre><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><pre><code>1. 连接池就是一个存储连接的容器(线程安全的集合对象)，保证不能让两个线程拿到同一个连接；
    1. 该集合还必须实现队列的特性：先进后出；
    2. 连接池能够减少获取连接所消耗的时间。
2. Mybatis连接池有3种配置方式
    1. 主配置文件 SqlMapConfig.xml 中的 &lt;dataSource type=&quot;连接池配置&quot;&gt;
    2. POOLED：采用传统的 javax.sql.DataSource 规范，Mybatis中有针对此规范的实现;
    3. UNPOOLED：采用传统获取连接的方式，虽然也实现了DataSource接口，但并没有 池 的思想;
    4. JNDI：采用服务器提供的JNDI技术实现，来获取 DataSource 对象，不同的服务器所拿到的
    DataSource 是不同的;
    5. 注意：如果不是 Web 或者 maven的war工程，不能使用JNDI;
    6. 使用Tomcat服务器时，采用的是DBCP连接池.
3. type=&quot;POOLED&quot;：从连接池中获取一个连接，使用完之后，归还给连接池
    1. Mybatis准备了2个连接池：空闲池和活动池；
    2. 当有一个线程获取连接时，先到空闲池中查看是否有连接，有则直接返回一个连接给线程；
    3. 如果空闲池没有连接，则转去活动池，如果活动池的连接数量已经达到了最大值，则返回其中
    最老的一个连接(Oldest Connection)
    4. 线程获取到 Oldest Connection 之后，会重置其相关参数，保证此连接是一个有效的连接.
4. type=&quot;UNPOOLED&quot;：每次都会创建一个新的连接，使用完之后，关闭连接.
</code></pre><h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><pre><code>1. if标签
    List&lt;User&gt; findByCond(User u);
    &lt;select id=&quot;findByCond&quot; resultMap=&quot;userMap&quot; parameterType=&quot;user&quot;&gt;
        select * from user where 1=1
        &lt;if test=&quot;userName != null&quot;&gt;
            and name = #{userName}
        &lt;/if&gt;
    &lt;/select&gt;
    1. &lt;if&gt; 上使用的属性来自于参数User对象；
    2. where 1=1 中的 1=1 是为了在&lt;if&gt;条件不成立时，保证有一个条件为真的语句；
    3. &lt;if&gt;条件成立时，拼接上标签内的语句：where 1=1 and name=#{userName}
2. where标签：替换掉 where 1=1
    &lt;select id=&quot;findByCond&quot; resultMap=&quot;userMap&quot; parameterType=&quot;user&quot;&gt;
        select * from user
        &lt;where&gt;
            &lt;if test=&quot;userName != null&quot;&gt;
                and name = #{userName}
            &lt;/if&gt;
            &lt;if test=&quot;userAge &gt; 0&quot;&gt;
                and age = #{userAge}
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
3. foreach标签：比如select * from user where id in (1, 3, 6)
    1. 在包装类 QueryVo 中新增一个集合属性
        public class QueryVo {
            private User user;
            private List&lt;Integer&gt; ids
            //getter、setter
        }
    2. 在 IUserDao 接口中新增方法：List&lt;User&gt; findByIds(QueryVo vo);
    3. 在映射配置文件 IUserDao.xml 中新增查询语句
    &lt;select id=&quot;findByIds&quot; resultMap=&quot;userMap&quot; parameterType=&quot;QueryVo的别名&quot;&gt;
        select * from user
        &lt;where&gt;
            &lt;if test=&quot;ids!=null and ids.size()&gt;0&quot;&gt;
                &lt;foreach collection=&quot;ids&quot; open=&quot;and id in (&quot; close=&quot;)&quot; item=&quot;id&quot;
                separator=&quot;,&quot;&gt;  #{id}  &lt;/foreach&gt;
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
    1. collection：要遍历的集合属性；
    2. open、close：分别表示语句的开始部分与结束部分
    3. item：保存每次遍历集合时的元素值；
    4. separator：分隔符；
    5. #{id} 中的 id 来自于 item 的属性值；
    QueryVo vo = new QueryVo();
    List&lt;Integer&gt; ids = new ArrayList&lt;&gt;();  ids.add(1); ids.add(3); ids.add(6);
    vo.setIds(ids);
    List&lt;User&gt; us = dao.findByIds(vo);
4. sql标签：抽取重复的SQL语句
    &lt;sql id=&quot;defult&quot;&gt;
        select * from user
    &lt;/sql&gt;
    &lt;select id=&quot;findAll&quot; resultType=&quot;userMap&quot;&gt;
        &lt;include refid=&quot;defult&quot;&gt;&lt;/include&gt;  ===&gt;引用 id=&quot;default&quot; 的&lt;sql&gt;
    &lt;/select&gt;
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/02/05/JavaEE之过滤监听/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/05/JavaEE之过滤监听/" itemprop="url">JavaEE之过滤监听</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-02-05T00:00:00+08:00">
                2016-02-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><pre><code>1. 过滤器(拦截器)：对服务器接收的请求资源和响应给浏览器的资源进行统一管理，保护Servlet;
    1. 比如在请求到达Servlet之前，请求编码格式的统一设置，session管理...
    2. 过滤器会执行两次：请求达到Servlet之前，Servlet响应数据之后。
2. 使用Filter
    1. 实现Filter接口，覆写 init()、doFilter()、destroy()
    2. 在 web.xml 中配置过滤器
    &lt;filter&gt;
        &lt;filter-name&gt;TestFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;it.test.cn.TestFilter&lt;/filter-name&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;TestFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    3. 注解的方式配置
    @WebFilter(&quot;/*&quot;)
    public class TestFilter implements Filter { ... }
    4. /*：拦截访问此项目的所有请求;
    5. *.do：拦截以 .do 结尾的请求，一般用于模块拦截处理;
    6. /to.do：拦截 /to.do 的请求，针对某个具体的Servlet请求进行拦截，保护Servlet;
    7. 如果同时配置了三个过滤器，那么在执行Filter的过程，匹配范围越大，优先级越高.
    /* --&gt; *.do --&gt; /to.do
3. 过滤器会拦截请求，不会到达Servlet，需要手动给予放行，才能达到Servlet
    public void doFilter(ServletRequest request, ServletResponse response, 
        FilterChain chain) {
        chain.doFilter(request, response);  ---&gt; 放行
    }
    1. chain.doFilter() 表示放行当前的请求，交给Servlet进行处理；
    2. Servlet发送响应数据之后，会先达到Filter，执行 chain.doFilter() 之后的代码逻辑，
    然后才会响应给浏览器.
4. 生命周期：从服务器启动(Filter init())，到服务器关闭(Filter destroy())
</code></pre><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><pre><code>1. 统一编码格式设置
    public void doFilter(request, response, chain) {
        request.setCharacterEncoding(&quot;utf-8&quot;);
        response.setContentType(&quot;text/html;charset=utf-8&quot;);
        chain.doFilter(request, response);
    }
2. session管理
    public void doFilter(request, response, chain) {
        HttpSession hs = ((HttpServletRequest)request).getSession();
        //判断Session是否过期
        if(hs.getAttribute(&quot;user&quot;) == null) {
            //过期则重定向到登录页
            ((HttpServletResponse)response).sendRedirect(&quot;/login.jsp&quot;);
        } else {
            chain.doFilter(request, response);
        }
    }
3. 权限管理，资源管理(统一水印、和谐词汇...) ...
</code></pre><h2 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h2><pre><code>1. Servlet监听器：监听数据流转的过程，比如作用域对象的创建与销毁，数据的存取、变化、删除；
2. 监听的作用域对象包括request、session、application
3. 比如session销毁时，在线人数-1
4. 在 web.xml 中配置监听器
    &lt;listener&gt;
        &lt;listener-class&gt;it.test.cn.TestListener&lt;/listener-class&gt;
    &lt;/listener&gt;
</code></pre><h3 id="request-Listener"><a href="#request-Listener" class="headerlink" title="request Listener"></a>request Listener</h3><pre><code>1. ServletRequestListener：实现此接口，监听request的创建销毁;
    1. 接收到一个请求，则创建request对象；响应结束，销毁request对象;
    2. 创建时触发requestInitialized(sre)，销毁时触发requestDestroyed(sre);
    3. 获取当前正在监听的的Servlet Request对象：sre.getServletRequest();
2. ServletRequestAttributeListener：实现此接口，监听request对象中的Attribute数据;
    1. req.setAttribute(&quot;key&quot;, value); 第一次添加数据时，触发 attributeAdded(srea);
    2. req.setAttribute(&quot;key&quot;, value); 重复添加同键的数据，则触发attributeReplaced(srea);
    3. req.removeAttribute(&quot;key&quot;); 移除数据，则触发：attributeRemoved(srea);
    4. 获取当前正在变化的Attribute数据：srea.getName(); srea.getValue();
</code></pre><h3 id="session-Listener"><a href="#session-Listener" class="headerlink" title="session Listener"></a>session Listener</h3><pre><code>1. HttpSessionListener：实现此接口，监听session的创建与销毁;
    1. req.getSession(); 第一次获取Session表示创建，则触发sessionCreated(se);
    2. Session被销毁时，触发sessionDestroyed(se);
    3. 获取当前正在监听的Session对象：se.getSession();
2. HttpSessionAttributeListener：实现此接口，监听session中的attribute数据;
    1. session.setAttribute(&quot;key&quot;, value);  获取/重置Session Attribute数据;
    2. session.removeAttribute(&quot;key&quot;);  移除Session Attribute数据;
    3. 覆写方法：attributeAdded(hsbe)、attributeReplaced(hsbe)、attributeRemoved(hsbe);
    4. hsbe.getName();  hsbe.getValue();  分别获取正在变化的Attribute数据的键、值.
</code></pre><h3 id="application-Listener"><a href="#application-Listener" class="headerlink" title="application Listener"></a>application Listener</h3><pre><code>1. ServletContextListener：实现此接口，监听ServletContext的创建与销毁;
    1. 服务器启动/关闭时，分别触发 contextInitialized(sce); contextDestroyed(sce);
    2. 获取当前正在监听的ServletContext对象：sce.getServletContext();
2. ServletContextAttributeListener：监听application中的attribute数据;
    1. attributeAdded(scae)、attributeReplaced(scae)、attributeRemoved(scae);
    2. scae.getName();  scae.getValue();
</code></pre><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><pre><code>1. 统计当前在线人数
2. 统计网页浏览次数
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/02/03/JavaEE之JSP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/03/JavaEE之JSP/" itemprop="url">JavaEE之JSP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-02-03T00:00:00+08:00">
                2016-02-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><pre><code>1. JSP：Java Server Pages，一种动态网页技术标准，本质是一个简化的Servlet
2. 原理：浏览器访问jsp文件时，JSP引擎把jsp文件转为Servlet(java文件)，然后执行此Servlet
3. Tomcat/conf/web.xml 对jsp访问的配置
    &lt;servlet&gt;
        &lt;servlet-name&gt;jsp&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.apache.jasper.servlet.JspServlet&lt;/servlet-class&gt;
        ...
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;jsp&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;
        &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
4. JSP的访问有一个转译的过程，所以JSP文件的修改不需要重启服务器。
5. JSP的三种注释：前端注释、Java语言注释、JSP注释
    1. 前端注释会被转译，也会被发送给浏览器，但不会执行；
    2. Java语言注释会被转译，但不会被Servlet执行；
    3. JSP注释不会被转译：&lt;%-- JSP注释 --%&gt;
</code></pre><h3 id="page指令"><a href="#page指令" class="headerlink" title="page指令"></a>page指令</h3><pre><code>1. page指令：配置JSP转译的相关参数
    &lt;%@ page 属性名=&quot;属性值&quot; 属性名=&quot;属性值&quot; ... %&gt;
2. language：声明JSP被转译的语言，如language=&quot;java&quot;
3. import：使用什么语言，就需要导入什么语言的包，不同的包以&quot;,&quot;隔开，也可以导入项目中的类
    import=&quot;java.util.*,java.lang.*,it.test.cn.modal.*&quot;
4. pageEncoding：文件保存的编码，如pageEncoding=&quot;utf-8&quot;
    1. 对于高版本的JSP，pageEncoding可以同时指定响应的编码；
    2. 对于低版本的JSP，还需要指定响应的编码：contentType=&quot;text/html;charset=UTF-8&quot;
5. session：设置转译的Servlet中是否支持Session，默认开启，不开启则设置session=&quot;false&quot;
6. errorPage：配置错误页面的路径，errorPage=&quot;error.jsp&quot;
7. extends：设置JSP转译的Servlet要继承的父类(全类名)
8. isELIgnored：是否忽略EL表达式，设置为true时，EL表达式会被当做普通字符串解析.
</code></pre><h3 id="JSP逻辑代码"><a href="#JSP逻辑代码" class="headerlink" title="JSP逻辑代码"></a>JSP逻辑代码</h3><pre><code>1. JSP的局部代码块
    &lt;%
        int num = 1;
        if(num &gt; 0) {
    %&gt;
            &lt;div&gt;num大于0&lt;/div&gt;
    &lt;% } else { %&gt;
            &lt;div&gt;另作处理&lt;/div&gt;
    &lt;% } %&gt;
    1. 转译到Servlet中
    int num = 1;
    if(num &gt; 0) {
        out.write(&quot;\r\n&quot;);
        out.write(&quot;\t\t&lt;div&gt;num大于0&lt;/div&gt;\r\n&quot;);
    } else {
        out.write(&quot;\t\t&lt;div&gt;另作处理&lt;/div&gt;\r\n&quot;);
    }
    2. 在JSP中写逻辑代码，编码困难，可阅读性和可维护性极差，所以尽量在Servlet中处理逻辑，
    JSP只负责展示内容。
2. JSP的全局代码块
    1. 声明Servlet的成员方法和成员变量
    &lt;%!
        int num = 1;
        public void test(){ ... }
    %&gt;
    2. 全局代码块声明的属性和方法，只能在局部代码块中使用。
3. JSP脚本段语句
    1. &lt;%= num %&gt;
    2. &lt;%= test() %&gt;  ==&gt;方法要有返回值
</code></pre><h3 id="JSP的引入与转发"><a href="#JSP的引入与转发" class="headerlink" title="JSP的引入与转发"></a>JSP的引入与转发</h3><pre><code>1. 静态引入： &lt;%@include file=&quot;header.jsp&quot; %&gt;
    1. 两个JSP文件会合并成一个Servlet文件;
    2. 静态引入的JSP不会单独转为一个Servlet;
    3. 两个JSP文件不能声明同名的Java变量.
2. 动态引入： &lt;jsp:include page=&quot;active.jsp&quot;&gt;&lt;/jsp:include&gt;
    1. 动态引入的JSP文件也会单独转为一个Servlet;
    2. 在当前JSP文件转译的Servlet中，会调用动态引入的JSP文件转译的Servlet;
    3. 允许在两个JSP文件中声明同名的Java变量.
3. JSP转发标签
    &lt;jsp:forward page=&quot;target.jsp&quot;&gt;&lt;/jsp:forward&gt;
    1. 一次请求，浏览器地址栏信息不变;
    2. 在&lt;jsp:forward&gt;标签中只能写&lt;jsp:param name=&quot;xxx&quot; value=&quot;xxx&quot;/&gt;，向目的JSP页面
    传递参数，而不能有其他任何字符，甚至是空格也不行，否则就会报错;
    &lt;jsp:forward page=&quot;target.jsp&quot;&gt;
        &lt;jsp:param name=&quot;user&quot; value=&quot;Mack&quot; /&gt;
    &lt;/jsp:forward&gt;
    3. 以GET形式转发参数：转发路径?user=Mack
    4. 在目的JSP页面获取参数：&lt;%= request.getParameter(&quot;user&quot;) %&gt;
</code></pre><h3 id="JSP的内置对象"><a href="#JSP的内置对象" class="headerlink" title="JSP的内置对象"></a>JSP的内置对象</h3><pre><code>1. 九大内置对象：JSP文件转译为Servlet时自动生成并声明的对象，可以在JSP文件中直接使用；
2. 内置对象只能在局部代码块和脚本段语句中使用；
1. pageContext：JSP的页面上下文对象，内部封装了另外8个内置对象；
    1. PageContext封存了当前JSP的运行信息，每个JSP文件都有一个PageContext对象；
    2. 每次请求都会重新创建一个PageContext对象，存储当前页面内的数据。
2. application
    ServletContext application = pageContext.getServletContext();
3. config
    ServletConfig application = pageContext.getServletConfig();
4. out
    JspWriter out = pageContext.getOut();
    1. JSP内部使用的响应对象，带有缓冲区，效率高于response
5. session：一次会话的Session对象，存储同一用户、不同请求的共享数据；
    1. 要使用Session对象，必须先在page指令中开启，session=&quot;true&quot;
    session = pageContext.getSession();
6. request，response：分别是当前的请求对象、响应对象；
7. page：this，当前JSP对象(Servlet对象);
8. exception：存储当前运行的异常信息，先在page指令中使用 isErrorPage=&quot;true&quot; 开启;
9. 数据流转
    1. pageContext：当前页面内的数据共享，获取其他内置对象;
    2. request：一次请求的数据共享，通过请求转发，把数据流转给下一个Servlet;
    3. session：一次会话，同一用户、不同请求的数据共享，将数据从一次请求流转给其他请求;
    4. application：项目内的数据，不同用户的数据共享，将数据从一个用户流转给其他用户.
</code></pre><h3 id="JSP的资源路径"><a href="#JSP的资源路径" class="headerlink" title="JSP的资源路径"></a>JSP的资源路径</h3><pre><code>1. 在JSP中使用相对路径时，资源位置不可随意更改；
2. 绝对路径：&lt;a href=&quot;/servtest/a.jsp&quot;&gt;，
    1. 第一个 &quot;/&quot; 表示服务器根目录(Tomcat/webapps)，&quot;/servtest&quot; 表示服务器的项目根目录，
    servtest是项目在Tomcat/webapps下的虚拟目录名。
3. 在JSP中声明全局路径
    &lt;%
        String path = request.getContextPath();
        String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;
        +request.getServerPort()+path+&quot;/&quot;;
    %&gt;
    &lt;html&gt;
        &lt;head&gt;
            &lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt;
    1. 那么，在JSP文件中引入资源时，资源路径会自动加上 Ip:Port/项目虚拟目录名/
    2. &lt;a href=&quot;a.jsp&quot;&gt; 跳转到 http://Ip:Port/servtest/a.jsp
4. 重定向到 main目录下的main.jsp
    resp.sendRedirect(&quot;/servtest/main/main.jsp&quot;);
    1. 重定向时，尽量使用绝对路径取代资源路径：/项目虚拟目录名/资源路径;
    2. 假定当前的Servlet的别名带有目录，如&lt;url-pattern&gt;/user/abc&lt;/url-pattern&gt;
    3. 如果使用相对路径，如resp.sendRedirect(&quot;main/main.jsp&quot;);  那么跳转的main.jsp的
    路径为 /项目虚拟目录名/user/main/main.jsp;
    4. 而main.jsp的真实路径是 /项目虚拟目录名/main/main.jsp ，那么就会报404错误.
5. 转发到一个JSP页面
    req.getRequestDispatcher(&quot;/login.jsp&quot;).forward(req, resp);
    1. 与请求重定向不同，请求转发的第一个 &quot;/&quot; 表示项目根目录，而不是服务器根目录，所以不用
    加项目的虚拟目录名.
</code></pre><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><pre><code>1. EL：Expression Language，一种写法非常简洁的表达式，灵感来源于ES和XPath;
2. EL表达式用于简化在JSP中获取作用域数据和请求数据，不需要导入相关的类(包);
3. 传统的获取方式
    1. 在Servlet中处理请求之后，通过请求转发到JSP页面：req.setAttribute(&quot;key&quot;, Object);
    2. 在JSP页面中获取数据：&lt;%= request.getAttribute(&quot;key&quot;) %&gt;
    3. 在JSP页面中获取请求参数：&lt;%= request.getParameter(&quot;key&quot;) %&gt;
4. 语法结构：${expression}
    1. 获取请求参数
    ${ param.key } --&gt; 单个值
    ${ paramvalues.key } --&gt; 同键不同值如Checkbox
    2. 获取 req.setAttribute(&quot;key&quot;, Object) 传递的数据：${ Object }
    3. ${} 只获取 pageContext、request、session、application四个对象中的数据;
    &lt;%  String uname = &quot;Java&quot;;  %&gt;
    &lt;h3&gt;${ uname }&lt;/h3&gt;
    4. 如果在四大对象中找不到uname，不报错，也不显示内容，但决不理会页面中定义的变量uname;
5. EL查找作用域数据的默认顺序：pageContext --&gt; request --&gt; session --&gt; application
    &lt;%
        pageContext.setAttribute(&quot;uname&quot;, &quot;aaaa&quot;);
        request.setAttribute(&quot;uname&quot;, &quot;bbbb&quot;);
        session.setAttribute(&quot;uname&quot;, &quot;cccc&quot;);
        application.setAttribute(&quot;uname&quot;, &quot;dddd&quot;);
    %&gt;
    &lt;div&gt;${ uname }&lt;/div&gt; ===&gt; aaaa
    1. 除了默认顺序，还可以手动指定查找方向
    request：${ requestScope.uname }，pageContext：${ pageScope.uname }
    session：${ sessionScope.uname }，application：${ applicationScope.uname }
6. EL支持简单的逻辑运算：算术表达式、关系表达式、逻辑表达式(&amp;&amp; || !)、三元表达式
    ${ 1+3 } =&gt; 4，${ 1&gt;3 } =&gt; false，${ flag==0?&quot;正确&quot;:&quot;错误&quot; }
    1. EL表达式中不允许做字符串连接
    ${ 1+&quot;4&quot; } =&gt; 5，${ 1+&quot;a&quot; } =&gt; 报错
7. EL的空值判断：${ empty key }，空字符串、空集合都返回true，但是对象返回false
8. EL获取请求头数据：${ header }
    1. 单个值：${ header[&quot;key&quot;] }，如${ header[&quot;user-agent&quot;] }
    2. 数组：${ headerValues[&quot;key&quot;] }，同键不同值
9. EL获取Cookie数据：${ cookie }
    1. 获取一条Cookie数据，如sessionID：${ cookie.JSESSIONID }
    2. 获取这条Cookie数据的键值：
    ${ cookie.JSESSIONID.name }，${ cookie.JSESSIONID.value }
</code></pre><h2 id="JSTL标签库"><a href="#JSTL标签库" class="headerlink" title="JSTL标签库"></a>JSTL标签库</h2><pre><code>1. JSTL是 Apache 对EL表达式的扩展，JSTL依赖于EL，使用时需要导包，并指定标签库；
    1. MyEclipse会在lib目录下自动存放jstl.jar
    2. JSTL的标签库：核心库、格式化库、SQL库、函数库、XML库
2. JSTL标签库能够提升JSP页面编写逻辑代码的效率，可阅读性更强；
</code></pre><h3 id="JSTL核心标签库"><a href="#JSTL核心标签库" class="headerlink" title="JSTL核心标签库"></a>JSTL核心标签库</h3><pre><code>1. 导入jar包，声明jstl核心标签库的引入
    &lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
2. 输出：&lt;c:out&gt; 类似于 &lt;%=xxx %&gt;
    &lt;%  request.setAttribute(&quot;uname&quot;, &quot;Java&quot;);  %&gt;
    &lt;c:out value=&quot;${uname}&quot; default=&quot;xxx&quot;&gt;&lt;/c:out&gt;
    1. 结合EL表达式输出，如果uname不存在，则输出默认值default
3. 向作用域中存储键值： &lt;c:set var=&quot;key&quot; value=&quot;xxx&quot;&gt;&lt;c:set&gt;
    1. 默认存储在pageContext中，也可以手动指定存储的作用域对象
    &lt;c:set var=&quot;key&quot; value=&quot;xxx&quot; scope=&quot;page/request/session/application&quot;&gt;&lt;c:set&gt;
4. 删除作用域的数据：&lt;c:remove&gt;
    &lt;c:remove var=&quot;uname&quot; /&gt;
    1. 默认把4个作用域对象中的uname都删除，scope属性指定作用域
    &lt;c:remove var=&quot;uname&quot; scope=&quot;page/request/session/application&quot; /&gt;
5. 逻辑标签：依赖于EL表达式
    1. 单个判断
    &lt;c:set var=&quot;score&quot; value=&quot;66&quot;&gt;&lt;c:set&gt;
    &lt;c:if test=&quot;${score&gt;60}&quot;&gt;
        &lt;div&gt;条件通过&lt;/div&gt;
    &lt;/c:if&gt;
    2. 多重判断
    &lt;c:choose&gt;
        &lt;c:when test=&quot;${score&gt;=90}&quot;&gt;
            &lt;li&gt;11111111&lt;/li&gt;
        &lt;/c:when&gt;
        &lt;c:when test=&quot;${score&lt;90 &amp;&amp; score&gt;=70}&quot;&gt;
            &lt;li&gt;2222222&lt;/li&gt;
        &lt;/c:when&gt;
        &lt;c:when test=&quot;${score&lt;70 &amp;&amp; score&gt;=60}&quot;&gt;
            &lt;li&gt;3333333&lt;/li&gt;
        &lt;/c:when&gt;
        &lt;c:otherwise&gt;
            &lt;li&gt;4444444&lt;/li&gt;
        &lt;/c:otherwise&gt;
    &lt;/c:choose&gt;
6. 常量循环
    &lt;c:forEach begin=&quot;1&quot; end=&quot;4&quot; step=&quot;1&quot; varStatus=&quot;vs&quot;&gt;  ==&gt; 循环4次
        &lt;li&gt;${vs.index} -- ${vs.count} -- ${vs.first} -- ${vs.last}&lt;/li&gt;
    &lt;/c:forEach&gt;
    1. step属性设置每次循环的自增步数，默认自增1
    2. varStatus属性保存当前循环的状态
        1. vs.index：当前循环的角标
        2. vs.count：当前是第几次循环
        3. vs.first/vs.last：当前是不是第一次/最后一次循环，true/false
7. 动态循环
    &lt;%
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;111&quot;);
        request.setAttribute(&quot;list&quot;, list);
        HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;a&quot;, &quot;11&quot;);
        request.setAttribute(&quot;map&quot;, map);
    %&gt;
    1. 遍历List集合
    &lt;c:forEach items=&quot;${list}&quot; var=&quot;v&quot;&gt;
        &lt;li&gt;${v}&lt;/li&gt;
    &lt;/c:forEach&gt;
    2. var属性是每次循环的元素值;
    3. 遍历Map集合
    &lt;c:forEach items=&quot;${map}&quot; var=&quot;v&quot;&gt;
        &lt;li&gt;${v.key} -- ${v.value}&lt;/li&gt;
    &lt;/c:forEach&gt;
    4. v 表示每次循环的一条Map元素，v.key、v.value 分别表示这条数据的键、值。
</code></pre><h3 id="JSTL格式化标签库"><a href="#JSTL格式化标签库" class="headerlink" title="JSTL格式化标签库"></a>JSTL格式化标签库</h3><pre><code>1. 声明jstl核心标签库的引入
    &lt;%@taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; %&gt;
2. 可以格式化输入文本、日期、时间、数字
    1. &lt;fmt:formatNumber&gt;：使用指定的格式或精度格式化数字;
    2. &lt;fmt:parseNumber&gt;：解析一个代表着数字/货币/百分比的字符串;
    3. &lt;fmt:formatDate&gt;：使用指定的风格或模式格式化日期和时间;
    4. &lt;fmt:parseDate&gt;：解析一个代表着日期或时间的字符串;
    5. &lt;fmt:requestEncoding&gt;：设置request的字符编码;
    6. &lt;fmt:timeZone&gt;：指定时区，供其它标签使用;
    7. &lt;fmt:setTimeZone&gt;：复制一个时区对象至指定的作用域.
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">大麦田怪圈</p>
              <p class="site-description motion-element" itemprop="description">敢做就能赢！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">47</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大麦田怪圈</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
