<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="敢做就能赢！">
<meta property="og:type" content="website">
<meta property="og:title" content="大麦田程序猿">
<meta property="og:url" content="http://hellomyshadow.github.io/page/6/index.html">
<meta property="og:site_name" content="大麦田程序猿">
<meta property="og:description" content="敢做就能赢！">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="大麦田程序猿">
<meta name="twitter:description" content="敢做就能赢！">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hellomyshadow.github.io/page/6/">





  <title>大麦田程序猿</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大麦田程序猿</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/03/07/Spring与动态代理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/07/Spring与动态代理/" itemprop="url">Spring与动态代理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-07T00:00:00+08:00">
                2016-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="事务问题"><a href="#事务问题" class="headerlink" title="事务问题"></a>事务问题</h2><pre><code>public class Account {  //账户实体类
    private int id;
    private String name;
    private double money;
    //setter、getter
}
public AccountServiceImpl implements IAccountService {
    private IAccountDao dao;
    ...... //CRUD
    public void transfer(String sourceName, String targetName, float money) {
        //sourceName向targetName转向金额money
        Account source = dao.findByName(sourceName);
        Account target = dao.findByName(targetName);
        source.setMoney(source.getMoney() - money);
        target.setMoney(target.getMoney() + money);
        //更新数据库
        dao.updateAccount(source);
        int i = 1/0;  //发生异常，不再向下执行
        dao.updateAccount(target);
    }
}
1. 因为发生了异常，导致源账户的金额虽然变化了，但目标账户的金额并没有增加，根本原因在于事务
   没有回滚；
2. QueryRunner 的配置：
&lt;bean id=&quot;runner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot; scope=&quot;prototype&quot;&gt;
    &lt;constructor-arg name=&quot;ds&quot; ref=&quot;dataSource&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
    1. QueryRunner是多例的，每次数据库操作都会获取一个新连接，一个独立的新事务，操作成功之后，
    事务自动提交；
    2. 所以，所以发生异常时，没有一个总的事务控制，数据也就不会回滚。
3. 使用ThreadLocal把Connection和当前线程绑定，从而使一个线程只有一个能控制事务的对象；
    1. 当前的所有数据控制都在持久层，应该转到业务层上；
    2. 创建连接的工具类
        public class ConnectionUtils {
            private ThreadLocal&lt;Connection&gt; tl = new ThreadLocal&lt;&gt;();
            private DataSource dataSource;
            ...... //DataSource的setter
            public Connection getThreadConn() {
                Connection conn = tl.get();
                if(conn == null) { //从数据源中获取一个连接，并存入连接池
                    conn = dataSource.getConnection();
                    tl.set(conn);
                }
                return conn;
            }
            public void removeConn() {
                // 移除ThreadLocal中当前线程的连接
                tl.remove();
            }
        }
    3. 事务管理的工具类
        public class TransactionManager {
            private ConnectionUtils connUtils;
            ......//setter
            public void beginTransaction() {
                //开启事务，修改为手动提交
                connUtils.getThreadConn().setAutoCommit(false);
            }
            public void commit() {  //手动提交事务
                connUtils.getThreadConn().commit();
            }
            public void rollback() {  //回滚
                connUtils.getThreadConn().rollback();
            }
            public void release() {
                //释放连接，并还给连接池
                connUtils.getThreadConn().close();
                connUtils.removeConn();
            }
        }
4. 在Service中控制事务
    public AccountServiceImpl implements IAccountService {
        private IAccountDao dao;
        private TransactionManager manager;
        ......//setter
        public List&lt;Account&gt; findAll() {
            try {
                manager.beginTransaction(); //开启事务
                List&lt;Account&gt; accounts = dao.findAll();
                manager.commit(); //提交事务
                return accounts;
            } catch(Exception e) {
                manager.rollback(); //回滚
                throw new RuntimeExcepion(e);
            } finally {
                manager.release(); //释放连接
            }
        }
        ...... //带有事务的CRUD
        public void transfer(String sourceName, String targetName, float money) {
            //sourceName向targetName转向金额money
            try {
                manager.beginTransaction(); //开启事务
                Account source = dao.findByName(sourceName);
                Account target = dao.findByName(targetName);
                source.setMoney(source.getMoney() - money);
                target.setMoney(target.getMoney() + money);
                //更新数据库
                dao.updateAccount(source);
                int i = 1/0;  //发生异常，不再向下执行
                dao.updateAccount(target);
                manager.commit(); //提交事务
            } catch(Exception e) {
                manager.rollback(); //回滚
                throw new RuntimeExcepion(e);
            } finally {
                manager.release(); //释放连接
            }
        }
    }
5. 不为QueryRunner的构造方法提供DataSource，也就不注入连接
    &lt;bean id=&quot;runner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot; 
        scope=&quot;prototype&quot;&gt;&lt;/bean&gt;
6. 在Dao层，为QueryRunner手动提供Connection连接
    public AccountDaoImpl implements IAccountDao {
        private QueryRunner runner;
        private ConnectionUtils connUtils;
        ......//setter
        public List&lt;Account&gt; findAll() {
            //Connection对象作为第一个参数，表示手动提供连接对象
            return runner.query(connUtils.getThreadConn(), ......);
        }
        ......
    }
7. 在 bean.xml 中配置ConnectionUtils和TransactionManager;
    &lt;bean id=&quot;accountDao&quot; class=&quot;it.bank.dao.impl.AccountDaoImpl&quot;&gt;
        &lt;property name=&quot;runner&quot; ref=&quot;runner&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;connUtils&quot; ref=&quot;connUtils&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;accountService&quot; class=&quot;it.bank.service.impl.AccountServiceImpl&quot;&gt;
        &lt;property name=&quot;dao&quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;manager&quot; ref=&quot;manager&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;connUtils&quot; class=&quot;it.bank.utils.ConnectUtils&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;manager&quot; class=&quot;it.bank.utils.TransactionManager&quot;&gt;
        &lt;property name=&quot;connUtils&quot; ref=&quot;connUtils&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    ...... //runner、dataSource
</code></pre><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><pre><code>1. 虽然解决了事务控制，但是类与类之间存在较强的依赖关系，方法名的改变，可能导致毁灭性打击；
2. 动态代理：不同于装饰者模式，不需要实现创建类，而是随用随加载，通过字节码动态创建对象；
    1. 作用：不修改源码的基础上，对方法增强；
    2. 分类：基于接口的动态代理，基于子类的动态代理。
</code></pre><h3 id="基于接口的动态代理"><a href="#基于接口的动态代理" class="headerlink" title="基于接口的动态代理"></a>基于接口的动态代理</h3><pre><code>1. 创建代理对象的要求：被代理的类最少实现一个接口，否则不能使用；
    Proxy.newProxyInstance(ClassLoader, Class[], InvocationHandler)
2. ClassLoader：类加载器，用于加载代理对象的字节码，和被代理对象使用相同的类加载器；
    被代理对象.getClass().getClassLoader()
3. Class[]：字节码数组，用于让代理对象和被代理对象具有相同的方法；
    被代理对象.getClass().getInterfaces()
4. InvocationHandler：用于提供增强的代码，定义代理的方式，一般都是此接口的匿名内部类；
    new InvocationHandler() {
        public Object invoke(Object proxy, Method method, Object[] args) {
            //默认方式，相当于没有任何增强
            return method.invoke(被代理对象, args);
        }
    }
    1. 执行被代理对象的任何接口方法时，都会经过invoke();
    2. proxy：代理对象的引用;
    3. method：当前执行的方法;
    4. args：当前执行方法所需的参数;
    5. invoke()的返回值，将作为被代理对象的方法的返回值.
5. 生产商Producer，生产商的准则IProducer(代理商对生产商的要求)
    public interface IProducer {
        void sale(float money);
        void after(float money);
    }
    public class Producer implements IProducer {
        public void sale(float money) {  //销售
            System.out.println(&quot;生产商销售产品，拿到钱：&quot; + money);
        }
        public void after(float money) {  //售后
            System.out.println(&quot;生产商提供售后，拿到钱：&quot; + money);
        }
    }
6. 消费者Client
    final Producer p = new Producer();
    1. 创建动态代理
    IProducer proxyProducer = (IProducer)Proxy.newProxyInstance(
            p.getClass().getClassLoader(), p.getClass().getInterfaces(), 
        new InvocationHandler() {
            public Object invoke(Object proxy, Method method, Object[] args) {
                Object leftMoney = null;
                Float money = (Float)args[0];
                if(&quot;sale&quot;.equals(method.getName())) {
                    //购买时，代理商提取20%的回扣
                    leftMoney = method.invoke(p, money*0.8f);
                }
                return leftMoney;
            }
        });
    2. 消费者通过代理对象实现购买与服务
    proxyProducer.sale(10000f);  //生产商销售产品，拿到钱：8000
</code></pre><h3 id="基于子类的动态代理"><a href="#基于子类的动态代理" class="headerlink" title="基于子类的动态代理"></a>基于子类的动态代理</h3><pre><code>1. 为一个普通的类创建动态代理：
    1. 被代理的类不能是最终类(final class XXX)，因为它不能再创建子类；
    2. 借助第三方cglib库，Enhancer.create()
    &lt;dependency&gt;
        &lt;groupId&gt;cglib&lt;/groupId&gt;
        &lt;artifactId&gt;cglib&lt;/artifactId&gt;
        &lt;version&gt;3.2.10&lt;/version&gt;
    &lt;/dependency&gt;
2. Enhancer.create(Class, Callback)
    1. Class：被代理对象的字节码；
    2. Callback：提供增强的代码，通常使用其子类，如MethodInterceptor
3. 生产商Producer
    public class Producer {
        public void sale(float money) {  //销售
            System.out.println(&quot;生产商销售产品，拿到钱：&quot; + money);
        }
        public void after(float money) {  //售后
            System.out.println(&quot;生产商提供售后，拿到钱：&quot; + money);
        }
    }
4. 消费者Client
    final Producer p = new Producer();
    1. 创建代理对象
    Producer proxyProducer = (Producer)Enhancer.create(p.getClass(), 
        new MethodInterceptor() {
            public Object intercept(Object proxy, Method method, Object[] args, 
                MethodProxy methodProxy) throws Throwable {
                Object leftMoney = null;
                Float money = (Float)args[0];
                if(&quot;sale&quot;.equals(method.getName())) {
                    leftMoney = method.invoke(p, money*0.8f);
                }
                return leftMoney;
            }
        });
    2. 执行被代理对象的方法时，也都会经过intercept()
    3. methodProxy：当前执行方法的代理对象.
</code></pre><h3 id="动态代理控制事务"><a href="#动态代理控制事务" class="headerlink" title="动态代理控制事务"></a>动态代理控制事务</h3><pre><code>1. 分离Service中控制事务的部分，交给代理对象去控制事务;
    public AccountServiceImpl implements IAccountService {
        private IAccountDao dao;
        ......//setter
        public List&lt;Account&gt; findAll() {
            return dao.findAll();
        }
        public Account findByName(String name) {
            return dao.findByName(name);
        }
        public void update(Account account) {
            dao.update(account);
        }
        ......
    }
2. 创建Service的代理对象的工厂
    public class BeanFactory {
        private IAccountService service;
        private TransactionManager manager;
        ......//setter
        public IAccountService getAccountService() {
            return (IAccountService) Proxy.newProxyInstance(
            service.getClass().getClassLoader(), service.getClass().getInterfaces(), 
            new InvocationHandler(){
                public Object invoke(Object proxy, Method method, Object[] args)  {
                    object rtValue = null;
                    try { //增强方法: 在执行Service的方法时, 加入事务
                        manager.beginTransaction();
                        rtValue = method.invoke(service, args);
                        manager.commit();
                        return rtValue;
                    } catch(Exception e) {
                        manager.rollback();
                        throw new RuntimeException(e);
                    } finally {
                        manager.release();
                    }
                }
            });
        }
    }
3. 在 bean.xml 中，修改&lt;bean&gt;的关系，并配置工厂类BeanFactory
    &lt;bean id=&quot;proxyService&quot; factory-bean=&quot;beanFactory&quot; factory-method=&quot;getAccountService&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;beanFactory&quot; class=&quot;it.bank.factory.BeanFactory&quot;&gt;
        &lt;property name=&quot;service&quot; ref=&quot;accountService&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;manager&quot; ref=&quot;connUtils&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;accountService&quot; class=&quot;it.bank.service.impl.AccountServiceImpl&quot;&gt;
        &lt;property name=&quot;dao&quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    ...... //accountDao、connUtils、manager、runner、dataSource
    1. 此时的容器中，有两个类型相同的bean对象：proxyService、accountService
    2. 那么在注入使用时，需要明确指定使用代理对象创建的Service Bean对象
        @Autowired
        @Qualifier(&quot;proxyService&quot;)
        private IAccountService service;
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/03/06/Spring注解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/06/Spring注解/" itemprop="url">Spring注解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-06T00:00:00+08:00">
                2016-03-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="IoC注解"><a href="#IoC注解" class="headerlink" title="IoC注解"></a>IoC注解</h2><pre><code>1. @Component：创建对象，&lt;bean&gt;标签的功能，把类对象存入Spring容器中
    @Component(&quot;userService&quot;)  ---&gt;@Component(value=&quot;userService&quot;)
    public class UserServiceImpl implements IUserService {
        ......
    }
    1. value属性就是Bean对象的id，如果直接使用 @Component，而不指定value，则默认id为
    首字母小写的类名userServiceImpl;
    2. 在配置文件 bean.xml 中导入context命名空间和约束，并告知Spring扫描哪个包下的注解
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
        &lt;!-- 告知Spring在创建容器时要扫描的包 --&gt;
        &lt;context:component-scan base-package=&quot;项目的包名&quot;&gt;&lt;/context:component-scan&gt;
    &lt;/beans&gt;
    3. 通过注解创建对象
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
    IUserService us = (IUserService)ac.getBean(&quot;userService&quot;);
2. Spring为了三层架构更加清晰, 还有三个与 Component 功能相同的衍生注解
    1. Controller：一般用于表现层；
    2. Service：一般用于表现层；
    3. Repository：一般用在持久层。
3. Scope：指定Bean对象的作用范围，同&lt;bean&gt;上的scope属性；
    1. value属性：指定取值范围;
    2. 常用取值：singleton、prototype.
4. 生命周期相关
    1. PreDestroy：指定销毁方法，&lt;bean&gt;上的destroy-method;
    2. PostConstruct：指定初始化方法，&lt;bean&gt;上的init-method;
        @Component(&quot;userService&quot;)
        @Scope(&quot;prototype&quot;)  --------&gt;指定为多例
        public class UserServiceImpl implements IUserService {
            @PostConstruct
            public void init() {
                ......//Bean的初始化
            }
            @PreDestroy
            public void destroy() {
                ......//Bean的销毁
            }
        }
</code></pre><h3 id="注入数据的注解"><a href="#注入数据的注解" class="headerlink" title="注入数据的注解"></a>注入数据的注解</h3><pre><code>1. @Autowired：自动按照类型注入；
    1. 只要容器中有唯一的一个Bean对象与要注入的变量类型匹配，就可以注入成功；
    2. 可以用在变量上，也可以用在方法上；
    @Repository(&quot;userDao&quot;)
    public class UserDaoImpl implements IUserDao {
        public void saveUser() { ... }
    }
    @Service(&quot;userService&quot;)
    public class UserServiceImpl implements IUserService {
        @Autowired
        private IUserDao dao;
        public void saveUser() {
            dao.saveUser();
        }
    }
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
    //指定getBean()的第二个参数，则不需要再强转类型
    IUserService us = ac.getBean(&quot;userService&quot;, IUserService.class);
    us.saveUser();  //内部可以调用Dao对象的方法，dao不再是null
    3. 如果IoC有多个匹配的Bean对象，Spring会取出这些Bean对象的id，然后使用变量名与这些id
    进行匹配，有则匹配，否则报错；
        @Repository(&quot;userDao1&quot;)
        public class UserDao1Impl implements IUserDao {
            public void saveUser() { ... }
        }
        @Repository(&quot;userDao2&quot;)
        public class UserDao2Impl implements IUserDao {
            public void saveUser() { ... }
        }
        @Service(&quot;userService&quot;)
        public class UserServiceImpl implements IUserService {
            @Autowired
            private IUserDao userDao2;  //与 UserDao2Impl 相匹配
            ......
        }
    4. 不再需要setter
2. @Qualifier：在按照类中注入的基础上，再按照名称注入；
    1. 在给类成员注入时，不能单独使用; 但给方法参数注入时，可以单独使用;
    2. 属性value：指定注入Bean对象的id;
    @Service(&quot;userService&quot;)
    public class UserServiceImpl implements IUserService {
        @Autowired
        @Qualifier(&quot;userDao2&quot;)  --&gt; 注入 UserDao2Impl 对象
        private IUserDao dao;
        ......
    }
3. @Resource：按照Bean的id注入，且可以单独使用，属性name用于指定注入Bean的id;
    @Resource(name=&quot;userDao2&quot;)  --&gt;如果不指定name属性，默认把属性变量名作为Bean的id
    private IUserDao dao;
4. 这三种注解都只能注入IoC容器管理的Bean对象，不能注入基本数据类型，而集合类型只能使用XML实现注入;
5. Value：用于注入基本数据类型，属性value用于指定数据的值；
    1. 它可以使用Spring的SpEL(Spring的EL表达式);
    2. SpEL的写法：${表达式}，虽然与JSP的EL表达式写法相同，但出现的位置并不相同；
</code></pre><h2 id="Spring整合数据库操作"><a href="#Spring整合数据库操作" class="headerlink" title="Spring整合数据库操作"></a>Spring整合数据库操作</h2><pre><code>1. Dbutils：由Apache提供，主要封装了JDBC，简化Dao层的操作，又不会影响性能；
    1. 三个核心类：DbUtils、QueryRunner、ResultSetHandle
    2. DbUtils：连接数据库对象，控制连接，jdbc辅助方法的集合类，线程安全；
    3. QueryRunner：SQL语句的操作对象，线程安全；
        1. QueryRunner()：无参构造，创建一个与数据库无关的QueryRunner对象，需要提供一个
        Connection对象，它可以手动控制事务;
            Connection.setAutoCommit(false); //设置手动管理事务
            Connection.commit(); //手动提交事务
        2. QueryRunner(DataSource ds)：有参构造，创建一个与数据库关联的对象，不需要提供
        Connection对象，自动管理事务;
        3. DataSource：数据库连接池对象，由c3p0提供;
        4. update()：用于执行DDL(create、alter、drop);
        5. query()：用于执行DML(insert、update、delete);
        6. batch()：执行批处理.
    4. ResultSetHandle：封装数据的策略对象，将封装结果集中的数据转换到另一个对象。
2. c3p0：连接池，为了提高应用程序与数据库之间的访问效率，简单易用、连接复用、连接管理;
3. 引入依赖：spring-context、commons-dbutils、c3p0、mysql-connector-java
4. 持久层、业务层
    1. 实体类：com.test.domain.User
        public class User {
            //id、name、age
        }
    2. 持久层Dao：com.test.dao.IUserDao
        public interface IUserDao {
            //CRUD
        }
        public class UserDaoImpl implements IUserDao {
            private QueryRunner runner;
            //setter
            public List&lt;User&gt; findAll() { //查询所有
                return runner.query(&quot;select * from user&quot;, 
                            new BeanListHandler&lt;User&gt;(User.class));
            }
            public List&lt;User&gt; findById(int id) { //查询一个
                return runner.query(&quot;select * from user where id=?&quot;, 
                                    new BeanHandler&lt;User&gt;(User.class), id);
            }
            public void save(User u) { //保存
                runner.update(&quot;insert into user(name, age) values(?, ?)&quot;, 
                                                    u.getName(), u.getAge());
            }
            public void update(User u) { //更新
                runner.update(&quot;update user set name=?,age=? where id=?&quot;, 
                                        u.getName(), u.getAge(), u.getId());
            }
            public void delete(int id) { //删除
                runner.update(&quot;delete from user where id=?&quot;, id);
            }
        }
3. 业务层Service：com.test.service.IUserService
    public interface IUserService { ...... }
    public class UserServiceImpl implements IUserService {
        private IUserDao dao;
        //setter
        ......
    }
4. 配置Spring：resources/bean.xml
    &lt;bean id=&quot;userService&quot; class=&quot;com.test.service.impl.UserServiceImpl&quot;&gt;
        &lt;property name=&quot;dao&quot; ref=&quot;userDao&quot;&gt;&lt;property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.test.dao.impl.UserDaoImpl&quot;&gt;
        &lt;property name=&quot;runner&quot; ref=&quot;runner&quot;&gt;&lt;property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;runner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot; scope=&quot;prototype&quot;&gt;
        &lt;constructor-arg name=&quot;ds&quot; ref=&quot;dataSource&quot;&gt;&lt;/constructor-arg&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
        &lt;!-- 链接数据库的信息 --&gt;
        &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:......&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    1. QueryRunner设置为多例对象，避免多线程之间相互干扰;
    2. 开始使用：
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
    IUserService service = ac.getBean(&quot;userService&quot;, IUserService.class);
    List&lt;User&gt; us = service.findAll(); //查询所有
6. 修改为注解配置
    1. 在 bean.xml 的约束中，增加context的命名空间；
    2. 移除UserServiceImpl和UserDaoImpl的&lt;bean&gt;，告知Spring创建容器时要扫描的包；
    &lt;context:component-scan base-package=&quot;com.test&quot;&gt;&lt;/context:component-scan&gt;
    &lt;bean id=&quot;runner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot; scope=&quot;prototype&quot;&gt;
        &lt;constructor-arg name=&quot;ds&quot; ref=&quot;dataSource&quot;&gt;&lt;/constructor-arg&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
        ...... &lt;!-- 链接数据库的信息 --&gt;
    &lt;/bean&gt;
    3. 为 UserServiceImpl和UserDaoImpl 添加注解，并移除其中的setter.
        @Repository(&quot;userDao&quot;)
        public class UserDaoImpl implements IUserDao {
            @Autowired
            private QueryRunner runner;
            ......
        }
        @Service(&quot;userService&quot;)
        public class UserServiceImpl implements IUserService {
            @Autowired
            private IUserDao dao;
            ......
        }
</code></pre><h3 id="Spring新注解"><a href="#Spring新注解" class="headerlink" title="Spring新注解"></a>Spring新注解</h3><pre><code>1. Configuration：声明一个类为配置类，用于取代配置文件 bean.xml;
2. ComponentScan：指定创建容器时要扫描的包;
    1. value属性和basePackages属性的作用相同，都是指定包名;
    2. 此注解的功能等同于 bean.xml 中的 &lt;context:component-scan&gt;
3. Bean：把当前方法的返回值作为bean对象，存入Spring的IoC容器中;
    1. name属性：指定bean的id，不显式声明id时，默认为当前方法名;
    2. 此注解可以取代&lt;bean id=&quot;runner&quot; ···&gt; 和 &lt;bean id=&quot;dataSource&quot; ···&gt;
    3. @Scope：指定bean对象的作用范围;
        @Configuration
        @ComponentScan(basePackages=&quot;com.test&quot;)
        public class SpringConfiguration {
            @Bean(name=&quot;runner&quot;)
            @Scope(&quot;prototype&quot;)
            public QueryRunner createQueryRunner(DataSource dataSource) {
                return new QueryRunner(dataSource);
            }
            @Bean(name=&quot;dataSource&quot;)
            public DataSource createDataSource() {
                ComboPooledDataSource ds = new ComboPooledDataSource();
                ds.setDriverClass(&quot;com.mysql.cj.jdbc.Driver&quot;);
                ds.setJdbcUrl(&quot;jdbc:mysql:......&quot;);
                ds.setUser(&quot;root&quot;);
                ds.setPassword(&quot;123456&quot;);
                return ds;
            }
        }
    4. 在使用注解配置方法时，如果方法上有参数(也是bean对象)，Spring会去容器中查找有没有
    与此参数对应的bean对象，查找方式与Autowired相同;
        1. 如果有且只有一个匹配的bean对象，则匹配成功;
        2. 如果有多个匹配的bean对象，则根据参数名与bean的id进行匹配.
    5. 另外，方法的参数上可以单独使用 @Qualifier，明确指定要匹配的bean对象;
    @Bean(name=&quot;runner&quot;)
    @Scope(&quot;prototype&quot;)
    public QueryRunner createQueryRunner(@Qualifier(&quot;ds2&quot;) DataSource dataSource) {
        return new QueryRunner(dataSource);
    }
    @Bean(name=&quot;ds1&quot;)
    public DataSource createDataSource() { ... }

    @Bean(name=&quot;ds2&quot;)
    public DataSource createDataSource() { ... }
    6. @Qualifier(&quot;ds2&quot;) 指定去匹配 @Bean(name=&quot;ds2&quot;) 的方法.
4. 使用 AnnotationConfigApplicationContext 加载配置类，获取bean对象
    ApplicationContext ac = 
        new AnnotationConfigApplicationContext(SpringConfiguration.class);
    IUserService service = ac.getBean(&quot;userService&quot;, IUserService.class);
</code></pre><h3 id="分解注解类"><a href="#分解注解类" class="headerlink" title="分解注解类"></a>分解注解类</h3><pre><code>1. 为了便于管理，一个主配置类可以分为多个子配置类，如把JDBC相关的配置放在 JdbcConf类 中;
    @Configuration
    public class JdbcConf {   //全类名为config.JdbcConf
        @Bean(name=&quot;runner&quot;)
        @Scope(&quot;prototype&quot;)
        public QueryRunner createQueryRunner(DataSource ds) { ... }
        @Bean(name=&quot;ds&quot;)
        public DataSource createDataSource() { ... }
    }
2. 在主配置类中声明要扫描的包，包括子配置文件所在的包
    @Configuration
    @ComponentScan({&quot;com.test&quot;, &quot;config&quot;})
    public class SpringConfiguration { }
3. 在创建ApplicationContext对象时，如果直接把配置类作为参数，则可省略 @Configuration，
   也不需要扫描配置类所在的包；
    public class JdbcConf { ... }

    @ComponentScan({&quot;com.test&quot;})
    public class SpringConfiguration { }

    ApplicationContext ac = new AnnotationConfigApplicationContext(
                                    SpringConfiguration.class, JdbcConf.class);
4. Import：导入其他的配置类
    1. 被导入的配置类上可以使用 @Configuration，也可以不声明它所在的包;
    public class JdbcConf { ... }

    @ComponentScan({&quot;com.test&quot;})
    @Import(JdbcConf.class)
    public class SpringConfiguration { }

    ApplicationContext ac = 
            new AnnotationConfigApplicationContext(SpringConfiguration.class);
    2. 此时，SpringConfiguration称为父配置类，JdbcConf称为子配置类
5. PropertySource：加载properties文件;
    1. value属性：指定文件的名称和路径;
    2. classpath关键字：表示类路径下;
        resources/spring/conf/jdbc.properties ---&gt; 
                    @PropertySource(&quot;classpath:spring/conf/jdbc.properties&quot;)
6. 抽取出数据库连接的信息
    1. 在resources目录下创建 jdbcConf.properties
        jdbc.driver = com.mysql.cj.jdbc.Driver
        jdbc.url = jdbc:mysql:......
        jdbc.user = root
        jdbc.password = 123456
    2. 在主配置类上注解 @PropertySource，引入properties文件，那么其子配置类都可以通过EL表达式获取键-值
        @ComponentScan({&quot;com.test&quot;})
        @Import(JdbcConf.class)
        @PropertySource(&quot;classpath:jdbcConf.properties&quot;)
        public class SpringConfiguration { }
    3. 在子配置类JdbcConf 中使用Spring的EL表达式，获取properties中的key-value值
        public class JdbcConf { --&gt;亦或者直接在JdbcConf类上注解 @PropertySource(...)
            @Value(&quot;${jdbc.driver}&quot;)
            private String driver;

            @Value(&quot;${jdbc.url}&quot;)
            private String url;

            @Value(&quot;${jdbc.user}&quot;)
            private String user;

            @Value(&quot;${jdbc.password}&quot;)
            private String password;

            @Bean(name=&quot;dataSource&quot;)
            public DataSource createDataSource() {
                ComboPooledDataSource ds = new ComboPooledDataSource();
                ds.setDriverClass(driver);
                ds.setJdbcUrl(url);
                ds.setUser(user);
                ds.setPassword(password);
                return ds;
            }
            ......
        }
</code></pre><h2 id="Spring整合Junit"><a href="#Spring整合Junit" class="headerlink" title="Spring整合Junit"></a>Spring整合Junit</h2><pre><code>1. Junit单元测试中没有直接提供main()，是因为它集成了一个main()
    1. Junit会判断测试类中有哪些方法上使用了 @Test;
    2. Junit main()只会执行有 @Test 的方法.
2. Junit并不关心Spring框架;
    1. 在执行测试方法时，Junit也不会关心Spring的配置文件/配置类，更不会创建IoC容器;
    2. 没有IoC容器，在测试类中使用 @Autowired，也无法实现注入.
3. spring-test：Spring整合junit测试框架; 加入依赖：spring-test、junit
4. @RunWith：Junit提供的注解，把 main() 替换成Spring提供的;
5. @ContextConfiguration：告知Spring的运行器，创建IoC容器使用的是XML还是注解，并指定其位置;
    1. locations属性：指定XML文件的位置，使用classpath关键字，表示在类路径下;
        @ContextConfiguration(locations=&quot;classpath:bean.xml&quot;)
    2. classes属性：指定注解类所在的位置；
    @RunWith(SpringJUnit4ClassRunner.class)
    @ContextConfiguration(classes=SpringConfiguration.class)
    public class UserTest {
        @Autowired
        private IUserService service;

        @Test
        public void testFindAll() {
            List&lt;User&gt; us = service.findAll();
        }
    }
6. 另外，Spring5.x版本时，junit的版本必须为4.12+
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/03/05/Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/05/Spring/" itemprop="url">Spring</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-05T00:00:00+08:00">
                2016-03-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><pre><code>1. Spring是分层的JavaSE/EE应用full-stack(全栈)轻量级开源框架;
    1. 目的是解决企业级应用开发的复杂性，简化Java开发，适用于任何Java应用;
    2. Spring的成功来源于理念，而不是技术本身，以IoC(控制反转)和AOP(面向切面编程)为核心;
    3. 优势：.
2. 发展历程
    1. 1997年IBM提出了EJB的思想，1998年SUN制定并开发EJB1.0;
    2. Spring之父Rod Johnson，2002年阐述了J2EE使用EJB开发设计的优点及解决方案;
    3. 2004年Rod Johnson阐述了J2EE不使用EJB的解决方案，也就是Spring的雏形；
    4. 2017年9月发布了Spring的最新版Spring5.0通用版(GA).
3. 优势：低侵入/低耦合、声明式事务管理、无缝集成其他框架、降低Java开发难度
    1. 解耦：IoC容器可以将对象间的依赖关系交由Spring控制，降低耦合，专注于上层应用；
    2. AOP编程：Spring的AOP功能让许多传统OOP难以实现的功能，更加容易；
    3. 声明式事务管理：使用配置文件取代单调烦闷的事物管理；
    4. 方便程序的测试：可以用非容器依赖的编程方式，实现几乎所有的测试工作；
    5. 方便集成各种优秀的框架，提供直接支持，降低框架的使用难度；
    6. Spring对JavaEE API进行了一层简单的封装，但却大为降低了API的使用难度。
4. Spring Framework Runtime 体系结构
</code></pre><p><img src="//hellomyshadow.github.io/2016/03/05/Spring/framework.jpg" alt="Spring"></p>
<pre><code>1. Core Container：核心容器，Spring的IoC容器，其他部分的运行必须依赖于核心容器；
2. 核心容器的上面一层是AOP相关的部分；
3. Data Access：持久层解决方案；
4. Test：单元测试，也依赖于核心容器才能运行。
</code></pre><h2 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h2><pre><code>1. 耦合：程序间的依赖关系，包括类之间的依赖、方法间的依赖；
2. 解耦：降低程序间的依赖关系，应做到编译期不依赖，运行时才依赖；
</code></pre><h3 id="类之间的依赖"><a href="#类之间的依赖" class="headerlink" title="类之间的依赖"></a>类之间的依赖</h3><pre><code>1. 以装载数据库的驱动为例
    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);
    DriverManager.registerDriver(new com.mysql.cj.jdbc.Driver());
    1. 这两种方式都可以装载驱动，但第一种装载是通过字符串，第二种需要使用具体的类；
    2. 如果当前没有MySQL的相关依赖包，那么第二种在运行时就会报错，这就是类之间的依赖；
    3. 而且，如果切换成装载Oracle驱动，仍需要去修改全限定类名的字符串。
2. 解耦的思路
    1. 使用反射来创建对象，避免使用 new 关键字；
    2. 通过读取配置文件来获取类的全限定类名。
</code></pre><h3 id="工厂模式解耦"><a href="#工厂模式解耦" class="headerlink" title="工厂模式解耦"></a>工厂模式解耦</h3><pre><code>1. 非解耦的持久层Dao与业务层Service
    1. Dao接口及其实现类
        public interface IUserDao {
            void save(User u);
        }
        public class UserDaoImpl implements IUserDao {
            public void save(User u) {
                //连接数据库，插入一条记录
            }
        }
    2. Service接口及其实现类
        public interface IUserService {
            void save(User u);
        }
        public class UserServiceImpl implements IUserService {
            private IUserDao dao = new UserDaoImpl();
            public void save(User u) {
                ......//before
                dao.save(u);  //调用Dao的方法
                ......//after
            }
        }
    3. App调用Service
        IUserService service = new UserServiceImpl();
        service.save(new User());
2. 工厂模式解耦
    1. 在resource目录下创建配置文件，如bean.properties，配置Dao与Service的实现类；
        userService = it.demo.cn.service.impl.UserServiceImpl
        userDao = it.demo.cn.dao.impl.UserDaoImpl
    2. Bean工厂：用于反射创建/生产Service和Dao的对象；
        public class BeanFactory {
            private static Properties prop;
            static {
                try {
                    prop = new Properties();
                    //使用类加载器获取resources目录下的文件
                    InputStream is = BeanFactory.class.getClassLoader()
                                    .getResourceAsStream(&quot;bean.properties&quot;);
                    prop.load(is);
                } catch (Exception e) {
                    throw new ExceptionInInitializerError(&quot;初始化配置文件失败！&quot;);
                }
            }
            public static Object getBean(String beanName) {
                //根据Bean的名称获取Bean对象
                String beanPath = prop.getProperty(beanName);
                Object bean = Class.forName(beanPath).newInstance();
                return bean;
            }
        }
    3. 通过Bean工厂创建Dao对象和Service对象
        public class UserServiceImpl implements IUserService {
            private IUserDao dao = (IUserDao) BeanFactory.getBean(&quot;userDao&quot;);
            public void save(User u) {
                dao.save(u);
            }
        }
    IUserService service = (IUserService) BeanFactory.getBean(&quot;userService&quot;);
    service.save(new User());
3. 但是，这种方式并不能保证Dao和Service对象的单例，需要在Bean工厂中增加一个Map结构的容器，
   存储Dao和Service的对象；
    public class BeanFactory {
        private static Properties prop;
        private static Map&lt;String, Object&gt; beans;  //Map结构的容器
        static {
            try {
                prop = new Properties();
                InputStream is = BeanFactory.class.getClassLoader()
                                .getResourceAsStream(&quot;bean.properties&quot;);
                prop.load(is);
                beans = new HashMap&lt;String, Object&gt;();  //实例化容器
                Enumeration keys = prop.keys();  //取出配置文件中的所有key
                while (keys.hasMoreElements()) {
                    //事先创建好配置文件中的对象，存入容器，作为单例对象使用
                    String k = keys.nextElement().toString();
                    String beanPath = prop.getProperty(k);
                    Object val = Class.forName(beanPath).newInstance();
                    beans.put(k, val);
                }
            } catch (Exception e) {
                throw new ExceptionInInitializerError(&quot;初始化配置文件失败！&quot;);
            }
        }
        public static Object getBean(String beanName) {
            //直接返回容器中的Bean对象
            return beans.get(beanName);
        }
    }
</code></pre><h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><pre><code>private IUserDao dao = new UserDaoImpl(); 与
private IUserDao dao = (IUserDao) BeanFactory.getBean(&quot;userDao&quot;);
-----------------------------------------------------------------
IUserService service = new UserServiceImpl(); 与
IUserService service = (IUserService) BeanFactory.getBean(&quot;userService&quot;);
1. 与new创建对象相比，通过Bean工厂创建对象，切断了App与资源(Dao/Service)的直接联系，
   交由Bean工厂控制资源、提供资源，这就是IoC;
2. 之所以称为IoC，而不叫降低解耦，是因为把对象控制的权力交给了工厂(框架)，控制反转不再是
   面向对象编程的专业术语;
3. IoC包括依赖注入(DI)和依赖查找(DL);
4. IoC的作用：消减计算机程序的耦合，并不能完全消除.
</code></pre><h3 id="Spring的IoC"><a href="#Spring的IoC" class="headerlink" title="Spring的IoC"></a>Spring的IoC</h3><pre><code>1. 添加Spring的IoC依赖
    &lt;packaging&gt;jar&lt;/packaging&gt;  ---&gt;项目的打包方式为jar
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.1.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
2. 在resources目录下创建配置文件，bean.xml
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
        &lt;!--把对象的创建交给Spring来管理--&gt;
        &lt;bean id=&quot;userService&quot; class=&quot;cn.test.service.impl.UserServiceImpl&quot;&gt;&lt;/bean&gt;
        &lt;bean id=&quot;userDao&quot; class=&quot;cn.test.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;
    &lt;/beans&gt;
3. 获取Spring的IoC核心容器，根据id获取对象
    //1. 解析配置文件，获取核心容器对象
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
    //2. 根据id获取Bean对象
    IUserDao dao = (IUserDao) ac.getBean(&quot;userDao&quot;);
    IUserService service = ac.getBean(&quot;userService&quot;, IUserService.class);
4. ApplicationContext的三个常用实现类
    1. ClassPathXmlApplicationContext：加载类路径下的配置文件，配置文件必须在类路径下;
    2. FileSystemXmlApplicationContext：加载磁盘任意路径下的配置文件，必须有访问权限;
        new ClassPathXmlApplicationContext(&quot;D:\\workplace\\test\\bean.xml&quot;);
    3. AnnotationConfigApplicationContext：用于读取注解类创建的容器.
        new AnnotationConfigApplicationContext(XXXConfig.class);
5. Spring中，ApplicationContext与BeanFactory的区别
    1. ApplicationContext：它在构建核心容器时，会立即创建Bean对象，即一旦读取完配置文件，
    立即创建文件中配置的对象；
    2. BeanFactory：它是顶层接口，采用延迟加载的方式创建Bean对象，即在根据id获取对象时，
    才真正的创建Bean对象；
        Resource res = new ClassPathResource(&quot;bean.xml&quot;);
        BeanFactory factory = new XmlBeanFactory(res);
        IUserDao dao = (IUserDao) factory.getBean(&quot;userDao&quot;);
    3. ApplicationContext适用于单例对象，BeanFactory适用于多例对象。
</code></pre><h3 id="Spring对Bean的管理"><a href="#Spring对Bean的管理" class="headerlink" title="Spring对Bean的管理"></a>Spring对Bean的管理</h3><pre><code>1. 创建Bean的三种方式
    1. 使用默认构造函数创建，&lt;bean&gt;上只有id和class属性，此时类中必须要有默认构造函数，
    否则无法创建Bean对象;
    &lt;bean id=&quot;userService&quot; class=&quot;cn.test.service.impl.UserServiceImpl&quot;&gt;&lt;/bean&gt;
    2. 使用普通工厂中的方法创建Bean对象，并存入Spring的IoC容器;
        public class ServiceFactory {  //工厂类
            public IUserService getUserService() {
                return new UserServiceImpl();
            }
        }
    &lt;bean id=&quot;servFac&quot; class=&quot;cn.test.factory.ServiceFactory&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;userService&quot; factory-bean=&quot;servFac&quot; -----&gt;&gt;引用id为servFac的&lt;bean&gt;
                            factory-method=&quot;getUserService&quot;&gt;&lt;/bean&gt;
        //创建Bean对象
        IUserService service = (IUserService) ac.getBean(&quot;userService&quot;);
    3. 使用工厂中的静态方法创建对象
        public class ServiceFactory {  //工厂类
            public static IUserService getUserService() {
                return new UserServiceImpl();
            }
        }
    &lt;bean id=&quot;userService&quot; class=&quot;cn.test.service.factory.ServiceFactory&quot; 
                                    factory-method=&quot;getUserService&quot;&gt;&lt;/bean&gt;
    //创建Bean对象
    IUserService service = (IUserService) ac.getBean(&quot;userService&quot;);
2. Bean的作用范围
    1. Bean对象默认就是单例的;
        IUserService us1 = (IUserService) ac.getBean(&quot;userService&quot;);
        IUserService us2 = (IUserService) ac.getBean(&quot;userService&quot;);
        us1==us2;  --&gt;true
    2. &lt;bean&gt;的 scope 属性：用于指定bean的作用范围;
        1. singleton：默认值，单例;
        2. prototype：多例，每次 getBean() 时，Spring就会创建一个新的对象;
        3. request：作用于web应用的请求范围;
        4. session：作用于web应用的会话范围;
        5. global-session：作用于集群环境的全局会话范围，如果不是集群，等效于session.
3. Bean的生命周期
    &lt;bean id=&quot;userService&quot; class=&quot;cn.test.service.impl.UserServiceImpl&quot; 
        init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt;&lt;/bean&gt;
    1. init-method=&quot;init&quot;：指定Bean对象的初始化方法，UserServiceImpl.init();
    2. destory-method=&quot;destroy&quot;：指定Bean对象的销毁方法，UserServiceImpl.destory();  
    3. 单例对象：随着容器的创建而创建，随着容器的消亡而消亡;
        //1. 获取核心容器对象：执行 UserServiceImpl.init()
        ClassPathXmlApplicationContext ac = 
                new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
        //2. 根据id获取Bean对象
        IUserService service = (IUserService) ac.getBean(&quot;userService&quot;);
        //3. 手动销毁容器：执行 UserServiceImpl.destroy()
        ac.close();
    4. 多例对象：scope=&quot;prototype&quot;，每次使用对象时由Spring创建，但Spring无法控制销毁，
    只能由Java垃圾回收器销毁.
</code></pre><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><pre><code>1. IoC降低了程序间的耦合(依赖关系)，一个类需要引用另一个类对象时，我们只需要在Spring的
   配置文件中说明两个类的依赖关系，交由Spring去维护这种依赖关系，这就是依赖注入;
2. 能注入的数据：基本类型、Bean对象(在配置文件中或者注解配置过的bean)、复杂/集合类型;
3. 注入的三种方式：使用构造函数、setter、注解
</code></pre><h4 id="构造函数注入"><a href="#构造函数注入" class="headerlink" title="构造函数注入"></a>构造函数注入</h4><pre><code>public class UserServiceImpl implements IUserService {
    private String name;  //基本类型
    private int age;
    private Date birthday;  //对象
    private IUserDao dao;
    public UserServiceImpl(String name, int age, Date birthday, IUserDao dao){
        this.name = name;  this.age = age;
        this.birthday = birthday;  this.dao = dao;
    }
}
1. 使用&lt;bean&gt;的子标签 &lt;constructor-arg&gt;，相关属性：
    1. type：注入数据的类型，也就是构造函数上的某个参数类型;
    2. index: 参数的索引位置，从 0 开始;
    3. name：参数名称;
    4. value：参数值，提供基本数据类型的数据;
    5. ref：参数值，引用另一个&lt;bean&gt;对象的数据;
    &lt;bean id=&quot;userService&quot; class=&quot;cn.test.service.impl.UserServiceImpl&quot;&gt;
        &lt;constructor-arg name=&quot;name&quot; value=&quot;Java&quot;&gt;&lt;constructor-arg&gt;
        &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;constructor-arg&gt;
        &lt;constructor-arg name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;constructor-arg&gt;
        &lt;constructor-arg name=&quot;dao&quot; ref=&quot;userDao&quot;&gt;&lt;/constructor-arg&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;cn.test.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;
2. 弊端：这种方式只能匹配一个固定的构造函数，改变了Bean对象的实例化方式，在创建对象时，
   即使用不到这些数据，也必须提供，否则Spring无法创建对象.
</code></pre><h4 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h4><pre><code>public class UserServiceImpl implements IUserService {
    private String name;  //基本类型
    private int age;
    private Date birthday;  //对象
    private IUserDao dao;
    //setter是必须的，可以没有getter
}
1. 使用&lt;bean&gt;的子标签 &lt;property&gt;，相关属性：
    1. name：setter的方法名，取set后的字母、并把首字母转为小写;
        age--&gt;setUserAge()--&gt;userAge，
    2. value、ref
    &lt;bean id=&quot;userService&quot; class=&quot;cn.test.service.impl.UserServiceImpl&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;Java&quot;&gt;&lt;property&gt;
        &lt;property name=&quot;age&quot; value=&quot;20&quot;&gt;&lt;property&gt;
        &lt;property name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;property&gt;
        &lt;property name=&quot;dao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;cn.test.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;
2. 这种方式解决了构造函数注入的弊端，创建对象时没有明确的限制，直接使用默认构造函数;
3. 弊端：如果某个成员必须有值(构造函数被重载，存在有参构造函数)，获取对象时可能没有配置
   此成员的setter，导致此成员没有值.
</code></pre><h4 id="复杂类型-集合对象的注入"><a href="#复杂类型-集合对象的注入" class="headerlink" title="复杂类型/集合对象的注入"></a>复杂类型/集合对象的注入</h4><pre><code>public class UserServiceImpl implements IUserService {
    private String[] myArr;  //数组
    private List&lt;String&gt; myList;  //List集合
    private Set&lt;String&gt; mySet;  //Set集合
    private Map&lt;String, String&gt; myMap;  //Map集合
    private Properties myProp;  //Properties
    //setter是必须的
}
1. 使用&lt;property&gt;的子标签
    &lt;bean id=&quot;userService&quot; class=&quot;cn.test.service.impl.UserServiceImpl&quot;&gt;
        &lt;property name=&quot;myArr&quot;&gt;
            &lt;array&gt;
                &lt;value&gt;AAA&lt;/value&gt;
                &lt;value&gt;BBB&lt;/value&gt;
            &lt;/array&gt;
        &lt;property&gt;
        &lt;property name=&quot;myList&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;AAA&lt;/value&gt;
                &lt;value&gt;BBB&lt;/value&gt;
            &lt;/list&gt;
        &lt;property&gt;
        &lt;property name=&quot;mySet&quot;&gt;
            &lt;set&gt;
                &lt;value&gt;AAA&lt;/value&gt;
                &lt;value&gt;BBB&lt;/value&gt;
            &lt;/set&gt;
        &lt;property&gt;
        &lt;property name=&quot;myMap&quot;&gt;
            &lt;map&gt;
                &lt;!-- 两种配置key-value的方式 --&gt;
                &lt;entry key=&quot;testA&quot; value=&quot;AAA&quot;&gt;&lt;/entry&gt;
                &lt;entry key=&quot;testB&quot;&gt;
                    &lt;value&gt;BBB&lt;/value&gt;
                &lt;/entry&gt;
            &lt;/map&gt;
        &lt;property&gt;
        &lt;property name=&quot;myProp&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;testA&quot;&gt;AAA&lt;/prop&gt;
                &lt;prop key=&quot;testB&quot;&gt;BBB&lt;/prop&gt;
            &lt;/props&gt;
        &lt;property&gt;
    &lt;/bean&gt;
2. 结构相同，标签是可以互换的，list、array、set是一类，map、props是一类。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/03/02/Mybatis进阶/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/02/Mybatis进阶/" itemprop="url">Mybatis进阶</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-02T00:00:00+08:00">
                2016-03-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h2><pre><code>事物的四大特性：ACID
1. A：原子性，要么全部被执行，要么全部不执行；
2. C：一致性，事务的执行使数据库从一种正确状态转换成另外一种正确状态；
3. I：隔离性，在事务正确提交之前，它可能的结果不应该显示给其他事务；
4. D：持久性，事务正确提交之后，即使有了其他故障，其结果也永远保存在数据库中。
</code></pre><h3 id="并发下的事务"><a href="#并发下的事务" class="headerlink" title="并发下的事务"></a>并发下的事务</h3><pre><code>1. 事务A和事务B操纵的是同一个资源，它们都有若干个子事务，在高并发的情况下，会出现各种问题；
2. 主要有五种问题：第一类丢失更新、第二类丢失更新、脏读、不可重复读、幻读；
3. 脏读：事务A读到了事务B还没有提交的数据；
    1. 账户余额1000元，事务A开启事务，此时切换到事务B，事务B开启事务--&gt;取走100元
    2. 此时又切换回事务A，因为事务B并没有提交，事务A读取的仍是1000元，这就是脏读
4. 不可重复读：在同一个事务里读取了两次某个数据，结果不一致；
    1. 事务A开启事务--&gt;查出账户余额为1000元
    2. 此时切换到事务B，事务B开启事务--&gt;取走100元--&gt;提交，账户余额变为900元
    3. 此时又切换回事务A，事务A再查一次的账户余额为900元
    4. 那么对于事务A，在同一个事务内两次读取的数据不一致，这就是不可重复读。
5. 幻读：在同一个事务里的操作中发现了未被操作的数据；
    1. 事务A开启事务--&gt;修改所有学生当天签到状况为false
    2. 此时切换到事务B，事务B开启事务--&gt;插入了一条学生数据
    3. 此时又切换回事务A，事务A提交时发现了一条自己没有修改过的数据，这就是幻读。
    4. 幻读出现的前提：并发的事务中有事务发生了插入、删除操作。
6. 事务隔离级别就是为了解决这几种问题。
</code></pre><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><pre><code>1. 事务隔离级别越高，在并发下产生的问题就越少，同时消耗的性能也越大，因此很多时候必须在并发性和性能之间做一个权衡;
2. 设立事务隔离级别的目的：为了让不同的项目可以根据自己的并发情况，选择合适的事务隔离级别；
   对于在事务隔离级别之外会产生的并发问题，在代码中做补偿；
3. 事务隔离级别有4种，但是像Spring会提供5种；
1. DEFAULT：默认隔离级别
    1. Spring配置事务时，将 isolation 设置为 DEFAULT，则使用数据库的默认事务隔离级别；
    2. 每种数据库支持的事务隔离级别是不一样的。
2. READ_UNCOMMITTED：读未提交
    1. 能够读取到没有被提交的数据，所以无法解决脏读、不可重复读、幻读，很少使用；
3. READ_COMMITED：读已提交
    1. 能够读到那些已经提交的数据，所以能防止脏读，但是无法限制不可重复读和幻读；
    2. 此级别下，写数据只会锁住相应的行。
4. REPEATABLE_READ：重复读取
    1. 在数据读出来之后加锁，类似 select * from XXX for update，明确数据读取出来就是为了更新用的，
    所以要加一把锁，防止别人修改它;
    2. 读取了一条数据，这个事务不结束，其他事务就不可以修改这条记录，解决了脏读、不可重复读的问题，但无法解决幻读;
5. SERLALIZABLE：串行化，加锁读，最高的事务隔离级别
    1. 不管多少事务，必须执行完一个事务的所有子事务之后，才可以执行下一个事务，这样就解决了脏读、不可重复读和幻读;
    2. 此级别下，读写数据都会锁住整张表。
1. 虽然隔离级别越高，越能保证数据的完整性和一致性，但对并发性能的影响也越大；
2. 一般情况下会设置为READ_COMMITED，此时避免了脏读，并发性也还不错，之后再通过其他手段解决不可重复读和幻读的问题;
3. MySQL的事务隔离级别
    1. 对于MySql，其默认事务级别是REPEATABLE_READ，虽然定义上无法解决幻读的问题，但MySql使用了一种
    Next key-lock 的算法来实现REPEATABLE_READ，这种算法能够解决幻读问题；
    2. Next key-lock算法：在进行查询时，不仅会锁住当前操作的记录，也会将查询所涉及到的范围锁住，
    其他事务如果在此范围内进行数据操作，就会被阻塞，因而MySql在此级别下就已经具备了Serializable级别的事务隔离性;
    3. 查看事务隔离级别
        select @@tx_isolation;  --&gt;旧版MySQL
        select @@transaction_isolation;  --&gt;旧版MySQL
        show variables like &apos;transaction_isolation&apos;;
    4. 开启一个事务：start transaction;
    5. 回滚当前事务：rollback;
    6. 提交当前事务：commit;
4. MySQL设置当前会话的事务隔离级别：SET session TRANSACTION ISOLATION LEVEL 隔离级别
    1. 隔离级别：Read uncommitted、Read committed、Repeatable read、Serializable
    2. 对于 Mybatis getSqlSession()，只针对本次拿到的Session有效；
    3. 对于CMD命令行，只在本次窗口有效。
5. MySQL设置全局事务隔离级别：SET global TRANSACTION ISOLATION LEVEL 隔离级别
    1. 隔离级别：Read uncommitted、Read committed、Repeatable read、Serializable
    2. 修改了全局的事务隔离级别，那么对此后所有的会话都有效，当前已经存在的会话则不受影响.
</code></pre><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><pre><code>1. 表与表之间的关系：一对一、一对多、多对多
2. 新创建一张表account，外键字段uid 关联user表的主键id
3. 创建表account的实体类
    public class Account implements Serializable {
        private int id;  //主键
        private int uid;  //外键，关联user表的主键id
        private double money;
        // getter、setter
    }
4. 同理，新建Dao接口：com.test.dao.IAccountDao
    public interface IAccountDao {
        List&lt;Account&gt; findAll();
    }
5. 在主配置文件 SqlMapConfig.xml 配置 &lt;typeAliases&gt; 和 &lt;mappers&gt;
    &lt;typeAliases&gt;
        &lt;package name=&quot;com.test.domain&quot; /&gt;
    &lt;/typeAliases&gt;
    ......
    &lt;mappers&gt;
        &lt;package name=&quot;com.test.dao&quot; /&gt;
    &lt;/mappers&gt;
6. 创建 resources/com/test/dao/IAccountDao.xml
    &lt;mapper namespace=&quot;com.test.dao.IAccountDao&quot;&gt;
        &lt;select id=&quot;findAll&quot; resultType=&quot;com.test.domain.Account&quot;&gt;
            select * from account
        &lt;/select&gt;
    &lt;/mapper&gt;
</code></pre><h3 id="一对一查询"><a href="#一对一查询" class="headerlink" title="一对一查询"></a>一对一查询</h3><pre><code>1. account表--&gt;user表：一对一的关系
2. 查询account的所有字段，只查询user表的username字段
    1. 新增一个实体类AccountUser，继承自Account
        public class AccountUser extends Account {
            private String username;  //user表的字段
            //getter、setter
        }
    2. 在 IAccountDao 接口中新增方法：List&lt;AccountUser&gt; findAccount();
    3. 在 IAccountDao.xml 中配置SQL语句
        &lt;select id=&quot;findAccount&quot; resultType=&quot;accountuser&quot;&gt;
            select u.username, a.* from account a, user u where u.id=a.uid
        &lt;/select&gt;
3. 但是，这并不是常用的方式，而是将 从表(user) 的实体类封装到 主表(account) 的实体类中
    public class Account implements Serializable {
        private User user;  //从表user的实体类属性
        ......
    }
4. 在 IAccountDao.xml 使用 &lt;resultMap&gt; 配置一对一的关系映射
    &lt;resultMap id=&quot;accountUserMap&quot; type=&quot;account&quot;&gt;
        &lt;id property=&quot;id&quot; column=&quot;aid&quot; /&gt;
        &lt;result property=&quot;uid&quot; column=&quot;uid&quot; /&gt;
        &lt;result property=&quot;money&quot; column=&quot;money&quot; /&gt;
        &lt;!-- 一对一的映射关系，配置封装User的属性 --&gt;
        &lt;association property=&quot;user&quot; column=&quot;uid&quot; javaType=&quot;user&quot;&gt;
            &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
            &lt;result property=&quot;username&quot; column=&quot;username&quot; /&gt;
        &lt;/association&gt;
    &lt;/resultMap&gt;
    &lt;select id=&quot;findAll&quot; resultMap=&quot;accountUserMap&quot;&gt;
        &lt;!-- 查询出两张表的所有字段，并对account表的id属性重命名为aid--&gt;
        select u.*, a.id as aid, a.uid, a.money from account a, user u 
         where u.id=a.uid
        同
        select u.*, a.id as aid, a.uid, a.money from account a 
         left join user u on u.id=a.uid
    &lt;/select&gt;
    1. &lt;resultMap&gt; 上的 type属性 使用的是实体类的别名；
    2. 如果查询结果中包含两张表的同名字段，必须重命名其中一个字段，如account表的主键字段(id--&gt;aid)，否则结果错误;
    3. SQL语句上重命名了account表的主键字段，所以对应&lt;id&gt;上的column属性也为aid.
5. &lt;association&gt;标签用于配置一对一的映射关系
    1. 属性column：主表account的外键字段;
    2. 属性property：实体类Account 中封装从表实体类User的对象属性user;
    3. 属性javaType：声明从表实体类User的全类名，也可以使用实体类的别名;
    4. 标签内配置的是从表(user)字段与实体类(User)属性的映射关系.
6. 连接查询与子查询
    1. 表的连接查询都可以替换为子查询，但不是所有的子查询都可以替换为表连接查询；
    2. 数据库对连接查询做了优化，而子查询是多次查询，效率较低，但胜在方便灵活。
</code></pre><h3 id="一对多查询"><a href="#一对多查询" class="headerlink" title="一对多查询"></a>一对多查询</h3><pre><code>1. user表--&gt;account表：一对多的关系
2. 在实体类User 中增加实体类Account 的集合
    public class User implements Serializable {
        private List&lt;Account&gt; accounts;  //从表user的实体类集合属性
        ......
    }
3. 在 IUserDao.xml 中配置 &lt;resultMap&gt;
    &lt;resultMap id=&quot;userAccountMap&quot; type=&quot;user&quot;&gt;
        &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
        &lt;result property=&quot;username&quot; column=&quot;username&quot; /&gt;
        &lt;!-- 配置User对象中的实体类集合 --&gt;
        &lt;collection property=&quot;accounts&quot; ofType=&quot;account&quot;&gt;
            &lt;id property=&quot;id&quot; column=&quot;aid&quot; /&gt;
            &lt;result property=&quot;uid&quot; column=&quot;uid&quot; /&gt;
            &lt;result property=&quot;money&quot; column=&quot;money&quot; /&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;
    &lt;select id=&quot;findAll&quot; resultMap=&quot;userAccountMap&quot;&gt;
        select u.*, a.id as aid, a.uid, a.money from user u 
         left join account a on u.id=a.uid
    &lt;/select&gt;
4. &lt;collection&gt;标签用于配置一对多的关系映射
    1. 属性ofType：从表account的实体类，也可以使用别名；
    2. 属性property：实体类User 中封装从表实体类Account的集合属性accounts;
    3. 同理，涉及到两张表的同名字段，要在SQL语句上对字段重命名(id--&gt;aid)
</code></pre><h3 id="多对多查询"><a href="#多对多查询" class="headerlink" title="多对多查询"></a>多对多查询</h3><pre><code>1. 对于存在多对多关系的两张表，需要引入中间表(也叫做连接表)
    1. 中间表包含两个实体表的主键，作为外键，建立两张表的联系；
    2. 中间表的主键，可以使用两个外键作为联合主键，不必新增一个专门的主键字段；
    3. 中间表也可以有普通字段，此时为了逻辑清晰，则增加一个主键字段。
2. 角色表role与用户表user具有多对多的关系，同时新建一张中间表user_role
    create table user_role(
        uid int,
        rid int,
        foreign key(uid) references user(id),
        foreign key(rid) references role(id),
        primary key(uid,rid));  -------------&gt;两个外键作为联合主键
3. 用户表user和角色表role的实体类中，包含对方的对象集合
    public class User implements Serializable {
        private int id;
        private String username;
        private List&lt;Role&gt; roles;
        //getter、setter
    }

    public class Role implements Serializable {
        private int id;
        private String rolename;
        private List&lt;User&gt; users;
        //getter、setter
    }
4. 查询角色表role时，关联对应的用户表user
    1. 角色表的Dao接口：IRoleDao
        public interface IRoleDao {
            List&lt;Role&gt; findAll();
        }
    2. 角色表的映射配置文件 IRoleDao.xml
        &lt;resultMap id=&quot;roleUserMap&quot; type=&quot;role&quot;&gt;
            &lt;id property=&quot;id&quot; column=&quot;rid&quot; /&gt;  ---&gt;SQL语句上重命名了同名字段
            &lt;result property=&quot;rolename&quot; column=&quot;role_name&quot; /&gt;
            &lt;!-- 配置Role对象中的实体类集合 --&gt;
            &lt;collection property=&quot;users&quot; ofType=&quot;user&quot;&gt;
                &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
                &lt;result property=&quot;username&quot; column=&quot;username&quot; /&gt;
            &lt;/collection&gt;
        &lt;/resultMap&gt;
        &lt;select id=&quot;findAll&quot; resultMap=&quot;roleUserMap&quot;&gt;
            select u.*, r.id as rid, r.role_name from role r 
             left outer join user_role ur on r.id=ur.rid 
             left outer join user u on u.id=ur.uid
        &lt;/select&gt;
5. 查询用户表时，关联对应的角色表数据，IuserDao接口、IUserDao.xml 中的配置同理.
</code></pre><h2 id="JNDI"><a href="#JNDI" class="headerlink" title="JNDI"></a>JNDI</h2><pre><code>1. JNDI：Java Naming and Directory Interface，SUN公司提供的一套标准的命名系统接口；
2. JNDI也属于JavaEE技术，目的是模仿Windows系统中的注册表，在服务器中注册数据源；
3. 注册表其实是Map结构，key存放的是路径+名称
4. Tomcat服务器启动时，也准备了一个这样的Map结构，Key是字符串(路径+名称)，Value是Object
    1. 路径的directory是固定的，name是可以自定义的；
    2. value中存放的内容通过配置文件的方式指定。
</code></pre><h3 id="JavaWeb项目与JNDI"><a href="#JavaWeb项目与JNDI" class="headerlink" title="JavaWeb项目与JNDI"></a>JavaWeb项目与JNDI</h3><pre><code>1. 在JavaWeb项目中使用JNDI，必须在 webapp 目录下创建 META-INF 目录
    1. 在 META-INF 目录下创建配置文件context.xml
        &lt;Context&gt;
            &lt;Resource
                name=&quot;jdbc/test_ibatis&quot; type=&quot;javax.sql.DataSource&quot; 
                auth=&quot;Container&quot; 
                maxActive=&quot;20&quot;
                maxWait=&quot;10000&quot;
                maxIdle=&quot;5&quot;
                username=&quot;root&quot;
                password=&quot;123456&quot;
                driverClassName=&quot;com.mysql.jdbc.Driver&quot;
                url=&quot;jdbc:mysql://localhost:3306/db_mybatis&quot; /&gt;
        &lt;/Context&gt;
    2. name：Map结构中key路径的名称部分;
    3. type：value中存储的对象;
    4. auth：指定提供者，Container表示容器，此时指Tomcat;
    5. maxActive：最大活动连接;
    6. maxWait：最大等待时长;
    7. maxIdle：最大空闲数;
    8. 属性username、password、driverClassName、url：数据库的连接信息.
2. 主配置文件 SqlMapConfig.xml
    &lt;dataSource type=&quot;JNDI&quot;&gt;
        &lt;property name=&quot;data_source&quot; value=&quot;java:comp/env/jdbc/test_ibatis&quot; /&gt;
    &lt;/dataSource&gt;
    1. java:comp/env/jdbc 就是key路径中固定的directory部分;
    2. context.xml中已经包含了数据库的连接信息，不需要再额外配置。
3. 使用Mybatis操作数据库时，必须经过Tomcat，所以只能在Servlet/JSP中使用，测试模块中不能使用.
</code></pre><h2 id="延迟加载"><a href="#延迟加载" class="headerlink" title="延迟加载"></a>延迟加载</h2><pre><code>1. 延迟加载：在真正使用数据时才发起查询，不用的时候就不查询，这就是按需加载，亦或懒加载；
    1. 一对多，多对多：通常采用延迟加载；
    2. 多对一，一对一：通常采用默认的立即加载。
2. 一对一的延迟加载：表account--&gt;表user
    1. 在主配置文件 SqlMapConfig.xml 中开启延迟加载
    &lt;configuration&gt;
        &lt;settings&gt;
            &lt;!-- 延迟加载的全局开关 --&gt;
            &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot; /&gt;
            &lt;!-- 大于Mybatis3.4.1的默认值为false，表示按需加载每个属性 --&gt;
            &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot; /&gt;
            &lt;!-- 开启驼峰扫描 --&gt;
            &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot; /&gt;
        &lt;/settings&gt;
    &lt;/configuration&gt;
    2. 开启驼峰扫描之后，可以自动将SQL语句中带下划线的字段，转换为驼峰标志，再去匹配实体类中的属性;
        1. 比如字段user_type，在Java实体类中的属性通常为驼峰式：userType
        2. 如果不开启驼峰扫描，在SQL语句中需要使用 AS 实现映射匹配;
        select user_type as userType from user
        3. 但开启了Mybatis的驼峰匹配之后，就可以自动匹配：select user_type from user
    3. IUserDao接口 与 IUserDao.xml
        User findById(int id);  //根据主键 id 查询user表
        &lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt;
            select * from user where id=#{uid}
        &lt;/select&gt;
    4. IAccountDao.xml：配置 &lt;association&gt; 上的 select属性
        &lt;resultMap id=&quot;accountUserMap&quot; type=&quot;account&quot;&gt;
            &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
            &lt;result property=&quot;uid&quot; column=&quot;uid&quot; /&gt;
            &lt;result property=&quot;money&quot; column=&quot;money&quot; /&gt;
            &lt;association property=&quot;user&quot; column=&quot;uid&quot; javaType=&quot;user&quot; 
                    select=&quot;com.test.dao.IUserDao.findById&quot;&gt;&lt;/association&gt;
        &lt;/resultMap&gt;
        &lt;select id=&quot;findAll&quot; resultMap=&quot;accountUserMap&quot;&gt;
            select * from account  ---&gt;不能再使用连接查询，否则延迟加载是无效的
        &lt;/select&gt;
    5. IUserDao.findById() 接收参数是&lt;association&gt;上的column属性，所以不能省略此属性。
3. 一对多的延迟加载：表user--&gt;表account
    1. IAccountDao接口 与 IAccountDao.xml
        //根据外键 uid 去查询account表
        List&lt;Account&gt; findByUid(int uid);
        &lt;select id=&quot;findByUid&quot; parameterType=&quot;int&quot; resultType=&quot;account&quot;&gt;
            select * from account where uid=#{uid}
        &lt;/select&gt;
    2. IUserDao.xml：配置 &lt;collection&gt; 上的select属性
    &lt;resultMap id=&quot;userAccountMap&quot; type=&quot;user&quot;&gt;
        &lt;id property=&quot;id&quot; column=&quot;id&quot; /&gt;
        &lt;result property=&quot;username&quot; column=&quot;username&quot; /&gt;
        &lt;collection property=&quot;accounts&quot; ofType=&quot;account&quot; 
            select=&quot;com.test.dao.IAccountDao.findByUid&quot; column=&quot;id&quot;&gt;&lt;/collection&gt;
    &lt;/resultMap&gt;
    &lt;select id=&quot;findAll&quot; resultMap=&quot;userAccountMap&quot;&gt;
        select * from user  ---&gt;不能再使用连接查询
    &lt;/select&gt;
</code></pre><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><pre><code>1. 缓存就是存在于内存中的数据，减少与数据库的交互次数，提高执行效率；
2. 适用于缓存的数据：经常查询的，且不经常改变的，数据的正确与否对最终结果影响不大的；
3. 一级缓存：SqlSession对象的缓存，无需特殊配置
    1. 每个SqlSession对象会提供一块独有的Map结构的区域，缓存查询的结果；
    User u1 = dao.findById(2);  User u2 = dao.findById(2); //连续两次查询同一条数据
    u1==u2;  --&gt; true
    2. 手动清空一级缓存：session.clearCache();
    3. 为了保证数据的一致性，当发生数据的插入/更新/删除，或者调用SqlSession的commit()、close()等方法时，
    会立即清空当前SqlSession的一级缓存，让后续的SQL重新查询数据库。
4. 二级缓存：SqlSessionFactory对象的缓存
    1. 由同一个SqlSessionFactory创建的所有SqlSession对象，共享二级缓存；
    2. 在主配置文件 SqlMapConfig.xml 中开启全局缓存，默认就是开启的
        &lt;settings&gt;
            &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot; /&gt;
        &lt;/settings&gt;
    3. 在映射配置文件 IUserDao.xml 中开启user的二级缓存
        &lt;cache /&gt;
        &lt;select id=&quot;findById&quot; resultType=&quot;user&quot; useCache=&quot;true&quot;&gt;
            select * from user where id=#{uid}
        &lt;/select&gt;
5. 二级缓存中存储的是散装数据，使用缓存数据时，这些数据会封装成一个新的User对象，所以比较两次查询结果时，返回false.
</code></pre><h2 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h2><pre><code>1. Mybatis的注解开发：针对的是Dao的映射配置文件，目的是省略映射配置文件
2. CRUD的对应注解：@Insert、@Select、@Update、@Delete，在Dao接口的方法上使用
3. 使用注解时，如果resources目录下还存在映射配置文件，不管是否使用了此配置文件，都会报错；
4. 单表的CRUD：IUserDao接口
    1. 查询：@Select
        @Select(&quot;select * from user&quot;)
        @Results(id=&quot;accountMap&quot;, value={
            @Result(column=&quot;create_time&quot;, property=&quot;createTime&quot;)  --&gt;数据库字段与POJO对象属性的映射关系
        })
        List&lt;User&gt; findAll();

        @Select(&quot;select * from user where name like #{username}&quot;)  或
        @Select(&quot;select * from user where name like &apos;%${value}%&apos;&quot;)
        List&lt;User&gt; findByName(String username);

        @Select(&quot;select count(id) from user&quot;)
        int findTotal();
    2. 插入：@Insert
        @Insert(&quot;insert into user(name, age) values(#{username}, #{age})&quot;)
        @Options(useGeneratedKeys=true, keyProperty=&quot;id&quot;, keyColumn=&quot;id&quot;)  --&gt;属性与字段的映射
        void saveUser(User u);   ---&gt; useGeneratedKeys=true 表示自增长的主键
    3. 更新：@Update
        @Update(&quot;update user set name=#{username}, age=#{age} where id=#{id}&quot;)
        void updateUser(User u);
    4. 删除：@Delete
        @Delete(&quot;delete from user where id=#{id}&quot;)
        void deleteUser(int id);
5. 实体类的属性名与表字段名不匹配：id--&gt;uId，name--&gt;username
    @Select(&quot;select * from user&quot;)
    @Results(id=&quot;userMap&quot;, value={
        @Result(id=true, column=&quot;id&quot;, property=&quot;uId&quot;),
        @Result(column=&quot;name&quot;, property=&quot;username&quot;)
    })
    List&lt;User&gt; findAll();

    @Select(&quot;select * from user where id=#{id}&quot;)
    @ResultMap(value={&quot;userMap&quot;})  --&gt;复用id命名的@Results，支持多个
    User findById(int id);
</code></pre><h3 id="多表的CRUD"><a href="#多表的CRUD" class="headerlink" title="多表的CRUD"></a>多表的CRUD</h3><pre><code>1. 一对一：表account--&gt;表user
    1. IAccountDao接口
    @Select(&quot;select * from account&quot;)
    @Results(id=&quot;accountMap&quot;, value={
        @Result(id=true, column=&quot;id&quot;, property=&quot;id&quot;),
        @Result(column=&quot;uid&quot;, property=&quot;uid&quot;),
        @Result(column=&quot;money&quot;, property=&quot;money&quot;),
        @Result(column=&quot;uid&quot;, property=&quot;user&quot;, one=@One(
            select=&quot;com.test.dao.IUserDao.findById&quot;, fetchType=FetchType.EAGER
        ))
    })
    List&lt;Account&gt; findAll();
    2. @One 用于一对一的关联查询，调用 IUserDao.findById()，接收参数为uid;
    3. select属性用于指定要调用的全限定方法名，fetchType属性用于配置加载的时机;
    4. FetchType有3个属性：LAZY(懒加载)、EAGER(立即加载)、DEFAULT.
2. 一对多：表user--&gt;表account，
    @Select(&quot;select * from user&quot;)
    @Results(id=&quot;userMap&quot;, value={
        @Result(id=true, column=&quot;id&quot;, property=&quot;uId&quot;),
        @Result(column=&quot;name&quot;, property=&quot;username&quot;),
        @Result(column=&quot;id&quot;, property=&quot;accounts&quot;, many=@Many(
            select=&quot;com.test.dao.IAccountDao.findByUid&quot;, fetchType=FetchType.LAZY
        ))
    })
    List&lt;User&gt; findAll();
3. 配置二级缓存
    1. 在主配置文件 SqlMapConfig.xml 中开启缓存;
    2. 在Dao接口上使用注解@CacheNamespace
    @CacheNamespace(blocking = true)
    public interface IUserDao { ... }
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/03/01/Mybatis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/01/Mybatis/" itemprop="url">Mybatis</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-01T00:00:00+08:00">
                2016-03-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><pre><code>1. 框架是软件开发中的一套解决方案，不同的框架解决不同的问题，Mybatis解决的是持久层问题
2. 三层结构
    1. 表现层：用于展示数据，如SpringMVC:MVC框架
    2. 业务层：处理业务需求
    3. 持久层，和数据库交互，如Mybatis:持久层框架
    4. Spring：Ioc(控制反转)、AOP(面向切面编程)，不属于任何一层。
3. 持久层技术的解决方案
    1. JDBC技术：Connection、PreparedStatement、ResultSet，JDBC是规范；
    2. Spring的JdbcTemplate：Spring中对JDBC的简单封装；
    3. Apache的DBUtils：类似于String的JdbcTemplate，都只是工具类；
    4. 它们都不能从根本上提高开发效率，这就是 Mybatis 框架的意义所在。
</code></pre><h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><pre><code>1. Mybatis：基于Java的持久层框架，内部封装了JDBC，开发者只需要关心SQL语句本身即可；
    1. Mybatis通过XML或注解的方式配置各种Statement，映射成最终要执行的SQL语句；
    2. 采用ORM思想解决实体和数据库映射的问题，将执行SQL返回的结果映射成Java对象。
2. 使用Maven工程搭建Mybatis环境
3. 添加依赖
    &lt;dependency&gt;  -------------------------&gt;Mybatis
        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
        &lt;version&gt;3.4.5&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;  -------------------------&gt;使用MySQL数据库，则配置MySQL的数据库驱动
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;5.1.6&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><pre><code>1. 创建实体类，实现Serializable接口
    public class User implements Serializable {
        private String name;
        private int age;
        //getter、setter
    }
2. 创建数据库操作的Dao接口：com.test.dao.IUserDao
    public interface IUserDao {
        List&lt;User&gt; findAll();  //查询所有
    }
3. 在resources目录下创建一个XML文件：SqlMapConfig.xml，作为Mybatis的主配置文件
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;   ==&gt;约束
    &lt;configuration&gt;
        &lt;!-- 配置环境 --&gt;
        &lt;environments default=&quot;mysql&quot;&gt;  ==&gt;default属性值可任意取名字
            &lt;!-- 配置MySQL的环境 --&gt;
            &lt;environment id=&quot;mysql&quot;&gt;  ====&gt;此id属性值与父节点的default一致
                &lt;!-- 配置事物的类型 --&gt;
                &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;/transactionManager&gt;
                &lt;!-- 配置数据源：连接池，有三种 --&gt;
                &lt;dataSource type=&quot;POOLED&quot;&gt;
                    &lt;!-- 配置连接数据库的基本信息，5.0和6.0的驱动、URL是不同的 --&gt;
                    &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;
                    &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/db_mybatis&quot;/&gt;
                    &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;
                    &lt;property name=&quot;password&quot; value=&quot;123456&quot; /&gt;
                &lt;/dataSource&gt;
            &lt;/environment&gt;
        &lt;/environments&gt;
        &lt;!-- 指定Dao的映射配置文件 --&gt;
        &lt;mappers&gt;
            &lt;mapper resource=&quot;com/test/dao/IUserDao.xml&quot;/&gt;  =&gt;指向resources目录
        &lt;/mappers&gt;
    &lt;/configuration&gt;
4. 映射配置文件是每个Dao的独立配置文件，创建resources/com/test/dao/IUserDao.xml
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
    &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
                    &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
    &lt;mapper namespace=&quot;com.test.dao.IUserDao&quot;&gt;  ==&gt;namespace指定对应Dao的全类名
        &lt;!-- 配置IUserDao中的方法findAll，必须指定查询的实体类 --&gt;
        &lt;select id=&quot;findAll&quot; resultType=&quot;com.test.domain.User&quot;&gt;
            select * from user  ---&gt;findAll()执行的SQL语句
        &lt;/select&gt;
    &lt;/mapper&gt;
    1. resultType属性指定 findAll() 的返回值类型，每条数据封装在实体类User对象中；
    2. Mybatis把持久层的操作接口名称和映射文件称为Mapper，所以IUserDao也通常命名为IUserMapper
5. 开始使用Mybatis操作数据库
    1. 获取配置文件路径的两种方式：类加载器、ServletContext的getRealPath()
        // 读取主配置文件
        InputStream is = Resources.getResourceAsStream(&quot;SqlMapConfig.xml&quot;);
    2. 构建者模式：创建SqlSessionFactory工厂
        SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
        SqlSessionFactory factory = builder.build(is);
    3. 工厂模式
        SqlSession session = factory.openSession(); //使用工厂生产SqlSession对象
    4. 代理模式：使用SqlSession创建Dao接口的代理对象
        IUserDao dao = session.getMapper(IUserDao.class);
        // 使用代理对象执行方法，获取SQL语句的结果
        List&lt;User&gt; users = dao.findAll();
    5. 释放资源
        session.close();  is.close();
6. 把映射配置文件改为注解实现
    1. 删除映射配置文件 resources/com/test/dao/IUserDao.xml
    2. 在接口IUserDao的方法findAll()上使用注解
        @Select(&quot;select * from user&quot;)
        List&lt;User&gt; findAll();
    3. 更改主配置文件SqlMapConfig.xml中的&lt;mappers&gt;，指定Dao接口
        &lt;mappers&gt;
            &lt;mapper class=&quot;com.test.dao.IUserDao&quot; /&gt;
        &lt;/mappers&gt;
</code></pre><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><pre><code>1. 插入一条数据
    1. 在接口 IUserDao 中添加插入数据的方法：void saveUser(User user);
    2. 在 IUserDao.xml 中配置插入的SQL语句
        &lt;insert id=&quot;saveUser&quot; parameterType=&quot;com.test.domain.User&quot;&gt;
            insert into user(name, age) values(#{name}, #{age})
        &lt;/insert&gt;
    3. parameterType属性用于指定 saveUser() 的参数类型；
    4. #{prop}：用于取出参数对象 User 中的属性值；
    5. 执行插入时，必须手动提交事务，否则数据会回滚，但自增长的ID又会被占用；
        User u = new User();  u.setName(&quot;Java&quot;);  u.setAge(20);
        dao.saveUser(u);
        session.commit();  //手动提交事务
    6. 自动提交事物的SqlSession对象
        SqlSession session = factory.openSession(true);
2. 更新数据
    void updateUser(User user);
    &lt;update id=&quot;updateUser&quot; parameterType=&quot;com.test.domain.User&quot;&gt;
        update user set name=#{name},age=#{age} where id=#{id}
    &lt;/update&gt;
    User u = new User();  u.setId(2);  u.setName(&quot;Python&quot;);  u.setAge(30);
    dao.updateUser(u);  session.commit();
3. 删除数据
    void deleteUser(int id);
    &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;java.lang.Integer&quot;&gt;
        delete from user where id=#{id}
    &lt;/delete&gt;
    dao.deleteUser(3);  session.commit();
    1. parameterType 的参数类型不是实体类，#{id} 中的 id 只是占位符，可以任意名称；
    2. java.lang.Integer、int、INT 是等效的，都可以表示 int 类型。
4. 聚合函数
    int findTotal();
    &lt;select id=&quot;findTotal&quot; resultType=&quot;int&quot;&gt;
        select count(id) from user
    &lt;/select&gt;
    int count = dao.findTotal();
5. 模糊查询
    List&lt;User&gt; findByName(String name);
    &lt;select id=&quot;findByName&quot; resultType=&quot;com.test.domain.User&quot; parameterType=&quot;string&quot;&gt;
        select * from user where name like #{un}
    &lt;/select&gt;
    List&lt;User&gt; us = dao.findByName(&quot;%tho%&quot;);
    1. 模糊查询的特殊符号(%、_...)在传递参数时，手动指定需要的符号，Mybatis会采用安全的
    预处理方式加入参数：select * from user where name like ?
    2. 由Mybatis的源码可知，还有一种配置可以在SQL语句中指定模糊查询的符号：
        &lt;select id=&quot;findByName&quot; ...&gt;
            select * from user where name like &apos;%${value}%&apos;
        &lt;/select&gt;
        List&lt;User&gt; us = dao.findByName(&quot;tho&quot;);
    3. ${value} 中的 value 是固定的，由Mybatis的源码绑定，但这种方式采用的是字符串拼接，
    所以是不安全的：select * from user where name like %tho%
6. 插入数据时，返回新增用户的主键ID
    &lt;insert id=&quot;saveUser&quot; parameterType=&quot;com.test.domain.User&quot;&gt;
        &lt;selectKey keyProperty=&quot;id&quot; keyColumn=&quot;id&quot; resultType=&quot;int&quot; order=&quot;AFTER&quot;&gt;
            select last_insert_id();
        &lt;/selectKey&gt;
        insert into user(name, age) values(#{name}, #{age})
    &lt;/insert&gt;
    User u = new User();  u.setName(&quot;Java&quot;);  u.setAge(20);
    dao.saveUser(u);  session.commit();
    int id = u.getId(); //新插入数据的ID字段值
    1. order=&quot;AFTER&quot; 表示在执行插入之后，再执行此SQL语句select last_insert_id();
    2. resultType=&quot;int&quot; 声明主键的类型；
    3. keyColumn=&quot;id&quot; 声明数据库中的主键字段名；
    4. keyProperty=&quot;id&quot; 声明实体类中对应的主键属性名；
    5. 插入成功之后，对象类对象 的 id 属性值为数据库中真实的 id 值。
</code></pre><h2 id="parameterType"><a href="#parameterType" class="headerlink" title="parameterType"></a>parameterType</h2><pre><code>1. OGNL：Object Graphic Navigation Language，对象图导航语言
    1. OGNL 的作用：通过对象的取值方法来获取属性值，写法上省略了getter方法；
    2. 比如：获取一个实体类User的属性值时
        1. 在类中的写法：user.getName()
        2. OGNL表达式的写法：user.name
    3. parameterType 为POJO对象(实体类)时，Mybatis使用 OGNL表达式 来解析对象的属性值，
    所以 #{} 或 ${} 中可以省略getter方法；
    4. 同时，parameterType 已经指明了属性所属的实体类，所以不需要声明对象#{user.name}，
    而是直接使用属性名#{name}
2. parameterType 为POJO(实体类)的包装对象
    1. 有时候查询条件可能由多个实体类组成，那么就需要把不同的实体类包装成一个对象；
    2. 创建包装对象QueryVo
        public class QueryVo {
            private User user;  //包装实体类User
            //getter、setter
        }
    3. 在接口 IUserDao 中新增方法：List&lt;User&gt; findByVo(QueryVo vo);
    4. 在 IUserDao.xml 中配置SQL语句
    &lt;select id=&quot;findByVo&quot;
        parameterType=&quot;com.test.domain.QueryVo&quot; resultType=&quot;com.test.domain.User&quot;&gt;
        select * from user where name like #{user.name}
    &lt;/select&gt;
    5. 执行 findByVo()
        QueryVo vo = new QueryVo();
        User u = new User();  u.setName(&quot;%tho%&quot;);
        vo.setUser(u);
        List&lt;User&gt; us = dao.findByVo(vo);
</code></pre><h2 id="resultType"><a href="#resultType" class="headerlink" title="resultType"></a>resultType</h2><pre><code>1. MySQL数据库在Windows系统下不区分字段名与属性名的大小写；
    1. 比如：数据库表中的字段名为username，而实体类中的属性名为userName
    2. 在执行 findAll() 时，仍然可以把username的字段值映射给userName属性。
2. 当实体类中的属性名与表中的字段名不匹配时：id--uId，userName--name，userAge--age
    1. 在查询所有时，使用SQL语句的别名
        &lt;select id=&quot;findAll&quot; resultType=&quot;com.test.domain.User&quot;&gt;
            select id as uId, name as userName, age as userAge from user
        &lt;/select&gt;
    2. 在插入时，指定属性名
    &lt;insert id=&quot;saveUser&quot; parameterType=&quot;com.test.domain.User&quot;&gt;
        &lt;selectKey keyProperty=&quot;uId&quot; keyColumn=&quot;id&quot; resultType=&quot;int&quot; order=&quot;AFTER&quot;&gt;
            select last_insert_id();
        &lt;/selectKey&gt;
        insert into user(name, age) values(#{userName}, #{userAge})
    &lt;/insert&gt;
3. 在Mybatis中，提供了一种没有使用别名高效、但能提高开发效率的方式
    1. 使用 &lt;resultMap&gt; 配置属性名与字段名的映射关系
    &lt;mapper namespace=&quot;com.test.dao.IUserDao&quot;&gt;
        &lt;resultMap id=&quot;userMap&quot; type=&quot;com.test.domain.User&quot;&gt;
            &lt;id property=&quot;uId&quot; column=&quot;id&quot;&gt;&lt;/id&gt;  ===&gt;主键字段
            &lt;result property=&quot;userName&quot; column=&quot;name&quot;&gt;&lt;/result&gt;  ==&gt;非主键字段
            &lt;result property=&quot;userAge&quot; column=&quot;age&quot;&gt;&lt;/result&gt;
        &lt;/resultMap&gt;

        &lt;select id=&quot;findAll&quot; resultMap=&quot;userMap&quot;&gt;
            select * from user
        &lt;/select&gt;

        &lt;select id=&quot;findByVo&quot; parameterType=&quot;com.test.domain.QueryVo&quot; resultType=&quot;userMap&quot;&gt;
            select * from user where name like #{user.userName}
        &lt;/select&gt;
    &lt;/mapper&gt;
    2. &lt;resultMap&gt; 的 id 属性为 resultMap 的唯一标识，type 属性为实体类的全类名；
    3. &lt;select&gt;的 resultType 属性值为实体类时，改为 resultMap=&quot;userMap&quot;.
</code></pre><h2 id="更多配置"><a href="#更多配置" class="headerlink" title="更多配置"></a>更多配置</h2><pre><code>1. Mybatis也支持自定义Dao的实现类，SqlSession对象中提供了数据库操作的API
    public class UserDaoImpl implements IUserDao {
        private SqlSessionFactory factory;

        public UserDaoImpl(SqlSessionFactory factory) {
            this.factory = factory;
        }

        public List&lt;User&gt; findAll() {  //查询所有
            SqlSession sess = factory.openSession();
            List&lt;User&gt; us = sess.selectList(&quot;com.test.dao.IUserDao.findAll&quot;);
            sess.close();
            return us;
        }

        public void saveUser(User u) {  //插入一条数据
            SqlSession sess = factory.openSession();
            sess.insert(&quot;com.test.dao.IUserDao.saveUser&quot;, u);
            sess.commit();
            sess.close();
        }
        ......
    }
</code></pre><h3 id="properties标签"><a href="#properties标签" class="headerlink" title="properties标签"></a>properties标签</h3><pre><code>1. 在主配置文件 SqlMapConfig.xml 中，使用 &lt;properties&gt; 抽取数据库的连接信息
    &lt;properties&gt;
        &lt;!-- 配置JDBC的连接信息 --&gt;
        &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/db_mybatis&quot; /&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;
        &lt;property name=&quot;password&quot; value=&quot;123456&quot; /&gt;
    &lt;/properties&gt;
    &lt;environments default=&quot;mysql&quot;&gt;
        &lt;environment id=&quot;mysql&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot;&gt;&lt;transactionManager&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;!-- 引用 &lt;properties&gt; 标签中配置的信息 --&gt;
                &lt;property name=&quot;driver&quot; value=&quot;${driver}&quot; /&gt;
                &lt;property name=&quot;url&quot; value=&quot;${url}&quot; /&gt;
                &lt;property name=&quot;username&quot; value=&quot;${username}&quot; /&gt;
                &lt;property name=&quot;password&quot; value=&quot;${password}&quot; /&gt;
        ......
2. 除了在标签内配置，&lt;properties&gt;标签还可以引用外部的配置文件
    1. 在resources目录下创建 jdbcConf.properties，保存数据库的连接信息
        jdbc.driver=com.mysql.jdbc.Driver
        jdbc.url=jdbc:mysql://localhost:3306/db_mybatis
        jdbc.user=root
        jdbc.password=123456
    2. 引入resources/jdbcConf.properties，并使用其中的配置信息
        &lt;properties resource=&quot;jdbcConf.properties&quot;&gt;&lt;/properties&gt;
        ......
        &lt;dataSource type=&quot;POOLED&quot;&gt;
            &lt;property name=&quot;driver&quot; value=&quot;${jdbc.driver}&quot; /&gt;
            &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;
            &lt;property name=&quot;username&quot; value=&quot;${jdbc.user}&quot; /&gt;
            &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;
3. &lt;properties&gt; 除了 resource 属性可以引入外部文件，还有 url 属性
    1. resource 属性值是类路径的形式，因为 jdbcConf.properties 和 SqlMapConfig.xml
    在同一目录，所以不用写包名；
    2. url 属性值是统一资源定位符，因为是本地文件，所以使用file协议
    url=&quot;file:///D:/workplace/testibatis/src/main/resources/jdbcConf.properties&quot;
    3. SqlMapConfig.xml 中的 &lt;mapper&gt; 标签用于引用Dao的映射配置文件，它也有 url 属性，
    也是统一资源定位符，使用方式与 &lt;properties&gt; 上的 url 属性是相同的。
</code></pre><h3 id="typeAliases标签"><a href="#typeAliases标签" class="headerlink" title="typeAliases标签"></a>typeAliases标签</h3><pre><code>1. 在使用 parameterType 属性声明基本类型时，不需要区分大小写，int 和 INT、Int、inT 都是
   等效的，但自定义的实体类却不行，这是因为它把常用基本类型都注册了别名；
2. 在 SqlMapConfig.xml 中，使用 &lt;typeAliases&gt; 标签可以为自定义的实体类配置别名
    &lt;configuration&gt;
        &lt;typeAliases&gt;
            &lt;typeAlias type=&quot;com.test.domain.User&quot; alias=&quot;user&quot; /&gt;
        &lt;/typeAliases&gt;
        ......
    1. type属性指定实体类的全类名，alias属性自定义别名；
    2. 指定了别名之后，就不再区分大小写了
        &lt;insert id=&quot;saveUser&quot; parameterType=&quot;user&quot;&gt;
        &lt;insert id=&quot;saveUser&quot; parameterType=&quot;USER&quot;&gt;
    3. &lt;resultMap&gt;标签上的 type属性也可以使用实体类的别名：type=&quot;user&quot;
3. 但是，如果实体类过多时，使用 &lt;typeAlias&gt; 配置别名也会很繁琐；
    1. &lt;typeAliases&gt; 还支持配置实体类所在的包名
        &lt;typeAliases&gt;
            &lt;package name=&quot;com.test.domain&quot; /&gt;
        &lt;/typeAliases&gt;
    2. 配置了实体类的包名之后，实体类的类名就是别名，不再区分大小写.
4. SqlMapConfig.xml 中的 &lt;mappers&gt; 也有一个子标签为 &lt;package&gt;，用于指定dao接口的包名;
    &lt;mappers&gt;
        &lt;package name=&quot;com.test.dao&quot; /&gt;  ==&gt;无需再配置&lt;mapper&gt;标签
    &lt;/mappers&gt;
</code></pre><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><pre><code>1. 连接池就是一个存储连接的容器(线程安全的集合对象)，保证不能让两个线程拿到同一个连接；
    1. 该集合还必须实现队列的特性：先进后出；
    2. 连接池能够减少获取连接所消耗的时间。
2. Mybatis连接池有3种配置方式
    1. 主配置文件 SqlMapConfig.xml 中的 &lt;dataSource type=&quot;连接池配置&quot;&gt;
    2. POOLED：采用传统的 javax.sql.DataSource 规范，Mybatis中有针对此规范的实现;
    3. UNPOOLED：采用传统获取连接的方式，虽然也实现了DataSource接口，但并没有 池 的思想;
    4. JNDI：采用服务器提供的JNDI技术实现，来获取 DataSource 对象，不同的服务器所拿到的
    DataSource 是不同的;
    5. 注意：如果不是 Web 或者 maven的war工程，不能使用JNDI;
    6. 使用Tomcat服务器时，采用的是DBCP连接池.
3. type=&quot;POOLED&quot;：从连接池中获取一个连接，使用完之后，归还给连接池
    1. Mybatis准备了2个连接池：空闲池和活动池；
    2. 当有一个线程获取连接时，先到空闲池中查看是否有连接，有则直接返回一个连接给线程；
    3. 如果空闲池没有连接，则转去活动池，如果活动池的连接数量已经达到了最大值，则返回其中
    最老的一个连接(Oldest Connection)
    4. 线程获取到 Oldest Connection 之后，会重置其相关参数，保证此连接是一个有效的连接.
4. type=&quot;UNPOOLED&quot;：每次都会创建一个新的连接，使用完之后，关闭连接.
</code></pre><h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><pre><code>1. if标签
    List&lt;User&gt; findByCond(User u);
    &lt;select id=&quot;findByCond&quot; resultMap=&quot;userMap&quot; parameterType=&quot;user&quot;&gt;
        select * from user where 1=1
        &lt;if test=&quot;userName != null&quot;&gt;
            and name = #{userName}
        &lt;/if&gt;
    &lt;/select&gt;
    1. &lt;if&gt; 上使用的属性来自于参数User对象；
    2. where 1=1 中的 1=1 是为了在&lt;if&gt;条件不成立时，保证有一个条件为真的语句；
    3. &lt;if&gt;条件成立时，拼接上标签内的语句：where 1=1 and name=#{userName}
2. where标签：替换掉 where 1=1
    &lt;select id=&quot;findByCond&quot; resultMap=&quot;userMap&quot; parameterType=&quot;user&quot;&gt;
        select * from user
        &lt;where&gt;
            &lt;if test=&quot;userName != null&quot;&gt;
                and name = #{userName}
            &lt;/if&gt;
            &lt;if test=&quot;userAge &gt; 0&quot;&gt;
                and age = #{userAge}
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
3. foreach标签：比如select * from user where id in (1, 3, 6)
    1. 在包装类 QueryVo 中新增一个集合属性
        public class QueryVo {
            private User user;
            private List&lt;Integer&gt; ids
            //getter、setter
        }
    2. 在 IUserDao 接口中新增方法：List&lt;User&gt; findByIds(QueryVo vo);
    3. 在映射配置文件 IUserDao.xml 中新增查询语句
    &lt;select id=&quot;findByIds&quot; resultMap=&quot;userMap&quot; parameterType=&quot;QueryVo的别名&quot;&gt;
        select * from user
        &lt;where&gt;
            &lt;if test=&quot;ids!=null and ids.size()&gt;0&quot;&gt;
                &lt;foreach collection=&quot;ids&quot; open=&quot;and id in (&quot; close=&quot;)&quot; item=&quot;id&quot;
                separator=&quot;,&quot;&gt;  #{id}  &lt;/foreach&gt;
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;
    1. collection：要遍历的集合属性；
    2. open、close：分别表示语句的开始部分与结束部分
    3. item：保存每次遍历集合时的元素值；
    4. separator：分隔符；
    5. #{id} 中的 id 来自于 item 的属性值；
    QueryVo vo = new QueryVo();
    List&lt;Integer&gt; ids = new ArrayList&lt;&gt;();  ids.add(1); ids.add(3); ids.add(6);
    vo.setIds(ids);
    List&lt;User&gt; us = dao.findByIds(vo);
4. sql标签：抽取重复的SQL语句
    &lt;sql id=&quot;defult&quot;&gt;
        select * from user
    &lt;/sql&gt;
    &lt;select id=&quot;findAll&quot; resultType=&quot;userMap&quot;&gt;
        &lt;include refid=&quot;defult&quot;&gt;&lt;/include&gt;  ===&gt;引用 id=&quot;default&quot; 的&lt;sql&gt;
    &lt;/select&gt;
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/02/05/JavaEE之过滤监听/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/05/JavaEE之过滤监听/" itemprop="url">JavaEE之过滤监听</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-02-05T00:00:00+08:00">
                2016-02-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><pre><code>1. 过滤器(拦截器)：对服务器接收的请求资源和响应给浏览器的资源进行统一管理，保护Servlet;
    1. 比如在请求到达Servlet之前，请求编码格式的统一设置，session管理...
    2. 过滤器会执行两次：请求达到Servlet之前，Servlet响应数据之后。
2. 使用Filter
    1. 实现Filter接口，覆写 init()、doFilter()、destroy()
    2. 在 web.xml 中配置过滤器
    &lt;filter&gt;
        &lt;filter-name&gt;TestFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;it.test.cn.TestFilter&lt;/filter-name&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;TestFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    3. 注解的方式配置
    @WebFilter(&quot;/*&quot;)
    public class TestFilter implements Filter { ... }
    4. /*：拦截访问此项目的所有请求;
    5. *.do：拦截以 .do 结尾的请求，一般用于模块拦截处理;
    6. /to.do：拦截 /to.do 的请求，针对某个具体的Servlet请求进行拦截，保护Servlet;
    7. 如果同时配置了三个过滤器，那么在执行Filter的过程，匹配范围越大，优先级越高.
    /* --&gt; *.do --&gt; /to.do
3. 过滤器会拦截请求，不会到达Servlet，需要手动给予放行，才能达到Servlet
    public void doFilter(ServletRequest request, ServletResponse response, 
        FilterChain chain) {
        chain.doFilter(request, response);  ---&gt; 放行
    }
    1. chain.doFilter() 表示放行当前的请求，交给Servlet进行处理；
    2. Servlet发送响应数据之后，会先达到Filter，执行 chain.doFilter() 之后的代码逻辑，
    然后才会响应给浏览器.
4. 生命周期：从服务器启动(Filter init())，到服务器关闭(Filter destroy())
</code></pre><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><pre><code>1. 统一编码格式设置
    public void doFilter(request, response, chain) {
        request.setCharacterEncoding(&quot;utf-8&quot;);
        response.setContentType(&quot;text/html;charset=utf-8&quot;);
        chain.doFilter(request, response);
    }
2. session管理
    public void doFilter(request, response, chain) {
        HttpSession hs = ((HttpServletRequest)request).getSession();
        //判断Session是否过期
        if(hs.getAttribute(&quot;user&quot;) == null) {
            //过期则重定向到登录页
            ((HttpServletResponse)response).sendRedirect(&quot;/login.jsp&quot;);
        } else {
            chain.doFilter(request, response);
        }
    }
3. 权限管理，资源管理(统一水印、和谐词汇...) ...
</code></pre><h2 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h2><pre><code>1. Servlet监听器：监听数据流转的过程，比如作用域对象的创建与销毁，数据的存取、变化、删除；
2. 监听的作用域对象包括request、session、application
3. 比如session销毁时，在线人数-1
4. 在 web.xml 中配置监听器
    &lt;listener&gt;
        &lt;listener-class&gt;it.test.cn.TestListener&lt;/listener-class&gt;
    &lt;/listener&gt;
</code></pre><h3 id="request-Listener"><a href="#request-Listener" class="headerlink" title="request Listener"></a>request Listener</h3><pre><code>1. ServletRequestListener：实现此接口，监听request的创建销毁;
    1. 接收到一个请求，则创建request对象；响应结束，销毁request对象;
    2. 创建时触发requestInitialized(sre)，销毁时触发requestDestroyed(sre);
    3. 获取当前正在监听的的Servlet Request对象：sre.getServletRequest();
2. ServletRequestAttributeListener：实现此接口，监听request对象中的Attribute数据;
    1. req.setAttribute(&quot;key&quot;, value); 第一次添加数据时，触发 attributeAdded(srea);
    2. req.setAttribute(&quot;key&quot;, value); 重复添加同键的数据，则触发attributeReplaced(srea);
    3. req.removeAttribute(&quot;key&quot;); 移除数据，则触发：attributeRemoved(srea);
    4. 获取当前正在变化的Attribute数据：srea.getName(); srea.getValue();
</code></pre><h3 id="session-Listener"><a href="#session-Listener" class="headerlink" title="session Listener"></a>session Listener</h3><pre><code>1. HttpSessionListener：实现此接口，监听session的创建与销毁;
    1. req.getSession(); 第一次获取Session表示创建，则触发sessionCreated(se);
    2. Session被销毁时，触发sessionDestroyed(se);
    3. 获取当前正在监听的Session对象：se.getSession();
2. HttpSessionAttributeListener：实现此接口，监听session中的attribute数据;
    1. session.setAttribute(&quot;key&quot;, value);  获取/重置Session Attribute数据;
    2. session.removeAttribute(&quot;key&quot;);  移除Session Attribute数据;
    3. 覆写方法：attributeAdded(hsbe)、attributeReplaced(hsbe)、attributeRemoved(hsbe);
    4. hsbe.getName();  hsbe.getValue();  分别获取正在变化的Attribute数据的键、值.
</code></pre><h3 id="application-Listener"><a href="#application-Listener" class="headerlink" title="application Listener"></a>application Listener</h3><pre><code>1. ServletContextListener：实现此接口，监听ServletContext的创建与销毁;
    1. 服务器启动/关闭时，分别触发 contextInitialized(sce); contextDestroyed(sce);
    2. 获取当前正在监听的ServletContext对象：sce.getServletContext();
2. ServletContextAttributeListener：监听application中的attribute数据;
    1. attributeAdded(scae)、attributeReplaced(scae)、attributeRemoved(scae);
    2. scae.getName();  scae.getValue();
</code></pre><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><pre><code>1. 统计当前在线人数
2. 统计网页浏览次数
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/02/03/JavaEE之JSP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/03/JavaEE之JSP/" itemprop="url">JavaEE之JSP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-02-03T00:00:00+08:00">
                2016-02-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><pre><code>1. JSP：Java Server Pages，一种动态网页技术标准，本质是一个简化的Servlet
2. 原理：浏览器访问jsp文件时，JSP引擎把jsp文件转为Servlet(java文件)，然后执行此Servlet
3. Tomcat/conf/web.xml 对jsp访问的配置
    &lt;servlet&gt;
        &lt;servlet-name&gt;jsp&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.apache.jasper.servlet.JspServlet&lt;/servlet-class&gt;
        ...
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;jsp&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;
        &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
4. JSP的访问有一个转译的过程，所以JSP文件的修改不需要重启服务器。
5. JSP的三种注释：前端注释、Java语言注释、JSP注释
    1. 前端注释会被转译，也会被发送给浏览器，但不会执行；
    2. Java语言注释会被转译，但不会被Servlet执行；
    3. JSP注释不会被转译：&lt;%-- JSP注释 --%&gt;
</code></pre><h3 id="page指令"><a href="#page指令" class="headerlink" title="page指令"></a>page指令</h3><pre><code>1. page指令：配置JSP转译的相关参数
    &lt;%@ page 属性名=&quot;属性值&quot; 属性名=&quot;属性值&quot; ... %&gt;
2. language：声明JSP被转译的语言，如language=&quot;java&quot;
3. import：使用什么语言，就需要导入什么语言的包，不同的包以&quot;,&quot;隔开，也可以导入项目中的类
    import=&quot;java.util.*,java.lang.*,it.test.cn.modal.*&quot;
4. pageEncoding：文件保存的编码，如pageEncoding=&quot;utf-8&quot;
    1. 对于高版本的JSP，pageEncoding可以同时指定响应的编码；
    2. 对于低版本的JSP，还需要指定响应的编码：contentType=&quot;text/html;charset=UTF-8&quot;
5. session：设置转译的Servlet中是否支持Session，默认开启，不开启则设置session=&quot;false&quot;
6. errorPage：配置错误页面的路径，errorPage=&quot;error.jsp&quot;
7. extends：设置JSP转译的Servlet要继承的父类(全类名)
8. isELIgnored：是否忽略EL表达式，设置为true时，EL表达式会被当做普通字符串解析.
</code></pre><h3 id="JSP逻辑代码"><a href="#JSP逻辑代码" class="headerlink" title="JSP逻辑代码"></a>JSP逻辑代码</h3><pre><code>1. JSP的局部代码块
    &lt;%
        int num = 1;
        if(num &gt; 0) {
    %&gt;
            &lt;div&gt;num大于0&lt;/div&gt;
    &lt;% } else { %&gt;
            &lt;div&gt;另作处理&lt;/div&gt;
    &lt;% } %&gt;
    1. 转译到Servlet中
    int num = 1;
    if(num &gt; 0) {
        out.write(&quot;\r\n&quot;);
        out.write(&quot;\t\t&lt;div&gt;num大于0&lt;/div&gt;\r\n&quot;);
    } else {
        out.write(&quot;\t\t&lt;div&gt;另作处理&lt;/div&gt;\r\n&quot;);
    }
    2. 在JSP中写逻辑代码，编码困难，可阅读性和可维护性极差，所以尽量在Servlet中处理逻辑，
    JSP只负责展示内容。
2. JSP的全局代码块
    1. 声明Servlet的成员方法和成员变量
    &lt;%!
        int num = 1;
        public void test(){ ... }
    %&gt;
    2. 全局代码块声明的属性和方法，只能在局部代码块中使用。
3. JSP脚本段语句
    1. &lt;%= num %&gt;
    2. &lt;%= test() %&gt;  ==&gt;方法要有返回值
</code></pre><h3 id="JSP的引入与转发"><a href="#JSP的引入与转发" class="headerlink" title="JSP的引入与转发"></a>JSP的引入与转发</h3><pre><code>1. 静态引入： &lt;%@include file=&quot;header.jsp&quot; %&gt;
    1. 两个JSP文件会合并成一个Servlet文件;
    2. 静态引入的JSP不会单独转为一个Servlet;
    3. 两个JSP文件不能声明同名的Java变量.
2. 动态引入： &lt;jsp:include page=&quot;active.jsp&quot;&gt;&lt;/jsp:include&gt;
    1. 动态引入的JSP文件也会单独转为一个Servlet;
    2. 在当前JSP文件转译的Servlet中，会调用动态引入的JSP文件转译的Servlet;
    3. 允许在两个JSP文件中声明同名的Java变量.
3. JSP转发标签
    &lt;jsp:forward page=&quot;target.jsp&quot;&gt;&lt;/jsp:forward&gt;
    1. 一次请求，浏览器地址栏信息不变;
    2. 在&lt;jsp:forward&gt;标签中只能写&lt;jsp:param name=&quot;xxx&quot; value=&quot;xxx&quot;/&gt;，向目的JSP页面
    传递参数，而不能有其他任何字符，甚至是空格也不行，否则就会报错;
    &lt;jsp:forward page=&quot;target.jsp&quot;&gt;
        &lt;jsp:param name=&quot;user&quot; value=&quot;Mack&quot; /&gt;
    &lt;/jsp:forward&gt;
    3. 以GET形式转发参数：转发路径?user=Mack
    4. 在目的JSP页面获取参数：&lt;%= request.getParameter(&quot;user&quot;) %&gt;
</code></pre><h3 id="JSP的内置对象"><a href="#JSP的内置对象" class="headerlink" title="JSP的内置对象"></a>JSP的内置对象</h3><pre><code>1. 九大内置对象：JSP文件转译为Servlet时自动生成并声明的对象，可以在JSP文件中直接使用；
2. 内置对象只能在局部代码块和脚本段语句中使用；
1. pageContext：JSP的页面上下文对象，内部封装了另外8个内置对象；
    1. PageContext封存了当前JSP的运行信息，每个JSP文件都有一个PageContext对象；
    2. 每次请求都会重新创建一个PageContext对象，存储当前页面内的数据。
2. application
    ServletContext application = pageContext.getServletContext();
3. config
    ServletConfig application = pageContext.getServletConfig();
4. out
    JspWriter out = pageContext.getOut();
    1. JSP内部使用的响应对象，带有缓冲区，效率高于response
5. session：一次会话的Session对象，存储同一用户、不同请求的共享数据；
    1. 要使用Session对象，必须先在page指令中开启，session=&quot;true&quot;
    session = pageContext.getSession();
6. request，response：分别是当前的请求对象、响应对象；
7. page：this，当前JSP对象(Servlet对象);
8. exception：存储当前运行的异常信息，先在page指令中使用 isErrorPage=&quot;true&quot; 开启;
9. 数据流转
    1. pageContext：当前页面内的数据共享，获取其他内置对象;
    2. request：一次请求的数据共享，通过请求转发，把数据流转给下一个Servlet;
    3. session：一次会话，同一用户、不同请求的数据共享，将数据从一次请求流转给其他请求;
    4. application：项目内的数据，不同用户的数据共享，将数据从一个用户流转给其他用户.
</code></pre><h3 id="JSP的资源路径"><a href="#JSP的资源路径" class="headerlink" title="JSP的资源路径"></a>JSP的资源路径</h3><pre><code>1. 在JSP中使用相对路径时，资源位置不可随意更改；
2. 绝对路径：&lt;a href=&quot;/servtest/a.jsp&quot;&gt;，
    1. 第一个 &quot;/&quot; 表示服务器根目录(Tomcat/webapps)，&quot;/servtest&quot; 表示服务器的项目根目录，
    servtest是项目在Tomcat/webapps下的虚拟目录名。
3. 在JSP中声明全局路径
    &lt;%
        String path = request.getContextPath();
        String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;
        +request.getServerPort()+path+&quot;/&quot;;
    %&gt;
    &lt;html&gt;
        &lt;head&gt;
            &lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt;
    1. 那么，在JSP文件中引入资源时，资源路径会自动加上 Ip:Port/项目虚拟目录名/
    2. &lt;a href=&quot;a.jsp&quot;&gt; 跳转到 http://Ip:Port/servtest/a.jsp
    3. &lt;img src=&quot;images/header.png&quot; /&gt;
        http://Ip:Port/servtest/images/header.png
    4. &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/main.css&quot; /&gt;
        http://Ip:Port/servtest/css/main.css
4. 重定向到 main目录下的main.jsp
    resp.sendRedirect(&quot;/servtest/main/main.jsp&quot;);
    1. 重定向时，尽量使用绝对路径取代资源路径：/项目虚拟目录名/资源路径;
    2. 假定当前的Servlet的别名带有目录，如&lt;url-pattern&gt;/user/abc&lt;/url-pattern&gt;
    3. 如果使用相对路径，如resp.sendRedirect(&quot;main/main.jsp&quot;);  那么跳转的main.jsp的
    路径为 /项目虚拟目录名/user/main/main.jsp;
    4. 而main.jsp的真实路径是 /项目虚拟目录名/main/main.jsp ，那么就会报404错误.
5. 转发到一个JSP页面
    req.getRequestDispatcher(&quot;/login.jsp&quot;).forward(req, resp);
    1. 与请求重定向不同，请求转发的第一个 &quot;/&quot; 表示项目根目录，而不是服务器根目录，所以不用
    加项目的虚拟目录名.
</code></pre><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><pre><code>1. EL：Expression Language，一种写法非常简洁的表达式，灵感来源于ES和XPath;
2. EL表达式用于简化在JSP中获取作用域数据和请求数据，不需要导入相关的类(包);
3. 传统的获取方式
    1. 在Servlet中处理请求之后，通过请求转发到JSP页面：req.setAttribute(&quot;key&quot;, Object);
    2. 在JSP页面中获取数据：&lt;%= request.getAttribute(&quot;key&quot;) %&gt;
    3. 在JSP页面中获取请求参数：&lt;%= request.getParameter(&quot;key&quot;) %&gt;
4. 语法结构：${expression}
    1. 获取请求参数
    ${ param.key } --&gt; 单个值
    ${ paramvalues.key } --&gt; 同键不同值如Checkbox
    2. 获取 req.setAttribute(&quot;key&quot;, Object) 传递的数据：${ Object }
    3. ${} 只获取 pageContext、request、session、application四个对象中的数据;
    &lt;%  String uname = &quot;Java&quot;;  %&gt;
    &lt;h3&gt;${ uname }&lt;/h3&gt;
    4. 如果在四大对象中找不到uname，不报错，也不显示内容，但决不理会页面中定义的变量uname;
5. EL查找作用域数据的默认顺序：pageContext --&gt; request --&gt; session --&gt; application
    &lt;%
        pageContext.setAttribute(&quot;uname&quot;, &quot;aaaa&quot;);
        request.setAttribute(&quot;uname&quot;, &quot;bbbb&quot;);
        session.setAttribute(&quot;uname&quot;, &quot;cccc&quot;);
        application.setAttribute(&quot;uname&quot;, &quot;dddd&quot;);
    %&gt;
    &lt;div&gt;${ uname }&lt;/div&gt; ===&gt; aaaa
    1. 除了默认顺序，还可以手动指定查找方向
    request：${ requestScope.uname }，pageContext：${ pageScope.uname }
    session：${ sessionScope.uname }，application：${ applicationScope.uname }
6. EL支持简单的逻辑运算：算术表达式、关系表达式、逻辑表达式(&amp;&amp; || !)、三元表达式
    ${ 1+3 } =&gt; 4，${ 1&gt;3 } =&gt; false，${ flag==0?&quot;正确&quot;:&quot;错误&quot; }
    1. EL表达式中不允许做字符串连接
    ${ 1+&quot;4&quot; } =&gt; 5，${ 1+&quot;a&quot; } =&gt; 报错
7. EL的空值判断：${ empty key }，空字符串、空集合都返回true，但是对象返回false
8. EL获取请求头数据：${ header }
    1. 单个值：${ header[&quot;key&quot;] }，如${ header[&quot;user-agent&quot;] }
    2. 数组：${ headerValues[&quot;key&quot;] }，同键不同值
9. EL获取Cookie数据：${ cookie }
    1. 获取一条Cookie数据，如sessionID：${ cookie.JSESSIONID }
    2. 获取这条Cookie数据的键值：
    ${ cookie.JSESSIONID.name }，${ cookie.JSESSIONID.value }
</code></pre><h2 id="JSTL标签库"><a href="#JSTL标签库" class="headerlink" title="JSTL标签库"></a>JSTL标签库</h2><pre><code>1. JSTL是 Apache 对EL表达式的扩展，JSTL依赖于EL，使用时需要导包，并指定标签库；
    1. MyEclipse会在lib目录下自动存放jstl.jar
    2. JSTL的标签库：核心库、格式化库、SQL库、函数库、XML库
2. JSTL标签库能够提升JSP页面编写逻辑代码的效率，可阅读性更强；
</code></pre><h3 id="JSTL核心标签库"><a href="#JSTL核心标签库" class="headerlink" title="JSTL核心标签库"></a>JSTL核心标签库</h3><pre><code>1. 导入jar包，声明jstl核心标签库的引入
    &lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
2. 输出：&lt;c:out&gt; 类似于 &lt;%=xxx %&gt;
    &lt;%  request.setAttribute(&quot;uname&quot;, &quot;Java&quot;);  %&gt;
    &lt;c:out value=&quot;${uname}&quot; default=&quot;xxx&quot;&gt;&lt;/c:out&gt;
    1. 结合EL表达式输出，如果uname不存在，则输出默认值default
3. 向作用域中存储键值： &lt;c:set var=&quot;key&quot; value=&quot;xxx&quot;&gt;&lt;c:set&gt;
    1. 默认存储在pageContext中，也可以手动指定存储的作用域对象
    &lt;c:set var=&quot;key&quot; value=&quot;xxx&quot; scope=&quot;page/request/session/application&quot;&gt;&lt;c:set&gt;
4. 删除作用域的数据：&lt;c:remove&gt;
    &lt;c:remove var=&quot;uname&quot; /&gt;
    1. 默认把4个作用域对象中的uname都删除，scope属性指定作用域
    &lt;c:remove var=&quot;uname&quot; scope=&quot;page/request/session/application&quot; /&gt;
5. 逻辑标签：依赖于EL表达式
    1. 单个判断
    &lt;c:set var=&quot;score&quot; value=&quot;66&quot;&gt;&lt;c:set&gt;
    &lt;c:if test=&quot;${score&gt;60}&quot;&gt;
        &lt;div&gt;条件通过&lt;/div&gt;
    &lt;/c:if&gt;
    2. 多重判断
    &lt;c:choose&gt;
        &lt;c:when test=&quot;${score&gt;=90}&quot;&gt;
            &lt;li&gt;11111111&lt;/li&gt;
        &lt;/c:when&gt;
        &lt;c:when test=&quot;${score&lt;90 &amp;&amp; score&gt;=70}&quot;&gt;
            &lt;li&gt;2222222&lt;/li&gt;
        &lt;/c:when&gt;
        &lt;c:when test=&quot;${score&lt;70 &amp;&amp; score&gt;=60}&quot;&gt;
            &lt;li&gt;3333333&lt;/li&gt;
        &lt;/c:when&gt;
        &lt;c:otherwise&gt;
            &lt;li&gt;4444444&lt;/li&gt;
        &lt;/c:otherwise&gt;
    &lt;/c:choose&gt;
6. 常量循环
    &lt;c:forEach begin=&quot;1&quot; end=&quot;4&quot; step=&quot;1&quot; varStatus=&quot;vs&quot;&gt;  ==&gt; 循环4次
        &lt;li&gt;${vs.index} -- ${vs.count} -- ${vs.first} -- ${vs.last}&lt;/li&gt;
    &lt;/c:forEach&gt;
    1. step属性设置每次循环的自增步数，默认自增1
    2. varStatus属性保存当前循环的状态
        1. vs.index：当前循环的角标
        2. vs.count：当前是第几次循环
        3. vs.first/vs.last：当前是不是第一次/最后一次循环，true/false
7. 动态循环
    &lt;%
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;111&quot;);
        request.setAttribute(&quot;list&quot;, list);
        HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;a&quot;, &quot;11&quot;);
        request.setAttribute(&quot;map&quot;, map);
    %&gt;
    1. 遍历List集合
    &lt;c:forEach items=&quot;${list}&quot; var=&quot;v&quot;&gt;
        &lt;li&gt;${v}&lt;/li&gt;
    &lt;/c:forEach&gt;
    2. var属性是每次循环的元素值;
    3. 遍历Map集合
    &lt;c:forEach items=&quot;${map}&quot; var=&quot;v&quot;&gt;
        &lt;li&gt;${v.key} -- ${v.value}&lt;/li&gt;
    &lt;/c:forEach&gt;
    4. v 表示每次循环的一条Map元素，v.key、v.value 分别表示这条数据的键、值。
</code></pre><h3 id="JSTL格式化标签库"><a href="#JSTL格式化标签库" class="headerlink" title="JSTL格式化标签库"></a>JSTL格式化标签库</h3><pre><code>1. 声明jstl核心标签库的引入
    &lt;%@taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; %&gt;
2. 可以格式化输入文本、日期、时间、数字
    1. &lt;fmt:formatNumber&gt;：使用指定的格式或精度格式化数字;
    2. &lt;fmt:parseNumber&gt;：解析一个代表着数字/货币/百分比的字符串;
    3. &lt;fmt:formatDate&gt;：使用指定的风格或模式格式化日期和时间;
    4. &lt;fmt:parseDate&gt;：解析一个代表着日期或时间的字符串;
    5. &lt;fmt:requestEncoding&gt;：设置request的字符编码;
    6. &lt;fmt:timeZone&gt;：指定时区，供其它标签使用;
    7. &lt;fmt:setTimeZone&gt;：复制一个时区对象至指定的作用域.
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/02/01/JavaEE之Servlet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/01/JavaEE之Servlet/" itemprop="url">JavaEE之Servlet</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-02-01T00:00:00+08:00">
                2016-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h2><pre><code>1. HTTP的特点：快速连接、灵活、无连接、无状态；
    1. 无连接：限制每次连接只处理一个请求，可以节省传输时间；
    2. 无状态：HTTP协议是无状态协议，对于事物处理没有记忆能力，如果第二次请求用到了第一次
    请求响应的数据，仍然需要重新传递。
2. HTTP1.1版本后支持可持续连接：连接不立即断开，而是一段时间内没任何请求时，才会断开通道；
3. HTTP的请求方式
    1. HTTP1.0定义三种请求方法：GET、POST、HEAD
    2. HTTP1.1新增5种：OPTIONS、PUT、DELETE、TRACE、CONNECT
4. Tomcat
    1. 目录结构：bin(可执行文件目录)、conf(服务器配置文件目录)、lib(jar包目录)、log(日志)
    temp(缓存文件目录)、webapps(存放web应用的目录)、work(存放JSP转换后的servlet文件)
    2. windows系统启动Tomcat：bin/startup.bat，默认IP和端口号为localhost:8080
    3. Tomcat的运行依赖JDK，必须配置JDK环境。
5. log4j：打印日志，引入log4j.jar后，把log4j.properties放在项目的src目录下；
6. 在原生的HTML中，使用 &lt;frame&gt; 引入公共的html文件
    &lt;frameset cols=&quot;25%,50%,25%&quot;&gt;
        &lt;frame src=&quot;left.html&quot; /&gt;
        &lt;frame src=&quot;content.html&quot; /&gt;
        &lt;frame src=&quot;right.html&quot; /&gt;
    &lt;/frameset&gt;
    1. 在存在层级关系的HTML页面中，window.self表示自身的window对象;
    2. window.parent表示父级HTML的window对象;
    3. window.top表示最顶级HTML的window对象.
</code></pre><h3 id="Servlet技术"><a href="#Servlet技术" class="headerlink" title="Servlet技术"></a>Servlet技术</h3><pre><code>1. Servlet是Java实现的一个接口，任何实现Servlet接口的类都可以成为Servlet；
2. Servlet运行于支持Java的应用服务器中，理论上可以响应任何类型的请求，但一般只用于扩展基于
   HTTP协议的Web服务器；
3. Servlet的特点
    1. 运行在支持Java的应用服务器上，简单方便、可移植性强；
    2. 服务器会自动根据请求调用对应的Servlet，进行请求的处理。
4. Servlet的使用(MyEclipse)
    1. 继承HttpServlet，覆写service()，处理请求、响应数据；
    public class ServletTest extends HttpServlet {
        protected void service(HttpServletRequest req, HttpServletResponse resp) {
            // super.service(req, resp); -----&gt; 务必注释掉，否则会报405
            resp.getWriter().write(&quot;Hello ServletTest&quot;);
        }
    }
    2. 在WebRoot/WEB-INF/web.xml中，配置servlet
    &lt;servlet&gt;
        &lt;servlet-name&gt;ServletTest&lt;/servlet-name&gt;
        &lt;servlet-class&gt;it.test.cn.ServletTest&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;ServletTest&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/test&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    3. 在Tomcat/webapps下新建目录servtest，把WebRoot目录中的文件复制到servtest目录中
    4. 启动Tomcat，访问ServletTest：http://localhost:8080/servtest/test
    5. webapps下的项目文件夹名称，又叫虚拟项目名；servlet的url-pattern又称为servlet别名
    6. 除了在web.xml中配置Servlet，servlet3.0开始支持注解配置
    @WebServlet(name = &quot;ServletTest&quot;, urlPatterns=&quot;/test&quot;)
    public class ServletTest extends HttpServlet { ... }
    7. url-pattern支持正则表达式，如/user/*，可以匹配/user/find，/user/add ...
    8. Servlet3.0部署 web.xml 的根节点 &lt;web-app&gt; 时，metadata-complete默认值为false，
    表示启用注解支持；设置为true时，表示只依赖 web.xml，忽略所有注解。
5. Servlet的生命周期
    1. Servlet的初始化函数：init()，第一次访问此Servlet时加载进内存，执行初始化，一直到
    关闭Tomcat服务，无论接受多少请求，都只会执行一次，即使删除本地文件，也能正常访问；
    2. service()：处理请求的方法，每次接收到请求都会执行；
    3. destory()：Servlet销毁的方法，关闭Tomcat服务时执行；
    4. 在 web.xml 中，在&lt;servlet&gt;中配置子节点&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;，
    那么此Servlet将在启动Tomcat服务时，加载进内存，执行 init() 初始化。
6. doGet()、doPost()
    1. doGet() 处理Get请求，doPost() 处理Post请求，service() 可以同时处理这两种请求;
    2. 如果Servlet中同时配置了 doGet()、doPost()、service()，那么优先执行service();
    3. service()中的 super.service() 会根据当前的请求方式，再去调用doGet()、doPost()
    所以在覆写 service() 时，通常注释掉super.service(); 否则会报405
7. HttpServletRequest：请求对象
    1. getMethod()：获取请求方法；
    2. getRequestURL()：获取请求的完整地址；
    3. getRequestURI()：请求接口地址，不包含域名和端口号；
    4. getHeader(&quot;key&quot;)：根据请求行的键获取值；
    5. Enumeration&lt;String&gt; e = req.getHeaderNames(); 所有请求行的键的枚举
    while(e.hasMoreElements()) {
        String s = e.nextElement();  --&gt; 键
    }
    6. getParameter(&quot;key&quot;)：获取用户数据(Get和Post)；
    7. getParameterValues(&quot;key&quot;)：类似Checkbox的一键多值；
8. HttpServletResponse：响应对象
    1. setHeader(&quot;key&quot;, &quot;value&quot;)：设置响应头，同键覆盖；
    2. addHeader(&quot;key&quot;, &quot;value&quot;)：添加响应头，同键不会覆盖；
    3. sendError(200, &quot;OK&quot;)：设置响应状态码；
    4. res.getWriter().write(...)：设置响应体；
    5. 中文乱码问题：
    res.setHeader(&quot;content-type&quot;, &quot;text/html;charset=utf-8&quot;);
    或 res.setContentType(&quot;text/html;charset=utf-8&quot;);
    6. text/html：表示响应体是HTML，让浏览器按照HTML进行解析；
    7. text/plain：响应体是普通字符串；
    8. text/xml：响应体是XML
</code></pre><h2 id="响应处理"><a href="#响应处理" class="headerlink" title="响应处理"></a>响应处理</h2><pre><code>1. 请求乱码问题
    1. 浏览器默认是iso8859-1编码，用户提交的数据为中文时，可能出现乱码，需要转为utf-8
    String a = new String(b.getBytes(&quot;iso8859-1&quot;), &quot;utf-8&quot;); --&gt; 通用解决方式
    2. GET请求的扩展方式：req.setCharacterEncoding(&quot;utf-8&quot;);
    同时配置Tomcat/conf/server.xml：&lt;Connector useBodyEncodingForURI=&quot;true&quot; .../&gt;
    3. POST请求的扩展方式：req.setCharacterEncoding(&quot;utf-8&quot;);
2. 请求转发
    1. 特点：一次请求，浏览器地址栏的信息不变；
    2. req.getRequestDispatcher(&quot;转发的地址&quot;).forward(req, resp);
    3. 在转发过程中，因为是同一个HttpServletRequest对象，可以从当前Servlet向目的Servlet
    传递数据：
    req.setAttribute(&quot;key&quot;, value); ---&gt; 当前Servlet设置数据
    value = req.getAttribute(&quot;key&quot;); ---------------------&gt; 目的Servlet获取数据
    4. session.removeAttribute(&quot;key&quot;); 移除键值数据。
3. 请求重定向
    1. 特点：两次请求，两个Request对象，浏览器地址栏信息改变；
    2. resp.sendRedirect(&quot;地址&quot;);
    3. 既然是两个Request对象，要实现数据传递，只能借助Session
</code></pre><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><pre><code>1. Cookie是浏览器端的数据存储，在服务器端响应数据时，告诉浏览器存储Cookie
2. 在服务器端声明Cookie
    Cookie ck = new Cookie(&quot;key&quot;, &quot;value&quot;);
    resp.addCookie(ck);
    1. 如果需要存储多个key-value，则创建多个Cookie对象；
    2. 默认情况下，Cookie临时存储在浏览器内存中，一旦关闭浏览器，Cookie将消失；
    3. 设置Cookie的有效期：ck.setMaxAge(3*24*3600); --&gt; 3天
    4. 设置有效期的Cookie会存储在浏览器本地，即使关闭了浏览器，只要未过期、就不会消失。
3. 默认情况下，每次请求都会携带当前域名下的Cookie，除非设置有效路径
    1. ck.setPath(&quot;/abc/xxx&quot;);
    2. 只有在请求 /abc/xxx 时才会携带此Cookie
4. 在服务器端获取请求对象中携带的Cookie
    Cookie[] cks = req.getCookies();
    for(Cookie c: cks) {
        String name = c.getName();
        String value = c.getValue();
    }
</code></pre><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><pre><code>1. 同一用户、不同请求的数据共享，如重定向的两个Servlet，可以使用Session存储共享数据；
2. Session存储在服务器端，标识不同用户的Session的唯一ID，会以Cookie的形式存储在浏览器端
    用户第一次访问服务器 --&gt; 服务器创建Session，并将此Session对象的JSESSIONID以Cookie
    的形式存储到浏览器中 --&gt; 同一个用户再次访问时，会携带此JSESSIONID --&gt; 通过JSESSIONID
    查找此用户的Session数据
3. Session的特点：存储在服务器端、由服务器端创建、依赖Cookie技术、一次会话
4. 创建/获取Session
    1. HttpSession hs = req.getSession();  --&gt; 没有Session对象则创建，有则获取
    2. 创建Session之后，会自动把JSESSIONID作为Cookie返回给浏览器存储；
    2. hs.getId(); --&gt; 获取Session的唯一标识JSESSIONID
5. JSESSIONID默认是临时存储，关闭浏览器则失效；
6. Session的默认存储时间是30分钟
    1. 关闭浏览器，JSESSIONID就失效了，但服务器并不知道，所以就不能及时删除对应的Session，
    这就需要设置Session的过期时间了，以免服务器端的Session数据过多；
    1. 设置Session的有效期：hs.setMaxInactiveInterval(60); --&gt; 60秒
    2. 不管是默认值还是自定义有效期，只要在有效期内发起了请求，Session有效期都会重新计时；
    3. hs.invalidate(); --&gt; 强制失效
    4. 如果Session失效了，req.getSession() 还会重新创建Session，并将ID存储到浏览器
7. Session的数据存储
    1. hs.setAttribute(&quot;key&quot;, value); --&gt; 在一个Servlet中存储Session数据
    2. value = hs.getAttribute(&quot;key&quot;);  ----&gt; 在其他Servlet中获取Session中的数据
8. 配置Session的默认有效期
    1. 在Tomcat/conf/web.xml中
    &lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt;
    2. 此配置对Tomcat下部署的所有项目有效；
    3. 在项目下的web.xml中配置 &lt;session-config&gt; , 只对本项目有效。
</code></pre><h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><pre><code>1. ServletContext：一个项目只有一个ServletContext对象；
2. ServletContext的生命周期：从服务器启动到结束；
3. 三种获取方式：
    1. ServletContext sc = this.getServletContext();
    2. ServletContext sc = this.getServletConfig().getServletContext();
    3. ServletContext sc = req.getSession().getServletContext();
4. 不同用户可以共享ServletContext数据
    1. sc.setAttribute(&quot;key&quot;, value);  --&gt; 设置
    2. value = sc.getAttribute(&quot;key&quot;); --&gt; 获取
5. 获取项目 web.xml 的全局配置数据
    1. 配置全局数据
    &lt;web-app ...&gt;
        &lt;context-param&gt;  ---&gt; 一组&lt;context-param&gt;只能存储一对键值数据，可以声明多组
            &lt;param-name&gt;key&lt;/param-name&gt;
            &lt;param-value&gt;value&lt;/param-value&gt;
        &lt;/context-param&gt;
    2. String param = sc.getInitParameter(&quot;key&quot;);
    3. sc.getInitParameterNames();  --&gt; 键的枚举
    4. 作用：将静态数据和代码进行解耦
6. 获取项目WebRoot目录下的资源路径(MyEclipse环境，WebRoot目录下文件会复制到Tomcat中)
    1. 在WebRoot下创建doc目录，在doc下新建文件a.txt
    2. String doca = sc.getRealPath(&quot;/doc/a.txt&quot;);  --&gt; 获取a.txt的路径
    3. InputStream is = sc.getResourceAsStream(&quot;/doc/a.txt&quot;);  --&gt; 获取流对象
    4. ServletContext只能获取资源文件，不能获取class文件(需要类加载器)
7. 比如，统计一段时间内的访问次数，可以使用ServletContext
</code></pre><h3 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h3><pre><code>1. ServletConfig是Servlet的专属配置对象，每个Servlet都单独拥有一个ServletConfig对象；
2. ServletConfig用于获取 web.xml 中的Servlet配置信息；
3. 获取Servlet的ServletConfig对象：
    ServletConfig config = this.getServletConfig();
4. 在 web.xml 的 &lt;servlet&gt; 下配置：
    &lt;init-param&gt;
        &lt;param-name&gt;key&lt;/param-name&gt;
        &lt;param-value&gt;value&lt;/param-value&gt;
    &lt;/init-param&gt;
5. 获取Servlet配置的键-值数据：String value = config.getInitParameter(&quot;key&quot;);
</code></pre><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><pre><code>1. Tomcat/conf/web.xml 与 Web项目/web.xml
    1. Tomcat下的web.xml为全局配置，对所有web项目有效，配置公共信息；
    2. web项目/web.xml为局部配置，只对当前项目有效；
    3. 对于相同的配置内容，web项目/web.xml的优先级更高。
2. web.xml的核心配置：
    1. 全局上下文ServletContext、Servlet配置context-param、过滤器filter、监听器listener
    2. 排列顺序是任意的，但加载顺序是固定的：
    ServletContext --&gt; context-param --&gt; listener --&gt; filter --&gt; Servlet
    3. web.xml都是在服务器启动时加载
</code></pre><h3 id="server-xml"><a href="#server-xml" class="headerlink" title="server.xml"></a>server.xml</h3><pre><code>1. Tomcat/conf/server.xml，核心节点&lt;Service&gt;，一个&lt;Server&gt;节点下可以配置多个&lt;Service&gt;
    1. HTTP协议的端口号配置
    &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; 
        connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;
    2. 服务器集群配置
    &lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;
2. 引擎节点：&lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;
    1. 一个&lt;Service&gt;节点下只能配置一个&lt;Engine&gt;节点
    2. &lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot; ...&gt;，appBase属性指定项目所在的目录
    3. &lt;Engine&gt;的defaultHost属性指定了默认的host，指向子节点&lt;Host name=&quot;localhost&quot; ...&gt;
    4. 浏览器访问Tomcat服务器时，如果输入的host在&lt;Engine&gt;下没有配置，如本机的私有地址
    192.168.xxx.xxx，则执行默认的host
3. 在&lt;Host&gt;节点下配置热部署
    &lt;Context path=&quot;/abc&quot; reloadable=&quot;true&quot; docBase=&quot;F:/WebTest&quot; /&gt;
    1. path：项目的虚拟目录名；
    2. reloadable：是否自动加载；
    3. docBase：项目所在的绝对路径；
    4. 热部署不需要在Tomcat/webapps下为项目创建文件夹(项目的虚拟目录)，所以如果项目删除，
    对应的&lt;Context/&gt;也必须删除，否则Tomcat启动会报错。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/01/10/Java之Maven/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/10/Java之Maven/" itemprop="url">Java之Maven</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-10T00:00:00+08:00">
                2016-01-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><pre><code>1. Maven是一个项目管理工具，两大核心功能：依赖管理、一键构建;
2. 依赖管理(jar包管理)
    1. Maven项目中的jar包在一个jar包仓库中，项目中只放jar包的坐标，在代码编译时去仓库中找到jar包;
    2. 大大减少了磁盘空间，解决了jar包冲突，实现了代码可重用。
3. 一键构建
    1. 构建：项目从编译、测试、运行、打包、安装、部署的整个过程都交给Maven进行管理；
    2. 一个Maven命令就可以实现构建，在maven/lib目录中集成了Tomcat插件。
4. Maven项目必须使用依赖管理，而一键构建却不是必须的，还可以使用本地安装的Tomcat构建项目;
5. Maven依赖于JDK，还需要配置环境变量，然后测试是否安装配置成功：mvn -v
</code></pre><h2 id="Maven仓库"><a href="#Maven仓库" class="headerlink" title="Maven仓库"></a>Maven仓库</h2><pre><code>1. Maven仓库的分类：本地仓库、远程仓库(私服)、中央仓库
    1. 当启动Maven项目时，Maven会通过 pom.xml 中配置的依赖坐标，去本地仓库中查找对应的jar包;
    2. 默认情况下，如果本地仓库没有对应的jar包，Maven会自动从中央仓库下载jar包到本地仓库;
    3. 如果配置了私服，则去私服下载jar包到本地仓库; 私服中没有，则转去中央仓库下载，还没有则报错.
2. 本地仓库
    1. 在 Maven/conf/settings.xml 中，本地仓库的默认配置为 ${user.home}/.m2/repository
    2. user.home 表示C盘下的个人目录
    3. 考虑到C盘通常是系统盘，所以会自定义本地仓库的路径，如D盘下
        &lt;localRepository&gt;D:/local/repo&lt;/localRepository&gt;
    4. 配置淘宝等国内镜像，可以加快下载速度，比如阿里的Maven镜像;
    &lt;mirrors&gt;
        &lt;mirror&gt; 
            &lt;id&gt;alimaven&lt;/id&gt; 
            &lt;name&gt;aliyun maven&lt;/name&gt; 
            &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; 
            &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;         
        &lt;/mirror&gt; 
    &lt;/mirrors&gt;
3. 远程仓库(私服)：
    1. 在公司内有专门的局域网服务器作为jar包的远程仓库，又称为私服;
    2. 配置了远程仓库之后，预先在私服中上传常用的jar包，让本地仓库从局域网内的私服下载jar包;
    3. 如果私服中没有需要的jar包，再转去中央仓库下载。
4. 中央仓库：Maven的云服务器jar包仓库，存放了几乎所有的开源jar包。
</code></pre><h2 id="Maven项目"><a href="#Maven项目" class="headerlink" title="Maven项目"></a>Maven项目</h2><pre><code>1. Maven项目的目录可分为四大部分：核心代码、配置文件、测试代码、测试配置文件
2. Maven的Java项目
    1. src/main/java：核心代码;
    2. src/main/resources：配置文件;
    3. src/test/java：测试代码;
    4. src/test/resources：测试配置文件;
3. 对于Java Web项目，除了这4个目录，还有一个 src/main/webapp，存放JSP页面资源、web.xml等。
</code></pre><h3 id="Maven的生命周期"><a href="#Maven的生命周期" class="headerlink" title="Maven的生命周期"></a>Maven的生命周期</h3><pre><code>1. Maven常用命令
    1. mvn clean：清除项目中的编译信息，删除target目录；
    2. mvn compile：编译src/main/java中的核心代码，生成target目录，存放编译好的class文件
    3. mvn test：除了编译核心代码，还会编译src/main/test中的测试代码；
    4. mvn package：打包，除了编译核心代码和测试代码，还会打包成war/jar包；
    5. mvn install：安装，编译核心代码和测试代码，打成war包，同时把war包安装到本地仓库中。
2. mvn clean：独立的一个生命周期，称为清理生命周期；
3. 编译(compile)、测试(test)、打包(package)、安装(install)、发布(mvn deploy)
    1. 称为默认生命周期，所以执行越靠后的命令时，会自动执行前面的命令；
    2. 其中，发布需要额外配置。
4. 另外，还有一个不常用的站点生命周期.
</code></pre><h3 id="jar包和war包"><a href="#jar包和war包" class="headerlink" title="jar包和war包"></a>jar包和war包</h3><pre><code>1. jar和war是两种不同的打包方式，在项目的 pom.xml 中配置：&lt;packaging&gt;war&lt;/packaging&gt;
2. war是一个web模块，其中需要包括WEB-INF，是可以直接运行的web模块;
3. 将war包放置 Tomcat/webapps/ 下，启动Tomcat，war包会自动解压成项目的web目录，相当于发布了;
4. jar一般只是包括一些class文件，在声明了 main() 之后就可以用java命令运行;
5. Spring项目一般都是打成war包发布到Tomcat上，而SpringBoot项目一般使用jar包的打包模式;
6. SpringBoot内部已经集成了Tomcat插件，省去了安装Tomcat等中间件，所以打成jar包也很有必要.
    java -jar jar包名  //运行jar包项目的命令
</code></pre><h2 id="POM模型"><a href="#POM模型" class="headerlink" title="POM模型"></a>POM模型</h2><pre><code>1. Maven的概念模型POM
</code></pre><p><img src="//hellomyshadow.github.io/2016/01/10/Java之Maven/Maven.jpg" alt="Maven"></p>
<h2 id="idea集成Maven"><a href="#idea集成Maven" class="headerlink" title="idea集成Maven"></a>idea集成Maven</h2><pre><code>1. 下载并解压Maven，配置环境变量(必须有JDK环境)：
    1. 新建环境变量MAVEN_HOME：D:\maven\apache-maven-3.6.0
    2. 配置Path：%MAVEN_HOME%\bin
2. idea：Settings --&gt; 搜索 Maven
    1. 配置使用本地Maven
        Maven home directory: D:\maven\apache-maven-3.6.0
        User settings file: D:\maven\apache-maven-3.6.0\conf\settings.xml
        Local repository: D:\maven\maven_repository
    2. 如果Maven项目骨架(模板)已经下载过了，不要再下载了：
        Maven --&gt; Runner VM Options: archetypeCatalog=internal
3. 使用Maven骨架(模板)创建Java项目
    New Project --&gt; Maven --&gt; 勾选Create... --&gt; 选择maven-archetype-quickstart
    1. 一个jar包的坐标由三个基本元素构成：
        GroupId(公司或组织的名称): com.test  ---&gt;作为项目的包名
        ArtifactId(项目名称): maven_test
        Version(版本号): 1.0-SNAPSHOT  ---&gt;RSNAPSHOT表示测试版，RELEASE表示发布/正式版
    2. Next --&gt; 确认当前使用的Maven环境，与 Settings--&gt;Maven 中的配置一致；
    3. 如果第一次使用此骨架，会联网下载，而且默认只会创建使用到的目录，不会把Maven标准目录结构都创建;
    4. 创建main/resources目录，右键 --&gt; Mark Directory As --&gt; Resources Root
    5. 刚创建的项目不能运行，点击右下角的 Import Changes 或 Enable Auto-Import(自动导入依赖)
        Add Configurations -&gt; + Application(自定义名字) -&gt; Main class(选择入口文件) -&gt; OK
4. 不适用骨架的Java项目
    1. 目录结构：src/main/java，src/main/resources
    2. 与使用骨架相比，目录结构更接近Maven项目的标准目录，文件也更干净。
</code></pre><h3 id="创建JavaWeb项目"><a href="#创建JavaWeb项目" class="headerlink" title="创建JavaWeb项目"></a>创建JavaWeb项目</h3><pre><code>1. 选择骨架：maven-archetype-webapp
2. 默认只有一个 main/webapp 目录，并没有main/java、main/resources目录;
3. 新建java目录，右击 --&gt; Mark Directory as --&gt; Sources Root;
4. 点击 Import Changes 或 Enable Auto-Import，在项目的 External Libraries 可以查看当前项目的依赖列表;
5. 在项目的 pom.xml 中，添加Servlet相关的依赖，在maven中央仓库搜索需要的jar包;
    &lt;dependencies&gt;
        &lt;dependency&gt;  ===&gt;如果本地仓库没有这些依赖，idea会自动联网下载
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
            &lt;version&gt;4.0.1&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
            &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt;
            &lt;version&gt;2.3.3&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
6. web.xml 中，为根节点 &lt;web-app&gt; 添加约束
    &lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee
            http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;
        version=&quot;3.0&quot;&gt;
7. 使用Maven自带的Tomcat插件运行项目：打开右侧的Maven面板
    1. 点击上面带有&quot;m&quot;的小图标 --&gt; 输入 tomcat:run 命令运行项目;
    2. 展开项目的Lifecycle，双击 run 命令也可以运行;
    3. 访问：http://localhost:8080/项目名/
8. 使用本地的Tomcat运行项目：
    Add Configurations --&gt; + Tomcat Server -&gt; Local --&gt; Name命名，Deployment添加项目
    1. + Artifacts --&gt; war表示打包启动，war exploded表示打包热启动，选择热启动;
    2. Application context 设置项目的虚拟目录名，设置为 /
    3. 访问：http://localhost::8080/
</code></pre><h3 id="tomcat-run的问题"><a href="#tomcat-run的问题" class="headerlink" title="tomcat:run的问题"></a>tomcat:run的问题</h3><pre><code>1. jar冲突问题：xxxServlet cannot be cast to javax.servlet.Servlet
    1. Tomcat中自带servlet-api.jar和jsp-api.jar，项目中又引入了这两个jar包，所以在运行时报jar包冲突异常;
    2. &lt;scope&gt;provided&lt;/scope&gt;：设置jar包的作用范围，provided 表示只在编译期和测试时有效，解决运行时冲突;
2. 对于测试jar包junit的&lt;scope&gt;设置：&lt;scope&gt;test&lt;/scope&gt;，表示只在测试时有效；
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.11&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
3. &lt;scope&gt;
    1. &lt;scope&gt;compile&lt;/scope&gt;：默认值，在编译、测试、运行三个时期都起作用；
    2. &lt;scope&gt;runtime&lt;/scope&gt;：只在测试期和运行时有效，常见于JDBC驱动的依赖；
    3. &lt;scope&gt;system&lt;/scope&gt;：只在编译期和测试时有效。
4. Tomcat版本与JDK版本不匹配问题：Unable to compile class for JSP
    1. tomcat:run 运行项目时，Maven默认使用的是Tomcat6，它与JDK8配合时无法转化JSP
    2. 在 pom.xml 中配置tomcat7的插件
        &lt;build&gt;
            ......
            &lt;pluginManagement&gt;
                &lt;plugins&gt;
                    ......
                    &lt;plugin&gt;
                        &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;
                        &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;
                        &lt;version&gt;2.2&lt;/version&gt;
                    &lt;/plugin&gt;
                &lt;/plugins&gt;
            &lt;/pluginManagement&gt;
        &lt;/build&gt;
    3. 使用Tomcat7运行web项目：tomcat7:run
5. Tomcat的默认端口号都是8080，可以修改Tomcat7的端口号，可以同时启动tomcat6和tomcat7;
    &lt;plugin&gt;
        &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;
        &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.2&lt;/version&gt;
        &lt;configuration&gt;
            &lt;port&gt;8888&lt;/port&gt;
        &lt;/configuration&gt;
    &lt;/plugin&gt;
</code></pre><h3 id="配置JDK版本"><a href="#配置JDK版本" class="headerlink" title="配置JDK版本"></a>配置JDK版本</h3><pre><code>1. 插件的方式
    &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
            &lt;target&gt;1.8&lt;/target&gt;  ===&gt;使用JDK1.8编译
            &lt;source&gt;1.8&lt;/source&gt;  ===&gt;编译后的class文件也使用JDK1.8
            &lt;encoding&gt;UTF-8&lt;/encoding&gt;  ==&gt;编码
        &lt;/configuration&gt;
    &lt;/plugin&gt;
2. 常用方式
    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;
</code></pre><h2 id="jar包冲突"><a href="#jar包冲突" class="headerlink" title="jar包冲突"></a>jar包冲突</h2><pre><code>1. 依赖树：打开右侧Maven面板 --&gt; 点击提示Show Dependencies的图标，可以查看当前项目的依赖树结构;
2. 解决方式一：第一声明优先原则
    1. 哪个jar包的坐标配置靠前，那么这个jar包就优先声明;
    2. 优先声明的jar包坐标及其依赖包，也会优先进入项目中;
3. 解决方式二：路径近者优先原则
    1. 直接依赖：项目中显式引入的jar包坐标;
    2. 传递依赖：项目中没有显式配置的jar包，但通过直接依赖的jar包传递到项目中;
    3. 比如，项目中依次引入了 AA(4.2.4)、BB(5.1.6) 两个依赖包，它们又都依赖于CC，所以项目中又会自动引入CC，
    但因为 AA 在前，BB 在后，由第一声明优先原则可知，项目中引入的 CC 版本为4.2.4;
    4. 但如果显式引入了 CC(4.8.0)，那么不管它处于哪个位置，都会优先引入，因为直接依赖比传递依赖的路径更近;
4. 解决方式三：直接排除法(推荐方式)
    1. &lt;exclusions&gt; 标签实现依赖包的排除;
    2. AA(4.2.4) 配置在 BB(5.1.6) 的前面，但又希望使用 CC(5.1.6)，那么就排除 AA 中的 CC(4.2.4);
        &lt;dependency&gt;
            &lt;groupId&gt;aa.xxx&lt;/groupId&gt;
            &lt;artifactId&gt;AA&lt;/artifactId&gt;
            &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;cc.xxx&lt;/groupId&gt;
                    &lt;artifactId&gt;CC&lt;/artifactId&gt;
                    &lt;!-- 不必再声明版本号，默认就是使用上层节点的版本号 --&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/01/07/Java数据库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/07/Java数据库/" itemprop="url">Java数据库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-07T00:00:00+08:00">
                2016-01-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><pre><code>1. JDBC：Java Database Connection，为Java使用数据库提供了统一的编程接口；
2. JDBC由一组Java类和接口组成，是Java程序与数据库系统通信的标准API；
3. 所谓数据库驱动就是数据库厂商对JDBC接口的实现；
4. ORM框架：Hibernate、mybatis
</code></pre><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><pre><code>1. Driver：由数据库厂商提供，引入相关数据库驱动jar包，装载数据库驱动
    1. 装载MySql驱动
    Class.forName(&quot;com.mysql.jdbc.Driver&quot;); --&gt; MySQL5.0
    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); --&gt; MySQL6.0+
2. DriverManager：JDBC的管理层，作用于用户和驱动程序之间，在数据库和驱动程序之间建立连接
    DriverManager.registerDriver(new com.mysql.cj.jdbc.Driver()); --&gt;也能加载驱动
3. Connection：与特定数据库的连接会话，执行SQL语句并返回结果
    1. 连接MySQL5.0数据库
    Connection conn = DriverManager.getConnection(
        &quot;jdbc:mysql://host:port/database&quot;, &quot;username&quot;, &quot;password&quot;);
    2. 连接MySQL6.0+数据库，需要指定时区serverTimezone
    jdbc:mysql://host:port/database?serverTimezone=Asia/Shanghai
    3. 如果host和port都是默认值，可以省略：jdbc:mysql:///database?...
    4. 连接的建立是比较耗时的，内部包含Socket，实际上是建立一个Socket远程连接;
    5. 关闭连接：conn.close();
4. Statement：执行静态SQL语句并返回结果的对象
    1. Statement用于发送简单的SQL语句(不带参数)，执行SQL时需要拼接参数，有SQL注入的危险
    Statement stat = conn.createStatement();
    2. PreparedStatement：继承Statement，用于发送含有任意多个参数的SQL语句，会预编译，
    所以效率比Statement高，且防SQL注入；
    String sql = &quot;insert into users(name, time) values(?, ?)&quot;; --&gt; ? 表示占位符
    PreparedStatement stat = conn.prepareStatement(sql);
    stat.setString(1, &quot;Mack&quot;);  --&gt; 设置字符串类型的占位符，占位符索引从1开始
    stat.setDate(2, new java.sql.Date(System.currentTimeMillis())); -&gt;设置日期时间
    stat.execute();  --&gt; 执行SQL语句
    3. 如果不想关心字段类型，则使用 setObject()
    4. CallableStatement：继承自PreparedStatement，由 conn.prepareCall(sql) 创建，
    用于调用存储过程。
5. 常用方法
    1. execute()：运行语句，返回是否有结果集(true/false)
    2. executeQuery()：运行select语句，返回 ResultSet 结果集
    3. executeUpdate()：运行insert/update/delete操作，返回更新的行数
    4. close(); 关闭
6. ResultSet
    String sql = &quot;select * from users where id&gt;?&quot;;
    PreparedStatement stat = conn.prepareStatement(sql);
    stat.setInt(1, 10);
    ResultSet rs = stat.executeQuery();
    while (rs.next()) {
        int id = rs.getInt(1); --&gt; 获取第一列的数据，且字段类型为int
        String name = rs.getString(2); --&gt; 获取第二列的数据，且字段类型为String
    }
    rs.close();  stat.close(); --&gt;关闭
    1. 如果不想关心数据类型，则使用 getObject()
    2. rs.next()：迭代下一行数据，如果没有了，则返回false
7. 时间相关
    1. java.sql.Date(年月日)
    2. java.sql.Time(时分秒)
    3. java.sql.Timestamp(年月日时分秒)
8. Properties
    1. 读取和处理配置资源文件中的信息，如数据库url、database、username、password等信息
    2. 如db.properties文件，用于存储数据的配置信息：
    driver=com.mysql.cj.jdbc.Driver
    url=jdbc:mysql://localhost:3306/db_test?serverTimezone=Asia/Shanghai
    user=root
    password=123456
    3. 加载db.properties文件
    static Properties pros = null;
    static {
        pros = new Properties();
        pros.load(Thread.currentThread().getContextClassLoader()
        .getResourceAsStream(&quot;db.properties&quot;));
    }
    4. 使用db.properties中的配置信息
    Class.forName(pros.getProperty(&quot;driver&quot;));
</code></pre><h3 id="批量处理"><a href="#批量处理" class="headerlink" title="批量处理"></a>批量处理</h3><pre><code>1. PreparedStatement的预编译空间有限，数据量特别大时会发生异常，所以建议使用Statement
2. JDBC中的事务默认是自动提交，还需要设置为手动提交
    conn.setAutoCommit(false); --&gt; 禁止自动提交
    Statement stat = conn.createStatement();
    for(int i=0; i&lt;20000; i++) {
        stat.addBatch(&quot;insert into ...&quot;); --&gt;一次性插入20000条数据
    }
    stat.executeBatch();
    conn.commit(); //手动提交事务
</code></pre><h3 id="大数据量处理"><a href="#大数据量处理" class="headerlink" title="大数据量处理"></a>大数据量处理</h3><pre><code>1. CLOB：Character Large Object，用于存储大文本数据
    1. 不同数据库对大文本(大字段)有不同的处理方式，通常以流的方式处理；
    2. MySQL中的相关类型及其最大长度(字符)：TINYTEXT(2^8-1)，TEXT(2^16-1)，
    MEDIUMTEXT(2^24-1)，LONGTEXT(2^32-1或4GB)
2. JDBC操作大文本
    1. 存储
    PreparedStatement stat = conn.prepareStatement(sql);
    stat.setClob(3, new FileReader(&quot;d:/a.txt&quot;)); //接受一个流对象
    2. 读取
    ResultSet rs = ...
    while (rs.next()) {
        Clob c = rs.getClob(&quot;desc&quot;); --&gt; 指定字段名获取值
        Reader r = c.getCharacterStream(); --&gt; 获取大文本流
    }
3. BLOB：Byte Large Object，用于存储大二进制数据
    1. 不同数据库对大二进制数据(大字段)有不同的处理方式，通常以流的方式处理；
    2. MySQL中的相关类型及其最大长度(字符)：TINYBLOB(2^8-1)，BLOB(2^16-1)
    MEDIUMBLOB(2^24-1)，LONGBLOB(2^32-1或4GB)
4. JDBC操作大二进制数据
    1. 存储
    PreparedStatement stat = conn.prepareStatement(sql);
    stat.setBlob(3, new FileInputStream(&quot;d:/b.jpg&quot;)); //接受一个流对象
    2. 读取
    ResultSet rs = ...
    while (rs.next()) {
        Blob b = rs.getBlob(&quot;avatar&quot;); --&gt; 指定字段名获取值
        InputStream is = b.getBinaryStream(); --&gt;获取大二进制流
    }
</code></pre><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><pre><code>1. 事务：一组要么同时执行成功，要么同时执行失败的SQL语句，是数据库操作的一个执行单元；
2. 事务开始于：
    1. 连接数据库，并执行一条DML语句(INSERT、UPDATE、DELETE)
    2. 前一个事务结束后，又输入另一条DML语句
3. 事务结束于：
    1. 执行COMMIT或ROLLBACK语句；
    2. 执行一条DDL语句，如CREATE TABLE，这种情况会自动执行COMMIT语句；
    3. 执行一条DCL语句，如GRANT，这种情况也会自动执行COMMIT语句；
    4. 断开与数据库的连接；
    5. 执行一条DML语句，但却失败了，这种情况会执行ROLLBACK语句。
4. 四大特性：
    1. 原子性：一个事务内的所有操作是一个整体，要么全部成功，要么全部失败；
    2. 一致性：一个事务内有一个操作失败时，所有更改过的数据都必须回滚到初始状态；
    3. 隔离性：查看数据状态时，要么是另一个事务修改之前的状态，要么是修改之后的状态，不会
    出现中间状态的数据，级别：读取未提交&lt;读取已提交&lt;可重复读&lt;序列化，通常是读取已提交；
    4. 持久性：对于系统的影响是永久性的；
    conn.setAutoCommit(false); --&gt; 禁止事务自动提交
    conn.commit(); --&gt; 手动提交事务
    conn.rollback(); --&gt; 提交失败后(发生异常)，执行数据回滚
</code></pre><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><pre><code>1. Redis是内存级数据库，当Redis服务器重启，数据可能会丢失，实现持久化则需要保存在硬盘中;
2. Redis持久化机制：ROB、AOF
3. ROB：默认方式，无需配置，对内存IO性能影响较小；
    1. 在一定的时间间隔内，检测key的变化情况，然后持久化数据；
    2. 在Redis的配置文件中，默认持久化的时间间隔;
    save 900 1   ---&gt; 15分钟后，至少有1个key发生变化，则持久化一次
    save 300 10  ---&gt; 5分钟后，至少有10个key发生变化，则持久化一次
    save 60 10000  --&gt; 60秒后，至少有10000个key发生变化，则持久化一次
    3. 修改配置文件的时间间隔，手动设置持久化的频率;
    save 10 5  --&gt; 10秒后，有5个key发生了变化，就持久化一次
    4. 持久化频率的配置取决于Redis服务器的性能和具体的业务需求。
4. AOF：日志纪录方式
    1. 会纪录每一条命令的操作，且每一次命令操作后，持久化数据；
    2. 在配置文件中，默认关闭AOF机制：appendonly no
    3. 开启：appendonly yes，配置AOF持久化的频率，三选一
    # appendfsync always  ---&gt; 每次操作都进行数据持久化
    # appendfsync everysec  --&gt; 每隔1秒进行一次持久化
    # appendfsync no  --&gt; 不执行持久化
5. Redis虽然提供了数据持久化机制，但并不能保证数据一定是安全的，还需要配置关系型数据库。
</code></pre><h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h3><pre><code>1. Jedis：Java操作Redis数据库的工具，导入相关jar包；
2. 建立连接，
    Jedis jedis = new Jedis(&quot;IP&quot;, port);  --&gt; 默认IP：localhost，默认port：6379
    1. 操作字符串数据
    jedis.set(&quot;username&quot;, &quot;Mack&quot;);
    String uname = jedis.get(&quot;username&quot;);
    2. 关闭连接：jedis.close();
    3. 指定过期时间，如20s后过期删除
    jedis.setex(&quot;username&quot;, 20, &quot;Mack&quot;);
3. 哈希类型的数据：key-Map格式
    jedis.hset(&quot;user&quot;, &quot;name&quot;, &quot;Mack&quot;);
    jedis.hset(&quot;user&quot;, &quot;age&quot;, &quot;20&quot;);
    1. 参数1表示一条数据的键，参数2和参数3是这条数据的值，Map类型
    2. 获取单条数据的Map
    Map&lt;String, String&gt; user = jedis.hgetAll(&quot;key&quot;);
    3. 获取单条数据中的Map，同时根据Map的键获取值
    String name = jedis.hget(&quot;user&quot;, &quot;name&quot;);
4. 列表类型的数据：key-LinkedList格式，类似于管道，有序，支持重复数据
    jedis.lpush(&quot;mylist&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;); --&gt;从左边存一组数据，顺序为 c b a
    jedis.rpush(&quot;mylist&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;); --&gt;从右边存一组数据，顺序为 a b c
    1. 参数1表示这条数据的键，其后的参数都是列表中的值；
    2. 从左边开始取数据：
    List&lt;String&gt; mylist = jedis.lrange(&quot;mylist&quot;, 0, -1);
    3. 参数1表示一条数据的键，参数2和参数3分别表示起始角标，-1表示取到最后一个；
    [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
    4. 弹出元素，相当于从Redis中删除
    String leftEle = jedis.lpop(&quot;mylist&quot;);  --&gt; 从左边弹出一个元素，&quot;c&quot;
    String rightEle = jedis.rpop(&quot;mylist&quot;); --&gt; 从右边弹出一个元素，&quot;c&quot;
5. 集合类型的数据：key-Set格式，无序，不支持重复元素
    jedis.sadd(&quot;myset&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
    Set&lt;String&gt; myset = jedis.smembers(&quot;myset&quot;);
6. 有序集合的数据：key-sortedset格式，不允许重复元素，元素可以排序
    jedis.zadd(&quot;myzset&quot;, 10, &quot;aa&quot;);
    jedis.zadd(&quot;myzset&quot;, 2, &quot;bb&quot;);
    jedis.zadd(&quot;myzset&quot;, 30, &quot;cc&quot;);
    1. 参数1表示一条数据的键，参数2表示排序的依据，数值越小，顺序越靠前，参数3是元素值;
    2. 获取一条数据
    Set&lt;String&gt; myzset = jedis.zrange(&quot;myzset&quot;, 0, -1);  --&gt;[&quot;bb&quot;, &quot;aa&quot;, &quot;cc&quot;]
</code></pre><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><pre><code>1. Jedis自带连接池：JedisPool
    JedisPool pool = new JedisPool(); --&gt; 默认ip：localhost，默认port：6397
    Jedis jedis = pool.getResource(); --&gt; 获取Jedis对象
2. 连接池的配置对象JedisPoolConfig
    JedisPoolConfig config = new JedisPoolConfig();
    config.setMaxTotal(50);  --&gt; 最大连接数50个
    config.setMaxIdle(10);  --&gt; 最大空闲连接10个
    JedisPool pool = new JedisPool(config, ...);
3. 通过properties文件，配置数据库信息
    1. 在src目录下创建 jedis.properties
        host=127.0.0.1
        port=6379
        maxTotal=50
        maxIdle=10
    2. 在工具类JedisPoolUtil.java中加载配置文件
    static {
        InputStream is = JedisPoolUtil.class.getClassLoader()
            .getResourceAsStream(&quot;jedis.properties&quot;);
        Properties prop = new Properties();
        prop.load(is);
        JedisPoolConfig config = new JedisPoolConfig();
        int total = Integer.parseInt(prop.getProperty(&quot;maxTotal&quot;));
        config.setMaxTotal(total);
        int idle = Integer.parseInt(prop.getProperty(&quot;maxIdle&quot;));
        config.setMaxIdle(idle);
    }
</code></pre><h3 id="缓存优化"><a href="#缓存优化" class="headerlink" title="缓存优化"></a>缓存优化</h3><pre><code>1. 第一次从Redis查询数据时，如果不存在，则去MySQL中查询，并把查询结果存入Redis
2. 第二次从Redis查询数据时，Redis中已经存在了，不需要再去MySQL中查询了；
3. Redis只适合缓存一些不经常变化的数据；
4. MySQL中的数据一旦发生了变化，在其增删改的方法中，及时更新Reids中的缓存数据。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">大麦田怪圈</p>
              <p class="site-description motion-element" itemprop="description">敢做就能赢！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">64</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大麦田怪圈</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
