<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="敢做就能赢！">
<meta property="og:type" content="website">
<meta property="og:title" content="大麦田程序猿">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="大麦田程序猿">
<meta property="og:description" content="敢做就能赢！">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="大麦田程序猿">
<meta name="twitter:description" content="敢做就能赢！">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/6/">





  <title>大麦田程序猿</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大麦田程序猿</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/25/linux命令入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/25/linux命令入门/" itemprop="url">linux命令入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-25T00:00:00+08:00">
                2017-07-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Linux-的目录结构"><a href="#Linux-的目录结构" class="headerlink" title="Linux 的目录结构"></a>Linux 的目录结构</h2><pre><code>不同于windows，Linux没有分盘，只有一个根目录 /：
</code></pre><p><img src="http://i.imgur.com/eNoIkyr.jpg" alt></p>
<pre><code>/bin：和程序相关；  /boot：和系统启动相关；  /cdrom：和光盘相关；  /dev：和设备相关；
/etc：程序和服务器配置相关；  /lib：存放库；  /home：存放家目录，即打开终端默认所在路径；
</code></pre><h2 id="linux常用命令"><a href="#linux常用命令" class="headerlink" title="linux常用命令"></a>linux常用命令</h2><pre><code>pwd：查看当前所在路径；
ls：列出当前目录下的文件和文件夹； ls /：列出根目录下的文件和文件夹；  
ls的常用参数：
    1. ls -a：显示隐藏文件及目录；
    2. ls -l：以列表形式显示详细信息；
    3. ls -lh：显示文件及目录的大小时，转换为合适的单位； 
touch 文件名：创建文件；
mkdir 目录名：创建文件夹；  mkdir a/b/c -p：如果c之前有不存在的目录，则创建；
tree：显示当前目录的内容结构；
rmdir：删除空目录；
rm：删除文件；  rm -r：可以删除非空的目录，-r，递归；  -f，强制删除；
命令名 --help：查询命令的文档；
man 命令名：分屏的方式查询命令，会进入一个新的界面显示查询结果，每次只显示一屏，支持上下键
    翻动，f:向下翻一屏，b：向上翻一屏，q：退出；
Tab：自动补全；
cat 文件名：查看文件的内容；    cat a.txt b.txt：同时查看文件a和b。
more 文件名：分屏的方式查看文件内容；
ls -alh /bin | more：以分屏的方式显示根目录下bin文件夹的内容；    |：管道，ls输出的内容
    先存入管道，more再从管道中取出，以分屏的方式显示；
history：查看输入过的命令；  !行号：执行行号对应的命令；
&gt;、&gt;&gt;：重定向
    ls &gt; a.txt，将ls命令显示的内容写入a.txt中，会先清空文件的内容；
    ls &gt;&gt; a.txt，追加内容，不会清空文件原内容；如果文件不存在，则会先创建文件；
    cat a.txt b.txt &gt; c.txt：合并文件a和文件b。
cd ./a：.代表当前目录，等效于 cd a；
cd ..：回到上一层目录；  cd ../..：回到上一层目录的上一层目录；
cd -：回到上一次所在的目录，不一定是上一层目录；
cd ~：回到家目录；
软连接、硬链接
    ln -s 文件名 自定义的软连接文件名：创建一个软连接，相当于快捷方式，如果删除了原文件，
        软连接文件无效；
    ln 文件名 自定义的硬链接文件名：创建一个硬链接，相当于为文件创建一个别名，删除原文件，
        硬链接仍有效；
    创建一个文件时，文件内容和文件名是分开存储的，文件名其实就是一个硬链接，当一个文件的硬
    链接数为 0 时，系统就会删除文件内容。
</code></pre><p><img src="http://i.imgur.com/2UC6GMc.jpg" alt></p>
<pre><code>mv：重命名、移动；如果目录不允许移动，则加 -r；
cp：复制并粘贴；如果目录不允许操作，则加 -r；
文本搜索：grep
    grep &quot;内容&quot; 文件名：-n，显示匹配的内容在文件中对应的行号；    -v，求反，搜索内容之外
        的其他内容；    -i，忽略大小写；
    grep &quot;^abc&quot; 文件名：以abc开头的内容；
    grep &quot;abc$&quot; 文件名：以abc结尾的内容。
搜索文件：find
</code></pre><p><img src="http://i.imgur.com/Hugd8Vp.jpg" alt></p>
<pre><code>    find ./ -name &quot;*name*&quot;：查找文件名中包含&quot;name&quot;的文件；
执行命令时，如果没有权限，可以在命令的开头使用 sudo；
归档管理：tar
    1. tar命令很特殊，其参数前可以不使用 &quot;-&quot;；
    2. tar -cvf abc.tar *.py：将所有.py后缀的文件打包成abc.tar；  
       tar -xvf abc.tar：解压缩；
    3. tar -zcvf abc.tar.gz *.py：压缩并打包成abc.tar.gz，占用空间比abc.tar小很多；  
       tar -zxvf abc.tar：解压缩；
       tar -zxvf abc.tar.gz -C workspace：解压到指定目录；
    4. tar -jcvf abc.tar.bz2 *.py：压缩并打包，占用空间比gz稍微大一点；  
       tar -jxvf abc.tar.bz2：解压缩；
    5. zip ab.zip *.py：打包成ab.zip，占用空间较大；
       unzip ab.zip：解压缩
       unzip -d ./test ab.zip：解压到指定目录。
    6. 常用 gz，bz2
which 命令名：查看命令所在目录；
cal：查看日历；
date：查看当前时间，自定义格式：date &quot;+%Y年%m月%d日&quot;；
查看进程信息
    ps -aux：查看所有进程的详细信息（windows的任务管理器）
    top、htop：在一个独立的界面显示进程的信息，q：退出。
kill PID：杀死指定PID的进程，kill -9 PID：强制杀死；
关机重启
    reboot：重启系统，等效于 init 6；
    shutdown -r now：重启系统，会提示给别的用户；
    shutdown -h now：立即关机，等效于 init 0；
    shutdown -h 20:25：定时今天20:25关机；
    shutdown -h +10：10分钟后关机；
df -h：查看当前内存的使用情况；
du -h：查看当前路径下的目录和文件的占用空间大小；
ifconfig -a：查看所有网卡的信息，主要用于查看IP地址信息；
    sudo ifconfig 网卡名(ens33) 新IP：修改指定网卡的IP；
    sudo dhclient：重新动态获取Ip；
ping IP地址：检测是否能与某个IP通信（连通性）；
对于虚拟机上的ubuntu系统，其网卡Ip必须和本机Ip设置在同一个网段，才能实现通信。
用户相关
    linux是多用户多任务的操作系统；
    useradd 用户名 -m：添加一个新的用户，在/etc/passwd文件中可以查看，在/home中会同时
        创建该账户的家目录；
    passwd 用户名：设置（修改）账户密码，新创建的账户默认没有密码；
    userdel -r 用户名：删除用户，并删除home下的家目录；
    whoami：查看当前用户；
    exit：退出当前用户；
    ssh 用户名@IP：远程登陆另一台电脑；
    who：查看登陆当前用户的电脑，显示IP的表示远程登陆的用户，没有IP的表示当前的终端登录；
    su 账户名：切换用户，需要输入该账户的密码；但是，并不会切换当前目录；
        su - 账户名：切换用户，并切换到该账户的家目录；
        su、 su root：切换到超级管理员root；
        su - 、 su - root：切换到root，同时切换到/root目录；
    sudo -s：切换到root权限，并不通用，只在ubuntu的Linux中；
    但是，普通用户会切换root失败，并且会报告给管理员。
用户组
    groupadd 组名：创建一个用户组，在/etc/group文件中可以查看；
    groupdel 组名：删除一个组；
    groupmod +多个Tab：查看当前所有用户组
    为创建的普通用户添加 root 权限
        能切换到 root 权限的组是 adm 和 sudo；
        普通用户不在 adm 和 sudo 组，也就不能通过 sudo -s 切换到root权限；
        cat /etc/group | grep sudo：查看在group文件中搜索出的、属于 sudo 组的用户；
        sudo usermod a -G adm 用户名：加入到 adm 组；
        sudo usermod -a -G sudo 用户名：加入到 sudo 组；
chown 用户名 文件：修改所有者；
chgrp 用户组 文件：修改用户组。
文件的权限
</code></pre><p><img src="http://i.imgur.com/MUFG2iL.jpg" alt></p>
<pre><code>r：读，w：写，x：可执行；
字母法修改文件的权限
    chmod u=rwx 文件名：修改所有者权限为可读、可写、可执行；
    chmod u=r 文件名：修改所有者权限为可读；
    chmod g=rx 文件名：修改所有组权限为可读、可执行；
    chmod o=x 文件名：修改其他人的权限为可执行；
    chmod u=w,g=r,o=x 文件名：同时修改三者的权限；
    chmod u=,g=,o= 文件名：三者都没有任何权限；
数字法修改文件的权限
    r --&gt; 4，w --&gt; 2，x --&gt; 1；
    rw --&gt; 6，rx -- &gt; 5，wx --&gt; 3，rwx --&gt; 7；
    chmod 777 文件名：三者可读、可写、可执行；
    chmod 000 文件名：三者没有任何权限。
</code></pre><h2 id="vi、vim"><a href="#vi、vim" class="headerlink" title="vi、vim"></a>vi、vim</h2><pre><code>vi、vim：进入命令模式，vim 是 vi 的升级版；
vi 文件名 +15：打开文件时，光标定位到15行；
i、I、A、a、O、o：命令模式进入编辑(插入)模式；
    编辑的位置：i，光标前； I，行首； a，光标后； A，行末； o，下一行； O，上一行；
在命令模式下，：--&gt; 进入末行模式；
Esc：退出编辑模式或末行模式；
命令模式下常用命令：
    yy：复制光标所在的行；  4yy：复制光标所在行开始向下的4行；  p：粘贴；
    dd：剪切(删除)光标所在的行；  3dd：剪切光标所在行开始向下的3行；
    D：从光标的位置开始剪切，一直到行末；  d0：从光标位置开始剪切，一直到行首；
    x：向后删除一个；  X：向前删除一个；
    h：控制光标向左；  j：向下；  k：向上；  l：向右；
    H：控制光标定位到当前屏幕的最上面一行；  M：当前屏幕的中间一行；
    L：当前屏幕的最下面一行；  G：整个文件的最后一行，  gg：整个文件的第一行，
    20G：光标定位到第20行；
    w：光标跳到下一个单词的开始处；  b：光标调到上一个单词的开始处；  dw：剪切整个单词；
    u：撤销回上一步操作；  Ctrl+r：反撤销；
    v、V：选中一片代码；v：选中光标经过的位置；  V：选中光标经过的行；
        选中之后， y：复制；  d：剪切；  &gt;：整体向右移动；  &lt;：整体向左移动；
        .：重复执行上一次的命令。
    Ctrl+d：向下翻半屏； Ctrl+u：向上翻半屏； Ctrl+f：向下翻一屏； Ctrl+b：向上翻一屏；
    {：光标向上移动到一块代码的开始；  }：向下移动到一块代码的结尾；
    r、R：替换；  r：替换光标所在的单个字符；  R：替换光标以及后面的字符；
    /：搜索；  /Hello + Enter：搜索“Hello”；
        n：光标移动到下一个搜索的内容；  N：移动到上一个；
    Shift+zz：保存并退出。
末行模式下常用的命令：
    %s/world/hello/g：将文件中的所有 “ world ” 替换为 “ Hello ”；
    %5,20s/world/hello/g：只替换5-20行的 “ world ”；
    w：保存；
    q：退出；  q!：强制退出；  wq：保存并退出；  wq!：保存并强制退出；
    x：保存并退出。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/02/Java基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/02/Java基础/" itemprop="url">Java基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-02T00:00:00+08:00">
                2017-01-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><pre><code>1. 浮点数的精确计算：BigDecimal，java.math包中的类
    1. 相减
    BigDecimal db1 = BigDecimal.valueOf(1.0);  --&gt; 浮点数1.0
    db1 = db1.subtract(BigDecimal.valueOf(0.1));  --&gt; 1.0 - 0.1
    2. 相除
    BigDecimal db2 = BigDecimal.valueOf(0.1);
    BigDecimal db3 = BigDecimal.valueOf(1.0/10.0);
    System.out.println(db2.equals(db3)); --&gt; true
2. 自动类型转换：容量小的类型自动向容量大的类型转换
    1. 特例：byte b = 123;
    2. 123 本身是 int 类型(Java中的数值默认是int类型)，byte类型的范围为-128~127
    3. 所以，123 可以直接赋值给 byte类型(自动转为byte类型)。
3. 溢出
    1. int m = 1000000000;  int y = 20;
    2. int t = m * y; --&gt; 负数(溢出导致)
    3. long t = m * (long)y; --&gt; 20000000000
4. TreeMap与TreeSet
    1. TreeMap：红黑二叉树的典型实现，按照key自增长的方向排序；
    2. TreeSet：内部维持了一个简化版的TreeMap，通过key存储Set的元素；
    3. 如果存储的是对象，此对象应实现 Comparable 接口，以便于对其进行排序。
5. 多线程之Callable
    1. Callable是一个接口，包含方法call()，接收一个泛型，默认是Object，作为call()的
    返回值类型
    public class CLoader implements Callable&lt;Boolean&gt; {  --&gt; 泛型指定为Boolean
        public Boolean call() throw Exception {
            ...... //执行任务
            return true
        }
    }
    CLoader cd1 = new CLoader(); CLoader cd2 = new CLoader();
    2. 使用线程池，创建服务
    ExecutorService es = Executors.newFixedThreadPool(2);
    3. 提交执行
    Future&lt;Boolean&gt; ft1 = es.submit(cd1);  Future&lt;Boolean&gt; ft2 = es.submit(cd2);
    4. 获取结果
    boolean re1 = ft1.get();  boolean re2 = ft2.get();
    5. 关闭服务
    es.shutdownNow();
    6. 与Thread/Runnable的 run() 相比，call()可以抛出异常，而 run() 不能抛出异常，只能
    try-catch捕获。
6. lambda表达式
    1. 针对的是只包含一个方法的接口，如Runnable
    new Thread(new Runnable(){
        public void run(){ System.out.println(&quot;start Run&quot;); }
    }).start();
    new Thread(()-&gt; {
        System.out.println(&quot;start Run&quot;);
    }).start();
7. 静态代理
    1. 代理对象和原对象都实现同一个接口
    interface Task {  void work();  }
    2. 原对象
    class Stuff implements Sask {
        public void work() { }
    }
    3. 静态代理对象
    class StaticProxy implements Task {
        private Task target;
        public StaticProxy(Task target) {
            this.target = target;
        }
        public void work() {
            this.start();
            this.target.work();
            this.end();
        }
        private void start(){ }
        private void end(){ }
    }
    4. 通过代理对象，执行原对象的任务方法
    new StaticProxy(new Stuff()).work();
</code></pre><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><pre><code>1. 线程状态
</code></pre><p><img src="https://i.imgur.com/vLw2xgt.jpg" alt></p>
<pre><code>    1. Thread.State：线程的状态，NEW(尚未启动的线程)、RUNNABLE、BLOCKED、WAITING、
    TIMED_WAITING、TERMINATED(已退出的线程)
    2. RUNNABLE：包含就绪状态和运行状态；
    3. getState()：获取线程的状态。
2. 线程的 stop() 方法已经被废弃，因为线程的终止可以通过一个boolean型的标志位变量完成；
3. sleep() yield() join()
    1. sleep() 表示休眠，会阻塞线程，且不会释放锁，睡眠时间到了之后，重新进入就绪状态；
    常用于模拟网络延迟、倒计时...
    2. yield() 则礼让出CPU的执行权，线程进入就绪状态；
    3. join() 插队，待此线程执行完成后，再执行其他线程，这段时间内，其他线程处于阻塞状态；
4. 优先级：线程的优先级并不能决定哪个线程先执行，优先级高的线程被执行的概率相对会高一些；
    1. setPriority(priority)：设置线程的优先级，范围1-10，在 start() 之前设置有效；
    2. Thread.MIN_PRIORITY，Thread.MAX_PRIORITY，Thread.NORM_PRIORITY：1，10，5
5. 线程分为用户线程和守护线程，默认的线程都是用户线程
    1. 虚拟机JVM会确保所有的用户线程执行完毕，再退出程序，但不会等待守护线程执行完毕；
    2. 如后台记录操作日志、监控内存使用等
    3. setDaemon(true)：把线程设置为守护线程，在 start() 之前调用。
6. Thread.currentThread()：获取当前线程；
7. isAlive()：线程是否还活着。
</code></pre><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><pre><code>1. 线程同步：synchronized，队列
    1. 若将一个大的方法声明为synchronized，将会大大影响效率；
    2. 与大的synchronized方法相比，synchronized块能在一定程度上减少性能的损失；
    3. 使用 synchronized 的关键在于，第一要锁对目标，第二要取舍synchronized块的面积。
2. 同步块的锁：
    1. 同步方法的锁是this，表示当前对象，不可改变；
    2. 同步块的锁可以指定，锁住的目标更明确，还能减小锁的面积。
3. 并发容器：CopyOnWriteArrayList，加锁的ArrayList，保证在写入数据时的安全；
4. 死锁：相互持有对方的锁，需要避免锁的嵌套。
</code></pre><h3 id="并发协作"><a href="#并发协作" class="headerlink" title="并发协作"></a>并发协作</h3><pre><code>1. 生产者与消费者模式：线程同步问题，生产者和消费者共享同一资源，且生产者和消费者相互依赖；
    1. synchronized只是阻止并发更新同一共享资源，实现同步，但并不能实现线程间的通信；
    2. 管程法：利用并发缓冲容器实现；
    3. 信号灯法：借助标志位实现。
2. 管程法：wait()，notify()，notifyAll()
3. 信号灯法：
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/01/多线程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/01/01/多线程/" itemprop="url">多线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-01T00:00:00+08:00">
                2017-01-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="并发-与-并行"><a href="#并发-与-并行" class="headerlink" title="并发 与 并行"></a>并发 与 并行</h2><ul>
<li>并发：指两个任务都请求，而处理器只能接受一个任务，只能安排轮流进行，由于间隔时间较短，感觉两个任务都在执行；</li>
<li>并行：需要多核CPU，任务甲进行的同时，任务乙也在进行。</li>
</ul>
<hr>
<p>Java程序的运行原理也是一个多线程，因为Java命令会启动Java虚拟机，相当于启动了一个应用程序，也即启动了一个进程。该进行会自动启动一个主线程，然后由主线程去调用某个类的 main 方法。</p>
<hr>
<p>Jvm的启动至少启动了垃圾回收线程和主线程，所以也是多线程。</p>
<hr>
<h2 id="实现多线程"><a href="#实现多线程" class="headerlink" title="实现多线程"></a>实现多线程</h2><ul>
<li>继承Thread，重写 run 方法；启动线程：new Thread().start()；</li>
<li>实现Runnable接口，重写 run 方法;启动线程：new Thread(Runnable).start();</li>
<li>start()：启动线程，JVM调用该线程的 run 方法；但是，多次启动一个线程是非法的，特别是线程结束之后，不能再重新启动。<h3 id="Runnable-的原理"><a href="#Runnable-的原理" class="headerlink" title="Runnable 的原理"></a>Runnable 的原理</h3></li>
<li>Thread 的构造函数接收 Runnable 接口的引用target；</li>
<li>init() 方法中，Thread 的成员变量 target 接收传递的 target；</li>
<li>start() 调用的 run() 方法中，判断 target != null，则执行 target.run()，即执行 Runnable 的 run() 方法。<h3 id="两种实现多线程的区别"><a href="#两种实现多线程的区别" class="headerlink" title="两种实现多线程的区别"></a>两种实现多线程的区别</h3></li>
<li>继承Thread：因为重写了 run() 方法，当调用 start() 时，直接调用子类的 run() 方法。优点：可以直接使用 Thead 类中的方法，代码简单；弊端：因为Java是单继承，如果有了父类，就不能再继承Thead;</li>
<li>实现Runnable接口：见 Runnable 的实现原理。优点：接口可以多实现，即使有了父类也没关系；弊端：不能直接使用Thread中的方法，需要获取Thread对象，代码复杂。<h2 id="多线程的一些方法"><a href="#多线程的一些方法" class="headerlink" title="多线程的一些方法"></a>多线程的一些方法</h2></li>
<li><strong>getName()</strong>，获取线程名称，主线程的名称为 main；<strong>setName()，Thread(name)</strong>：设置线程名称；</li>
<li><strong>Thread.currentThread()</strong>：获取当前线程对象的引用；</li>
<li><strong>Thread.sleep(</strong>毫秒<strong>)</strong>：控制当前线程休眠；</li>
<li>setDaemon(true)：设置为守护线程，该线程不会单独执行，当其他非守护线程都执行结束后，自动退出；但是，有些情况还会有时间缓冲，即非守护线程退出时通知守护线程退出的一段时间；比如，QQ在传文件时，传输文件的窗口就是守护线程，QQ主界面就是非守护线程，关闭QQ主界面时，传输窗口并不会立刻退出，而且继续发送若干可数据包，因为传输窗口的线程需要等待退出的命令。</li>
<li><strong>join()</strong>：插队线程。当前线程暂停，等待join的线程执行结束后，当前线程再继续。<br><img src="http://i.imgur.com/5f6fVvM.jpg" alt><br>join(毫秒)：参数表示该线程插队执行的时间。</li>
<li><strong>Thread.jield()</strong>：礼让线程。当前线程让出CPU的执行权，但效果并不明显。</li>
<li><strong>setPriority(1-10)</strong>：设置线程的优先级。最小优先级 Thread.MIN_PRIORITY = 1；默认优先级 Thread.NORM_PRIORITY = 5；最大优先级 Thread.MAX_PRIORITY = 10。<h2 id="多线程的同步"><a href="#多线程的同步" class="headerlink" title="多线程的同步"></a>多线程的同步</h2></li>
<li>当多线程并发，有多段代码同时执行时，希望某一段代码执行的过程中，CPU不要切换到其他线程，此时就需要同步；</li>
<li>如果两段代码是同步的，那么同一时间只能执行一段代码。<h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3></li>
<li>使用 synchronized 关键字和一个锁对象；</li>
<li>多个同步代码块使用同一个锁对象，那么它们就是同步的；所以，锁对象不能用匿名对象，因为匿名对象不是同一个对象。<h3 id="同步代码方法"><a href="#同步代码方法" class="headerlink" title="同步代码方法"></a>同步代码方法</h3></li>
<li>使用 synchronized 关键字修饰的方法；该方法中所有的代码都是同步的。</li>
<li>非静态的同步方法的锁对象是 this，等同于同步代码块 synchronized(this) {…}</li>
<li>静态是优先于对象存在的，静态是随类的加载而加载的，类加载时存在的对象是字节码对象，所以，静态的同步方法的锁对象是字节码对象，等同于 synchronized(类名.class) {…}<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2></li>
<li>多线程并发操作同一数据时，可能出现线程安全问题；</li>
<li>使用同步技术，把操作数据的代码进行同步，可以避免线程安全问题；</li>
<li>使用同步技术时，必须保证锁对象是唯一的，比如 类名.class，静态成员变量对象的引用。<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2></li>
<li>同步代码嵌套，且使用相同的锁，可能出现死锁；<br><img src="http://i.imgur.com/j1zTdIa.jpg" alt></li>
<li>为了避免死锁，尽量不要嵌套同步代码。</li>
</ul>
<hr>
<h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><ul>
<li>保证类在内存中只有一个对象<ul>
<li>控制类的创建，不让其他类创建本类对象，即private私有化构造方法；</li>
<li></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">大麦田怪圈</p>
              <p class="site-description motion-element" itemprop="description">敢做就能赢！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">53</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大麦田怪圈</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
