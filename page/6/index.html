<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="敢做就能赢！">
<meta property="og:type" content="website">
<meta property="og:title" content="大麦田程序猿">
<meta property="og:url" content="http://hellomyshadow.github.io/page/6/index.html">
<meta property="og:site_name" content="大麦田程序猿">
<meta property="og:description" content="敢做就能赢！">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="大麦田程序猿">
<meta name="twitter:description" content="敢做就能赢！">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hellomyshadow.github.io/page/6/">





  <title>大麦田程序猿</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大麦田程序猿</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2017/07/26/python基础1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/26/python基础1/" itemprop="url">python基础1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-26T00:00:00+08:00">
                2017-07-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><pre><code>1. py为扩展名的文件编写python代码；
2. python/python3：分别进入python2与python3环境的交互模式，测试python的语法；
3. ipython、ipython3：进入交互模式，不仅支持python语法，而且支持Linux命令。
4. 注释
    1. #... ：单行注释，Python解释器会忽略单行注释的内容；
    2. &apos;&apos;&apos; ... &apos;&apos;&apos; / &quot;&quot;&quot; ... &quot;&quot;&quot; ：（三个单引号/双引号）多行注释；
    3. 多行注释其实是一种特殊的字符串，Python解释器会加载到内存中，如果多行注释
    的内容特别大，可能会造成内存崩溃。
5. python2的中文报错，在文件第一行声明：#coding=utf-8 或 #-*- coding:utf-8 -*-
6. 字符编码
    1. python3的字符串使用Unicode，直接支持多语言；
    2. b&apos;ABC&apos;与&apos;ABC&apos;：前者是bytes类型，每个字符占1个字节，用于网络传输/保存在磁盘；
    后者是一个Unicode编码的字符串；
    3. python源代码包含中文时，必须指定保存为UTF-8编码，为了让python解释器按UTF-8
    读取源代码，通常在文件开头指定：
    1. #!/usr/bin/env python3 ==&gt; 告诉Linux/OS X系统，这是一个python可执行程序；
    2. # -*- coding: utf-8 -*- ==&gt; 以utf-8保存/读取。
</code></pre><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><pre><code>Python是动态语言，定义变量不需要声明类型；但是，Python仍然区分数据类型。
</code></pre><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code>输入语句：raw_input()、input()
1. input()
    name = input(&quot;请输入名字：&quot;)，在python3中，返回输入的内容，赋值给name；
    而在python2中执行，只是作为一个语句执行；
2. raw_input()：python2中的输入函数，python3没有，其功能与python3中input()相同；
3. 输入函数的返回值都是字符串类型；
4. python2中的input()
    1. 输入 “ 1+2 ”，相当于 name = 1+2；
    2. 输入 “ abc ”，相当于 name = abc，abc 被当作变量，但是又没有定义该变量，
    所以会报no defined；
    3. 输入 lambda 表达式，相当于定义函数，name指向 lambda 表达式的函数体。
</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>输出语句：print()
1. %d：整数，age = 20，print(&quot;年龄：%d&quot; % age) ==&gt; 年龄：20；
2. %s：字符串，如果不清楚输出的数据类型，%s永远有效；
3. %f：浮点数，height = 1.75，print(&quot;身高：%0.2f&quot;%height)
    0.2：0表示1.75前面没有占位符，2表示小数点后保留2位，Python默认保留6位。
4. 输出多个参数：print(&quot;名字：%s，年龄：%d，身高：%0.2f&quot; % (name, age, height))
</code></pre><p><img src="http://i.imgur.com/G7bMLwW.png" alt></p>
<pre><code>5. print(&quot;abcd&quot;, end=&quot;&quot;)：执行输出之后不换行；
    1. end 是print() 的缺省参数，用于控制执行输出后的操作，默认值为换行符&quot;\n&quot;；
    2. end=&quot;&quot; ： 表示执行输出后，不再执行任何操作；
    3. end=&quot;,&quot; ： 表示执行输出后，加一个逗号&quot;,&quot;。
6. print(&quot;百分比:%d%%&quot;%age)：20%
    当输出语句中有%d、%f 等定向输出时，必须使用两个% 才能输出一个%，避免影响定向输出。
6. \n：换行，字符串中包含\n，\n后面的内容会换行显示；
7. \t：制表符；
8. \r：输出时，其后面的内容会从左边顶行输出；
</code></pre><p><img src="http://i.imgur.com/Yr5Dm3j.jpg" alt></p>
<pre><code>1. &quot;abcd\r12&quot;：\r后面的&quot;12&quot;会从左边顶行输出，覆盖前面的&quot;ab&quot;；
2. end=&quot;&quot;：表示每次输出不换行；\r：因为每次输出都不换行，\r后面的内容左起顶行输出，
所以每次输出的内容只有计算的rate在变化，可用于实时显示传输数据的进度。
</code></pre><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><img src="http://i.imgur.com/dCJxhSO.png" alt></p>
<pre><code>1. type(x)：查看x的数据类型；
2. int(x)/float(x)/str(x)：将x转换为一个整数/浮点数/字符串；
3. isinstance()：类型检查，返回值是boolean型；
    isinstance(x, (int, float))：x是int/float型，则返回True
</code></pre><h3 id="特有的运算符"><a href="#特有的运算符" class="headerlink" title="特有的运算符"></a>特有的运算符</h3><pre><code>1. a//b：取商；    a%b：取余数；
2. a**b：a 的 b 次方；
3. &quot;abc&quot; *3：&quot;abcabcabc&quot;；
4. &lt;&gt;：phthon2中的运算符，等效于 !=；
5. or/and：或/与运算；    not x：非运算；
6. is 与 ==
    1. ==：判断值是否相等；
    2. is：判断两个引用指向的地址是否相同。
7. 复合赋值运算符：+=、%=、**=、//= 等；
8. a, b = 3, 4：python中特有的赋值方式
    1. 交换两个变量的值：a, b = b, a
    2. 这种方式交换两个变量的值，比使用第三方变量的方式更高效。
9. 空字符串，None，0，空列表，空字典，空元组，都表示False；其他都表示True。
</code></pre><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><pre><code>1. while 循环
    1. while - else：
    while循环结束后会执行else，如果while循环中执行了break，则不会执行else；
    2. 死循环 while 1 比 while True 更高效
    python底层是C语言编写的，C语言中并没有boolean类型，False和True其实是按照 0 和 1
    存储的，每次循环判断时，True都需要在底层转换，而 1 不会，所以 while 1 的效率更高。
2. for循环：for...in
    1. 用于遍历可迭代对象的元素，比如 name = &quot;abcdef&quot;
    2. for temp in name：每个循环的字符存入temp；
    3. for...in - else：for结束后会执行else语句，如果for中有break，则不会执行else。
3. break/continue：跳出循环/结束本次循环。
</code></pre><h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><pre><code>import random：random.randint(0, 9)：随机生成一个0~9之间的整数。
</code></pre><h2 id="字符串：str"><a href="#字符串：str" class="headerlink" title="字符串：str"></a>字符串：str</h2><pre><code>1. 单引号和双引号都表示字符串；
2. 在内存中的存储方式
    1. 一个字节存储的最大数值是255，比如，数值100是用一个字节存储的；
    2. 字符串存储时，会把字符串拆分成一组字符，每个字符占一个字节；在底层C语言存储字符串时，
    会在字符串的末尾加一个&apos;\0&apos;。
3. str(x)：将x转换成一个字符串，列表、元组、字典、集合等都可以转为字符串；
4. len(str)：获取字符串的长度；
5. 拼接字符串
    1. + 号连接两个字符串，拼接的必须是字符串类型，否则会报异常；
    2. % 拼接字符串：a = &quot;abc&quot;，b = &quot;OK&quot;，c = &quot;==%s==&quot;%(a+b)，c：&quot;==abcOK==&quot;。
6. 下标：name = &quot;abc&quot;
    1. 正向：name[0]--&gt;&apos;a&apos;，name[len(name)-1]--&gt;&apos;c&apos;；
    2. 反向：name[-1]--&gt;&apos;c&apos;，name[-len(name)]--&gt;&apos;a&apos;；
    3. 下标的方式只能获取对应的字符，但不能通过下标修改字符； name[0]=&quot;w&quot; 会报异常。
7. b&apos;AB&apos; --&gt; 二进制数据，r&apos;AB\tAB&apos; --&gt; 不允许对字符串转义，u&apos;AB&apos; --&gt; Unicode字符串
</code></pre><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><pre><code>切片：name = &quot;abcdefABCDEF&quot;
1. name[开始角标:结束角标]：取字符串的一部分，左开右闭的原则；name[2:5]--&gt;&quot;cde&quot;；
2. name[2:-1]，等效于 name[2:len(name)-1] --&gt; &quot;cdefABCDE&quot;
3. 省略开始角标，默认为 0；name[:5]，等效于name[0:5]--&gt;&quot;abcde&quot;；
4. 省略结束角标，默认为len[name]；name[6:]--&gt;&quot;ABCDEF&quot;；
5. name[开始角标:结束角标:步长]：步长是取元素时跳过的个数，name[2:9:2]--&gt;&quot;ceAC&quot;，
   步长为1时，等效于name[2:9]，步长默认为1，但步长不能为0；
6. 逆序1：name[-1::-1] --&gt; &quot;FEDCBAfedcba&quot;，结束角标取决于步长；
    1. 如果步长是负数，则取到第一个字符，name[-1::-2] --&gt;FDBfdb；
    2. 如果步长为正数，则取到最后一个，即取到的字符串始终为&quot;F&quot;。
7. 逆序2：name[:]--&gt;&quot;abcdefABCDEF&quot;，相当于复制字符串；
    name[::-1]--&gt;&quot;FEDCBAfedcba&quot;，逆序。
</code></pre><h3 id="字符串的常见操作"><a href="#字符串的常见操作" class="headerlink" title="字符串的常见操作"></a>字符串的常见操作</h3><pre><code>1. 查找
    find(子串)/rfind(子串)：正向/反向查找指定的子串，返回子串首字母的下标，-1表示不存在；
    index()、rindex()：与find()的区别是，如果查找失败，则抛出异常；
2. count(子串)：返回指定子串的出现次数。
3. 替换
    replace(子串A，子串B)：用B替换字符串中所有的A，返回一个新的字符串，不会改变原字符串；
    replace(子串A，子串B，num)：num表示要替换的个数。
4. split(子串)：切割字符串，返回一个列表；
    split()：不加参数时，默认会按照空格、&apos;\t&apos;、&apos;\n&apos;进行切割；
</code></pre><p><img src="http://i.imgur.com/MTdw3qn.png" alt></p>
<pre><code>    splitlines()：按照行切割，即字符串中的&apos;\n&apos;。
5. 字母大小写
    capitalize()：把字符串的首字母大写；
    title()：把每个单词的首字母大写；
    lower()/upper()：所有大/小写字母都变成小/大写。
6. startswith(子串)/endswith(子串)：是否以指定子串开头/结束，返回True/false；
7. 指定位置
     center(num)：居中，num表示宽度，小于字符串长度时无效；
     ljust(num)/rjust(num)：左/右对齐。
8. 去除字符串的空格
     strip()：同时去除左右空格；
     lstrip()/rstrip()：去除左/右边的空格；
9. partition(子串)：以字符串中的第一个子串为中心，将字符串拆分成3部分，返回一个元组；
    rpartition()：反向查找出匹配子串，拆分字符串；
10. 判断字符串类型
     isalpha()：字符串是纯字母（a~z和A~Z），返回True；
     isdigit()：字符串是纯数字时，返回True；
     isalnum()：字符串是纯字母、纯数字，或者字母和数字的组合时，返回True；
     isspace()：字符串是纯空格，则返回True。
11. join(iterable)：以调用者为中间字符，连接iterable中的元素，组成一个新的字符串。
    iterable是指可迭代对象，如字符串，元组，列表，字典，集合 ...
    1. 元组，列表和集合的元素，以及字典的键，必须是字符串类型才能连接；
    2. 对于字符串，连接的是每个字符；对于字典，连接的是每个键；
    3. join() 连接字符串的效率要比 “ + ” 更高。
</code></pre><h2 id="列表：list"><a href="#列表：list" class="headerlink" title="列表：list"></a>列表：list</h2><pre><code>1. 定义：list = [ 元素1，元素2，元素3 ]，可以是不同数据类型的元素；
2. 交互模式下，help(list)，可以查看列表的文档；
3. len(list)：返回列表的长度，即元素个数；
4. list(iterable)：把iterable型的数据转为列表；
    1. 如果是字符串，会把字符串拆开，每个字符当作列表元素；
    2. 如果是字典，则把键当作列表元素。
5. 列表支持负角标，也支持切片。
</code></pre><h3 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h3><pre><code>1. append(x)：添加一个新元素，添加在列表最后；
    如果添加的元素是一个列表，则该列表会被看作是一个元素，而不会被拆开。
2. insert(index，x)：在指定位置index插入元素；
    python 的列表其实是一个数组，查找快，insert()插入的效率比append()低。
3. extend()：将两个列表合并成一个列表；两个列表相加，也可以合并成一个新的列表；
4. pop()：删除最后一个元素；    pop(index)：按照角标删除元素；
5. remove(x)：删除指定的元素，只删第一个；
6. del list[index]：根据下标删除；
7. list[index] = y：修改指定元素；
8. 查询：in、 not in
    if x in list：x 在列表 list 中；
    if x not in list：x 不在列表 list 中。
9. index(x)：获取元素的角标，如果该元素不存在，会抛出异常；
10. 排序
    1. sort()、sort(reverse=True)：从小到大排序、从大到小排序，对纯数值元素的列表有效；
    2. reverse()：反向列表，对纯数值元素的列表有效。
11. for...in：遍历列表的元素；
    迭代过程中不能删除列表的元素，因为删除后，列表的元素会发生移动，但迭代指针不会随之移动，
从而造成元素遗漏；
</code></pre><p><img src="http://i.imgur.com/eDBYpOn.jpg" alt></p>
<pre><code>解决的一种方式：创建一个列表Flag，保存要删除的元素；然后再迭代Flag，删除lists的元素。
</code></pre><h3 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h3><pre><code>1. range(start, stop, step)
   生成一个int型的列表，start 列表的第一个元素，stop-1 最后一个元素，step 表示步长；
2. range(5) 等效于 range(0, 5) --&gt; [0, 1, 2, 3, 4]；
3. python2：如果 stop 的值足够大，会内存溢出；所以，python2中的range()是有风险的；
4. python3：range() 并不会立刻生成一个列表，而是作为一个生成器，需要某个元素时再生成；
   所以，range()不会内存溢出；
5. python3下，list(range(5)) 会将生成器转化为列表：[0, 1, 2, 3, 4]
6. xrange() 在python2和python3环境下都是一个生成器，不会造成内存溢出；
7. [i for i in range(5)] --&gt; [0, 1, 2, 3, 4]
    for 语句只用于控制循环的次数，每次循环都会改变i的值，for前面的参数表示每次循环之后、
    存入列表的元素；
8. for - if：筛选生成的元素
      [i for i in range(10) if i%2==0]：只生成偶数的元素，[0, 2, 4, 6, 8]。
9. 多层for循环
    1. [i for i in range(3) for j in range(2)]：
    外层for循环一次，内层for会循环2次(0，1)，生成列表：[0, 0, 1, 1, 2, 2]；
    2. [(i, j) for i in range(3) for j in range(2)]：用元组存储一次生成的多个子元素，
    生成列表：[(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)]。
</code></pre><h2 id="字典：dict"><a href="#字典：dict" class="headerlink" title="字典：dict"></a>字典：dict</h2><pre><code>1. 定义：dict = {键:值，键:值，键:值}，以键值对形式存储数据；
2. 键的类型可以是字符串，数值，元组，但不能是列表；
   因为字典元素的存储地址，是对键进行哈希算法计算的，所以键一定要是不可变的类型，
   而列表是可变类型，计算的值会根据列表的变化而改变；
3. len(dict)：返回字典的长度，即元素个数；
</code></pre><h3 id="常见操作-1"><a href="#常见操作-1" class="headerlink" title="常见操作"></a>常见操作</h3><pre><code>1. 添加/修改： dict[&quot;name&quot;] = &quot;Make&quot;；
2. 指定键进行删除：del dict[键]，pop(key)
3. 查询
     dict[键]：获取值，但是如果该键不存在，将报出异常；
     get(键[, defaultValue])：获取值，如果键不存在，默认返回None，也可以设置默认值。
4. keys()：python2返回键的列表，python3返回一个生成器：dict_keys([键1, 键2])；
5. values()：python2返回值的列表，python3返回一个生成器：dict_values([值1, 值2])；
6. items()：dict = {&quot;name&quot;:&quot;DD&quot;, &quot;age&quot;:20}
    python2中：[(&apos;age&apos;, 20), (&apos;name&apos;, &apos;DD&apos;)]，是一个列表；
    python3中：dict_items([(&apos;name&apos;, &apos;DD&apos;), (&apos;age&apos;, 20)])，是一个生成器对象。
</code></pre><p><img src="http://i.imgur.com/xPbLLEo.jpg" alt></p>
<pre><code>7. for temp in dict：遍历的是字典的键。
</code></pre><h2 id="元组：tuple"><a href="#元组：tuple" class="headerlink" title="元组：tuple"></a>元组：tuple</h2><pre><code>1. 定义：tuple = (元素1，元素2，元素3)
2. 与列表的区别：元组的元素是不可变的，只能查看，不能修改；
3. 如果元组只有一个元素，必须在元素后加逗号：(20, )
4. tuple(iterable)：把iterable型的数据转为元组；
5. len(tuple)：获取元组的长度，即元素的个数；
6. 元组支持负角标，也支持切片；
7. 获取元组的值：a = (10, 12)
    1. 下标的方式：tuple[0]--&gt;10
    2. 拆包：b, c = a --&gt; b：10，c：12
8.  index(x)：返回元素x第一次出现的角标，如果元素不存在，会抛出异常；
9.  count(x)：计算元素x在元组中出现的个数。
10.  zip(list1, list2)：
    1.  zip([1, 2], [&apos;A&apos;, &apos;B&apos;]) --&gt; [(1, &apos;A&apos;), (2, &apos;B&apos;)]
    2.  zip([1, 2, 3, 4], [&apos;A&apos;, &apos;B&apos;]) --&gt; [(1, &apos;A&apos;), (2, &apos;B&apos;)]，多余元素被忽略
</code></pre><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><pre><code>1. 定义：set = { 元素1, 元素2, 元素3 }
2. set与dict类似，也是一组key的集合，但不存储value；同理，key不能重复、不能是可变的；
3. False和True是按照 0 和 1 存储的，所以，False和0、True和1，也被视为重复元素；
4. len(set)：获取集合的长度，即元素的个数；
5. set(iterable)：把iterable型的数据转为集合，并去除重复元素；
6. 常见操作：add(x) 添加一个元素；pop() 删除第一个元素；remove(x) 删除元素x。
7. for...in 的方式遍历，字典和集合的效率比列表要高；
8. 集合A，集合B
     A &amp; B：交集；A | B：并集
     A - B：A 的差集，A 中有，B 中没有的元素；同理，B-A：B的差集；
     A ^ B：对称差集，等效于 A-B 与 B-A 的并集；
9. 应用场景：集合A 表示上个月浏览的用户，集合B 表示这个月浏览的用户
A &amp; B 过滤出老用户；A | B 统计出所有用户；A - B 统计丢失的用户；B - A 统计新用户
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2017/07/25/linux命令入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/25/linux命令入门/" itemprop="url">linux命令入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-25T00:00:00+08:00">
                2017-07-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Linux-的目录结构"><a href="#Linux-的目录结构" class="headerlink" title="Linux 的目录结构"></a>Linux 的目录结构</h2><pre><code>不同于windows，Linux没有分盘，只有一个根目录 /：
</code></pre><p><img src="http://i.imgur.com/eNoIkyr.jpg" alt></p>
<pre><code>/bin：和程序相关；  /boot：和系统启动相关；  /cdrom：和光盘相关；  /dev：和设备相关；
/etc：程序和服务器配置相关；  /lib：存放库；  /home：存放家目录，即打开终端默认所在路径；
</code></pre><h2 id="linux常用命令"><a href="#linux常用命令" class="headerlink" title="linux常用命令"></a>linux常用命令</h2><pre><code>pwd：查看当前所在路径；
ls：列出当前目录下的文件和文件夹； ls /：列出根目录下的文件和文件夹；  
ls的常用参数：
    1. ls -a：显示隐藏文件及目录；
    2. ls -l：以列表形式显示详细信息；
    3. ls -lh：显示文件及目录的大小时，转换为合适的单位； 
touch 文件名：创建文件；
mkdir 目录名：创建文件夹；  mkdir a/b/c -p：如果c之前有不存在的目录，则创建；
tree：显示当前目录的内容结构；
rmdir：删除空目录；
rm：删除文件；  rm -r：可以删除非空的目录，-r，递归；  -f，强制删除；
命令名 --help：查询命令的文档；
man 命令名：分屏的方式查询命令，会进入一个新的界面显示查询结果，每次只显示一屏，支持上下键
    翻动，f:向下翻一屏，b：向上翻一屏，q：退出；
Tab：自动补全；
cat 文件名：查看文件的内容；    cat a.txt b.txt：同时查看文件a和b。
more 文件名：分屏的方式查看文件内容；
ls -alh /bin | more：以分屏的方式显示根目录下bin文件夹的内容；    |：管道，ls输出的内容
    先存入管道，more再从管道中取出，以分屏的方式显示；
history：查看输入过的命令；  !行号：执行行号对应的命令；
&gt;、&gt;&gt;：重定向
    ls &gt; a.txt，将ls命令显示的内容写入a.txt中，会先清空文件的内容；
    ls &gt;&gt; a.txt，追加内容，不会清空文件原内容；如果文件不存在，则会先创建文件；
    cat a.txt b.txt &gt; c.txt：合并文件a和文件b。
cd ./a：.代表当前目录，等效于 cd a；
cd ..：回到上一层目录；  cd ../..：回到上一层目录的上一层目录；
cd -：回到上一次所在的目录，不一定是上一层目录；
cd ~：回到家目录；
软连接、硬链接
    ln -s 文件名 自定义的软连接文件名：创建一个软连接，相当于快捷方式，如果删除了原文件，
        软连接文件无效；
    ln 文件名 自定义的硬链接文件名：创建一个硬链接，相当于为文件创建一个别名，删除原文件，
        硬链接仍有效；
    创建一个文件时，文件内容和文件名是分开存储的，文件名其实就是一个硬链接，当一个文件的硬
    链接数为 0 时，系统就会删除文件内容。
</code></pre><p><img src="http://i.imgur.com/2UC6GMc.jpg" alt></p>
<pre><code>mv：重命名、移动；如果目录不允许移动，则加 -r；
cp：复制并粘贴；如果目录不允许操作，则加 -r；
文本搜索：grep
    grep &quot;内容&quot; 文件名：-n，显示匹配的内容在文件中对应的行号；    -v，求反，搜索内容之外
        的其他内容；    -i，忽略大小写；
    grep &quot;^abc&quot; 文件名：以abc开头的内容；
    grep &quot;abc$&quot; 文件名：以abc结尾的内容。
搜索文件：find
</code></pre><p><img src="http://i.imgur.com/Hugd8Vp.jpg" alt></p>
<pre><code>    find ./ -name &quot;*name*&quot;：查找文件名中包含&quot;name&quot;的文件；
执行命令时，如果没有权限，可以在命令的开头使用 sudo；
归档管理：tar
    1. tar命令很特殊，其参数前可以不使用 &quot;-&quot;；
    2. tar -cvf abc.tar *.py：将所有.py后缀的文件打包成abc.tar；  
       tar -xvf abc.tar：解压缩；
    3. tar -zcvf abc.tar.gz *.py：压缩并打包成abc.tar.gz，占用空间比abc.tar小很多；  
       tar -zxvf abc.tar：解压缩；
       tar -zxvf abc.tar.gz -C workspace：解压到指定目录；
    4. tar -jcvf abc.tar.bz2 *.py：压缩并打包，占用空间比gz稍微大一点；  
       tar -jxvf abc.tar.bz2：解压缩；
    5. zip ab.zip *.py：打包成ab.zip，占用空间较大；
       unzip ab.zip：解压缩
       unzip -d ./test ab.zip：解压到指定目录。
    6. 常用 gz，bz2
which 命令名：查看命令所在目录；
cal：查看日历；
date：查看当前时间，自定义格式：date &quot;+%Y年%m月%d日&quot;；
查看进程信息
    ps -aux：查看所有进程的详细信息（windows的任务管理器）
    top、htop：在一个独立的界面显示进程的信息，q：退出。
kill PID：杀死指定PID的进程，kill -9 PID：强制杀死；
关机重启
    reboot：重启系统，等效于 init 6；
    shutdown -r now：重启系统，会提示给别的用户；
    shutdown -h now：立即关机，等效于 init 0；
    shutdown -h 20:25：定时今天20:25关机；
    shutdown -h +10：10分钟后关机；
df -h：查看当前内存的使用情况；
du -h：查看当前路径下的目录和文件的占用空间大小；
ifconfig -a：查看所有网卡的信息，主要用于查看IP地址信息；
    sudo ifconfig 网卡名(ens33) 新IP：修改指定网卡的IP；
    sudo dhclient：重新动态获取Ip；
ping IP地址：检测是否能与某个IP通信（连通性）；
对于虚拟机上的ubuntu系统，其网卡Ip必须和本机Ip设置在同一个网段，才能实现通信。
用户相关
    linux是多用户多任务的操作系统；
    useradd 用户名 -m：添加一个新的用户，在/etc/passwd文件中可以查看，在/home中会同时
        创建该账户的家目录；
    passwd 用户名：设置（修改）账户密码，新创建的账户默认没有密码；
    userdel -r 用户名：删除用户，并删除home下的家目录；
    whoami：查看当前用户；
    exit：退出当前用户；
    ssh 用户名@IP：远程登陆另一台电脑；
    who：查看登陆当前用户的电脑，显示IP的表示远程登陆的用户，没有IP的表示当前的终端登录；
    su 账户名：切换用户，需要输入该账户的密码；但是，并不会切换当前目录；
        su - 账户名：切换用户，并切换到该账户的家目录；
        su、 su root：切换到超级管理员root；
        su - 、 su - root：切换到root，同时切换到/root目录；
    sudo -s：切换到root权限，并不通用，只在ubuntu的Linux中；
    但是，普通用户会切换root失败，并且会报告给管理员。
用户组
    groupadd 组名：创建一个用户组，在/etc/group文件中可以查看；
    groupdel 组名：删除一个组；
    groupmod +多个Tab：查看当前所有用户组
    为创建的普通用户添加 root 权限
        能切换到 root 权限的组是 adm 和 sudo；
        普通用户不在 adm 和 sudo 组，也就不能通过 sudo -s 切换到root权限；
        cat /etc/group | grep sudo：查看在group文件中搜索出的、属于 sudo 组的用户；
        sudo usermod a -G adm 用户名：加入到 adm 组；
        sudo usermod -a -G sudo 用户名：加入到 sudo 组；
chown 用户名 文件：修改所有者；
chgrp 用户组 文件：修改用户组。
文件的权限
</code></pre><p><img src="http://i.imgur.com/MUFG2iL.jpg" alt></p>
<pre><code>r：读，w：写，x：可执行；
字母法修改文件的权限
    chmod u=rwx 文件名：修改所有者权限为可读、可写、可执行；
    chmod u=r 文件名：修改所有者权限为可读；
    chmod g=rx 文件名：修改所有组权限为可读、可执行；
    chmod o=x 文件名：修改其他人的权限为可执行；
    chmod u=w,g=r,o=x 文件名：同时修改三者的权限；
    chmod u=,g=,o= 文件名：三者都没有任何权限；
数字法修改文件的权限
    r --&gt; 4，w --&gt; 2，x --&gt; 1；
    rw --&gt; 6，rx -- &gt; 5，wx --&gt; 3，rwx --&gt; 7；
    chmod 777 文件名：三者可读、可写、可执行；
    chmod 000 文件名：三者没有任何权限。
</code></pre><h2 id="vi、vim"><a href="#vi、vim" class="headerlink" title="vi、vim"></a>vi、vim</h2><pre><code>vi、vim：进入命令模式，vim 是 vi 的升级版；
vi 文件名 +15：打开文件时，光标定位到15行；
i、I、A、a、O、o：命令模式进入编辑(插入)模式；
    编辑的位置：i，光标前； I，行首； a，光标后； A，行末； o，下一行； O，上一行；
在命令模式下，：--&gt; 进入末行模式；
Esc：退出编辑模式或末行模式；
命令模式下常用命令：
    yy：复制光标所在的行；  4yy：复制光标所在行开始向下的4行；  p：粘贴；
    dd：剪切(删除)光标所在的行；  3dd：剪切光标所在行开始向下的3行；
    D：从光标的位置开始剪切，一直到行末；  d0：从光标位置开始剪切，一直到行首；
    x：向后删除一个；  X：向前删除一个；
    h：控制光标向左；  j：向下；  k：向上；  l：向右；
    H：控制光标定位到当前屏幕的最上面一行；  M：当前屏幕的中间一行；
    L：当前屏幕的最下面一行；  G：整个文件的最后一行，  gg：整个文件的第一行，
    20G：光标定位到第20行；
    w：光标跳到下一个单词的开始处；  b：光标调到上一个单词的开始处；  dw：剪切整个单词；
    u：撤销回上一步操作；  Ctrl+r：反撤销；
    v、V：选中一片代码；v：选中光标经过的位置；  V：选中光标经过的行；
        选中之后， y：复制；  d：剪切；  &gt;：整体向右移动；  &lt;：整体向左移动；
        .：重复执行上一次的命令。
    Ctrl+d：向下翻半屏； Ctrl+u：向上翻半屏； Ctrl+f：向下翻一屏； Ctrl+b：向上翻一屏；
    {：光标向上移动到一块代码的开始；  }：向下移动到一块代码的结尾；
    r、R：替换；  r：替换光标所在的单个字符；  R：替换光标以及后面的字符；
    /：搜索；  /Hello + Enter：搜索“Hello”；
        n：光标移动到下一个搜索的内容；  N：移动到上一个；
    Shift+zz：保存并退出。
末行模式下常用的命令：
    %s/world/hello/g：将文件中的所有 “ world ” 替换为 “ Hello ”；
    %5,20s/world/hello/g：只替换5-20行的 “ world ”；
    w：保存；
    q：退出；  q!：强制退出；  wq：保存并退出；  wq!：保存并强制退出；
    x：保存并退出。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/02/05/JavaEE之过滤监听/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/05/JavaEE之过滤监听/" itemprop="url">JavaEE之过滤监听</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-02-05T00:00:00+08:00">
                2016-02-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><pre><code>1. 过滤器(拦截器)：对服务器接收的请求资源和响应给浏览器的资源进行统一管理，保护Servlet;
    1. 比如在请求到达Servlet之前，请求编码格式的统一设置，session管理...
    2. 过滤器会执行两次：请求达到Servlet之前，Servlet响应数据之后。
2. 使用Filter
    1. 实现Filter接口，覆写 init()、doFilter()、destroy()
    2. 在 web.xml 中配置过滤器
    &lt;filter&gt;
        &lt;filter-name&gt;TestFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;it.test.cn.TestFilter&lt;/filter-name&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;TestFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    3. /*：拦截访问此项目的所有请求;
    4. *.do：拦截以 .do 结尾的请求，一般用于模块拦截处理;
    5. /to.do：拦截 /to.do 的请求，针对某个具体的Servlet请求进行拦截，保护Servlet;
    6. 如果同时配置了三个过滤器，那么在执行Filter的过程，匹配范围越大，优先级越高.
    /* --&gt; *.do --&gt; /to.do
3. 过滤器会拦截请求，不会到达Servlet，需要手动给予放行，才能达到Servlet
    public void doFilter(ServletRequest request, ServletResponse response, 
        FilterChain chain) {
        chain.doFilter(request, response);  ---&gt; 放行
    }
    1. chain.doFilter() 表示放行当前的请求，交给Servlet进行处理；
    2. Servlet发送响应数据之后，会先达到Filter，执行 chain.doFilter() 之后的代码逻辑，
    然后才会响应给浏览器.
4. 生命周期：从服务器启动(Filter init())，到服务器关闭(Filter destroy())
</code></pre><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><pre><code>1. 统一编码格式设置
    public void doFilter(request, response, chain) {
        request.setCharacterEncoding(&quot;utf-8&quot;);
        response.setContentType(&quot;text/html;charset=utf-8&quot;);
        chain.doFilter(request, response);
    }
2. session管理
    public void doFilter(request, response, chain) {
        HttpSession hs = ((HttpServletRequest)request).getSession();
        //判断Session是否过期
        if(hs.getAttribute(&quot;user&quot;) == null) {
            //过期则重定向到登录页
            ((HttpServletResponse)response).sendRedirect(&quot;/login.jsp&quot;);
        } else {
            chain.doFilter(request, response);
        }
    }
3. 权限管理，资源管理(统一水印、和谐词汇...) ...
</code></pre><h2 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h2><pre><code>1. Servlet监听器：监听数据流转的过程，比如作用域对象的创建与销毁，数据的存取、变化、删除；
2. 监听的作用域对象包括request、session、application
3. 比如session销毁时，在线人数-1
4. 在 web.xml 中配置监听器
    &lt;listener&gt;
        &lt;listener-class&gt;it.test.cn.TestListener&lt;/listener-class&gt;
    &lt;/listener&gt;
</code></pre><h3 id="request-Listener"><a href="#request-Listener" class="headerlink" title="request Listener"></a>request Listener</h3><pre><code>1. ServletRequestListener：实现此接口，监听request的创建销毁;
    1. 接收到一个请求，则创建request对象；响应结束，销毁request对象;
    2. 创建时触发requestInitialized(sre)，销毁时触发requestDestroyed(sre);
    3. 获取当前正在监听的的Servlet Request对象：sre.getServletRequest();
2. ServletRequestAttributeListener：实现此接口，监听request对象中的Attribute数据;
    1. req.setAttribute(&quot;key&quot;, value); 第一次添加数据时，触发 attributeAdded(srea);
    2. req.setAttribute(&quot;key&quot;, value); 重复添加同键的数据，则触发attributeReplaced(srea);
    3. req.removeAttribute(&quot;key&quot;); 移除数据，则触发：attributeRemoved(srea);
    4. 获取当前正在变化的Attribute数据：srea.getName(); srea.getValue();
</code></pre><h3 id="session-Listener"><a href="#session-Listener" class="headerlink" title="session Listener"></a>session Listener</h3><pre><code>1. HttpSessionListener：实现此接口，监听session的创建与销毁;
    1. req.getSession(); 第一次获取Session表示创建，则触发sessionCreated(se);
    2. Session被销毁时，触发sessionDestroyed(se);
    3. 获取当前正在监听的Session对象：se.getSession();
2. HttpSessionAttributeListener：实现此接口，监听session中的attribute数据;
    1. session.setAttribute(&quot;key&quot;, value);  获取/重置Session Attribute数据;
    2. session.removeAttribute(&quot;key&quot;);  移除Session Attribute数据;
    3. 覆写方法：attributeAdded(hsbe)、attributeReplaced(hsbe)、attributeRemoved(hsbe);
    4. hsbe.getName();  hsbe.getValue();  分别获取正在变化的Attribute数据的键、值.
</code></pre><h3 id="application-Listener"><a href="#application-Listener" class="headerlink" title="application Listener"></a>application Listener</h3><pre><code>1. ServletContextListener：实现此接口，监听ServletContext的创建与销毁;
    1. 服务器启动/关闭时，分别触发 contextInitialized(sce); contextDestroyed(sce);
    2. 获取当前正在监听的ServletContext对象：sce.getServletContext();
2. ServletContextAttributeListener：监听application中的attribute数据;
    1. attributeAdded(scae)、attributeReplaced(scae)、attributeRemoved(scae);
    2. scae.getName();  scae.getValue();
</code></pre><h3 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h3><pre><code>1. 统计当前在线人数
2. 统计网页浏览次数
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/02/03/JavaEE之JSP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/03/JavaEE之JSP/" itemprop="url">JavaEE之JSP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-02-03T00:00:00+08:00">
                2016-02-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><pre><code>1. JSP：Java Server Pages，一种动态网页技术标准，本质是一个简化的Servlet
2. 原理：浏览器访问jsp文件时，JSP引擎把jsp文件转为Servlet(java文件)，然后执行此Servlet
3. Tomcat/conf/web.xml 对jsp访问的配置
    &lt;servlet&gt;
        &lt;servlet-name&gt;jsp&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.apache.jasper.servlet.JspServlet&lt;/servlet-class&gt;
        ...
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;jsp&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;
        &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
4. JSP的访问有一个转译的过程，所以JSP文件的修改不需要重启服务器。
5. JSP的三种注释：前端注释、Java语言注释、JSP注释
    1. 前端注释会被转译，也会被发送给浏览器，但不会执行；
    2. Java语言注释会被转译，但不会被Servlet执行；
    3. JSP注释不会被转译：&lt;%-- JSP注释 --%&gt;
</code></pre><h3 id="page指令"><a href="#page指令" class="headerlink" title="page指令"></a>page指令</h3><pre><code>1. page指令：配置JSP转译的相关参数
    &lt;%@ page 属性名=&quot;属性值&quot; 属性名=&quot;属性值&quot; ... %&gt;
2. language：声明JSP被转译的语言，如language=&quot;java&quot;
3. import：使用什么语言，就需要导入什么语言的包，不同的包以&quot;,&quot;隔开，也可以导入项目中的类
    import=&quot;java.util.*,java.lang.*,it.test.cn.modal.*&quot;
4. pageEncoding：文件保存的编码，如pageEncoding=&quot;utf-8&quot;
    1. 对于高版本的JSP，pageEncoding可以同时指定响应的编码；
    2. 对于低版本的JSP，还需要指定响应的编码：contentType=&quot;text/html;charset=UTF-8&quot;
5. session：设置转译的Servlet中是否支持Session，默认开启，不开启则设置session=&quot;false&quot;
6. errorPage：配置错误页面的路径，errorPage=&quot;error.jsp&quot;
7. extends：设置JSP转译的Servlet要继承的父类(全类名)
</code></pre><h3 id="JSP逻辑代码"><a href="#JSP逻辑代码" class="headerlink" title="JSP逻辑代码"></a>JSP逻辑代码</h3><pre><code>1. JSP的局部代码块
    &lt;%
        int num = 1;
        if(num &gt; 0) {
    %&gt;
            &lt;div&gt;num大于0&lt;/div&gt;
    &lt;% } else { %&gt;
            &lt;div&gt;另作处理&lt;/div&gt;
    &lt;% } %&gt;
    1. 转译到Servlet中
    int num = 1;
    if(num &gt; 0) {
        out.write(&quot;\r\n&quot;);
        out.write(&quot;\t\t&lt;div&gt;num大于0&lt;/div&gt;\r\n&quot;);
    } else {
        out.write(&quot;\t\t&lt;div&gt;另作处理&lt;/div&gt;\r\n&quot;);
    }
    2. 在JSP中写逻辑代码，编码困难，可阅读性和可维护性极差，所以尽量在Servlet中处理逻辑，
    JSP只负责展示内容。
2. JSP的全局代码块
    1. 声明Servlet的成员方法和成员变量
    &lt;%!
        int num = 1;
        public void test(){ ... }
    %&gt;
    2. 全局代码块声明的属性和方法，只能在局部代码块中使用。
3. JSP脚本段语句
    1. &lt;%= num %&gt;
    2. &lt;%= test() %&gt;  ==&gt;方法要有返回值
</code></pre><h3 id="JSP的引入与转发"><a href="#JSP的引入与转发" class="headerlink" title="JSP的引入与转发"></a>JSP的引入与转发</h3><pre><code>1. 静态引入： &lt;%@include file=&quot;header.jsp&quot; %&gt;
    1. 两个JSP文件会合并成一个Servlet文件;
    2. 静态引入的JSP不会单独转为一个Servlet;
    3. 两个JSP文件不能声明同名的Java变量.
2. 动态引入： &lt;jsp:include page=&quot;active.jsp&quot;&gt;&lt;/jsp:include&gt;
    1. 动态引入的JSP文件也会单独转为一个Servlet;
    2. 在当前JSP文件转译的Servlet中，会调用动态引入的JSP文件转译的Servlet;
    3. 允许在两个JSP文件中声明同名的Java变量.
3. JSP转发标签
    &lt;jsp:forward page=&quot;target.jsp&quot;&gt;&lt;/jsp:forward&gt;
    1. 一次请求，浏览器地址栏信息不变;
    2. 在&lt;jsp:forward&gt;标签中只能写&lt;jsp:param name=&quot;xxx&quot; value=&quot;xxx&quot;/&gt;，向目的JSP页面
    传递参数，而不能有其他任何字符，甚至是空格也不行，否则就会报错;
    &lt;jsp:forward page=&quot;target.jsp&quot;&gt;
        &lt;jsp:param name=&quot;user&quot; value=&quot;Mack&quot; /&gt;
    &lt;/jsp:forward&gt;
    3. 以GET形式转发参数：转发路径?user=Mack
    4. 在目的JSP页面获取参数：&lt;%= request.getParameter(&quot;user&quot;) %&gt;
</code></pre><h3 id="JSP的内置对象"><a href="#JSP的内置对象" class="headerlink" title="JSP的内置对象"></a>JSP的内置对象</h3><pre><code>1. 九大内置对象：JSP文件转译为Servlet时自动生成并声明的对象，可以在JSP文件中直接使用；
2. 内置对象只能在局部代码块和脚本段语句中使用；
1. pageContext：JSP的页面上下文对象，内部封装了另外8个内置对象；
    1. PageContext封存了当前JSP的运行信息，每个JSP文件都有一个PageContext对象；
    2. 每次请求都会重新创建一个PageContext对象，存储当前页面内的数据。
2. application
    ServletContext application = pageContext.getServletContext();
3. config
    ServletConfig application = pageContext.getServletConfig();
4. out
    JspWriter out = pageContext.getOut();
    1. JSP内部使用的响应对象，带有缓冲区，效率高于response
5. session：一次会话的Session对象，存储同一用户、不同请求的共享数据；
    1. 要使用Session对象，必须先在page指令中开启，session=&quot;true&quot;
    session = pageContext.getSession();
6. request，response：分别是当前的请求对象、响应对象；
7. page：this，当前JSP对象(Servlet对象);
8. exception：存储当前运行的异常信息，先在page指令中使用 isErrorPage=&quot;true&quot; 开启;
9. 数据流转
    1. pageContext：当前页面内的数据共享，获取其他内置对象;
    2. request：一次请求的数据共享，通过请求转发，把数据流转给下一个Servlet;
    3. session：一次会话，同一用户、不同请求的数据共享，将数据从一次请求流转给其他请求;
    4. application：项目内的数据，不同用户的数据共享，将数据从一个用户流转给其他用户.
</code></pre><h3 id="JSP的资源路径"><a href="#JSP的资源路径" class="headerlink" title="JSP的资源路径"></a>JSP的资源路径</h3><pre><code>1. 在JSP中使用相对路径时，资源位置不可随意更改；
2. 绝对路径：&lt;a href=&quot;/servtest/a.jsp&quot;&gt;，
    1. 第一个 &quot;/&quot; 表示服务器根目录(Tomcat/webapps)，&quot;/servtest&quot; 表示服务器的项目根目录，
    servtest是项目在Tomcat/webapps下的虚拟目录名。
3. 在JSP中声明全局路径
    &lt;%
        String path = request.getContextPath();
        String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;
        +request.getServerPort()+path+&quot;/&quot;;
    %&gt;
    &lt;html&gt;
        &lt;head&gt;
            &lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt;
    1. 那么，在JSP文件中引入资源时，资源路径会自动加上 Ip:Port/项目虚拟目录名/
    2. &lt;a href=&quot;a.jsp&quot;&gt; 跳转到 http://Ip:Port/servtest/a.jsp
4. 重定向到 main目录下的main.jsp
    resp.sendRedirect(&quot;/servtest/main/main.jsp&quot;);
    1. 重定向时，尽量使用绝对路径取代资源路径：/项目虚拟目录名/资源路径;
    2. 假定当前的Servlet的别名带有目录，如&lt;url-pattern&gt;/user/abc&lt;/url-pattern&gt;
    3. 如果使用相对路径，如resp.sendRedirect(&quot;main/main.jsp&quot;);  那么跳转的main.jsp的
    路径为 /项目虚拟目录名/user/main/main.jsp;
    4. 而main.jsp的真实路径是 /项目虚拟目录名/main/main.jsp ，那么就会报404错误.
5. 转发到一个JSP页面
    req.getRequestDispatcher(&quot;/login.jsp&quot;).forward(req, resp);
    1. 与请求重定向不同，请求转发的第一个 &quot;/&quot; 表示项目根目录，而不是服务器根目录，所以不用
    加项目的虚拟目录名.
</code></pre><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><pre><code>1. EL：Expression Language，一种写法非常简洁的表达式，灵感来源于ES和XPath;
2. EL表达式用于简化在JSP中获取作用域数据和请求数据，不需要导入相关的类(包);
3. 传统的获取方式
    1. 在Servlet中处理请求之后，通过请求转发到JSP页面：req.setAttribute(&quot;key&quot;, Object);
    2. 在JSP页面中获取数据：&lt;%= request.getAttribute(&quot;key&quot;) %&gt;
    3. 在JSP页面中获取请求参数：&lt;%= request.getParameter(&quot;key&quot;) %&gt;
4. 语法结构：${expression}
    1. 获取请求参数
    ${ param.key } --&gt; 单个值
    ${ paramvalues.key } --&gt; 同键不同值如Checkbox
    2. 获取 req.setAttribute(&quot;key&quot;, Object) 传递的数据：${ Object }
    3. ${} 只获取 pageContext、request、session、application四个对象中的数据;
    &lt;%  String uname = &quot;Java&quot;;  %&gt;
    &lt;h3&gt;${ uname }&lt;/h3&gt;
    4. 如果在四大对象中找不到uname，不报错，也不显示内容，但决不理会页面中定义的变量uname;
5. EL查找作用域数据的默认顺序：pageContext --&gt; request --&gt; session --&gt; application
    &lt;%
        pageContext.setAttribute(&quot;uname&quot;, &quot;aaaa&quot;);
        request.setAttribute(&quot;uname&quot;, &quot;bbbb&quot;);
        session.setAttribute(&quot;uname&quot;, &quot;cccc&quot;);
        application.setAttribute(&quot;uname&quot;, &quot;dddd&quot;);
    %&gt;
    &lt;div&gt;${ uname }&lt;/div&gt; ===&gt; aaaa
    1. 除了默认顺序，还可以手动指定查找方向
    request：${ requestScope.uname }，pageContext：${ pageScope.uname }
    session：${ sessionScope.uname }，application：${ applicationScope.uname }
6. EL支持简单的逻辑运算：算术表达式、关系表达式、逻辑表达式(&amp;&amp; || !)、三元表达式
    ${ 1+3 } =&gt; 4，${ 1&gt;3 } =&gt; false，${ flag==0?&quot;正确&quot;:&quot;错误&quot; }
    1. EL表达式中不允许做字符串连接
    ${ 1+&quot;4&quot; } =&gt; 5，${ 1+&quot;a&quot; } =&gt; 报错
7. EL的空值判断：${ empty key }，空字符串、空集合都返回true，但是对象返回false
8. EL获取请求头数据：${ header }
    1. 单个值：${ header[&quot;key&quot;] }，如${ header[&quot;user-agent&quot;] }
    2. 数组：${ headerValues[&quot;key&quot;] }，同键不同值
9. EL获取Cookie数据：${ cookie }
    1. 获取一条Cookie数据，如sessionID：${ cookie.JSESSIONID }
    2. 获取这条Cookie数据的键值：
    ${ cookie.JSESSIONID.name }，${ cookie.JSESSIONID.value }
</code></pre><h2 id="JSTL标签库"><a href="#JSTL标签库" class="headerlink" title="JSTL标签库"></a>JSTL标签库</h2><pre><code>1. JSTL是 Apache 对EL表达式的扩展，JSTL依赖于EL，使用时需要导包，并指定标签库；
    1. MyEclipse会在lib目录下自动存放jstl.jar
    2. JSTL的标签库：核心库、格式化库、SQL库、函数库、XML库
2. JSTL标签库能够提升JSP页面编写逻辑代码的效率，可阅读性更强；
</code></pre><h3 id="JSTL核心标签库"><a href="#JSTL核心标签库" class="headerlink" title="JSTL核心标签库"></a>JSTL核心标签库</h3><pre><code>1. 导入jar包，声明jstl核心标签库的引入
    &lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
2. 输出：&lt;c:out&gt; 类似于 &lt;%=xxx %&gt;
    &lt;%  request.setAttribute(&quot;uname&quot;, &quot;Java&quot;);  %&gt;
    &lt;c:out value=&quot;${uname}&quot; default=&quot;xxx&quot;&gt;&lt;/c:out&gt;
    1. 结合EL表达式输出，如果uname不存在，则输出默认值default
3. 向作用域中存储键值： &lt;c:set var=&quot;key&quot; value=&quot;xxx&quot;&gt;&lt;c:set&gt;
    1. 默认存储在pageContext中，也可以手动指定存储的作用域对象
    &lt;c:set var=&quot;key&quot; value=&quot;xxx&quot; scope=&quot;page/request/session/application&quot;&gt;&lt;c:set&gt;
4. 删除作用域的数据：&lt;c:remove&gt;
    &lt;c:remove var=&quot;uname&quot; /&gt;
    1. 默认把4个作用域对象中的uname都删除，scope属性指定作用域
    &lt;c:remove var=&quot;uname&quot; scope=&quot;page/request/session/application&quot; /&gt;
5. 逻辑标签：依赖于EL表达式
    1. 单个判断
    &lt;c:set var=&quot;score&quot; value=&quot;66&quot;&gt;&lt;c:set&gt;
    &lt;c:if test=&quot;${score&gt;60}&quot;&gt;
        &lt;div&gt;条件通过&lt;/div&gt;
    &lt;/c:if&gt;
    2. 多重判断
    &lt;c:choose&gt;
        &lt;c:when test=&quot;${score&gt;=90}&quot;&gt;
            &lt;li&gt;11111111&lt;/li&gt;
        &lt;/c:when&gt;
        &lt;c:when test=&quot;${score&lt;90 &amp;&amp; score&gt;=70}&quot;&gt;
            &lt;li&gt;2222222&lt;/li&gt;
        &lt;/c:when&gt;
        &lt;c:when test=&quot;${score&lt;70 &amp;&amp; score&gt;=60}&quot;&gt;
            &lt;li&gt;3333333&lt;/li&gt;
        &lt;/c:when&gt;
        &lt;c:otherwise&gt;
            &lt;li&gt;4444444&lt;/li&gt;
        &lt;/c:otherwise&gt;
    &lt;/c:choose&gt;
6. 常量循环
    &lt;c:forEach begin=&quot;1&quot; end=&quot;4&quot; step=&quot;1&quot; varStatus=&quot;vs&quot;&gt;  ==&gt; 循环4次
        &lt;li&gt;${vs.index} -- ${vs.count} -- ${vs.first} -- ${vs.last}&lt;/li&gt;
    &lt;/c:forEach&gt;
    1. step属性设置每次循环的自增步数，默认自增1
    2. varStatus属性保存当前循环的状态
        1. vs.index：当前循环的角标
        2. vs.count：当前是第几次循环
        3. vs.first/vs.last：当前是不是第一次/最后一次循环，true/false
7. 动态循环
    &lt;%
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;111&quot;);
        request.setAttribute(&quot;list&quot;, list);
        HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;a&quot;, &quot;11&quot;);
        request.setAttribute(&quot;map&quot;, map);
    %&gt;
    1. 遍历List集合
    &lt;c:forEach items=&quot;${list}&quot; var=&quot;v&quot;&gt;
        &lt;li&gt;${v}&lt;/li&gt;
    &lt;/c:forEach&gt;
    2. var属性是每次循环的元素值;
    3. 遍历Map集合
    &lt;c:forEach items=&quot;${map}&quot; var=&quot;v&quot;&gt;
        &lt;li&gt;${v.key} -- ${v.value}&lt;/li&gt;
    &lt;/c:forEach&gt;
    4. v 表示每次循环的一条Map元素，v.key、v.value 分别表示这条数据的键、值。
</code></pre><h3 id="JSTL格式化标签库"><a href="#JSTL格式化标签库" class="headerlink" title="JSTL格式化标签库"></a>JSTL格式化标签库</h3><pre><code>1. 声明jstl核心标签库的引入
    &lt;%@taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; %&gt;
2. 可以格式化输入文本、日期、时间、数字
    1. &lt;fmt:formatNumber&gt;：使用指定的格式或精度格式化数字;
    2. &lt;fmt:parseNumber&gt;：解析一个代表着数字/货币/百分比的字符串;
    3. &lt;fmt:formatDate&gt;：使用指定的风格或模式格式化日期和时间;
    4. &lt;fmt:parseDate&gt;：解析一个代表着日期或时间的字符串;
    5. &lt;fmt:requestEncoding&gt;：设置request的字符编码;
    6. &lt;fmt:timeZone&gt;：指定时区，供其它标签使用;
    7. &lt;fmt:setTimeZone&gt;：复制一个时区对象至指定的作用域.
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/02/01/JavaEE之Servlet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/01/JavaEE之Servlet/" itemprop="url">JavaEE之Servlet</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-02-01T00:00:00+08:00">
                2016-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h2><pre><code>1. HTTP的特点：快速连接、灵活、无连接、无状态；
    1. 无连接：限制每次连接只处理一个请求，可以节省传输时间；
    2. 无状态：HTTP协议是无状态协议，对于事物处理没有记忆能力，如果第二次请求用到了第一次
    请求响应的数据，仍然需要重新传递。
2. HTTP1.1版本后支持可持续连接：连接不立即断开，而是一段时间内没任何请求时，才会断开通道；
3. HTTP的请求方式
    1. HTTP1.0定义三种请求方法：GET、POST、HEAD
    2. HTTP1.1新增5种：OPTIONS、PUT、DELETE、TRACE、CONNECT
4. Tomcat
    1. 目录结构：bin(可执行文件目录)、conf(服务器配置文件目录)、lib(jar包目录)、log(日志)
    temp(缓存文件目录)、webapps(存放web应用的目录)、work(存放JSP转换后的servlet文件)
    2. windows系统启动Tomcat：bin/startup.bat，默认IP和端口号为localhost:8080
    3. Tomcat的运行依赖JDK，必须配置JDK环境。
5. log4j：打印日志，引入log4j.jar后，把log4j.properties放在项目的src目录下；
6. 在原生的HTML中，使用 &lt;frame&gt; 引入公共的html文件
    &lt;frameset cols=&quot;25%,50%,25%&quot;&gt;
        &lt;frame src=&quot;left.html&quot; /&gt;
        &lt;frame src=&quot;content.html&quot; /&gt;
        &lt;frame src=&quot;right.html&quot; /&gt;
    &lt;/frameset&gt;
    1. 在存在层级关系的HTML页面中，window.self表示自身的window对象;
    2. window.parent表示父级HTML的window对象;
    3. window.top表示最顶级HTML的window对象.
</code></pre><h3 id="Servlet技术"><a href="#Servlet技术" class="headerlink" title="Servlet技术"></a>Servlet技术</h3><pre><code>1. Servlet是Java实现的一个接口，任何实现Servlet接口的类都可以成为Servlet；
2. Servlet运行于支持Java的应用服务器中，理论上可以响应任何类型的请求，但一般只用于扩展基于
   HTTP协议的Web服务器；
3. Servlet的特点
    1. 运行在支持Java的应用服务器上，简单方便、可移植性强；
    2. 服务器会自动根据请求调用对应的Servlet，进行请求的处理。
4. Servlet的使用(MyEclipse)
    1. 继承HttpServlet，覆写service()，处理请求、响应数据；
    public class ServletTest extends HttpServlet {
        protected void service(HttpServletRequest req, HttpServletResponse resp) {
            // super.service(req, resp); -----&gt; 务必注释掉，否则会报405
            resp.getWriter().write(&quot;Hello ServletTest&quot;);
        }
    }
    2. 在WebRoot/WEB-INF/web.xml中，配置servlet
    &lt;servlet&gt;
        &lt;servlet-name&gt;ServletTest&lt;/servlet-name&gt;
        &lt;servlet-class&gt;it.test.cn.ServletTest&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;ServletTest&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/test&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    3. 在Tomcat/webapps下新建目录servtest，把WebRoot目录中的文件复制到servtest目录中
    4. 启动Tomcat，访问ServletTest：http://localhost:8080/servtest/test
    5. webapps下的项目文件夹名称，又叫虚拟项目名；servlet的url-pattern又称为servlet别名
    6. 除了在web.xml中配置Servlet，还可以使用注解配置
    @WebServlet(name = &quot;ServletTest&quot;, urlPatterns=&quot;/test&quot;)
    public class ServletTest extends HttpServlet { ... }
    7. Servlet3.0部署 web.xml 的根节点 &lt;web-app&gt; 时，metadata-complete默认值为false，
    表示启用注解支持；设置为true时，表示只依赖 web.xml，忽略所有注解。
5. Servlet的生命周期
    1. Servlet的初始化函数：init()，第一次访问此Servlet时加载进内存，执行初始化，一直到
    关闭Tomcat服务，无论接受多少请求，都只会执行一次，即使删除本地文件，也能正常访问；
    2. service()：处理请求的方法，每次接收到请求都会执行；
    3. destory()：Servlet销毁的方法，关闭Tomcat服务时执行；
    4. 在 web.xml 中，在&lt;servlet&gt;中配置子节点&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;，
    那么此Servlet将在启动Tomcat服务时，加载进内存，执行 init() 初始化。
6. doGet()、doPost()
    1. doGet() 处理Get请求，doPost() 处理Post请求，service() 可以同时处理这两种请求;
    2. 如果Servlet中同时配置了 doGet()、doPost()、service()，那么优先执行service();
    3. service()中的 super.service() 会根据当前的请求方式，再去调用doGet()、doPost()
    所以在覆写 service() 时，通常注释掉super.service(); 否则会报405
7. HttpServletRequest：请求对象
    1. getMethod()：获取请求方法；
    2. getRequestURL()：获取请求的完整地址；
    3. getRequestURI()：请求接口地址，不包含域名和端口号；
    4. getHeader(&quot;key&quot;)：根据请求行的键获取值；
    5. Enumeration&lt;String&gt; e = req.getHeaderNames(); 所有请求行的键的枚举
    while(e.hasMoreElements()) {
        String s = e.nextElement();  --&gt; 键
    }
    6. getParameter(&quot;key&quot;)：获取用户数据(Get和Post)；
    7. getParameterValues(&quot;key&quot;)：类似Checkbox的一键多值；
8. HttpServletResponse：响应对象
    1. setHeader(&quot;key&quot;, &quot;value&quot;)：设置响应头，同键覆盖；
    2. addHeader(&quot;key&quot;, &quot;value&quot;)：添加响应头，同键不会覆盖；
    3. sendError(200, &quot;OK&quot;)：设置响应状态码；
    4. res.getWriter().write(...)：设置响应体；
    5. 中文乱码问题：
    res.setHeader(&quot;content-type&quot;, &quot;text/html;charset=utf-8&quot;);
    或 res.setContentType(&quot;text/html;charset=utf-8&quot;);
    6. text/html：表示响应体是HTML，让浏览器按照HTML进行解析；
    7. text/plain：响应体是普通字符串；
    8. text/xml：响应体是XML
</code></pre><h2 id="响应处理"><a href="#响应处理" class="headerlink" title="响应处理"></a>响应处理</h2><pre><code>1. 请求乱码问题
    1. 浏览器默认是iso8859-1编码，用户提交的数据为中文时，可能出现乱码，需要转为utf-8
    String a = new String(b.getBytes(&quot;iso8859-1&quot;), &quot;utf-8&quot;); --&gt; 通用解决方式
    2. GET请求的扩展方式：req.setCharacterEncoding(&quot;utf-8&quot;);
    同时配置Tomcat/conf/server.xml：&lt;Connector useBodyEncodingForURI=&quot;true&quot; .../&gt;
    3. POST请求的扩展方式：req.setCharacterEncoding(&quot;utf-8&quot;);
2. 请求转发
    1. 特点：一次请求，浏览器地址栏的信息不变；
    2. req.getRequestDispatcher(&quot;转发的地址&quot;).forward(req, resp);
    3. 在转发过程中，因为是同一个HttpServletRequest对象，可以从当前Servlet向目的Servlet
    传递数据：
    req.setAttribute(&quot;key&quot;, value); ---&gt; 当前Servlet设置数据
    value = req.getAttribute(&quot;key&quot;); ---------------------&gt; 目的Servlet获取数据
    4. session.removeAttribute(&quot;key&quot;); 移除键值数据。
3. 请求重定向
    1. 特点：两次请求，两个Request对象，浏览器地址栏信息改变；
    2. resp.sendRedirect(&quot;地址&quot;);
    3. 既然是两个Request对象，要实现数据传递，只能借助Session
</code></pre><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><pre><code>1. Cookie是浏览器端的数据存储，在服务器端响应数据时，告诉浏览器存储Cookie
2. 在服务器端声明Cookie
    Cookie ck = new Cookie(&quot;key&quot;, &quot;value&quot;);
    resp.addCookie(ck);
    1. 如果需要存储多个key-value，则创建多个Cookie对象；
    2. 默认情况下，Cookie临时存储在浏览器内存中，一旦关闭浏览器，Cookie将消失；
    3. 设置Cookie的有效期：ck.setMaxAge(3*24*3600); --&gt; 3天
    4. 设置有效期的Cookie会存储在浏览器本地，即使关闭了浏览器，只要未过期、就不会消失。
3. 默认情况下，每次请求都会携带当前域名下的Cookie，除非设置有效路径
    1. ck.setPath(&quot;/abc/xxx&quot;);
    2. 只有在请求 /abc/xxx 时才会携带此Cookie
4. 在服务器端获取请求对象中携带的Cookie
    Cookie[] cks = req.getCookies();
    for(Cookie c: cks) {
        String name = c.getName();
        String value = c.getValue();
    }
</code></pre><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><pre><code>1. 同一用户、不同请求的数据共享，如重定向的两个Servlet，可以使用Session存储共享数据；
2. Session存储在服务器端，标识不同用户的Session的唯一ID，会以Cookie的形式存储在浏览器端
    用户第一次访问服务器 --&gt; 服务器创建Session，并将此Session对象的JSESSIONID以Cookie
    的形式存储到浏览器中 --&gt; 同一个用户再次访问时，会携带此JSESSIONID --&gt; 通过JSESSIONID
    查找此用户的Session数据
3. Session的特点：存储在服务器端、由服务器端创建、依赖Cookie技术、一次会话
4. 创建/获取Session
    1. HttpSession hs = req.getSession();  --&gt; 没有Session对象则创建，有则获取
    2. 创建Session之后，会自动把JSESSIONID作为Cookie返回给浏览器存储；
    2. hs.getId(); --&gt; 获取Session的唯一标识JSESSIONID
5. JSESSIONID默认是临时存储，关闭浏览器则失效；
6. Session的默认存储时间是30分钟
    1. 关闭浏览器，JSESSIONID就失效了，但服务器并不知道，所以就不能及时删除对应的Session，
    这就需要设置Session的过期时间了，以免服务器端的Session数据过多；
    1. 设置Session的有效期：hs.setMaxInactiveInterval(60); --&gt; 60秒
    2. 不管是默认值还是自定义有效期，只要在有效期内发起了请求，Session有效期都会重新计时；
    3. hs.invalidate(); --&gt; 强制失效
    4. 如果Session失效了，req.getSession() 还会重新创建Session，并将ID存储到浏览器
7. Session的数据存储
    1. hs.setAttribute(&quot;key&quot;, value); --&gt; 在一个Servlet中存储Session数据
    2. value = hs.getAttribute(&quot;key&quot;);  ----&gt; 在其他Servlet中获取Session中的数据
8. 配置Session的默认有效期
    1. 在Tomcat/conf/web.xml中
    &lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt;
    2. 此配置对Tomcat下部署的所有项目有效；
    3. 在项目下的web.xml中配置 &lt;session-config&gt; , 只对本项目有效。
</code></pre><h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><pre><code>1. ServletContext：一个项目只有一个ServletContext对象；
2. ServletContext的生命周期：从服务器启动到结束；
3. 三种获取方式：
    1. ServletContext sc = this.getServletContext();
    2. ServletContext sc = this.getServletConfig().getServletContext();
    3. ServletContext sc = req.getSession().getServletContext();
4. 不同用户可以共享ServletContext数据
    1. sc.setAttribute(&quot;key&quot;, value);  --&gt; 设置
    2. value = sc.getAttribute(&quot;key&quot;); --&gt; 获取
5. 获取项目 web.xml 的全局配置数据
    1. 配置全局数据
    &lt;web-app ...&gt;
        &lt;context-param&gt;  ---&gt; 一组&lt;context-param&gt;只能存储一对键值数据，可以声明多组
            &lt;param-name&gt;key&lt;/param-name&gt;
            &lt;param-value&gt;value&lt;/param-value&gt;
        &lt;/context-param&gt;
    2. String param = sc.getInitParameter(&quot;key&quot;);
    3. sc.getInitParameterNames();  --&gt; 键的枚举
    4. 作用：将静态数据和代码进行解耦
6. 获取项目WebRoot目录下的资源路径(MyEclipse环境，WebRoot目录下文件会复制到Tomcat中)
    1. 在WebRoot下创建doc目录，在doc下新建文件a.txt
    2. String doca = sc.getRealPath(&quot;/doc/a.txt&quot;);  --&gt; 获取a.txt的路径
    3. InputStream is = sc.getResourceAsStream(&quot;/doc/a.txt&quot;);  --&gt; 获取流对象
    4. ServletContext只能获取资源文件，不能获取class文件(需要类加载器)
7. 比如，统计一段时间内的访问次数，可以使用ServletContext
</code></pre><h3 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h3><pre><code>1. ServletConfig是Servlet的专属配置对象，每个Servlet都单独拥有一个ServletConfig对象；
2. ServletConfig用于获取 web.xml 中的Servlet配置信息；
3. 获取Servlet的ServletConfig对象：
    ServletConfig config = this.getServletConfig();
4. 在 web.xml 的 &lt;servlet&gt; 下配置：
    &lt;init-param&gt;
        &lt;param-name&gt;key&lt;/param-name&gt;
        &lt;param-value&gt;value&lt;/param-value&gt;
    &lt;/init-param&gt;
5. 获取Servlet配置的键-值数据：String value = config.getInitParameter(&quot;key&quot;);
</code></pre><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><pre><code>1. Tomcat/conf/web.xml 与 Web项目/web.xml
    1. Tomcat下的web.xml为全局配置，对所有web项目有效，配置公共信息；
    2. web项目/web.xml为局部配置，只对当前项目有效；
    3. 对于相同的配置内容，web项目/web.xml的优先级更高。
2. web.xml的核心配置：
    1. 全局上下文ServletContext、Servlet配置context-param、过滤器filter、监听器listener
    2. 排列顺序是任意的，但加载顺序是固定的：
    ServletContext --&gt; context-param --&gt; listener --&gt; filter --&gt; Servlet
    3. web.xml都是在服务器启动时加载
</code></pre><h3 id="server-xml"><a href="#server-xml" class="headerlink" title="server.xml"></a>server.xml</h3><pre><code>1. Tomcat/conf/server.xml，核心节点&lt;Service&gt;，一个&lt;Server&gt;节点下可以配置多个&lt;Service&gt;
    1. HTTP协议的端口号配置
    &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; 
        connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;
    2. 服务器集群配置
    &lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;
2. 引擎节点：&lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;
    1. 一个&lt;Service&gt;节点下只能配置一个&lt;Engine&gt;节点
    2. &lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot; ...&gt;，appBase属性指定项目所在的目录
    3. &lt;Engine&gt;的defaultHost属性指定了默认的host，指向子节点&lt;Host name=&quot;localhost&quot; ...&gt;
    4. 浏览器访问Tomcat服务器时，如果输入的host在&lt;Engine&gt;下没有配置，如本机的私有地址
    192.168.xxx.xxx，则执行默认的host
3. 在&lt;Host&gt;节点下配置热部署
    &lt;Context path=&quot;/abc&quot; reloadable=&quot;true&quot; docBase=&quot;F:/WebTest&quot; /&gt;
    1. path：项目的虚拟目录名；
    2. reloadable：是否自动加载；
    3. docBase：项目所在的绝对路径；
    4. 热部署不需要在Tomcat/webapps下为项目创建文件夹(项目的虚拟目录)，所以如果项目删除，
    对应的&lt;Context/&gt;也必须删除，否则Tomcat启动会报错。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/01/10/Java之Maven/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/10/Java之Maven/" itemprop="url">Java之Maven</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-10T00:00:00+08:00">
                2016-01-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><pre><code>1. Maven是一个项目管理工具，它包含了：
    1. 一个项目对象模型(POM)，一组标准集合，一个项目生命周期，一个依赖管理系统，
    和 用来运行定义在生命周期阶段中插件目标的逻辑。
2. 依赖管理(jar包管理)
    1. Maven项目中的jar包在一个jar包仓库中，以依赖的形式存在于项目中，在代码编译时，
    再根据依赖到仓库中找到jar包；
    2. 大大减少了磁盘空间，而且避免了jar包冲突；
    3. 实现了代码可重用。
3. 项目的一键构建
    1. 构建：项目从编译、测试、运行、打包、安装、部署的整个过程都交给Maven进行管理；
    2. 一个Maven命令就可以实现构建，所以在maven/lib目录中一定集成了Tomcat插件。
4. Maven依赖于JDK，还需要配置环境变量，然后测试是否安装配置成功：mvn -v
</code></pre><h2 id="Maven仓库"><a href="#Maven仓库" class="headerlink" title="Maven仓库"></a>Maven仓库</h2><pre><code>1. 本地仓库、远程仓库(私服)、中央仓库
2. 本地仓库
    1. 在 Maven/conf/settings.xml 中，本地仓库的默认配置为 ${user.home}/.m2/repository
    2. user.home 表示C盘下的个人目录
    3. 考虑到C盘通常是系统盘，所以会自定义本地仓库的路径，如D盘下
    &lt;localRepository&gt;D:\local\repo&lt;/localRepository&gt;
3. 远程仓库(私服)：
    1. 在公司内有专门的局域网服务器作为jar包的远程仓库，又称为私服；
    2. 如果本地仓库没有需要的jar包，默认会联外网从中央仓库下载，配置了远程仓库之后，就可以在
    局域网内快速下载需要的jar包；
    3. 如果远程仓库中没有需要的jar包，则由远程仓库向中央仓库请求下载；
    4. 通常也会预先从本地上传常用的jar包到远程仓库。
4. 中央仓库：Maven的云服务器jar包仓库，存放了几乎所有的开源jar包。
</code></pre><h2 id="标准目录结构"><a href="#标准目录结构" class="headerlink" title="标准目录结构"></a>标准目录结构</h2><pre><code>1. Maven项目的目录可分为四大部分：核心代码、配置文件、测试代码、测试配置文件
2. Maven的Java项目
    1. src/main/java：核心代码
    2. src/main/resources：配置文件
    3. src/test/java：测试代码
    4. src/test/resources：测试配置文件
4. Maven的Java Web项目
    1. 除了Java项目的4个目录，还有一个 src/main/webapp，存放页面资源、JS、CSS、图片等等。
5. Maven常用命令
    1. mvn clean：清除项目中的编译信息，删除target目录；
    2. mvn compile：编译src/main/java中的核心代码，生成target目录，存放编译好的class文件
    3. mvn test：除了编译核心代码，还会编译src/main/test中的测试代码；
    4. mvn package：打包，除了编译核心代码和测试代码，还会打包成war包；
    在Maven项目/pom.xml中，默认配置有 &lt;packaging&gt;war&lt;/packaging&gt;，所以打包成war包
    5. mvn install：安装，编译核心代码和测试代码，打成war包，同时把war包安装到本地仓库中。
</code></pre><h2 id="Maven的生命周期"><a href="#Maven的生命周期" class="headerlink" title="Maven的生命周期"></a>Maven的生命周期</h2><pre><code>1. mvn clean：独立的一个生命周期，称为清理生命周期；
2. 编译(compile)、测试(test)、打包(package)、安装(install)、发布(mvn deploy)
    1. 称为默认生命周期，所以执行越靠后的命令时，会自动执行前面的命令；
    2. 其中，发布需要额外配置。
3. 另外，还有一个不常用的站点生命周期；
</code></pre><h2 id="POM模型"><a href="#POM模型" class="headerlink" title="POM模型"></a>POM模型</h2><pre><code>1. Maven的概念模型POM
</code></pre><p><img src="//hellomyshadow.github.io/2016/01/10/Java之Maven/Maven.jpg" alt="Maven"></p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/01/07/Java数据库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/07/Java数据库/" itemprop="url">Java数据库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-07T00:00:00+08:00">
                2016-01-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><pre><code>1. JDBC：Java Database Connection，为Java使用数据库提供了统一的编程接口；
2. JDBC由一组Java类和接口组成，是Java程序与数据库系统通信的标准API；
3. 所谓数据库驱动就是数据库厂商对JDBC接口的实现；
4. ORM框架：Hibernate、mybatis
</code></pre><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><pre><code>1. Driver：由数据库厂商提供，引入相关数据库驱动jar包，装载数据库驱动
    1. 装载MySql驱动
    Class.forName(&quot;com.mysql.jdbc.Driver&quot;); --&gt; MySQL5.0
    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); --&gt; MySQL6.0+
2. DriverManager：JDBC的管理层，作用于用户和驱动程序之间，在数据库和驱动程序之间建立连接
3. Connection：与特定数据库的连接会话，执行SQL语句并返回结果
    1. 连接MySQL5.0数据库
    Connection conn = DriverManager.getConnection(
        &quot;jdbc:mysql://host:port/database&quot;, &quot;username&quot;, &quot;password&quot;);
    2. 连接MySQL6.0+数据库，需要指定时区serverTimezone
    jdbc:mysql://host:port/database?useUnicode=true&amp;characterEncoding=UTF-8
    &amp;serverTimezone=Asia/Shanghai
    &amp;useSSL=false&amp;zeroDateTimeBehavior=CONVERT_TO_NULL
    3. 连接的建立是比较耗时的，内部包含Socket，实际上是建立一个Socket远程连接;
    4. 关闭连接：conn.close();
4. Statement：执行静态SQL语句并返回结果的对象
    1. Statement用于发送简单的SQL语句(不带参数)，执行SQL时需要拼接参数，有SQL注入的危险
    Statement stat = conn.createStatement();
    2. PreparedStatement：继承Statement，用于发送含有任意多个参数的SQL语句，会预编译，
    所以效率比Statement高，且防SQL注入；
    String sql = &quot;insert into users(name, time) values(?, ?)&quot;; --&gt; ? 表示占位符
    PreparedStatement stat = conn.prepareStatement(sql);
    stat.setString(1, &quot;Mack&quot;);  --&gt; 设置字符串类型的占位符，占位符索引从1开始
    stat.setDate(2, new java.sql.Date(System.currentTimeMillis())); -&gt;设置日期时间
    stat.execute();  --&gt; 执行SQL语句
    3. 如果不想关心字段类型，则使用 setObject()
    4. CallableStatement：继承自PreparedStatement，由 conn.prepareCall(sql) 创建，
    用于调用存储过程。
5. 常用方法
    1. execute()：运行语句，返回是否有结果集(true/false)
    2. executeQuery()：运行select语句，返回 ResultSet 结果集
    3. executeUpdate()：运行insert/update/delete操作，返回更新的行数
    4. close(); 关闭
6. ResultSet
    String sql = &quot;select * from users where id&gt;?&quot;;
    PreparedStatement stat = conn.prepareStatement(sql);
    stat.setInt(1, 10);
    ResultSet rs = stat.executeQuery();
    while (rs.next()) {
        int id = rs.getInt(1); --&gt; 获取第一列的数据，且字段类型为int
        String name = rs.getString(2); --&gt; 获取第二列的数据，且字段类型为String
    }
    rs.close();  stat.close(); --&gt;关闭
    1. 如果不想关心数据类型，则使用 getObject()
    2. rs.next()：迭代下一行数据，如果没有了，则返回false
7. 时间相关
    1. java.sql.Date(年月日)
    2. java.sql.Time(时分秒)
    3. java.sql.Timestamp(年月日时分秒)
8. Properties
    1. 读取和处理配置资源文件中的信息，如数据库url、database、username、password等信息
    2. 如db.properties文件，用于存储数据的配置信息：
    driver=com.mysql.cj.jdbc.Driver
    url=jdbc:mysql://localhost:3306/db_test?serverTimezone=Asia/Shanghai
    user=root
    password=123456
    3. 加载db.properties文件
    static Properties pros = null;
    static {
        pros = new Properties();
        pros.load(Thread.currentThread().getContextClassLoader()
        .getResourceAsStream(&quot;db.properties&quot;));
    }
    4. 使用db.properties中的配置信息
    Class.forName(pros.getProperty(&quot;driver&quot;));
</code></pre><h3 id="批量处理"><a href="#批量处理" class="headerlink" title="批量处理"></a>批量处理</h3><pre><code>1. PreparedStatement的预编译空间有限，数据量特别大时会发生异常，所以建议使用Statement
2. JDBC中的事务默认是自动提交，还需要设置为手动提交
    conn.setAutoCommit(false); --&gt; 禁止自动提交
    Statement stat = conn.createStatement();
    for(int i=0; i&lt;20000; i++) {
        stat.addBatch(&quot;insert into ...&quot;); --&gt;一次性插入20000条数据
    }
    stat.executeBatch();
    conn.commit(); //手动提交事务
</code></pre><h3 id="大数据量处理"><a href="#大数据量处理" class="headerlink" title="大数据量处理"></a>大数据量处理</h3><pre><code>1. CLOB：Character Large Object，用于存储大文本数据
    1. 不同数据库对大文本(大字段)有不同的处理方式，通常以流的方式处理；
    2. MySQL中的相关类型及其最大长度(字符)：TINYTEXT(2^8-1)，TEXT(2^16-1)，
    MEDIUMTEXT(2^24-1)，LONGTEXT(2^32-1或4GB)
2. JDBC操作大文本
    1. 存储
    PreparedStatement stat = conn.prepareStatement(sql);
    stat.setClob(3, new FileReader(&quot;d:/a.txt&quot;)); //接受一个流对象
    2. 读取
    ResultSet rs = ...
    while (rs.next()) {
        Clob c = rs.getClob(&quot;desc&quot;); --&gt; 指定字段名获取值
        Reader r = c.getCharacterStream(); --&gt; 获取大文本流
    }
3. BLOB：Byte Large Object，用于存储大二进制数据
    1. 不同数据库对大二进制数据(大字段)有不同的处理方式，通常以流的方式处理；
    2. MySQL中的相关类型及其最大长度(字符)：TINYBLOB(2^8-1)，BLOB(2^16-1)
    MEDIUMBLOB(2^24-1)，LONGBLOB(2^32-1或4GB)
4. JDBC操作大二进制数据
    1. 存储
    PreparedStatement stat = conn.prepareStatement(sql);
    stat.setBlob(3, new FileInputStream(&quot;d:/b.jpg&quot;)); //接受一个流对象
    2. 读取
    ResultSet rs = ...
    while (rs.next()) {
        Blob b = rs.getBlob(&quot;avatar&quot;); --&gt; 指定字段名获取值
        InputStream is = b.getBinaryStream(); --&gt;获取大二进制流
    }
</code></pre><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><pre><code>1. 事务：一组要么同时执行成功，要么同时执行失败的SQL语句，是数据库操作的一个执行单元；
2. 事务开始于：
    1. 连接数据库，并执行一条DML语句(INSERT、UPDATE、DELETE)
    2. 前一个事务结束后，又输入另一条DML语句
3. 事务结束于：
    1. 执行COMMIT或ROLLBACK语句；
    2. 执行一条DDL语句，如CREATE TABLE，这种情况会自动执行COMMIT语句；
    3. 执行一条DCL语句，如GRANT，这种情况也会自动执行COMMIT语句；
    4. 断开与数据库的连接；
    5. 执行一条DML语句，但却失败了，这种情况会执行ROLLBACK语句。
4. 四大特性：
    1. 原子性：一个事务内的所有操作是一个整体，要么全部成功，要么全部失败；
    2. 一致性：一个事务内有一个操作失败时，所有更改过的数据都必须回滚到初始状态；
    3. 隔离性：查看数据状态时，要么是另一个事务修改之前的状态，要么是修改之后的状态，不会
    出现中间状态的数据，级别：读取未提交&lt;读取已提交&lt;可重复读&lt;序列化，通常是读取已提交；
    4. 持久性：对于系统的影响是永久性的；
    conn.setAutoCommit(false); --&gt; 禁止事务自动提交
    conn.commit(); --&gt; 手动提交事务
    conn.rollback(); --&gt; 提交失败后(发生异常)，执行数据回滚
</code></pre><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><pre><code>1. Redis是内存级数据库，当Redis服务器重启，数据可能会丢失，实现持久化则需要保存在硬盘中;
2. Redis持久化机制：ROB、AOF
3. ROB：默认方式，无需配置，对内存IO性能影响较小；
    1. 在一定的时间间隔内，检测key的变化情况，然后持久化数据；
    2. 在Redis的配置文件中，默认持久化的时间间隔;
    save 900 1   ---&gt; 15分钟后，至少有1个key发生变化，则持久化一次
    save 300 10  ---&gt; 5分钟后，至少有10个key发生变化，则持久化一次
    save 60 10000  --&gt; 60秒后，至少有10000个key发生变化，则持久化一次
    3. 修改配置文件的时间间隔，手动设置持久化的频率;
    save 10 5  --&gt; 10秒后，有5个key发生了变化，就持久化一次
    4. 持久化频率的配置取决于Redis服务器的性能和具体的业务需求。
4. AOF：日志纪录方式
    1. 会纪录每一条命令的操作，且每一次命令操作后，持久化数据；
    2. 在配置文件中，默认关闭AOF机制：appendonly no
    3. 开启：appendonly yes，配置AOF持久化的频率，三选一
    # appendfsync always  ---&gt; 每次操作都进行数据持久化
    # appendfsync everysec  --&gt; 每隔1秒进行一次持久化
    # appendfsync no  --&gt; 不执行持久化
5. Redis虽然提供了数据持久化机制，但并不能保证数据一定是安全的，还需要配置关系型数据库。
</code></pre><h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h3><pre><code>1. Jedis：Java操作Redis数据库的工具，导入相关jar包；
2. 建立连接，
    Jedis jedis = new Jedis(&quot;IP&quot;, port);  --&gt; 默认IP：localhost，默认port：6379
    1. 操作字符串数据
    jedis.set(&quot;username&quot;, &quot;Mack&quot;);
    String uname = jedis.get(&quot;username&quot;);
    2. 关闭连接：jedis.close();
    3. 指定过期时间，如20s后过期删除
    jedis.setex(&quot;username&quot;, 20, &quot;Mack&quot;);
3. 哈希类型的数据：key-Map格式
    jedis.hset(&quot;user&quot;, &quot;name&quot;, &quot;Mack&quot;);
    jedis.hset(&quot;user&quot;, &quot;age&quot;, &quot;20&quot;);
    1. 参数1表示一条数据的键，参数2和参数3是这条数据的值，Map类型
    2. 获取单条数据的Map
    Map&lt;String, String&gt; user = jedis.hgetAll(&quot;key&quot;);
    3. 获取单条数据中的Map，同时根据Map的键获取值
    String name = jedis.hget(&quot;user&quot;, &quot;name&quot;);
4. 列表类型的数据：key-LinkedList格式，类似于管道，有序，支持重复数据
    jedis.lpush(&quot;mylist&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;); --&gt;从左边存一组数据，顺序为 c b a
    jedis.rpush(&quot;mylist&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;); --&gt;从右边存一组数据，顺序为 a b c
    1. 参数1表示这条数据的键，其后的参数都是列表中的值；
    2. 从左边开始取数据：
    List&lt;String&gt; mylist = jedis.lrange(&quot;mylist&quot;, 0, -1);
    3. 参数1表示一条数据的键，参数2和参数3分别表示起始角标，-1表示取到最后一个；
    [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
    4. 弹出元素，相当于从Redis中删除
    String leftEle = jedis.lpop(&quot;mylist&quot;);  --&gt; 从左边弹出一个元素，&quot;c&quot;
    String rightEle = jedis.rpop(&quot;mylist&quot;); --&gt; 从右边弹出一个元素，&quot;c&quot;
5. 集合类型的数据：key-Set格式，无序，不支持重复元素
    jedis.sadd(&quot;myset&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
    Set&lt;String&gt; myset = jedis.smembers(&quot;myset&quot;);
6. 有序集合的数据：key-sortedset格式，不允许重复元素，元素可以排序
    jedis.zadd(&quot;myzset&quot;, 10, &quot;aa&quot;);
    jedis.zadd(&quot;myzset&quot;, 2, &quot;bb&quot;);
    jedis.zadd(&quot;myzset&quot;, 30, &quot;cc&quot;);
    1. 参数1表示一条数据的键，参数2表示排序的依据，数值越小，顺序越靠前，参数3是元素值;
    2. 获取一条数据
    Set&lt;String&gt; myzset = jedis.zrange(&quot;myzset&quot;, 0, -1);  --&gt;[&quot;bb&quot;, &quot;aa&quot;, &quot;cc&quot;]
</code></pre><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><pre><code>1. Jedis自带连接池：JedisPool
    JedisPool pool = new JedisPool(); --&gt; 默认ip：localhost，默认port：6397
    Jedis jedis = pool.getResource(); --&gt; 获取Jedis对象
2. 连接池的配置对象JedisPoolConfig
    JedisPoolConfig config = new JedisPoolConfig();
    config.setMaxTotal(50);  --&gt; 最大连接数50个
    config.setMaxIdle(10);  --&gt; 最大空闲连接10个
    JedisPool pool = new JedisPool(config, ...);
3. 通过properties文件，配置数据库信息
    1. 在src目录下创建 jedis.properties
        host=127.0.0.1
        port=6379
        maxTotal=50
        maxIdle=10
    2. 在工具类JedisPoolUtil.java中加载配置文件
    static {
        InputStream is = JedisPoolUtil.class.getClassLoader()
            .getResourceAsStream(&quot;jedis.properties&quot;);
        Properties prop = new Properties();
        prop.load(is);
        JedisPoolConfig config = new JedisPoolConfig();
        int total = Integer.parseInt(prop.getProperty(&quot;maxTotal&quot;));
        config.setMaxTotal(total);
        int idle = Integer.parseInt(prop.getProperty(&quot;maxIdle&quot;));
        config.setMaxIdle(idle);
    }
</code></pre><h3 id="缓存优化"><a href="#缓存优化" class="headerlink" title="缓存优化"></a>缓存优化</h3><pre><code>1. 第一次从Redis查询数据时，如果不存在，则去MySQL中查询，并把查询结果存入Redis
2. 第二次从Redis查询数据时，Redis中已经存在了，不需要再去MySQL中查询了；
3. Redis只适合缓存一些不经常变化的数据；
4. MySQL中的数据一旦发生了变化，在其增删改的方法中，及时更新Reids中的缓存数据。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/01/06/Java动态性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/06/Java动态性/" itemprop="url">Java动态性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-06T00:00:00+08:00">
                2016-01-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><h3 id="类的反射"><a href="#类的反射" class="headerlink" title="类的反射"></a>类的反射</h3><pre><code>1. 获取Class对象的三种方式
    1. 对象.getClass()
    2. 类名.class
    3. Class.forName(&quot;包名.类名&quot;);
2. 获取类名
    Class clz = Class.forName(&quot;com.sxt.serv.Channel&quot;);
    clz.getName(); --&gt; 获取完整路径(包名)的类名
    clz.getSimpleName(); --&gt; 只获取类名 
3. 获取构造器Constructor
    1. clz.getConstructor(参数类型.class...); 只能获取public构造器
    2. clz.getDeclaredConstructor(参数类型.class...); 获取任意构造器
    Constructor&lt;Channel&gt; cons = clz.getDeclaredConstructor(String.class);
    cons.setAccessible(true); --&gt;默认不允许访问private成员，必须跳过安全检查
    Channel cha = cons.newInstance(&quot;123&quot;); -- &gt;传递参数，创建对象
    3. 参数类型都是可变长参数，对于无参构造器，则不传任何参数
    Channel cha = clz.newInstance(); --&gt;使用public无参构造的创建对象，从JDK9开始废弃
    Channel cha = clz.getConstructor().newInstance();
4. 获取属性Field
    1. clz.getField(&quot;属性名&quot;); 只能获取public修饰的属性
    2. clz.getDeclaredField(&quot;属性名&quot;); 获取任意的属性
    3. 操作(私有)属性
    Field id = clz.getDeclaredField(&quot;id&quot;); //int id
    id.setAccessible(true);  --&gt;跳过安全检查
    id.set(cha, 10); --&gt;设置对象cha上的id属性
    int i = id.get(cha); --&gt;获取id属性值
5. 获取方法Method
    1. clz.getMethod(&quot;方法名&quot;, 参数类型.class...); 只能获取public修饰的方法
    2. clz.getDeclaredMethod(&quot;方法名&quot;, 参数类型.class...); 获取任意的方法
    3. 如果方法是无参的，参数类型通常传null，也可以什么不传
    4. 调用(私有)方法
    Method m = clz.getDeclaredMethod(&quot;setAge&quot;, int.class);
    m.setAccessible(true);
    m.invoke(cha, 12);  //cha.setAge(12)
</code></pre><h3 id="泛型的反射"><a href="#泛型的反射" class="headerlink" title="泛型的反射"></a>泛型的反射</h3><pre><code>1. 泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换的麻烦，一旦编译完成，
   所有和泛型相关的类型都会全部擦除；
2. 为了让反射可以操作泛型，Java新增ParameterizedType、GenericArrayType、TypeVariable、
    WildcardType来代表不能被归到Class类中的类型、但又和原始类型齐名的类型；
    1. ParameterizedType：表示参数化的类型，比如Collection&lt;String&gt;
    2. GenericArrayType：表示元素类型是参数化类型，或类型变量的数组类型
    3. TypeVariable：各种类型变量的公共父接口
    4. WildcardType：代表通配符类型表达式，比如 ?，? extends Number，? super Integer
3. ParameterizedType
    public class TestTable {
        public void test01(Map&lt;String, TableBean&gt; map, List&lt;TableBean&gt; list) { }
        public Map&lt;Integer, TableBean&gt; test02() { return null; }
    }
    1. 获取参数泛型
    Method m = TestTable.class.getMethod(&quot;test01&quot;, Map.class, List.class);
    Type[] paramTypes = m.getGenericParameterTypes(); //获取带泛型的参数类型
    for (Type t: paramTypes) {
        System.out.println(&quot;paramType: &quot; + t); //带泛型的参数类型
        if (t instanceof ParameterizedType) {
            //获取真正的泛型类型
            Type[] typeArgs = ((ParameterizedType) t).getActualTypeArguments();
            for (Type gt: typeArgs) {
                System.out.println(&quot;参数上的泛型类型：&quot; + gt);
            }
        }
    }
    2. 获取返回的参数泛型
    Method m = TestTable.class.getMethod(&quot;test02&quot;, null);
    Type at = m.getGenericReturnType(); //获取带泛型的返回值类型
    if (at instanceof ParameterizedType) {
        //获取真正的泛型类型
        Type[] typeArgs = ((ParameterizedType) at).getActualTypeArguments();
        for (Type gt: typeArgs) {
            System.out.println(&quot;返回值的泛型类型：&quot; + gt);
        }
    }
</code></pre><h2 id="动态编译"><a href="#动态编译" class="headerlink" title="动态编译"></a>动态编译</h2><pre><code>1. Java6.0引入动态编译，有两种方式
    1. Runtime调用javac，启动新的进程去操作
    Runtime run = Runtime.getRuntime();
    Process p = run.exec(&quot;javac -cp d:/workplace/ HelloWorld.java&quot;);
    2. JavaCompiler动态编译
2. JavaCompiler
    1. 动态编译Java文件
    JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
    int result = compiler.run(null, null, null, &quot;E:/workplace/HelloWorld.java&quot;);
    ---&gt; result为0，表示编译成功，生成class文件
    2. 动态编译java字符串
    String text = &quot;public class Hi { public static void main(String[] args)
        { System.out.println(\&quot;hi\&quot;); } }&quot;;
    ---&gt; 需要把这个字符串通过IO流存成一个临时文件(Hi.java)，再进行动态编译
3. Runtime运行编译好的class文件
    Runtime run = Runtime.getRuntime();
    Process p = run.exec(&quot;java -cp E:/workplace HelloWorld&quot;);
    InputStream is = p.getInputStream();
    BufferedReader br = new BufferedReader(new InputStreamReader(is));
    String info = &quot;&quot;;
    while (null != (info=br.readLine())) {
        System.out.println(info); //hi
    }
4. 反射运行编译好的class文件
    URL[] urls = new URL[] {new URL(&quot;file:/&quot; + &quot;E:/workplace/&quot;)};
    URLClassLoader loader = new URLClassLoader(urls);
    Class clz = loader.loadClass(&quot;HelloWorld&quot;);
    Method me = clz.getMethod(&quot;main&quot;, String[].class);
    //由于可变参数在JDK5.0才引入，传递数组时，如new String[]{&quot;a&quot;, &quot;b&quot;}，会被解析为
    //invoke(null, &quot;a&quot;, &quot;b&quot;)，所以需要使用Object强转类型
    me.invoke(null, (Object)new String[]{});
</code></pre><h2 id="动态执行JavaScript代码"><a href="#动态执行JavaScript代码" class="headerlink" title="动态执行JavaScript代码"></a>动态执行JavaScript代码</h2><pre><code>1. JDK6.0新增脚本引擎，使Java应用可以通过一套固定的接口与各种脚本引擎交互，从而在Java平台
   上调用各种脚本语言
2. JavaScript引擎：Rhino
    1. Rhino是一种使用Java编写的JS的开源实现，原由Mozilla开发，现已被集成到JDK6.0
    ScriptEngineManager sem = new ScriptEngineManager();
    ScriptEngine engine = sem.getEngineByName(&quot;JavaScript&quot;);
    2. 可以执行字符串形式的JS语句，也可以执行JS脚本文件。
</code></pre><h2 id="动态字节码操作"><a href="#动态字节码操作" class="headerlink" title="动态字节码操作"></a>动态字节码操作</h2><pre><code>1. 运行时操作字节码可以实现：
    1. 动态生成新的类
    2. 动态改变某个类的结构(增删改 新的属性/方法)
2. 优点：比反射开销小、性能高，与反射相辅相成；
3. 常见的字节码操作类库
    1. BCEL：可以深入JVM汇编语言进行类操作的细节，拥有丰富的JVM指令级支持；
    2. ASM是一个轻量级Java字节码操作框架，直接涉及到JVM底层的操作和指令；
    3. BECL和ASM的效率最高，因为是在JVM指令层次上进行操作，学习难度也比较大；
    4. CGLIB：一个强大的、高性能、高质量的Code生成类库，基于ASM实现；
    5. Javassist：一个开源的Java字节码类库，强调的是源代码级别，性能跟CGLIB差不多，
    但使用简单，应用于很多开源框架。
4. Javassist
    1. 最外层API与Java反射的API颇为相似，如CtClass，CtMethod，CtField
    2. 局限性：只适合常规操作
</code></pre><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><pre><code>1. 内置注解：@Override，@Deprecated，@SuppressWarnings，@Target...
2. @interface 自定义注解，自动继承Annotation接口
    public @interface 注解名 { ... }
3. 元注解：负责解释其他注解，Java定义了4个标准的meta-annotation类型(元注解)
    1. @Target、@Retention、@Documented、@Inherited
    2. 这些类型和它们所支持的类在java.lang.annotation包中。
4. @Target：声明注解的使用范围，由ElementType定义可取的值
    1. package包：PACKAGE，@Target(value=ElementType.PACKAGE)
    2. 类、接口、枚举、Annotation类型：TYPE
    3. 类成员(构造方法、成员变量、方法、枚举值)：CONSTRUCTOR描述构造器，FIELD描述域(字段)，
    METHOD描述方法
    4. 方法参数和本地变量：LOCAL_VARIABLE用于描述局部变量，PARAMETER用于描述参数
    @Target(value=ElementType.METHOD)  --&gt; 声明此注解只能在方法上使用
    public @interface TestAnnot { ... }
    5. value可以取多个值，扩大应用范围
    @Target(value={ElementType.METHOD, ElementType.TYPE})
    public @interface TestAnnot { ... }  --&gt;此注解可以同时修饰方法、类
5. @Retention：表示需要在什么级别保存该注释信息，用于描述注解的生命周期
    1. SOURCE：在源文件中有效
    2. CLASS：在class文件中有效
    3. RUNTIME：在运行时有效，被反射机制读取(反射在运行期有效)
    @Target(value={ElementType.METHOD, ElementType.TYPE})
    @Retention(RetentionPolicy.RUNTIME)
    public @interface TestAnnot { ... }
</code></pre><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><pre><code>1. 定义注解的成员
    @Target(value={ElementType.METHOD, ElementType.TYPE})
    @Retention(RetentionPolicy.RUNTIME)
    public @interface TestAnnot {
        String stuName() default &quot;&quot;;  --&gt;参数类型String，参数名stuName，默认值&quot;&quot;
        int age() default 0;
        String[] schools() default {};
    }
2. 使用自定义注解
    @TestAnnot
    public class TestMain {
        @TestAnnot
        public void test(){ }
    }
    1. 如果没有注解中的成员没有默认值，则必须在使用时赋予值，否则会报编译期错误
    @TestAnnot(uname = &quot;&quot;, age = -1, schools = {})
    public class TestMain {
        @TestAnnot(uname = &quot;abc&quot;, age = 0, schools = {&quot;a&quot;, &quot;b&quot;})
        public void test(){ }
    }
    2. 如果注解中只有一个成员(通常定义为value)，在使用赋值时，可以不指定参数名
    @Target(value=ElementType.TYPE)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface MyAnnot {
        String value();
    }
    @MyAnnot(&quot;abc&quot;)
    public class TestMain { ... }
3. 注解的解析，配合反射，以数据库表的ORM映射为例
    1. 表的注解
    @Target(value = {ElementType.TYPE})
    @Retention(RetentionPolicy.RUNTIME)
    public @interface Table {
        String value(); --&gt; 记录表名
    }
    2. 表的字段约束
    @Target(value = ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface Column {
        String columnName(); --&gt; 字段名
        String type(); --&gt; 字段类型
        int length(); --&gt; 长度
    }
    3. 表映射的JavaBean
    @Table(&quot;user&quot;)
    public class UserBean {
        @Column(columnName = &quot;id&quot;, type = &quot;int&quot;, length = 10)
        private int id;
        @Column(columnName = &quot;name&quot;, type = &quot;varchar&quot;, length = 10)
        private String username;
        @Column(columnName = &quot;age&quot;, type = &quot;int&quot;, length = 3)
        private int age;
        ......
    }
    Class clz = Class.forName(&quot;it.test.cn.UserBean&quot;);
    4. 获取类上的注解
    Annotation[] annots = clz.getAnnotations(); --&gt; 获取类UserBean上的所有注解
    Table tab = (Table) clz.getAnnotation(Table.class); --&gt; 获取指定的注解
    String val = tab.value();  --&gt; 获取注解成员的值&quot;user&quot;
    5. 获取类属性上的注解(类方法同理)
    Field f = clz.getDeclaredField(&quot;username&quot;); --&gt; 获取属性username
    Column col = f.getAnnotation(Column.class); --&gt; 获取属性上的注解
    col.columnName();//&quot;name&quot;  col.type();//&quot;varchar&quot;  col.length();//10
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/01/05/Java网络编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/05/Java网络编程/" itemprop="url">Java网络编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-05T00:00:00+08:00">
                2016-01-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Ip相关的类：InetAddress"><a href="#Ip相关的类：InetAddress" class="headerlink" title="Ip相关的类：InetAddress"></a>Ip相关的类：InetAddress</h2><pre><code>1. 获取本机的Ip、hostname
    InetAddress addr = InetAddress.getLocalHost();
    String ip = addr.getHostAddress();
    String hostName = addr.getHostName(); //计算机名
2. 根据域名获取Ip、hostname
    InetAddress addr = InetAddress.getByName(&quot;www.baidu.com&quot;); //内部是NDS解析
    String ip = addr.getHostAddress(); //Ip
    String hostName = addr.getHostName(); //域名www.baidu.com
3. 如果getByName(&quot;Ip地址&quot;)，getHostName()获取的仍是Ip，而不是域名；
4. 子类：Inet4Address、Inet6Address
</code></pre><h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><pre><code>1. 端口号表示一个16位的二进制整数，2个字节，对应十进制0-65535
    1. 公认端口0-1023，如80是http协议的默认端口
    2. 注册端口1024-49151(分配给用户进程/应用程序)
    3. 动态/私有端口49152-65535
2. windows命令
    1. netstat -ano  ---&gt; 查看所有的端口号
    2. netstat -ano|findstr &quot;808&quot;  ---&gt; 查看指定端口号
    3. tasklist|findstr &quot;808&quot;  ---&gt; 查看指定进程
3. InetSocketAddress：包含端口号，用于socket通信
    InetSocketAddress s = new InetSocketAddress(&quot;127.0.0.1/localhost&quot;, 8080);
    s.getHostName();  s.getAddress();  s.getPort();
</code></pre><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><pre><code>1. URL和URN都是URI的子集
    1. URI：统一资源标识符，表示一个资源，比如一个具体的人
    2. URL：统一资源定位符，用地址定位一个资源，比如XX省XX市XX区...XX单元XX室的主人
    3. URN：统一资源名称，用名称定位一个资源，但不明确资源的位置，比如身份证号+姓名去找人
2. 网络三大基石：HTML、HTTP、URL
3. URL由4部分组成：协议、资源所在的主机域名、端口号、资源文件名
4. URL url = new URL(&quot;http://www.baidu.com:80/index.html#aa?xx=xxx&quot;);
    1. url.getProtocol()：协议名
    2. url.getDefaultPort()：获取与此URL关联的协议的默认端口号
    3. url.getHost()：主机名/域名
    4. url.getFile()：端口号后的所有内容
    5. url.getPath()：端口号后、参数前的内容
    6. url.getQuery()：参数部分
    7. url.getRef()：锚点
5. 相对路径构建URL
    URL u1 = new URL(&quot;http://www.baidu.com/aa/&quot;);
    URL u2 = new URL(u, &quot;b.html&quot;); --&gt; http://www.baidu.com/aa/b.html
6. 发起请求
    1. 抓取网络数据，非浏览器访问
    InputStream is = url.openStream();
    BufferedReader br = new BufferedReader(new InputStreamReader(is, &quot;UTF-8&quot;));
    String msg = null;
    while(null != (msg=br.readLine())) {
        System.out.println(msg);
    }
    br.close();
    2. 模拟浏览器访问
    HttpURLConnection conn = (HttpURLConnection) url.openConnection();
    conn.setRequestMethod(&quot;GET&quot;);  --&gt;设置请求方式
    conn.setRequestProperty(&quot;User-Agent&quot;, &quot;value&quot;); --&gt;设置请求头
    BufferedReader br = new BufferedReader(
        new InputStreamReader(conn.getInputStream(), &quot;GBK&quot;));
</code></pre><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><pre><code>1. DatagramSocket：用于发送/接受数据包的套接字；
2. DatagramPacket：数据包；
3. 发送端
    DatagramSocket client = new DatagramSocket(8888);
    String data = &quot;Hello I&apos;m Client&quot;;
    byte[] bys = data.getBytes();
    //发送给&quot;127.0.0.1:9999&quot;
    DatagramPacket packet = new DatagramPacket(bys, 0, bys.length, 
        new InetSocketAddress(&quot;127.0.0.1&quot;, 9999));
    client.send(packet);
    client.close();
4. 接收端
    DatagramSocket server = new DatagramSocket(9999); --&gt; 监听端口9999
    byte[] container = new byte[1024*60];
    DatagramPacket packet = new DatagramPacket(container, 0, container.length);
    server.receive(packet);
    byte[] bys = packet.getData();
    int len = packet.getLength();
    String data = new String(bys, 0, len);
    server.close();
</code></pre><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><pre><code>1. 服务端：ServerSocket
    ServerSocket server = new ServerSocket(8889);
    Socket client = server.accept(); --&gt;阻塞式，等待客户端连接
    DataInputStream dis = new DataInputStream(client.getInputStream());
    String data = dis.readUTF(); --&gt;客户端的数据
    dis.close();
    client.close();
    server.close();
    1. 通过每一次连接的client，向对应的客户端响应数据
    DataOutputStream dos = new DataOutputStream(client.getOutputStream());
    dos.writeUTF(&quot;hello I&apos;m Server&quot;); --&gt;向客户端响应数据
    dos.flush();
    dos.close();
2. 客户端：Socket
    //指定服务端的Ip和端口号，发起连接请求
    Socket client = new Socket(&quot;127.0.0.1&quot;, 8889);
    DataOutputStream dos = new DataOutputStream(client.getOutputStream());
    dos.writeUTF(&quot;hello I&apos;m Client&quot;); --&gt;向服务端写入数据
    dos.flush();
    dos.close();
    client.close();
    1. client接收服务端的响应数据
    DataInputStream dis = new DataInputStream(client.getInputStream());
    String data = dis.readUTF(); --&gt;接收响应数据
    dis.close();
3. HTTP底层正是TCP，浏览器作为客户端，也可以直接访问TCP服务器端.
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/01/03/Java多线程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/03/Java多线程/" itemprop="url">Java多线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-03T00:00:00+08:00">
                2016-01-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><pre><code>1. 线程状态
</code></pre><p><img src="https://i.imgur.com/vLw2xgt.jpg" alt></p>
<pre><code>    1. Thread.State：线程的状态，NEW(尚未启动的线程)、RUNNABLE、BLOCKED、WAITING、
    TIMED_WAITING、TERMINATED(已退出的线程)
    2. RUNNABLE：包含就绪状态和运行状态；
    3. getState()：获取线程的状态。
2. 线程的 stop() 方法已经被废弃，因为线程的终止可以通过一个boolean型的标志位变量完成；
3. sleep() yield() join()
    1. sleep() 表示休眠，会阻塞线程，且不会释放锁，睡眠时间到了之后，重新进入就绪状态；
    常用于模拟网络延迟、倒计时...
    2. yield() 则礼让出CPU的执行权，线程进入就绪状态；
    3. join() 插队，待此线程执行完成后，再执行其他线程，这段时间内，其他线程处于阻塞状态；
4. 优先级：线程的优先级并不能决定哪个线程先执行，优先级高的线程被执行的概率相对会高一些；
    1. setPriority(priority)：设置线程的优先级，范围1-10，在 start() 之前设置有效；
    2. Thread.MIN_PRIORITY，Thread.MAX_PRIORITY，Thread.NORM_PRIORITY：1，10，5
5. 线程分为用户线程和守护线程，默认的线程都是用户线程
    1. 虚拟机JVM会确保所有的用户线程执行完毕，再退出程序，但不会等待守护线程执行完毕；
    2. 如后台记录操作日志、监控内存使用等
    3. setDaemon(true)：把线程设置为守护线程，在 start() 之前调用。
6. Thread.currentThread()：获取当前线程；
7. isAlive()：线程是否还活着。
</code></pre><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><pre><code>1. 线程同步：synchronized，队列
    1. 若将一个大的方法声明为synchronized，将会大大影响效率；
    2. 与大的synchronized方法相比，synchronized块能在一定程度上减少性能的损失；
    3. 使用 synchronized 的关键在于，第一要锁对目标，第二要取舍synchronized块的面积。
2. 同步块的锁：
    1. 同步方法的锁是this，表示当前对象，不可改变；
    2. 同步块的锁可以指定，锁住的目标更明确，还能减小锁的面积。
3. 并发容器：CopyOnWriteArrayList，加锁的ArrayList，保证在写入数据时的安全；
4. 死锁：相互持有对方的锁，需要避免锁的嵌套。
</code></pre><h3 id="并发协作"><a href="#并发协作" class="headerlink" title="并发协作"></a>并发协作</h3><pre><code>1. 生产者与消费者模式：线程同步问题，生产者和消费者共享同一资源，且生产者和消费者相互依赖；
    1. synchronized只是阻止并发更新同一共享资源，实现同步，但并不能实现线程间的通信；
    2. 管程法：利用并发缓冲容器实现；
    3. 信号灯法：借助标志位实现；
    4. wait()，notify()，notifyAll()
2. 管程法
    1. 容器满了，则生产者等待；容器为空时，则消费者等待；
    2. 容器中有元素时，唤醒消费者取出；消费者取出元素之后，唤醒生产者存入；
    class Food {  --&gt; 生产/消费的对象
        public int count;
        public Food(int c) { this.count = c; }
    }
    3. 容器具备同步的存入和取出方法
    class Container {
        private Food[] foodList = new Food[10];  private int count = 0;
        public synchronized void push(Food f) {  ---&gt; 同步方法的锁默认是this
            if ((this.foodList.length-1)==count) {
                this.wait(); --&gt; 容器满了，生产者进入等待
            }
            this.foodList[count] = f;  count++;
            this.notifyAll();   ----&gt; 容器中已经有了元素，唤醒消费者
        }
        public synchronized Food pop() {
            if (count &lt; 1) {
                this.wait(); --&gt; 容器为空，生产者进入等待
            }
            count--;  Food f = this.foodList[count];
            this.notifyAll();   ----&gt; 消费者取出了元素，唤醒生产者
            return f;
        }
    }
    4. 生产者和消费者的线程
    class Producter extends Thread {
        private Container con;
        public Producter(Container con) { this.con = con; }
        public void run() {
            for (int i=0; i&lt;100; i++) {
                this.con.push(new Food(i+1)); ---&gt; 生产者向容器中存入元素
                System.out.println(&quot;生产第 &quot;+(i+1)+&quot; 个&quot;);
            }
        }
    }
    class Customer extends Thread {
        private Container con;
        public Customer(Container con) { this.con = con; }
        public void run() {
            for (int i=0; i&lt;100; i++) {
                Food food = this.con.pop(); ---&gt; 消费者从容器中取出元素
                System.out.println(&quot;消费第 &quot;+(food.count)+&quot; 个&quot;);
            }
        }
    }
    5. 生产者和消费者操作的必须是同一个容器
    Container con = new Container();
    Producter p = new Producter(con);  Customer c = new Customer(con);
    p.start();  c.start();
3. 信号灯法
    1. 标志位为true，让生产者等待，消费者运行完成后，设置标志位为false，并唤醒生产者；
    2. 反之，让消费者等待，生产者运行完成后，设置标志位为true，并唤醒消费者；
    class Tv {
        private String show;   --&gt; 生产和消费的元素
        private boolean flag;  --&gt; 标志位
        public synchronized void play(String show) {
            if (this.flag) {
                this.wait();   --&gt; 生产者等待
            }
            this.show = show;
            this.flag = !this.flag;  --&gt; 标志位取反
            this.notifyAll();  --&gt; 唤醒消费者
        }
        public synchronized String watch() {
            if (!this.flag) {
                this.wait();   --&gt; 消费者等待
            }
            this.flag = !this.flag;  --&gt; 标志位取反
            this.notifyAll();  --&gt; 唤醒生产者
            return show;
        }
    }
    3. 生产者和消费者的线程
    class Actor extends Thread {
        private Tv tv;
        public Actor(Tv tv) {  this.tv = tv;  }
        public void run() {
            for (int i=0; i&lt;100; i++) {
                String show = i%2==0?&quot;跳舞&quot;:&quot;唱歌&quot;;
                this.tv.play(show);
                System.out.println(&quot;生产者：&quot; + show + &quot;::&quot; + i);
            }
        }
    }
    class Audience extends Thread {
        private Tv tv;
        public Audience(Tv tv) {  this.tv = tv;  }
        public void run() {
            for (int i=0; i&lt;100; i++) {
                System.out.println(&quot;消费者：&quot; + this.tv.watch() + &quot;::&quot; + i);
            }
        }
    }
    Tv tv = new Tv();
    Actor actor = new Actor(tv);  Audience audience = new Audience(tv);
    actor.start();  audience.start();
</code></pre><h2 id="定时调度"><a href="#定时调度" class="headerlink" title="定时调度"></a>定时调度</h2><pre><code>1. Timer和TimerTask
    class EvenTask extends TimerTask {  --&gt; 任务线程
        public void run() { ... }
    }
    Timer t = new Timer();  --&gt; 定时器
    EvenTask task = new EvenTask();
    1. t.schedule(task, 3000);  ----&gt; 3s后执行一次
    2. t.schedule(task, 3000, 1000);  ----&gt; 3s后每隔1s执行一次
    3. t.schedule(task, date);  -----&gt; 指定时间定时执行
2. 调度框架：quartz
</code></pre><h2 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h2><pre><code>1. HappenBefore：虚拟机优化代码顺序，导致执行顺序可能与编写代码的顺序不一致，称为指令重排
2. 指令重排是编译器或运行时环境为了优化程序性能而采取的对指令进行重新排序执行的一种手段
3. CPU执行指令的步骤
    从内存中获取一条指令 --&gt; 解码指令，取值 --&gt; 操作值，得到结果 --&gt; 把结果写回寄存器中
4. 编译器和处理器在重排指令时，遵守数据依赖性，不会改变存在数据依赖关系的两个操作的执行顺序
5. 在虚拟机层面和硬件层面，都可能出现指令重排
    1. 在虚拟机层面：内存操作速度远慢于CPU运行速度，为了避免CPU空置的影响；
    2. 在硬件层面：CPU速度比缓存速度快。
</code></pre><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><pre><code>1. volatile保证线程间的可见性，当线程A修改变量X后，其后的其他线程能看到变量X的变动；
2. 线程有自己的工作内存，且彼此独立、互补可见；
    1. 工作内存不仅包含了线程内部定义的局部变量，也包含了线程所需要使用的共享变量的副本；
    2. 为了提高效率，线程并不会每次都从主内存中读取共享变量。
3. volatile的变量符合两个规则
    1. 线程对变量修改之后，要立刻写到主内存
    2. 线程对变量读取的时候，要从主内存中读，而不是缓存(工作内存)
4. volatile不能保证原子性
    1. 比如x=x+1分为3步：从内存中获取x，对x加1，再把结果写回内存中
    2. volatile并不能保证这3步同时发生，只能保证变量x的结果发生变化后，对每个线程都可见
5. volatile是一个轻量级的synchronized
    private volatile static int num = 0;
    new Thread(()-&gt;{
        while (num==0) {} ---&gt; 不执行任何具体任务
    }).start();
    Thread.sleep(1000);
    num = 1;
    1. 如果不使用volatile修饰，1s后的num虽然已经置为1，但因为子线程执行空的while循环，
    造成CPU很繁忙，来不及把变量num同步给子线程的内存空间，所以子线程始终不会结束；
    2. 一旦while(num==0){}中执行了具体任务，CPU就有可能把num=1同步给子线程的内存空间，
    结束while循环；
    3. 变量num使用volatile修饰，子线程中的while(num==0){}每次都从主内存中读取num的值，
    所以在1s之后，num被置为1，也会立即被子线程的while(num==0)所感知，终止循环。
6. 单例模式之懒汉式的并发控制：双重检测、指令重排
    public class LittleBable {
        //volatile防止new对象的过程中指令重排，造成其他线程访问一个还有初始化完成的对象
        private static volatile LittleBable instance;
        private LittleBable() {}
        public static LittleBable getInstance() {
            if (null != instance) { return instance; } //双重检测，防止不必要的同步
            synchronized (LittleBable.class) {
                if (null == instance) {  instance = new LittleBable(); }
            }
            return instance;
        }
    }
</code></pre><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><pre><code>1. ThreadLocal是线程局部变量的存储空间，虽然被多个线程共享，但能使线程安全；
    private static ThreadLocal&lt;Interger&gt; tl = new ThreadLocal&lt;&gt;();
    1. JDK建议把ThreadLocal声明为private static
    2. 泛型为Integer，默认值为null   --&gt; tl.get(); --&gt; null
    3. 指定默认值
    new ThreadLocal&lt;&gt;(){ protected Integer initialValue(){ return 20; } };
    4. JDK8的新特性
    private static ThreadLocal&lt;Interger&gt; tl = ThreadLocal.withInitial(()-&gt;20);
    5. 设置新的值：tl.set(100);
2. 多个线程在获取/设置ThreadLocal时，相互不会影响；
    tl.set(100); --&gt; 在主线程中修改为100 --&gt; tl.get(); --&gt; 100
    new Thread(()-&gt;{
        tl.get(); --&gt; 在子线程中仍是默认值20 --&gt; tl.set(100);  --&gt; tl.get(); --&gt; 100
    }).start();
3. 上下文环境问题
    class TestRun implements Runnable {
        public TestRun() { tl.set(33); }
        public void run() { tl.get();  -----&gt; 20 }
    }
    new Thread(new TestRun()).start(); --&gt; 在主线程中执行
    1. 创建对象是在主线程中进行的，所以TestRun的构造函数也是在主线程中，tl.set(33); 设置
    的是主线程的ThreadLocal变量
    2. run()才是在子线程中执行的，所以获取ThreadLocal的变量仍是默认值20
</code></pre><h3 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h3><pre><code>1. InheritableThreadLocal：上下文环境的可继承ThreadLocal
2. 子线程会从当前上下文环境拷贝一份ThreadLocal，重新设置ThreadLocal也不会影响原上下文
    private static ThreadLocal&lt;Integer&gt; tl = new InheritableThreadLocal&lt;&gt;();
    tl.set(100);
    new Thread(()-&gt;{
        tl.get();  ---&gt; 100
        tl.set(200);  ---&gt; tl.get(); --&gt; 200
    }).start();
    tl.get();  --&gt; 100
3. ThreadLocal的应用
    1. 最常见的是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息...
    2. Hibernate的Session工具类：HibernateUtil
    3. 通过不同的线程对象设置Bean属性，保证各个线程Bean对象的独立性。
</code></pre><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><pre><code>1. 锁作为保证并发共享数据一致性的工具，大多数内置锁都是可重入的，也就是可以延续使用；
2. 可重入
    1. 如果某个线程试图获取一个已经由它自己持有的锁时，那么此请求会立即成功，且会将这个锁
    的计数值加1；
    2. 当线程退出同步代码块时，计数器会递减，当计数值为0时，锁释放。
    3. 如果没有可重入锁的支持，在第二次试图获得锁时，将进入死锁状态；
    synchronized(this) { --&gt; 第一次获取锁
        while(true) {
            synchronized(this) { } --&gt; 第二次获取同一把锁
        }
    }
    public synchronized void testA() { }
    public synchronized void testB() { }
    public synchronized void testAll() {
        this.testA();  --&gt; 第二次获取同一把锁
        this.testB();
    }
3. 不可重入锁
    class Lock {
        private boolean isLocked = false;
        public synchronized void lock() {
            while(isLocked){ --&gt; 锁已经被占用了，则等待
                wait();
            }
            isLocked = true;
        }
        public synchronized void unlock() {
            isLocked = false;
            notify();  ---&gt; 释放锁，唤醒一个等待的线程
        }
    }
    Lock lock = new Lock();
    public void doSomething() {
        lock.lock();
        // ......
        lock.unlock();
    }
    public void test() {
        lock.lock();  --&gt; 上锁
        doSomething(); --&gt; 内部继续上同一把锁，但lock是不可重入的，所以陷入死锁状态
        lock.unlock();
    }
4. 可重入锁的实现原理
    class Lock {
        private boolean isLocked = false;
        private Thread t = null;
        private int count = 0; ---&gt; 计数器
        public synchronized void lock() {
            //对同一个线程放行，同一个线程可以重复上同一把锁
            Thread currentT = Thread.currentThread()
            while(isLocked &amp;&amp; (t!=currentT)){
                wait();  --&gt; 不是同一个线程，且锁已经被占用时，则等待
            }
            isLocked = true;  t = currentT;  count++;
        }
        public synchronized void unlock() {
            if(Thread.currentThread() == t) {
                count--;
                if(count == 0) { --&gt; 计数器为0时，当前线程才能释放锁
                    isLocked = false;
                    notify();  ---&gt; 唤醒一个等待的线程
                    t = null;
                }
            }
        }
    }
</code></pre><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><pre><code>1. 悲观锁：synchronized是独占锁(悲观锁)，会导致其他所有线程挂起，等待持有锁的线程释放锁
2. 乐观锁：完成某项操作时，每次不加锁，而是假设没有冲突，如果因为冲突失败就重试，直至成功
3. CAS：Compare and Swap，比较并交换，乐观锁的实现，如购物时的秒杀功能
    1. 有三个值：一个当前内存值V，旧的预期值A，将更新的值B
    2. 先获取内存中的值V，再将V与原值A比较，如果相等，则修改为B，并返回true，否则不修改，
    返回false
    3. CAS是一组原子操作，不会被外部打断；
    4. CAS属于硬件级别的操作(利用CPU的CAS指令，同时借助JNI来完成的非阻塞算法)，效率比加锁
    操作高；
    5. ABA问题：如果变量V初次读取时是A，且在准备赋值时检查到它仍是A，此时并不能保证变量V
    没被修改过，如果在这期间曾被修改成B，然后又改回A，那CAS操作就会误认为它从来没有修改过。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">大麦田怪圈</p>
              <p class="site-description motion-element" itemprop="description">敢做就能赢！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">61</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">35</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大麦田怪圈</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
