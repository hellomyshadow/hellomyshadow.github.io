<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="敢做就能赢！">
<meta property="og:type" content="website">
<meta property="og:title" content="大麦田程序猿">
<meta property="og:url" content="http://hellomyshadow.github.io/page/6/index.html">
<meta property="og:site_name" content="大麦田程序猿">
<meta property="og:description" content="敢做就能赢！">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="大麦田程序猿">
<meta name="twitter:description" content="敢做就能赢！">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hellomyshadow.github.io/page/6/">





  <title>大麦田程序猿</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大麦田程序猿</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/02/03/JavaEE之JSP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/03/JavaEE之JSP/" itemprop="url">JavaEE之JSP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-02-03T00:00:00+08:00">
                2016-02-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><pre><code>1. JSP：Java Server Pages，一种动态网页技术标准，本质是一个简化的Servlet
2. 原理：浏览器访问jsp文件时，JSP引擎把jsp文件转为Servlet(java文件)，然后执行此Servlet
3. Tomcat/conf/web.xml 对jsp访问的配置
    &lt;servlet&gt;
        &lt;servlet-name&gt;jsp&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.apache.jasper.servlet.JspServlet&lt;/servlet-class&gt;
        ...
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;jsp&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;
        &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
4. JSP的访问有一个转译的过程，所以JSP文件的修改不需要重启服务器。
5. JSP的三种注释：前端注释、Java语言注释、JSP注释
    1. 前端注释会被转译，也会被发送给浏览器，但不会执行；
    2. Java语言注释会被转译，但不会被Servlet执行；
    3. JSP注释不会被转译：&lt;%-- JSP注释 --%&gt;
</code></pre><h3 id="page指令"><a href="#page指令" class="headerlink" title="page指令"></a>page指令</h3><pre><code>1. page指令：配置JSP转译的相关参数
    &lt;%@ page 属性名=&quot;属性值&quot; 属性名=&quot;属性值&quot; ... %&gt;
2. language：声明JSP被转译的语言，如language=&quot;java&quot;
3. import：使用什么语言，就需要导入什么语言的包，不同的包以&quot;,&quot;隔开，也可以导入项目中的类
    import=&quot;java.util.*,java.lang.*,it.test.cn.modal.*&quot;
4. pageEncoding：文件保存的编码，如pageEncoding=&quot;utf-8&quot;
    1. 对于高版本的JSP，pageEncoding可以同时指定响应的编码；
    2. 对于低版本的JSP，还需要指定响应的编码：contentType=&quot;text/html;charset=UTF-8&quot;
5. session：设置转译的Servlet中是否支持Session，默认开启，不开启则设置session=&quot;false&quot;
6. errorPage：配置错误页面的路径，errorPage=&quot;error.jsp&quot;
7. extends：设置JSP转译的Servlet要继承的父类(全类名)
8. isELIgnored：是否忽略EL表达式，设置为true时，EL表达式会被当做普通字符串解析.
</code></pre><h3 id="JSP逻辑代码"><a href="#JSP逻辑代码" class="headerlink" title="JSP逻辑代码"></a>JSP逻辑代码</h3><pre><code>1. JSP的局部代码块
    &lt;%
        int num = 1;
        if(num &gt; 0) {
    %&gt;
            &lt;div&gt;num大于0&lt;/div&gt;
    &lt;% } else { %&gt;
            &lt;div&gt;另作处理&lt;/div&gt;
    &lt;% } %&gt;
    1. 转译到Servlet中
    int num = 1;
    if(num &gt; 0) {
        out.write(&quot;\r\n&quot;);
        out.write(&quot;\t\t&lt;div&gt;num大于0&lt;/div&gt;\r\n&quot;);
    } else {
        out.write(&quot;\t\t&lt;div&gt;另作处理&lt;/div&gt;\r\n&quot;);
    }
    2. 在JSP中写逻辑代码，编码困难，可阅读性和可维护性极差，所以尽量在Servlet中处理逻辑，
    JSP只负责展示内容。
2. JSP的全局代码块
    1. 声明Servlet的成员方法和成员变量
    &lt;%!
        int num = 1;
        public void test(){ ... }
    %&gt;
    2. 全局代码块声明的属性和方法，只能在局部代码块中使用。
3. JSP脚本段语句
    1. &lt;%= num %&gt;
    2. &lt;%= test() %&gt;  ==&gt;方法要有返回值
</code></pre><h3 id="JSP的引入与转发"><a href="#JSP的引入与转发" class="headerlink" title="JSP的引入与转发"></a>JSP的引入与转发</h3><pre><code>1. 静态引入： &lt;%@include file=&quot;header.jsp&quot; %&gt;
    1. 两个JSP文件会合并成一个Servlet文件;
    2. 静态引入的JSP不会单独转为一个Servlet;
    3. 两个JSP文件不能声明同名的Java变量.
2. 动态引入： &lt;jsp:include page=&quot;active.jsp&quot;&gt;&lt;/jsp:include&gt;
    1. 动态引入的JSP文件也会单独转为一个Servlet;
    2. 在当前JSP文件转译的Servlet中，会调用动态引入的JSP文件转译的Servlet;
    3. 允许在两个JSP文件中声明同名的Java变量.
3. JSP转发标签
    &lt;jsp:forward page=&quot;target.jsp&quot;&gt;&lt;/jsp:forward&gt;
    1. 一次请求，浏览器地址栏信息不变;
    2. 在&lt;jsp:forward&gt;标签中只能写&lt;jsp:param name=&quot;xxx&quot; value=&quot;xxx&quot;/&gt;，向目的JSP页面
    传递参数，而不能有其他任何字符，甚至是空格也不行，否则就会报错;
    &lt;jsp:forward page=&quot;target.jsp&quot;&gt;
        &lt;jsp:param name=&quot;user&quot; value=&quot;Mack&quot; /&gt;
    &lt;/jsp:forward&gt;
    3. 以GET形式转发参数：转发路径?user=Mack
    4. 在目的JSP页面获取参数：&lt;%= request.getParameter(&quot;user&quot;) %&gt;
</code></pre><h3 id="JSP的内置对象"><a href="#JSP的内置对象" class="headerlink" title="JSP的内置对象"></a>JSP的内置对象</h3><pre><code>1. 九大内置对象：JSP文件转译为Servlet时自动生成并声明的对象，可以在JSP文件中直接使用；
2. 内置对象只能在局部代码块和脚本段语句中使用；
1. pageContext：JSP的页面上下文对象，内部封装了另外8个内置对象；
    1. PageContext封存了当前JSP的运行信息，每个JSP文件都有一个PageContext对象；
    2. 每次请求都会重新创建一个PageContext对象，存储当前页面内的数据。
2. application
    ServletContext application = pageContext.getServletContext();
3. config
    ServletConfig application = pageContext.getServletConfig();
4. out
    JspWriter out = pageContext.getOut();
    1. JSP内部使用的响应对象，带有缓冲区，效率高于response
5. session：一次会话的Session对象，存储同一用户、不同请求的共享数据；
    1. 要使用Session对象，必须先在page指令中开启，session=&quot;true&quot;
    session = pageContext.getSession();
6. request，response：分别是当前的请求对象、响应对象；
7. page：this，当前JSP对象(Servlet对象);
8. exception：存储当前运行的异常信息，先在page指令中使用 isErrorPage=&quot;true&quot; 开启;
9. 数据流转
    1. pageContext：当前页面内的数据共享，获取其他内置对象;
    2. request：一次请求的数据共享，通过请求转发，把数据流转给下一个Servlet;
    3. session：一次会话，同一用户、不同请求的数据共享，将数据从一次请求流转给其他请求;
    4. application：项目内的数据，不同用户的数据共享，将数据从一个用户流转给其他用户.
</code></pre><h3 id="JSP的资源路径"><a href="#JSP的资源路径" class="headerlink" title="JSP的资源路径"></a>JSP的资源路径</h3><pre><code>1. 在JSP中使用相对路径时，资源位置不可随意更改；
2. 绝对路径：&lt;a href=&quot;/servtest/a.jsp&quot;&gt;，
    1. 第一个 &quot;/&quot; 表示服务器根目录(Tomcat/webapps)，&quot;/servtest&quot; 表示服务器的项目根目录，
    servtest是项目在Tomcat/webapps下的虚拟目录名。
3. 在JSP中声明全局路径
    &lt;%
        String path = request.getContextPath();
        String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;
        +request.getServerPort()+path+&quot;/&quot;;
    %&gt;
    &lt;html&gt;
        &lt;head&gt;
            &lt;base href=&quot;&lt;%=basePath%&gt;&quot;&gt;
    1. 那么，在JSP文件中引入资源时，资源路径会自动加上 Ip:Port/项目虚拟目录名/
    2. &lt;a href=&quot;a.jsp&quot;&gt; 跳转到 http://Ip:Port/servtest/a.jsp
    3. &lt;img src=&quot;images/header.png&quot; /&gt;
        http://Ip:Port/servtest/images/header.png
    4. &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/main.css&quot; /&gt;
        http://Ip:Port/servtest/css/main.css
4. 重定向到 main目录下的main.jsp
    resp.sendRedirect(&quot;/servtest/main/main.jsp&quot;);
    1. 重定向时，尽量使用绝对路径取代资源路径：/项目虚拟目录名/资源路径;
    2. 假定当前的Servlet的别名带有目录，如&lt;url-pattern&gt;/user/abc&lt;/url-pattern&gt;
    3. 如果使用相对路径，如resp.sendRedirect(&quot;main/main.jsp&quot;);  那么跳转的main.jsp的
    路径为 /项目虚拟目录名/user/main/main.jsp;
    4. 而main.jsp的真实路径是 /项目虚拟目录名/main/main.jsp ，那么就会报404错误.
5. 转发到一个JSP页面
    req.getRequestDispatcher(&quot;/login.jsp&quot;).forward(req, resp);
    1. 与请求重定向不同，请求转发的第一个 &quot;/&quot; 表示项目根目录，而不是服务器根目录，所以不用
    加项目的虚拟目录名.
</code></pre><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><pre><code>1. EL：Expression Language，一种写法非常简洁的表达式，灵感来源于ES和XPath;
2. EL表达式用于简化在JSP中获取作用域数据和请求数据，不需要导入相关的类(包);
3. 传统的获取方式
    1. 在Servlet中处理请求之后，通过请求转发到JSP页面：req.setAttribute(&quot;key&quot;, Object);
    2. 在JSP页面中获取数据：&lt;%= request.getAttribute(&quot;key&quot;) %&gt;
    3. 在JSP页面中获取请求参数：&lt;%= request.getParameter(&quot;key&quot;) %&gt;
4. 语法结构：${expression}
    1. 获取请求参数
    ${ param.key } --&gt; 单个值
    ${ paramvalues.key } --&gt; 同键不同值如Checkbox
    2. 获取 req.setAttribute(&quot;key&quot;, Object) 传递的数据：${ Object }
    3. ${} 只获取 pageContext、request、session、application四个对象中的数据;
    &lt;%  String uname = &quot;Java&quot;;  %&gt;
    &lt;h3&gt;${ uname }&lt;/h3&gt;
    4. 如果在四大对象中找不到uname，不报错，也不显示内容，但决不理会页面中定义的变量uname;
5. EL查找作用域数据的默认顺序：pageContext --&gt; request --&gt; session --&gt; application
    &lt;%
        pageContext.setAttribute(&quot;uname&quot;, &quot;aaaa&quot;);
        request.setAttribute(&quot;uname&quot;, &quot;bbbb&quot;);
        session.setAttribute(&quot;uname&quot;, &quot;cccc&quot;);
        application.setAttribute(&quot;uname&quot;, &quot;dddd&quot;);
    %&gt;
    &lt;div&gt;${ uname }&lt;/div&gt; ===&gt; aaaa
    1. 除了默认顺序，还可以手动指定查找方向
    request：${ requestScope.uname }，pageContext：${ pageScope.uname }
    session：${ sessionScope.uname }，application：${ applicationScope.uname }
6. EL支持简单的逻辑运算：算术表达式、关系表达式、逻辑表达式(&amp;&amp; || !)、三元表达式
    ${ 1+3 } =&gt; 4，${ 1&gt;3 } =&gt; false，${ flag==0?&quot;正确&quot;:&quot;错误&quot; }
    1. EL表达式中不允许做字符串连接
    ${ 1+&quot;4&quot; } =&gt; 5，${ 1+&quot;a&quot; } =&gt; 报错
7. EL的空值判断：${ empty key }，空字符串、空集合都返回true，但是对象返回false
8. EL获取请求头数据：${ header }
    1. 单个值：${ header[&quot;key&quot;] }，如${ header[&quot;user-agent&quot;] }
    2. 数组：${ headerValues[&quot;key&quot;] }，同键不同值
9. EL获取Cookie数据：${ cookie }
    1. 获取一条Cookie数据，如sessionID：${ cookie.JSESSIONID }
    2. 获取这条Cookie数据的键值：
    ${ cookie.JSESSIONID.name }，${ cookie.JSESSIONID.value }
</code></pre><h2 id="JSTL标签库"><a href="#JSTL标签库" class="headerlink" title="JSTL标签库"></a>JSTL标签库</h2><pre><code>1. JSTL是 Apache 对EL表达式的扩展，JSTL依赖于EL，使用时需要导包，并指定标签库；
    1. MyEclipse会在lib目录下自动存放jstl.jar
    2. JSTL的标签库：核心库、格式化库、SQL库、函数库、XML库
2. JSTL标签库能够提升JSP页面编写逻辑代码的效率，可阅读性更强；
</code></pre><h3 id="JSTL核心标签库"><a href="#JSTL核心标签库" class="headerlink" title="JSTL核心标签库"></a>JSTL核心标签库</h3><pre><code>1. 导入jar包，声明jstl核心标签库的引入
    &lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;
2. 输出：&lt;c:out&gt; 类似于 &lt;%=xxx %&gt;
    &lt;%  request.setAttribute(&quot;uname&quot;, &quot;Java&quot;);  %&gt;
    &lt;c:out value=&quot;${uname}&quot; default=&quot;xxx&quot;&gt;&lt;/c:out&gt;
    1. 结合EL表达式输出，如果uname不存在，则输出默认值default
3. 向作用域中存储键值： &lt;c:set var=&quot;key&quot; value=&quot;xxx&quot;&gt;&lt;c:set&gt;
    1. 默认存储在pageContext中，也可以手动指定存储的作用域对象
    &lt;c:set var=&quot;key&quot; value=&quot;xxx&quot; scope=&quot;page/request/session/application&quot;&gt;&lt;c:set&gt;
4. 删除作用域的数据：&lt;c:remove&gt;
    &lt;c:remove var=&quot;uname&quot; /&gt;
    1. 默认把4个作用域对象中的uname都删除，scope属性指定作用域
    &lt;c:remove var=&quot;uname&quot; scope=&quot;page/request/session/application&quot; /&gt;
5. 逻辑标签：依赖于EL表达式
    1. 单个判断
    &lt;c:set var=&quot;score&quot; value=&quot;66&quot;&gt;&lt;c:set&gt;
    &lt;c:if test=&quot;${score&gt;60}&quot;&gt;
        &lt;div&gt;条件通过&lt;/div&gt;
    &lt;/c:if&gt;
    2. 多重判断
    &lt;c:choose&gt;
        &lt;c:when test=&quot;${score&gt;=90}&quot;&gt;
            &lt;li&gt;11111111&lt;/li&gt;
        &lt;/c:when&gt;
        &lt;c:when test=&quot;${score&lt;90 &amp;&amp; score&gt;=70}&quot;&gt;
            &lt;li&gt;2222222&lt;/li&gt;
        &lt;/c:when&gt;
        &lt;c:when test=&quot;${score&lt;70 &amp;&amp; score&gt;=60}&quot;&gt;
            &lt;li&gt;3333333&lt;/li&gt;
        &lt;/c:when&gt;
        &lt;c:otherwise&gt;
            &lt;li&gt;4444444&lt;/li&gt;
        &lt;/c:otherwise&gt;
    &lt;/c:choose&gt;
6. 常量循环
    &lt;c:forEach begin=&quot;1&quot; end=&quot;4&quot; step=&quot;1&quot; varStatus=&quot;vs&quot;&gt;  ==&gt; 循环4次
        &lt;li&gt;${vs.index} -- ${vs.count} -- ${vs.first} -- ${vs.last}&lt;/li&gt;
    &lt;/c:forEach&gt;
    1. step属性设置每次循环的自增步数，默认自增1
    2. varStatus属性保存当前循环的状态
        1. vs.index：当前循环的角标
        2. vs.count：当前是第几次循环
        3. vs.first/vs.last：当前是不是第一次/最后一次循环，true/false
7. 动态循环
    &lt;%
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&quot;111&quot;);
        request.setAttribute(&quot;list&quot;, list);
        HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;a&quot;, &quot;11&quot;);
        request.setAttribute(&quot;map&quot;, map);
    %&gt;
    1. 遍历List集合
    &lt;c:forEach items=&quot;${list}&quot; var=&quot;v&quot;&gt;
        &lt;li&gt;${v}&lt;/li&gt;
    &lt;/c:forEach&gt;
    2. var属性是每次循环的元素值;
    3. 遍历Map集合
    &lt;c:forEach items=&quot;${map}&quot; var=&quot;v&quot;&gt;
        &lt;li&gt;${v.key} -- ${v.value}&lt;/li&gt;
    &lt;/c:forEach&gt;
    4. v 表示每次循环的一条Map元素，v.key、v.value 分别表示这条数据的键、值。
</code></pre><h3 id="JSTL格式化标签库"><a href="#JSTL格式化标签库" class="headerlink" title="JSTL格式化标签库"></a>JSTL格式化标签库</h3><pre><code>1. 声明jstl核心标签库的引入
    &lt;%@taglib prefix=&quot;fmt&quot; uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; %&gt;
2. 可以格式化输入文本、日期、时间、数字
    1. &lt;fmt:formatNumber&gt;：使用指定的格式或精度格式化数字;
    2. &lt;fmt:parseNumber&gt;：解析一个代表着数字/货币/百分比的字符串;
    3. &lt;fmt:formatDate&gt;：使用指定的风格或模式格式化日期和时间;
    4. &lt;fmt:parseDate&gt;：解析一个代表着日期或时间的字符串;
    5. &lt;fmt:requestEncoding&gt;：设置request的字符编码;
    6. &lt;fmt:timeZone&gt;：指定时区，供其它标签使用;
    7. &lt;fmt:setTimeZone&gt;：复制一个时区对象至指定的作用域.
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/02/01/JavaEE之Servlet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/02/01/JavaEE之Servlet/" itemprop="url">JavaEE之Servlet</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-02-01T00:00:00+08:00">
                2016-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h2><pre><code>1. HTTP的特点：快速连接、灵活、无连接、无状态；
    1. 无连接：限制每次连接只处理一个请求，可以节省传输时间；
    2. 无状态：HTTP协议是无状态协议，对于事物处理没有记忆能力，如果第二次请求用到了第一次
    请求响应的数据，仍然需要重新传递。
2. HTTP1.1版本后支持可持续连接：连接不立即断开，而是一段时间内没任何请求时，才会断开通道；
3. HTTP的请求方式
    1. HTTP1.0定义三种请求方法：GET、POST、HEAD
    2. HTTP1.1新增5种：OPTIONS、PUT、DELETE、TRACE、CONNECT
4. Tomcat
    1. 目录结构：bin(可执行文件目录)、conf(服务器配置文件目录)、lib(jar包目录)、log(日志)
    temp(缓存文件目录)、webapps(存放web应用的目录)、work(存放JSP转换后的servlet文件)
    2. windows系统启动Tomcat：bin/startup.bat，默认IP和端口号为localhost:8080
    3. Tomcat的运行依赖JDK，必须配置JDK环境。
5. log4j：打印日志，引入log4j.jar后，把log4j.properties放在项目的src目录下；
6. 在原生的HTML中，使用 &lt;frame&gt; 引入公共的html文件
    &lt;frameset cols=&quot;25%,50%,25%&quot;&gt;
        &lt;frame src=&quot;left.html&quot; /&gt;
        &lt;frame src=&quot;content.html&quot; /&gt;
        &lt;frame src=&quot;right.html&quot; /&gt;
    &lt;/frameset&gt;
    1. 在存在层级关系的HTML页面中，window.self表示自身的window对象;
    2. window.parent表示父级HTML的window对象;
    3. window.top表示最顶级HTML的window对象.
</code></pre><h3 id="Servlet技术"><a href="#Servlet技术" class="headerlink" title="Servlet技术"></a>Servlet技术</h3><pre><code>1. Servlet是Java实现的一个接口，任何实现Servlet接口的类都可以成为Servlet；
2. Servlet运行于支持Java的应用服务器中，理论上可以响应任何类型的请求，但一般只用于扩展基于
   HTTP协议的Web服务器；
3. Servlet的特点
    1. 运行在支持Java的应用服务器上，简单方便、可移植性强；
    2. 服务器会自动根据请求调用对应的Servlet，进行请求的处理。
4. Servlet的使用(MyEclipse)
    1. 继承HttpServlet，覆写service()，处理请求、响应数据；
    public class ServletTest extends HttpServlet {
        protected void service(HttpServletRequest req, HttpServletResponse resp) {
            // super.service(req, resp); -----&gt; 务必注释掉，否则会报405
            resp.getWriter().write(&quot;Hello ServletTest&quot;);
        }
    }
    2. 在WebRoot/WEB-INF/web.xml中，配置servlet
    &lt;servlet&gt;
        &lt;servlet-name&gt;ServletTest&lt;/servlet-name&gt;
        &lt;servlet-class&gt;it.test.cn.ServletTest&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;ServletTest&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/test&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    3. 在Tomcat/webapps下新建目录servtest，把WebRoot目录中的文件复制到servtest目录中
    4. 启动Tomcat，访问ServletTest：http://localhost:8080/servtest/test
    5. webapps下的项目文件夹名称，又叫虚拟项目名；servlet的url-pattern又称为servlet别名
    6. 除了在web.xml中配置Servlet，servlet3.0开始支持注解配置
    @WebServlet(name = &quot;ServletTest&quot;, urlPatterns=&quot;/test&quot;)
    public class ServletTest extends HttpServlet { ... }
    7. url-pattern支持正则表达式，如/user/*，可以匹配/user/find，/user/add ...
    8. Servlet3.0部署 web.xml 的根节点 &lt;web-app&gt; 时，metadata-complete默认值为false，
    表示启用注解支持；设置为true时，表示只依赖 web.xml，忽略所有注解。
5. Servlet的生命周期
    1. Servlet的初始化函数：init()，第一次访问此Servlet时加载进内存，执行初始化，一直到
    关闭Tomcat服务，无论接受多少请求，都只会执行一次，即使删除本地文件，也能正常访问；
    2. service()：处理请求的方法，每次接收到请求都会执行；
    3. destory()：Servlet销毁的方法，关闭Tomcat服务时执行；
    4. 在 web.xml 中，在&lt;servlet&gt;中配置子节点&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;，
    那么此Servlet将在启动Tomcat服务时，加载进内存，执行 init() 初始化。
6. doGet()、doPost()
    1. doGet() 处理Get请求，doPost() 处理Post请求，service() 可以同时处理这两种请求;
    2. 如果Servlet中同时配置了 doGet()、doPost()、service()，那么优先执行service();
    3. service()中的 super.service() 会根据当前的请求方式，再去调用doGet()、doPost()
    所以在覆写 service() 时，通常注释掉super.service(); 否则会报405
7. HttpServletRequest：请求对象
    1. getMethod()：获取请求方法；
    2. getRequestURL()：获取请求的完整地址；
    3. getRequestURI()：请求接口地址，不包含域名和端口号；
    4. getHeader(&quot;key&quot;)：根据请求行的键获取值；
    5. Enumeration&lt;String&gt; e = req.getHeaderNames(); 所有请求行的键的枚举
    while(e.hasMoreElements()) {
        String s = e.nextElement();  --&gt; 键
    }
    6. getParameter(&quot;key&quot;)：获取用户数据(Get和Post)；
    7. getParameterValues(&quot;key&quot;)：类似Checkbox的一键多值；
8. HttpServletResponse：响应对象
    1. setHeader(&quot;key&quot;, &quot;value&quot;)：设置响应头，同键覆盖；
    2. addHeader(&quot;key&quot;, &quot;value&quot;)：添加响应头，同键不会覆盖；
    3. sendError(200, &quot;OK&quot;)：设置响应状态码；
    4. res.getWriter().write(...)：设置响应体；
    5. 中文乱码问题：
    res.setHeader(&quot;content-type&quot;, &quot;text/html;charset=utf-8&quot;);
    或 res.setContentType(&quot;text/html;charset=utf-8&quot;);
    6. text/html：表示响应体是HTML，让浏览器按照HTML进行解析；
    7. text/plain：响应体是普通字符串；
    8. text/xml：响应体是XML
</code></pre><h2 id="响应处理"><a href="#响应处理" class="headerlink" title="响应处理"></a>响应处理</h2><pre><code>1. 请求乱码问题
    1. 浏览器默认是iso8859-1编码，用户提交的数据为中文时，可能出现乱码，需要转为utf-8
    String a = new String(b.getBytes(&quot;iso8859-1&quot;), &quot;utf-8&quot;); --&gt; 通用解决方式
    2. GET请求的扩展方式：req.setCharacterEncoding(&quot;utf-8&quot;);
    同时配置Tomcat/conf/server.xml：&lt;Connector useBodyEncodingForURI=&quot;true&quot; .../&gt;
    3. POST请求的扩展方式：req.setCharacterEncoding(&quot;utf-8&quot;);
2. 请求转发
    1. 特点：一次请求，浏览器地址栏的信息不变；
    2. req.getRequestDispatcher(&quot;转发的地址&quot;).forward(req, resp);
    3. 在转发过程中，因为是同一个HttpServletRequest对象，可以从当前Servlet向目的Servlet
    传递数据：
    req.setAttribute(&quot;key&quot;, value); ---&gt; 当前Servlet设置数据
    value = req.getAttribute(&quot;key&quot;); ---------------------&gt; 目的Servlet获取数据
    4. session.removeAttribute(&quot;key&quot;); 移除键值数据。
3. 请求重定向
    1. 特点：两次请求，两个Request对象，浏览器地址栏信息改变；
    2. resp.sendRedirect(&quot;地址&quot;);
    3. 既然是两个Request对象，要实现数据传递，只能借助Session
</code></pre><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><pre><code>1. Cookie是浏览器端的数据存储，在服务器端响应数据时，告诉浏览器存储Cookie
2. 在服务器端声明Cookie
    Cookie ck = new Cookie(&quot;key&quot;, &quot;value&quot;);
    resp.addCookie(ck);
    1. 如果需要存储多个key-value，则创建多个Cookie对象；
    2. 默认情况下，Cookie临时存储在浏览器内存中，一旦关闭浏览器，Cookie将消失；
    3. 设置Cookie的有效期：ck.setMaxAge(3*24*3600); --&gt; 3天
    4. 设置有效期的Cookie会存储在浏览器本地，即使关闭了浏览器，只要未过期、就不会消失。
3. 默认情况下，每次请求都会携带当前域名下的Cookie，除非设置有效路径
    1. ck.setPath(&quot;/abc/xxx&quot;);
    2. 只有在请求 /abc/xxx 时才会携带此Cookie
4. 在服务器端获取请求对象中携带的Cookie
    Cookie[] cks = req.getCookies();
    for(Cookie c: cks) {
        String name = c.getName();
        String value = c.getValue();
    }
</code></pre><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><pre><code>1. 同一用户、不同请求的数据共享，如重定向的两个Servlet，可以使用Session存储共享数据；
2. Session存储在服务器端，标识不同用户的Session的唯一ID，会以Cookie的形式存储在浏览器端
    用户第一次访问服务器 --&gt; 服务器创建Session，并将此Session对象的JSESSIONID以Cookie
    的形式存储到浏览器中 --&gt; 同一个用户再次访问时，会携带此JSESSIONID --&gt; 通过JSESSIONID
    查找此用户的Session数据
3. Session的特点：存储在服务器端、由服务器端创建、依赖Cookie技术、一次会话
4. 创建/获取Session
    1. HttpSession hs = req.getSession();  --&gt; 没有Session对象则创建，有则获取
    2. 创建Session之后，会自动把JSESSIONID作为Cookie返回给浏览器存储；
    2. hs.getId(); --&gt; 获取Session的唯一标识JSESSIONID
5. JSESSIONID默认是临时存储，关闭浏览器则失效；
6. Session的默认存储时间是30分钟
    1. 关闭浏览器，JSESSIONID就失效了，但服务器并不知道，所以就不能及时删除对应的Session，
    这就需要设置Session的过期时间了，以免服务器端的Session数据过多；
    1. 设置Session的有效期：hs.setMaxInactiveInterval(60); --&gt; 60秒
    2. 不管是默认值还是自定义有效期，只要在有效期内发起了请求，Session有效期都会重新计时；
    3. hs.invalidate(); --&gt; 强制失效
    4. 如果Session失效了，req.getSession() 还会重新创建Session，并将ID存储到浏览器
7. Session的数据存储
    1. hs.setAttribute(&quot;key&quot;, value); --&gt; 在一个Servlet中存储Session数据
    2. value = hs.getAttribute(&quot;key&quot;);  ----&gt; 在其他Servlet中获取Session中的数据
8. 配置Session的默认有效期
    1. 在Tomcat/conf/web.xml中
    &lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt;
    2. 此配置对Tomcat下部署的所有项目有效；
    3. 在项目下的web.xml中配置 &lt;session-config&gt; , 只对本项目有效。
</code></pre><h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><pre><code>1. ServletContext：一个项目只有一个ServletContext对象；
2. ServletContext的生命周期：从服务器启动到结束；
3. 三种获取方式：
    1. ServletContext sc = this.getServletContext();
    2. ServletContext sc = this.getServletConfig().getServletContext();
    3. ServletContext sc = req.getSession().getServletContext();
4. 不同用户可以共享ServletContext数据
    1. sc.setAttribute(&quot;key&quot;, value);  --&gt; 设置
    2. value = sc.getAttribute(&quot;key&quot;); --&gt; 获取
5. 获取项目 web.xml 的全局配置数据
    1. 配置全局数据
    &lt;web-app ...&gt;
        &lt;context-param&gt;  ---&gt; 一组&lt;context-param&gt;只能存储一对键值数据，可以声明多组
            &lt;param-name&gt;key&lt;/param-name&gt;
            &lt;param-value&gt;value&lt;/param-value&gt;
        &lt;/context-param&gt;
    2. String param = sc.getInitParameter(&quot;key&quot;);
    3. sc.getInitParameterNames();  --&gt; 键的枚举
    4. 作用：将静态数据和代码进行解耦
6. 获取项目WebRoot目录下的资源路径(MyEclipse环境，WebRoot目录下文件会复制到Tomcat中)
    1. 在WebRoot下创建doc目录，在doc下新建文件a.txt
    2. String doca = sc.getRealPath(&quot;/doc/a.txt&quot;);  --&gt; 获取a.txt的路径
    3. InputStream is = sc.getResourceAsStream(&quot;/doc/a.txt&quot;);  --&gt; 获取流对象
    4. ServletContext只能获取资源文件，不能获取class文件(需要类加载器)
7. 比如，统计一段时间内的访问次数，可以使用ServletContext
</code></pre><h3 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h3><pre><code>1. ServletConfig是Servlet的专属配置对象，每个Servlet都单独拥有一个ServletConfig对象；
2. ServletConfig用于获取 web.xml 中的Servlet配置信息；
3. 获取Servlet的ServletConfig对象：
    ServletConfig config = this.getServletConfig();
4. 在 web.xml 的 &lt;servlet&gt; 下配置：
    &lt;init-param&gt;
        &lt;param-name&gt;key&lt;/param-name&gt;
        &lt;param-value&gt;value&lt;/param-value&gt;
    &lt;/init-param&gt;
5. 获取Servlet配置的键-值数据：String value = config.getInitParameter(&quot;key&quot;);
</code></pre><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><pre><code>1. Tomcat/conf/web.xml 与 Web项目/web.xml
    1. Tomcat下的web.xml为全局配置，对所有web项目有效，配置公共信息；
    2. web项目/web.xml为局部配置，只对当前项目有效；
    3. 对于相同的配置内容，web项目/web.xml的优先级更高。
2. web.xml的核心配置：
    1. 全局上下文ServletContext、Servlet配置context-param、过滤器filter、监听器listener
    2. 排列顺序是任意的，但加载顺序是固定的：
    ServletContext --&gt; context-param --&gt; listener --&gt; filter --&gt; Servlet
    3. web.xml都是在服务器启动时加载
</code></pre><h3 id="server-xml"><a href="#server-xml" class="headerlink" title="server.xml"></a>server.xml</h3><pre><code>1. Tomcat/conf/server.xml，核心节点&lt;Service&gt;，一个&lt;Server&gt;节点下可以配置多个&lt;Service&gt;
    1. HTTP协议的端口号配置
    &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; 
        connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;
    2. 服务器集群配置
    &lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;
2. 引擎节点：&lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;
    1. 一个&lt;Service&gt;节点下只能配置一个&lt;Engine&gt;节点
    2. &lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot; ...&gt;，appBase属性指定项目所在的目录
    3. &lt;Engine&gt;的defaultHost属性指定了默认的host，指向子节点&lt;Host name=&quot;localhost&quot; ...&gt;
    4. 浏览器访问Tomcat服务器时，如果输入的host在&lt;Engine&gt;下没有配置，如本机的私有地址
    192.168.xxx.xxx，则执行默认的host
3. 在&lt;Host&gt;节点下配置热部署
    &lt;Context path=&quot;/abc&quot; reloadable=&quot;true&quot; docBase=&quot;F:/WebTest&quot; /&gt;
    1. path：项目的虚拟目录名；
    2. reloadable：是否自动加载；
    3. docBase：项目所在的绝对路径；
    4. 热部署不需要在Tomcat/webapps下为项目创建文件夹(项目的虚拟目录)，所以如果项目删除，
    对应的&lt;Context/&gt;也必须删除，否则Tomcat启动会报错。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/01/10/Java之Maven/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/10/Java之Maven/" itemprop="url">Java之Maven</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-10T00:00:00+08:00">
                2016-01-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><pre><code>1. Maven是一个项目管理工具，两大核心功能：依赖管理、一键构建;
2. 依赖管理(jar包管理)
    1. Maven项目中的jar包在一个jar包仓库中，项目中只放jar包的坐标，在代码编译时去仓库中找到jar包;
    2. 大大减少了磁盘空间，解决了jar包冲突，实现了代码可重用。
3. 一键构建
    1. 构建：项目从编译、测试、运行、打包、安装、部署的整个过程都交给Maven进行管理；
    2. 一个Maven命令就可以实现构建，在maven/lib目录中集成了Tomcat插件。
4. Maven项目必须使用依赖管理，而一键构建却不是必须的，还可以使用本地安装的Tomcat构建项目;
5. Maven依赖于JDK，还需要配置环境变量，然后测试是否安装配置成功：mvn -v
</code></pre><h2 id="Maven仓库"><a href="#Maven仓库" class="headerlink" title="Maven仓库"></a>Maven仓库</h2><pre><code>1. Maven仓库的分类：本地仓库、远程仓库(私服)、中央仓库
    1. 当启动Maven项目时，Maven会通过 pom.xml 中配置的依赖坐标，去本地仓库中查找对应的jar包;
    2. 默认情况下，如果本地仓库没有对应的jar包，Maven会自动从中央仓库下载jar包到本地仓库;
    3. 如果配置了私服，则去私服下载jar包到本地仓库; 私服中没有，则转去中央仓库下载，还没有则报错.
2. 本地仓库
    1. 在 Maven/conf/settings.xml 中，本地仓库的默认配置为 ${user.home}/.m2/repository
    2. user.home 表示C盘下的个人目录
    3. 考虑到C盘通常是系统盘，所以会自定义本地仓库的路径，如D盘下
        &lt;localRepository&gt;D:/local/repo&lt;/localRepository&gt;
    4. 配置淘宝等国内镜像，可以加快下载速度，比如阿里的Maven镜像;
    &lt;mirrors&gt;
        &lt;mirror&gt; 
            &lt;id&gt;alimaven&lt;/id&gt; 
            &lt;name&gt;aliyun maven&lt;/name&gt; 
            &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; 
            &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;         
        &lt;/mirror&gt; 
    &lt;/mirrors&gt;
3. 远程仓库(私服)：
    1. 在公司内有专门的局域网服务器作为jar包的远程仓库，又称为私服;
    2. 配置了远程仓库之后，预先在私服中上传常用的jar包，让本地仓库从局域网内的私服下载jar包;
    3. 如果私服中没有需要的jar包，再转去中央仓库下载。
4. 中央仓库：Maven的云服务器jar包仓库，存放了几乎所有的开源jar包。
</code></pre><h2 id="Maven项目"><a href="#Maven项目" class="headerlink" title="Maven项目"></a>Maven项目</h2><pre><code>1. Maven项目的目录可分为四大部分：核心代码、配置文件、测试代码、测试配置文件
2. Maven的Java项目
    1. src/main/java：核心代码;
    2. src/main/resources：配置文件;
    3. src/test/java：测试代码;
    4. src/test/resources：测试配置文件;
3. 对于Java Web项目，除了这4个目录，还有一个 src/main/webapp，存放JSP页面资源、web.xml等。
</code></pre><h3 id="Maven的生命周期"><a href="#Maven的生命周期" class="headerlink" title="Maven的生命周期"></a>Maven的生命周期</h3><pre><code>1. Maven常用命令
    1. mvn clean：清除项目中的编译信息，删除target目录；
    2. mvn compile：编译src/main/java中的核心代码，生成target目录，存放编译好的class文件
    3. mvn test：除了编译核心代码，还会编译src/main/test中的测试代码；
    4. mvn package：打包，除了编译核心代码和测试代码，还会打包成war/jar包；
    5. mvn install：安装，编译核心代码和测试代码，打成war包，同时把war包安装到本地仓库中。
2. mvn clean：独立的一个生命周期，称为清理生命周期；
3. 编译(compile)、测试(test)、打包(package)、安装(install)、发布(mvn deploy)
    1. 称为默认生命周期，所以执行越靠后的命令时，会自动执行前面的命令；
    2. 其中，发布需要额外配置。
4. 另外，还有一个不常用的站点生命周期.
</code></pre><h3 id="jar包和war包"><a href="#jar包和war包" class="headerlink" title="jar包和war包"></a>jar包和war包</h3><pre><code>1. jar和war是两种不同的打包方式，在项目的 pom.xml 中配置：&lt;packaging&gt;war&lt;/packaging&gt;
2. war是一个web模块，其中需要包括WEB-INF，是可以直接运行的web模块;
3. 将war包放置 Tomcat/webapps/ 下，启动Tomcat，war包会自动解压成项目的web目录，相当于发布了;
4. jar一般只是包括一些class文件，在声明了 main() 之后就可以用java命令运行;
5. Spring项目一般都是打成war包发布到Tomcat上，而SpringBoot项目一般使用jar包的打包模式;
6. SpringBoot内部已经集成了Tomcat插件，省去了安装Tomcat等中间件，所以打成jar包也很有必要.
    java -jar jar包名  //运行jar包项目的命令
</code></pre><h2 id="POM模型"><a href="#POM模型" class="headerlink" title="POM模型"></a>POM模型</h2><pre><code>1. Maven的概念模型POM
</code></pre><p><img src="//hellomyshadow.github.io/2016/01/10/Java之Maven/Maven.jpg" alt="Maven"></p>
<h2 id="idea集成Maven"><a href="#idea集成Maven" class="headerlink" title="idea集成Maven"></a>idea集成Maven</h2><pre><code>1. 下载并解压Maven，配置环境变量(必须有JDK环境)：
    1. 新建环境变量MAVEN_HOME：D:\maven\apache-maven-3.6.0
    2. 配置Path：%MAVEN_HOME%\bin
2. idea：Settings --&gt; 搜索 Maven
    1. 配置使用本地Maven
        Maven home directory: D:\maven\apache-maven-3.6.0
        User settings file: D:\maven\apache-maven-3.6.0\conf\settings.xml
        Local repository: D:\maven\maven_repository
    2. 如果Maven项目骨架(模板)已经下载过了，不要再下载了：
        Maven --&gt; Runner VM Options: archetypeCatalog=internal
3. 使用Maven骨架(模板)创建Java项目
    New Project --&gt; Maven --&gt; 勾选Create... --&gt; 选择maven-archetype-quickstart
    1. 一个jar包的坐标由三个基本元素构成：
        GroupId(公司或组织的名称): com.test  ---&gt;作为项目的包名
        ArtifactId(项目名称): maven_test
        Version(版本号): 1.0-SNAPSHOT  ---&gt;RSNAPSHOT表示测试版，RELEASE表示发布/正式版
    2. Next --&gt; 确认当前使用的Maven环境，与 Settings--&gt;Maven 中的配置一致；
    3. 如果第一次使用此骨架，会联网下载，而且默认只会创建使用到的目录，不会把Maven标准目录结构都创建;
    4. 创建main/resources目录，右键 --&gt; Mark Directory As --&gt; Resources Root
    5. 刚创建的项目不能运行，点击右下角的 Import Changes 或 Enable Auto-Import(自动导入依赖)
        Add Configurations -&gt; + Application(自定义名字) -&gt; Main class(选择入口文件) -&gt; OK
4. 不适用骨架的Java项目
    1. 目录结构：src/main/java，src/main/resources
    2. 与使用骨架相比，目录结构更接近Maven项目的标准目录，文件也更干净。
</code></pre><h3 id="创建JavaWeb项目"><a href="#创建JavaWeb项目" class="headerlink" title="创建JavaWeb项目"></a>创建JavaWeb项目</h3><pre><code>1. 选择骨架：maven-archetype-webapp
2. 默认只有一个 main/webapp 目录，并没有main/java、main/resources目录;
3. 新建java目录，右击 --&gt; Mark Directory as --&gt; Sources Root;
4. 点击 Import Changes 或 Enable Auto-Import，在项目的 External Libraries 可以查看当前项目的依赖列表;
5. 在项目的 pom.xml 中，添加Servlet相关的依赖，在maven中央仓库搜索需要的jar包;
    &lt;dependencies&gt;
        &lt;dependency&gt;  ===&gt;如果本地仓库没有这些依赖，idea会自动联网下载
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
            &lt;version&gt;4.0.1&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;
            &lt;artifactId&gt;javax.servlet.jsp-api&lt;/artifactId&gt;
            &lt;version&gt;2.3.3&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
6. web.xml 中，为根节点 &lt;web-app&gt; 添加约束
    &lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee
            http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;
        version=&quot;3.0&quot;&gt;
7. 使用Maven自带的Tomcat插件运行项目：打开右侧的Maven面板
    1. 点击上面带有&quot;m&quot;的小图标 --&gt; 输入 tomcat:run 命令运行项目;
    2. 展开项目的Lifecycle，双击 run 命令也可以运行;
    3. 访问：http://localhost:8080/项目名/
8. 使用本地的Tomcat运行项目：
    Add Configurations --&gt; + Tomcat Server -&gt; Local --&gt; Name命名，Deployment添加项目
    1. + Artifacts --&gt; war表示打包启动，war exploded表示打包热启动，选择热启动;
    2. Application context 设置项目的虚拟目录名，设置为 /
    3. 访问：http://localhost::8080/
</code></pre><h3 id="tomcat-run的问题"><a href="#tomcat-run的问题" class="headerlink" title="tomcat:run的问题"></a>tomcat:run的问题</h3><pre><code>1. jar冲突问题：xxxServlet cannot be cast to javax.servlet.Servlet
    1. Tomcat中自带servlet-api.jar和jsp-api.jar，项目中又引入了这两个jar包，所以在运行时报jar包冲突异常;
    2. &lt;scope&gt;provided&lt;/scope&gt;：设置jar包的作用范围，provided 表示只在编译期和测试时有效，解决运行时冲突;
2. 对于测试jar包junit的&lt;scope&gt;设置：&lt;scope&gt;test&lt;/scope&gt;，表示只在测试时有效；
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.11&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
3. &lt;scope&gt;
    1. &lt;scope&gt;compile&lt;/scope&gt;：默认值，在编译、测试、运行三个时期都起作用；
    2. &lt;scope&gt;runtime&lt;/scope&gt;：只在测试期和运行时有效，常见于JDBC驱动的依赖；
    3. &lt;scope&gt;system&lt;/scope&gt;：只在编译期和测试时有效。
4. Tomcat版本与JDK版本不匹配问题：Unable to compile class for JSP
    1. tomcat:run 运行项目时，Maven默认使用的是Tomcat6，它与JDK8配合时无法转化JSP
    2. 在 pom.xml 中配置tomcat7的插件
        &lt;build&gt;
            ......
            &lt;pluginManagement&gt;
                &lt;plugins&gt;
                    ......
                    &lt;plugin&gt;
                        &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;
                        &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;
                        &lt;version&gt;2.2&lt;/version&gt;
                    &lt;/plugin&gt;
                &lt;/plugins&gt;
            &lt;/pluginManagement&gt;
        &lt;/build&gt;
    3. 使用Tomcat7运行web项目：tomcat7:run
5. Tomcat的默认端口号都是8080，可以修改Tomcat7的端口号，可以同时启动tomcat6和tomcat7;
    &lt;plugin&gt;
        &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;
        &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;2.2&lt;/version&gt;
        &lt;configuration&gt;
            &lt;port&gt;8888&lt;/port&gt;
        &lt;/configuration&gt;
    &lt;/plugin&gt;
</code></pre><h3 id="配置JDK版本"><a href="#配置JDK版本" class="headerlink" title="配置JDK版本"></a>配置JDK版本</h3><pre><code>1. 插件的方式
    &lt;plugin&gt;
        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
        &lt;configuration&gt;
            &lt;target&gt;1.8&lt;/target&gt;  ===&gt;使用JDK1.8编译
            &lt;source&gt;1.8&lt;/source&gt;  ===&gt;编译后的class文件也使用JDK1.8
            &lt;encoding&gt;UTF-8&lt;/encoding&gt;  ==&gt;编码
        &lt;/configuration&gt;
    &lt;/plugin&gt;
2. 常用方式
    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;
</code></pre><h2 id="jar包冲突"><a href="#jar包冲突" class="headerlink" title="jar包冲突"></a>jar包冲突</h2><pre><code>1. 依赖树：打开右侧Maven面板 --&gt; 点击提示Show Dependencies的图标，可以查看当前项目的依赖树结构;
2. 解决方式一：第一声明优先原则
    1. 哪个jar包的坐标配置靠前，那么这个jar包就优先声明;
    2. 优先声明的jar包坐标及其依赖包，也会优先进入项目中;
3. 解决方式二：路径近者优先原则
    1. 直接依赖：项目中显式引入的jar包坐标;
    2. 传递依赖：项目中没有显式配置的jar包，但通过直接依赖的jar包传递到项目中;
    3. 比如，项目中依次引入了 AA(4.2.4)、BB(5.1.6) 两个依赖包，它们又都依赖于CC，所以项目中又会自动引入CC，
    但因为 AA 在前，BB 在后，由第一声明优先原则可知，项目中引入的 CC 版本为4.2.4;
    4. 但如果显式引入了 CC(4.8.0)，那么不管它处于哪个位置，都会优先引入，因为直接依赖比传递依赖的路径更近;
4. 解决方式三：直接排除法(推荐方式)
    1. &lt;exclusions&gt; 标签实现依赖包的排除;
    2. AA(4.2.4) 配置在 BB(5.1.6) 的前面，但又希望使用 CC(5.1.6)，那么就排除 AA 中的 CC(4.2.4);
        &lt;dependency&gt;
            &lt;groupId&gt;aa.xxx&lt;/groupId&gt;
            &lt;artifactId&gt;AA&lt;/artifactId&gt;
            &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;cc.xxx&lt;/groupId&gt;
                    &lt;artifactId&gt;CC&lt;/artifactId&gt;
                    &lt;!-- 不必再声明版本号，默认就是使用上层节点的版本号 --&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/01/07/Java数据库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/07/Java数据库/" itemprop="url">Java数据库</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-07T00:00:00+08:00">
                2016-01-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><pre><code>1. JDBC：Java Database Connection，为Java使用数据库提供了统一的编程接口；
2. JDBC由一组Java类和接口组成，是Java程序与数据库系统通信的标准API；
3. 所谓数据库驱动就是数据库厂商对JDBC接口的实现；
4. ORM框架：Hibernate、mybatis
</code></pre><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><pre><code>1. Driver：由数据库厂商提供，引入相关数据库驱动jar包，装载数据库驱动
    1. 装载MySql驱动
    Class.forName(&quot;com.mysql.jdbc.Driver&quot;); --&gt; MySQL5.0
    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); --&gt; MySQL6.0+
2. DriverManager：JDBC的管理层，作用于用户和驱动程序之间，在数据库和驱动程序之间建立连接
    DriverManager.registerDriver(new com.mysql.cj.jdbc.Driver()); --&gt;也能加载驱动
3. Connection：与特定数据库的连接会话，执行SQL语句并返回结果
    1. 连接MySQL5.0数据库
    Connection conn = DriverManager.getConnection(
        &quot;jdbc:mysql://host:port/database&quot;, &quot;username&quot;, &quot;password&quot;);
    2. 连接MySQL6.0+数据库，需要指定时区serverTimezone
    jdbc:mysql://host:port/database?serverTimezone=Asia/Shanghai
    3. 如果host和port都是默认值，可以省略：jdbc:mysql:///database?...
    4. 连接的建立是比较耗时的，内部包含Socket，实际上是建立一个Socket远程连接;
    5. 关闭连接：conn.close();
4. Statement：执行静态SQL语句并返回结果的对象
    1. Statement用于发送简单的SQL语句(不带参数)，执行SQL时需要拼接参数，有SQL注入的危险
    Statement stat = conn.createStatement();
    2. PreparedStatement：继承Statement，用于发送含有任意多个参数的SQL语句，会预编译，
    所以效率比Statement高，且防SQL注入；
    String sql = &quot;insert into users(name, time) values(?, ?)&quot;; --&gt; ? 表示占位符
    PreparedStatement stat = conn.prepareStatement(sql);
    stat.setString(1, &quot;Mack&quot;);  --&gt; 设置字符串类型的占位符，占位符索引从1开始
    stat.setDate(2, new java.sql.Date(System.currentTimeMillis())); -&gt;设置日期时间
    stat.execute();  --&gt; 执行SQL语句
    3. 如果不想关心字段类型，则使用 setObject()
    4. CallableStatement：继承自PreparedStatement，由 conn.prepareCall(sql) 创建，
    用于调用存储过程。
5. 常用方法
    1. execute()：运行语句，返回是否有结果集(true/false)
    2. executeQuery()：运行select语句，返回 ResultSet 结果集
    3. executeUpdate()：运行insert/update/delete操作，返回更新的行数
    4. close(); 关闭
6. ResultSet
    String sql = &quot;select * from users where id&gt;?&quot;;
    PreparedStatement stat = conn.prepareStatement(sql);
    stat.setInt(1, 10);
    ResultSet rs = stat.executeQuery();
    while (rs.next()) {
        int id = rs.getInt(1); --&gt; 获取第一列的数据，且字段类型为int
        String name = rs.getString(2); --&gt; 获取第二列的数据，且字段类型为String
    }
    rs.close();  stat.close(); --&gt;关闭
    1. 如果不想关心数据类型，则使用 getObject()
    2. rs.next()：迭代下一行数据，如果没有了，则返回false
7. 时间相关
    1. java.sql.Date(年月日)
    2. java.sql.Time(时分秒)
    3. java.sql.Timestamp(年月日时分秒)
8. Properties
    1. 读取和处理配置资源文件中的信息，如数据库url、database、username、password等信息
    2. 如db.properties文件，用于存储数据的配置信息：
    driver=com.mysql.cj.jdbc.Driver
    url=jdbc:mysql://localhost:3306/db_test?serverTimezone=Asia/Shanghai
    user=root
    password=123456
    3. 加载db.properties文件
    static Properties pros = null;
    static {
        pros = new Properties();
        pros.load(Thread.currentThread().getContextClassLoader()
        .getResourceAsStream(&quot;db.properties&quot;));
    }
    4. 使用db.properties中的配置信息
    Class.forName(pros.getProperty(&quot;driver&quot;));
</code></pre><h3 id="批量处理"><a href="#批量处理" class="headerlink" title="批量处理"></a>批量处理</h3><pre><code>1. PreparedStatement的预编译空间有限，数据量特别大时会发生异常，所以建议使用Statement
2. JDBC中的事务默认是自动提交，还需要设置为手动提交
    conn.setAutoCommit(false); --&gt; 禁止自动提交
    Statement stat = conn.createStatement();
    for(int i=0; i&lt;20000; i++) {
        stat.addBatch(&quot;insert into ...&quot;); --&gt;一次性插入20000条数据
    }
    stat.executeBatch();
    conn.commit(); //手动提交事务
</code></pre><h3 id="大数据量处理"><a href="#大数据量处理" class="headerlink" title="大数据量处理"></a>大数据量处理</h3><pre><code>1. CLOB：Character Large Object，用于存储大文本数据
    1. 不同数据库对大文本(大字段)有不同的处理方式，通常以流的方式处理；
    2. MySQL中的相关类型及其最大长度(字符)：TINYTEXT(2^8-1)，TEXT(2^16-1)，
    MEDIUMTEXT(2^24-1)，LONGTEXT(2^32-1或4GB)
2. JDBC操作大文本
    1. 存储
    PreparedStatement stat = conn.prepareStatement(sql);
    stat.setClob(3, new FileReader(&quot;d:/a.txt&quot;)); //接受一个流对象
    2. 读取
    ResultSet rs = ...
    while (rs.next()) {
        Clob c = rs.getClob(&quot;desc&quot;); --&gt; 指定字段名获取值
        Reader r = c.getCharacterStream(); --&gt; 获取大文本流
    }
3. BLOB：Byte Large Object，用于存储大二进制数据
    1. 不同数据库对大二进制数据(大字段)有不同的处理方式，通常以流的方式处理；
    2. MySQL中的相关类型及其最大长度(字符)：TINYBLOB(2^8-1)，BLOB(2^16-1)
    MEDIUMBLOB(2^24-1)，LONGBLOB(2^32-1或4GB)
4. JDBC操作大二进制数据
    1. 存储
    PreparedStatement stat = conn.prepareStatement(sql);
    stat.setBlob(3, new FileInputStream(&quot;d:/b.jpg&quot;)); //接受一个流对象
    2. 读取
    ResultSet rs = ...
    while (rs.next()) {
        Blob b = rs.getBlob(&quot;avatar&quot;); --&gt; 指定字段名获取值
        InputStream is = b.getBinaryStream(); --&gt;获取大二进制流
    }
</code></pre><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><pre><code>1. 事务：一组要么同时执行成功，要么同时执行失败的SQL语句，是数据库操作的一个执行单元；
2. 事务开始于：
    1. 连接数据库，并执行一条DML语句(INSERT、UPDATE、DELETE)
    2. 前一个事务结束后，又输入另一条DML语句
3. 事务结束于：
    1. 执行COMMIT或ROLLBACK语句；
    2. 执行一条DDL语句，如CREATE TABLE，这种情况会自动执行COMMIT语句；
    3. 执行一条DCL语句，如GRANT，这种情况也会自动执行COMMIT语句；
    4. 断开与数据库的连接；
    5. 执行一条DML语句，但却失败了，这种情况会执行ROLLBACK语句。
4. 四大特性：
    1. 原子性：一个事务内的所有操作是一个整体，要么全部成功，要么全部失败；
    2. 一致性：一个事务内有一个操作失败时，所有更改过的数据都必须回滚到初始状态；
    3. 隔离性：查看数据状态时，要么是另一个事务修改之前的状态，要么是修改之后的状态，不会
    出现中间状态的数据，级别：读取未提交&lt;读取已提交&lt;可重复读&lt;序列化，通常是读取已提交；
    4. 持久性：对于系统的影响是永久性的；
    conn.setAutoCommit(false); --&gt; 禁止事务自动提交
    conn.commit(); --&gt; 手动提交事务
    conn.rollback(); --&gt; 提交失败后(发生异常)，执行数据回滚
</code></pre><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><pre><code>1. Redis是内存级数据库，当Redis服务器重启，数据可能会丢失，实现持久化则需要保存在硬盘中;
2. Redis持久化机制：ROB、AOF
3. ROB：默认方式，无需配置，对内存IO性能影响较小；
    1. 在一定的时间间隔内，检测key的变化情况，然后持久化数据；
    2. 在Redis的配置文件中，默认持久化的时间间隔;
    save 900 1   ---&gt; 15分钟后，至少有1个key发生变化，则持久化一次
    save 300 10  ---&gt; 5分钟后，至少有10个key发生变化，则持久化一次
    save 60 10000  --&gt; 60秒后，至少有10000个key发生变化，则持久化一次
    3. 修改配置文件的时间间隔，手动设置持久化的频率;
    save 10 5  --&gt; 10秒后，有5个key发生了变化，就持久化一次
    4. 持久化频率的配置取决于Redis服务器的性能和具体的业务需求。
4. AOF：日志纪录方式
    1. 会纪录每一条命令的操作，且每一次命令操作后，持久化数据；
    2. 在配置文件中，默认关闭AOF机制：appendonly no
    3. 开启：appendonly yes，配置AOF持久化的频率，三选一
    # appendfsync always  ---&gt; 每次操作都进行数据持久化
    # appendfsync everysec  --&gt; 每隔1秒进行一次持久化
    # appendfsync no  --&gt; 不执行持久化
5. Redis虽然提供了数据持久化机制，但并不能保证数据一定是安全的，还需要配置关系型数据库。
</code></pre><h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h3><pre><code>1. Jedis：Java操作Redis数据库的工具，导入相关jar包；
2. 建立连接，
    Jedis jedis = new Jedis(&quot;IP&quot;, port);  --&gt; 默认IP：localhost，默认port：6379
    1. 操作字符串数据
    jedis.set(&quot;username&quot;, &quot;Mack&quot;);
    String uname = jedis.get(&quot;username&quot;);
    2. 关闭连接：jedis.close();
    3. 指定过期时间，如20s后过期删除
    jedis.setex(&quot;username&quot;, 20, &quot;Mack&quot;);
3. 哈希类型的数据：key-Map格式
    jedis.hset(&quot;user&quot;, &quot;name&quot;, &quot;Mack&quot;);
    jedis.hset(&quot;user&quot;, &quot;age&quot;, &quot;20&quot;);
    1. 参数1表示一条数据的键，参数2和参数3是这条数据的值，Map类型
    2. 获取单条数据的Map
    Map&lt;String, String&gt; user = jedis.hgetAll(&quot;key&quot;);
    3. 获取单条数据中的Map，同时根据Map的键获取值
    String name = jedis.hget(&quot;user&quot;, &quot;name&quot;);
4. 列表类型的数据：key-LinkedList格式，类似于管道，有序，支持重复数据
    jedis.lpush(&quot;mylist&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;); --&gt;从左边存一组数据，顺序为 c b a
    jedis.rpush(&quot;mylist&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;); --&gt;从右边存一组数据，顺序为 a b c
    1. 参数1表示这条数据的键，其后的参数都是列表中的值；
    2. 从左边开始取数据：
    List&lt;String&gt; mylist = jedis.lrange(&quot;mylist&quot;, 0, -1);
    3. 参数1表示一条数据的键，参数2和参数3分别表示起始角标，-1表示取到最后一个；
    [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
    4. 弹出元素，相当于从Redis中删除
    String leftEle = jedis.lpop(&quot;mylist&quot;);  --&gt; 从左边弹出一个元素，&quot;c&quot;
    String rightEle = jedis.rpop(&quot;mylist&quot;); --&gt; 从右边弹出一个元素，&quot;c&quot;
5. 集合类型的数据：key-Set格式，无序，不支持重复元素
    jedis.sadd(&quot;myset&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
    Set&lt;String&gt; myset = jedis.smembers(&quot;myset&quot;);
6. 有序集合的数据：key-sortedset格式，不允许重复元素，元素可以排序
    jedis.zadd(&quot;myzset&quot;, 10, &quot;aa&quot;);
    jedis.zadd(&quot;myzset&quot;, 2, &quot;bb&quot;);
    jedis.zadd(&quot;myzset&quot;, 30, &quot;cc&quot;);
    1. 参数1表示一条数据的键，参数2表示排序的依据，数值越小，顺序越靠前，参数3是元素值;
    2. 获取一条数据
    Set&lt;String&gt; myzset = jedis.zrange(&quot;myzset&quot;, 0, -1);  --&gt;[&quot;bb&quot;, &quot;aa&quot;, &quot;cc&quot;]
</code></pre><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><pre><code>1. Jedis自带连接池：JedisPool
    JedisPool pool = new JedisPool(); --&gt; 默认ip：localhost，默认port：6397
    Jedis jedis = pool.getResource(); --&gt; 获取Jedis对象
2. 连接池的配置对象JedisPoolConfig
    JedisPoolConfig config = new JedisPoolConfig();
    config.setMaxTotal(50);  --&gt; 最大连接数50个
    config.setMaxIdle(10);  --&gt; 最大空闲连接10个
    JedisPool pool = new JedisPool(config, ...);
3. 通过properties文件，配置数据库信息
    1. 在src目录下创建 jedis.properties
        host=127.0.0.1
        port=6379
        maxTotal=50
        maxIdle=10
    2. 在工具类JedisPoolUtil.java中加载配置文件
    static {
        InputStream is = JedisPoolUtil.class.getClassLoader()
            .getResourceAsStream(&quot;jedis.properties&quot;);
        Properties prop = new Properties();
        prop.load(is);
        JedisPoolConfig config = new JedisPoolConfig();
        int total = Integer.parseInt(prop.getProperty(&quot;maxTotal&quot;));
        config.setMaxTotal(total);
        int idle = Integer.parseInt(prop.getProperty(&quot;maxIdle&quot;));
        config.setMaxIdle(idle);
    }
</code></pre><h3 id="缓存优化"><a href="#缓存优化" class="headerlink" title="缓存优化"></a>缓存优化</h3><pre><code>1. 第一次从Redis查询数据时，如果不存在，则去MySQL中查询，并把查询结果存入Redis
2. 第二次从Redis查询数据时，Redis中已经存在了，不需要再去MySQL中查询了；
3. Redis只适合缓存一些不经常变化的数据；
4. MySQL中的数据一旦发生了变化，在其增删改的方法中，及时更新Reids中的缓存数据。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/01/06/Java动态性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/06/Java动态性/" itemprop="url">Java动态性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-06T00:00:00+08:00">
                2016-01-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><h3 id="类的反射"><a href="#类的反射" class="headerlink" title="类的反射"></a>类的反射</h3><pre><code>1. 获取Class对象的三种方式
    1. 对象.getClass()
    2. 类名.class
    3. Class.forName(&quot;包名.类名&quot;);
2. 获取类名
    Class clz = Class.forName(&quot;com.sxt.serv.Channel&quot;);
    clz.getName(); --&gt; 获取完整路径(包名)的类名
    clz.getSimpleName(); --&gt; 只获取类名 
3. 获取构造器Constructor
    1. clz.getConstructor(参数类型.class...); 只能获取public构造器
    2. clz.getDeclaredConstructor(参数类型.class...); 获取任意构造器
    Constructor&lt;Channel&gt; cons = clz.getDeclaredConstructor(String.class);
    cons.setAccessible(true); --&gt;默认不允许访问private成员，必须跳过安全检查
    Channel cha = cons.newInstance(&quot;123&quot;); -- &gt;传递参数，创建对象
    3. 参数类型都是可变长参数，对于无参构造器，则不传任何参数
    Channel cha = clz.newInstance(); --&gt;使用public无参构造的创建对象，从JDK9开始废弃
    Channel cha = clz.getConstructor().newInstance();
4. 获取属性Field
    1. clz.getField(&quot;属性名&quot;); 只能获取public修饰的属性
    2. clz.getDeclaredField(&quot;属性名&quot;); 获取任意的属性
    3. 操作(私有)属性
    Field id = clz.getDeclaredField(&quot;id&quot;); //int id
    id.setAccessible(true);  --&gt;跳过安全检查
    id.set(cha, 10); --&gt;设置对象cha上的id属性
    int i = id.get(cha); --&gt;获取id属性值
5. 获取方法Method
    1. clz.getMethod(&quot;方法名&quot;, 参数类型.class...); 只能获取public修饰的方法
    2. clz.getDeclaredMethod(&quot;方法名&quot;, 参数类型.class...); 获取任意的方法
    3. 如果方法是无参的，参数类型通常传null，也可以什么不传
    4. 调用(私有)方法
    Method m = clz.getDeclaredMethod(&quot;setAge&quot;, int.class);
    m.setAccessible(true);
    m.invoke(cha, 12);  //cha.setAge(12)
</code></pre><h3 id="泛型的反射"><a href="#泛型的反射" class="headerlink" title="泛型的反射"></a>泛型的反射</h3><pre><code>1. 泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换的麻烦，一旦编译完成，
   所有和泛型相关的类型都会全部擦除；
2. 为了让反射可以操作泛型，Java新增ParameterizedType、GenericArrayType、TypeVariable、
    WildcardType来代表不能被归到Class类中的类型、但又和原始类型齐名的类型；
    1. ParameterizedType：表示参数化的类型，比如Collection&lt;String&gt;
    2. GenericArrayType：表示元素类型是参数化类型，或类型变量的数组类型
    3. TypeVariable：各种类型变量的公共父接口
    4. WildcardType：代表通配符类型表达式，比如 ?，? extends Number，? super Integer
3. ParameterizedType
    public class TestTable {
        public void test01(Map&lt;String, TableBean&gt; map, List&lt;TableBean&gt; list) { }
        public Map&lt;Integer, TableBean&gt; test02() { return null; }
    }
    1. 获取参数泛型
    Method m = TestTable.class.getMethod(&quot;test01&quot;, Map.class, List.class);
    Type[] paramTypes = m.getGenericParameterTypes(); //获取带泛型的参数类型
    for (Type t: paramTypes) {
        System.out.println(&quot;paramType: &quot; + t); //带泛型的参数类型
        if (t instanceof ParameterizedType) {
            //获取真正的泛型类型
            Type[] typeArgs = ((ParameterizedType) t).getActualTypeArguments();
            for (Type gt: typeArgs) {
                System.out.println(&quot;参数上的泛型类型：&quot; + gt);
            }
        }
    }
    2. 获取返回的参数泛型
    Method m = TestTable.class.getMethod(&quot;test02&quot;, null);
    Type at = m.getGenericReturnType(); //获取带泛型的返回值类型
    if (at instanceof ParameterizedType) {
        //获取真正的泛型类型
        Type[] typeArgs = ((ParameterizedType) at).getActualTypeArguments();
        for (Type gt: typeArgs) {
            System.out.println(&quot;返回值的泛型类型：&quot; + gt);
        }
    }
</code></pre><h2 id="动态编译"><a href="#动态编译" class="headerlink" title="动态编译"></a>动态编译</h2><pre><code>1. Java6.0引入动态编译，有两种方式
    1. Runtime调用javac，启动新的进程去操作
    Runtime run = Runtime.getRuntime();
    Process p = run.exec(&quot;javac -cp d:/workplace/ HelloWorld.java&quot;);
    2. JavaCompiler动态编译
2. JavaCompiler
    1. 动态编译Java文件
    JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
    int result = compiler.run(null, null, null, &quot;E:/workplace/HelloWorld.java&quot;);
    ---&gt; result为0，表示编译成功，生成class文件
    2. 动态编译java字符串
    String text = &quot;public class Hi { public static void main(String[] args)
        { System.out.println(\&quot;hi\&quot;); } }&quot;;
    ---&gt; 需要把这个字符串通过IO流存成一个临时文件(Hi.java)，再进行动态编译
3. Runtime运行编译好的class文件
    Runtime run = Runtime.getRuntime();
    Process p = run.exec(&quot;java -cp E:/workplace HelloWorld&quot;);
    InputStream is = p.getInputStream();
    BufferedReader br = new BufferedReader(new InputStreamReader(is));
    String info = &quot;&quot;;
    while (null != (info=br.readLine())) {
        System.out.println(info); //hi
    }
4. 反射运行编译好的class文件
    URL[] urls = new URL[] {new URL(&quot;file:/&quot; + &quot;E:/workplace/&quot;)};
    URLClassLoader loader = new URLClassLoader(urls);
    Class clz = loader.loadClass(&quot;HelloWorld&quot;);
    Method me = clz.getMethod(&quot;main&quot;, String[].class);
    //由于可变参数在JDK5.0才引入，传递数组时，如new String[]{&quot;a&quot;, &quot;b&quot;}，会被解析为
    //invoke(null, &quot;a&quot;, &quot;b&quot;)，所以需要使用Object强转类型
    me.invoke(null, (Object)new String[]{});
</code></pre><h2 id="动态执行JavaScript代码"><a href="#动态执行JavaScript代码" class="headerlink" title="动态执行JavaScript代码"></a>动态执行JavaScript代码</h2><pre><code>1. JDK6.0新增脚本引擎，使Java应用可以通过一套固定的接口与各种脚本引擎交互，从而在Java平台
   上调用各种脚本语言
2. JavaScript引擎：Rhino
    1. Rhino是一种使用Java编写的JS的开源实现，原由Mozilla开发，现已被集成到JDK6.0
    ScriptEngineManager sem = new ScriptEngineManager();
    ScriptEngine engine = sem.getEngineByName(&quot;JavaScript&quot;);
    2. 可以执行字符串形式的JS语句，也可以执行JS脚本文件。
</code></pre><h2 id="动态字节码操作"><a href="#动态字节码操作" class="headerlink" title="动态字节码操作"></a>动态字节码操作</h2><pre><code>1. 运行时操作字节码可以实现：
    1. 动态生成新的类
    2. 动态改变某个类的结构(增删改 新的属性/方法)
2. 优点：比反射开销小、性能高，与反射相辅相成；
3. 常见的字节码操作类库
    1. BCEL：可以深入JVM汇编语言进行类操作的细节，拥有丰富的JVM指令级支持；
    2. ASM是一个轻量级Java字节码操作框架，直接涉及到JVM底层的操作和指令；
    3. BECL和ASM的效率最高，因为是在JVM指令层次上进行操作，学习难度也比较大；
    4. CGLIB：一个强大的、高性能、高质量的Code生成类库，基于ASM实现；
    5. Javassist：一个开源的Java字节码类库，强调的是源代码级别，性能跟CGLIB差不多，
    但使用简单，应用于很多开源框架。
4. Javassist
    1. 最外层API与Java反射的API颇为相似，如CtClass，CtMethod，CtField
    2. 局限性：只适合常规操作
</code></pre><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><pre><code>1. 内置注解：@Override，@Deprecated，@SuppressWarnings，@Target...
2. @interface 自定义注解，自动继承Annotation接口
    public @interface 注解名 { ... }
3. 元注解：负责解释其他注解，Java定义了4个标准的meta-annotation类型(元注解)
    1. @Target、@Retention、@Documented、@Inherited
    2. 这些类型和它们所支持的类在java.lang.annotation包中。
4. @Target：声明注解的使用范围，由ElementType定义可取的值
    1. package包：PACKAGE，@Target(value=ElementType.PACKAGE)
    2. 类、接口、枚举、Annotation类型：TYPE
    3. 类成员(构造方法、成员变量、方法、枚举值)：CONSTRUCTOR描述构造器，FIELD描述域(字段)，
    METHOD描述方法
    4. 方法参数和本地变量：LOCAL_VARIABLE用于描述局部变量，PARAMETER用于描述参数
    @Target(value=ElementType.METHOD)  --&gt; 声明此注解只能在方法上使用
    public @interface TestAnnot { ... }
    5. value可以取多个值，扩大应用范围
    @Target(value={ElementType.METHOD, ElementType.TYPE})
    public @interface TestAnnot { ... }  --&gt;此注解可以同时修饰方法、类
5. @Retention：表示需要在什么级别保存该注释信息，用于描述注解的生命周期
    1. SOURCE：在源文件中有效
    2. CLASS：在class文件中有效
    3. RUNTIME：在运行时有效，被反射机制读取(反射在运行期有效)
    @Target(value={ElementType.METHOD, ElementType.TYPE})
    @Retention(RetentionPolicy.RUNTIME)
    public @interface TestAnnot { ... }
</code></pre><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><pre><code>1. 定义注解的成员
    @Target(value={ElementType.METHOD, ElementType.TYPE})
    @Retention(RetentionPolicy.RUNTIME)
    public @interface TestAnnot {
        String stuName() default &quot;&quot;;  --&gt;参数类型String，参数名stuName，默认值&quot;&quot;
        int age() default 0;
        String[] schools() default {};
    }
2. 使用自定义注解
    @TestAnnot
    public class TestMain {
        @TestAnnot
        public void test(){ }
    }
    1. 如果没有注解中的成员没有默认值，则必须在使用时赋予值，否则会报编译期错误
    @TestAnnot(uname = &quot;&quot;, age = -1, schools = {})
    public class TestMain {
        @TestAnnot(uname = &quot;abc&quot;, age = 0, schools = {&quot;a&quot;, &quot;b&quot;})
        public void test(){ }
    }
    2. 如果注解中只有一个成员(通常定义为value)，在使用赋值时，可以不指定参数名
    @Target(value=ElementType.TYPE)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface MyAnnot {
        String value();
    }
    @MyAnnot(&quot;abc&quot;)
    public class TestMain { ... }
3. 注解的解析，配合反射，以数据库表的ORM映射为例
    1. 表的注解
    @Target(value = {ElementType.TYPE})
    @Retention(RetentionPolicy.RUNTIME)
    public @interface Table {
        String value(); --&gt; 记录表名
    }
    2. 表的字段约束
    @Target(value = ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface Column {
        String columnName(); --&gt; 字段名
        String type(); --&gt; 字段类型
        int length(); --&gt; 长度
    }
    3. 表映射的JavaBean
    @Table(&quot;user&quot;)
    public class UserBean {
        @Column(columnName = &quot;id&quot;, type = &quot;int&quot;, length = 10)
        private int id;
        @Column(columnName = &quot;name&quot;, type = &quot;varchar&quot;, length = 10)
        private String username;
        @Column(columnName = &quot;age&quot;, type = &quot;int&quot;, length = 3)
        private int age;
        ......
    }
    Class clz = Class.forName(&quot;it.test.cn.UserBean&quot;);
    4. 获取类上的注解
    Annotation[] annots = clz.getAnnotations(); --&gt; 获取类UserBean上的所有注解
    Table tab = (Table) clz.getAnnotation(Table.class); --&gt; 获取指定的注解
    String val = tab.value();  --&gt; 获取注解成员的值&quot;user&quot;
    5. 获取类属性上的注解(类方法同理)
    Field f = clz.getDeclaredField(&quot;username&quot;); --&gt; 获取属性username
    Column col = f.getAnnotation(Column.class); --&gt; 获取属性上的注解
    col.columnName();//&quot;name&quot;  col.type();//&quot;varchar&quot;  col.length();//10
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/01/05/Java网络编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/05/Java网络编程/" itemprop="url">Java网络编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-05T00:00:00+08:00">
                2016-01-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Ip相关的类：InetAddress"><a href="#Ip相关的类：InetAddress" class="headerlink" title="Ip相关的类：InetAddress"></a>Ip相关的类：InetAddress</h2><pre><code>1. 获取本机的Ip、hostname
    InetAddress addr = InetAddress.getLocalHost();
    String ip = addr.getHostAddress();
    String hostName = addr.getHostName(); //计算机名
2. 根据域名获取Ip、hostname
    InetAddress addr = InetAddress.getByName(&quot;www.baidu.com&quot;); //内部是NDS解析
    String ip = addr.getHostAddress(); //Ip
    String hostName = addr.getHostName(); //域名www.baidu.com
3. 如果getByName(&quot;Ip地址&quot;)，getHostName()获取的仍是Ip，而不是域名；
4. 子类：Inet4Address、Inet6Address
</code></pre><h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><pre><code>1. 端口号表示一个16位的二进制整数，2个字节，对应十进制0-65535
    1. 公认端口0-1023，如80是http协议的默认端口
    2. 注册端口1024-49151(分配给用户进程/应用程序)
    3. 动态/私有端口49152-65535
2. windows命令
    1. netstat -ano  ---&gt; 查看所有的端口号
    2. netstat -ano|findstr &quot;808&quot;  ---&gt; 查看指定端口号
    3. tasklist|findstr &quot;808&quot;  ---&gt; 查看指定进程
3. InetSocketAddress：包含端口号，用于socket通信
    InetSocketAddress s = new InetSocketAddress(&quot;127.0.0.1/localhost&quot;, 8080);
    s.getHostName();  s.getAddress();  s.getPort();
</code></pre><h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><pre><code>1. URL和URN都是URI的子集
    1. URI：统一资源标识符，表示一个资源，比如一个具体的人
    2. URL：统一资源定位符，用地址定位一个资源，比如XX省XX市XX区...XX单元XX室的主人
    3. URN：统一资源名称，用名称定位一个资源，但不明确资源的位置，比如身份证号+姓名去找人
2. 网络三大基石：HTML、HTTP、URL
3. URL由4部分组成：协议、资源所在的主机域名、端口号、资源文件名
4. URL url = new URL(&quot;http://www.baidu.com:80/index.html#aa?xx=xxx&quot;);
    1. url.getProtocol()：协议名
    2. url.getDefaultPort()：获取与此URL关联的协议的默认端口号
    3. url.getHost()：主机名/域名
    4. url.getFile()：端口号后的所有内容
    5. url.getPath()：端口号后、参数前的内容
    6. url.getQuery()：参数部分
    7. url.getRef()：锚点
5. 相对路径构建URL
    URL u1 = new URL(&quot;http://www.baidu.com/aa/&quot;);
    URL u2 = new URL(u, &quot;b.html&quot;); --&gt; http://www.baidu.com/aa/b.html
6. 发起请求
    1. 抓取网络数据，非浏览器访问
    InputStream is = url.openStream();
    BufferedReader br = new BufferedReader(new InputStreamReader(is, &quot;UTF-8&quot;));
    String msg = null;
    while(null != (msg=br.readLine())) {
        System.out.println(msg);
    }
    br.close();
    2. 模拟浏览器访问
    HttpURLConnection conn = (HttpURLConnection) url.openConnection();
    conn.setRequestMethod(&quot;GET&quot;);  --&gt;设置请求方式
    conn.setRequestProperty(&quot;User-Agent&quot;, &quot;value&quot;); --&gt;设置请求头
    BufferedReader br = new BufferedReader(
        new InputStreamReader(conn.getInputStream(), &quot;GBK&quot;));
</code></pre><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><pre><code>1. DatagramSocket：用于发送/接受数据包的套接字；
2. DatagramPacket：数据包；
3. 发送端
    DatagramSocket client = new DatagramSocket(8888);
    String data = &quot;Hello I&apos;m Client&quot;;
    byte[] bys = data.getBytes();
    //发送给&quot;127.0.0.1:9999&quot;
    DatagramPacket packet = new DatagramPacket(bys, 0, bys.length, 
        new InetSocketAddress(&quot;127.0.0.1&quot;, 9999));
    client.send(packet);
    client.close();
4. 接收端
    DatagramSocket server = new DatagramSocket(9999); --&gt; 监听端口9999
    byte[] container = new byte[1024*60];
    DatagramPacket packet = new DatagramPacket(container, 0, container.length);
    server.receive(packet);
    byte[] bys = packet.getData();
    int len = packet.getLength();
    String data = new String(bys, 0, len);
    server.close();
</code></pre><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><pre><code>1. 服务端：ServerSocket
    ServerSocket server = new ServerSocket(8889);
    Socket client = server.accept(); --&gt;阻塞式，等待客户端连接
    DataInputStream dis = new DataInputStream(client.getInputStream());
    String data = dis.readUTF(); --&gt;客户端的数据
    dis.close();
    client.close();
    server.close();
    1. 通过每一次连接的client，向对应的客户端响应数据
    DataOutputStream dos = new DataOutputStream(client.getOutputStream());
    dos.writeUTF(&quot;hello I&apos;m Server&quot;); --&gt;向客户端响应数据
    dos.flush();
    dos.close();
2. 客户端：Socket
    //指定服务端的Ip和端口号，发起连接请求
    Socket client = new Socket(&quot;127.0.0.1&quot;, 8889);
    DataOutputStream dos = new DataOutputStream(client.getOutputStream());
    dos.writeUTF(&quot;hello I&apos;m Client&quot;); --&gt;向服务端写入数据
    dos.flush();
    dos.close();
    client.close();
    1. client接收服务端的响应数据
    DataInputStream dis = new DataInputStream(client.getInputStream());
    String data = dis.readUTF(); --&gt;接收响应数据
    dis.close();
3. HTTP底层正是TCP，浏览器作为客户端，也可以直接访问TCP服务器端.
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/01/03/Java多线程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/03/Java多线程/" itemprop="url">Java多线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-03T00:00:00+08:00">
                2016-01-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><pre><code>1. 线程状态
</code></pre><p><img src="https://i.imgur.com/vLw2xgt.jpg" alt></p>
<pre><code>    1. Thread.State：线程的状态，NEW(尚未启动的线程)、RUNNABLE、BLOCKED、WAITING、
    TIMED_WAITING、TERMINATED(已退出的线程)
    2. RUNNABLE：包含就绪状态和运行状态；
    3. getState()：获取线程的状态。
2. 线程的 stop() 方法已经被废弃，因为线程的终止可以通过一个boolean型的标志位变量完成；
3. sleep() yield() join()
    1. sleep() 表示休眠，会阻塞线程，且不会释放锁，睡眠时间到了之后，重新进入就绪状态；
    常用于模拟网络延迟、倒计时...
    2. yield() 则礼让出CPU的执行权，线程进入就绪状态；
    3. join() 插队，待此线程执行完成后，再执行其他线程，这段时间内，其他线程处于阻塞状态；
4. 优先级：线程的优先级并不能决定哪个线程先执行，优先级高的线程被执行的概率相对会高一些；
    1. setPriority(priority)：设置线程的优先级，范围1-10，在 start() 之前设置有效；
    2. Thread.MIN_PRIORITY，Thread.MAX_PRIORITY，Thread.NORM_PRIORITY：1，10，5
5. 线程分为用户线程和守护线程，默认的线程都是用户线程
    1. 虚拟机JVM会确保所有的用户线程执行完毕，再退出程序，但不会等待守护线程执行完毕；
    2. 如后台记录操作日志、监控内存使用等
    3. setDaemon(true)：把线程设置为守护线程，在 start() 之前调用。
6. Thread.currentThread()：获取当前线程；
7. isAlive()：线程是否还活着。
</code></pre><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><pre><code>1. 线程同步：synchronized，队列
    1. 若将一个大的方法声明为synchronized，将会大大影响效率；
    2. 与大的synchronized方法相比，synchronized块能在一定程度上减少性能的损失；
    3. 使用 synchronized 的关键在于，第一要锁对目标，第二要取舍synchronized块的面积。
2. 同步块的锁：
    1. 同步方法的锁是this，表示当前对象，不可改变；
    2. 同步块的锁可以指定，锁住的目标更明确，还能减小锁的面积。
3. 并发容器：CopyOnWriteArrayList，加锁的ArrayList，保证在写入数据时的安全；
4. 死锁：相互持有对方的锁，需要避免锁的嵌套。
</code></pre><h3 id="并发协作"><a href="#并发协作" class="headerlink" title="并发协作"></a>并发协作</h3><pre><code>1. 生产者与消费者模式：线程同步问题，生产者和消费者共享同一资源，且生产者和消费者相互依赖；
    1. synchronized只是阻止并发更新同一共享资源，实现同步，但并不能实现线程间的通信；
    2. 管程法：利用并发缓冲容器实现；
    3. 信号灯法：借助标志位实现；
    4. wait()，notify()，notifyAll()
2. 管程法
    1. 容器满了，则生产者等待；容器为空时，则消费者等待；
    2. 容器中有元素时，唤醒消费者取出；消费者取出元素之后，唤醒生产者存入；
    class Food {  --&gt; 生产/消费的对象
        public int count;
        public Food(int c) { this.count = c; }
    }
    3. 容器具备同步的存入和取出方法
    class Container {
        private Food[] foodList = new Food[10];  private int count = 0;
        public synchronized void push(Food f) {  ---&gt; 同步方法的锁默认是this
            if ((this.foodList.length-1)==count) {
                this.wait(); --&gt; 容器满了，生产者进入等待
            }
            this.foodList[count] = f;  count++;
            this.notifyAll();   ----&gt; 容器中已经有了元素，唤醒消费者
        }
        public synchronized Food pop() {
            if (count &lt; 1) {
                this.wait(); --&gt; 容器为空，生产者进入等待
            }
            count--;  Food f = this.foodList[count];
            this.notifyAll();   ----&gt; 消费者取出了元素，唤醒生产者
            return f;
        }
    }
    4. 生产者和消费者的线程
    class Producter extends Thread {
        private Container con;
        public Producter(Container con) { this.con = con; }
        public void run() {
            for (int i=0; i&lt;100; i++) {
                this.con.push(new Food(i+1)); ---&gt; 生产者向容器中存入元素
                System.out.println(&quot;生产第 &quot;+(i+1)+&quot; 个&quot;);
            }
        }
    }
    class Customer extends Thread {
        private Container con;
        public Customer(Container con) { this.con = con; }
        public void run() {
            for (int i=0; i&lt;100; i++) {
                Food food = this.con.pop(); ---&gt; 消费者从容器中取出元素
                System.out.println(&quot;消费第 &quot;+(food.count)+&quot; 个&quot;);
            }
        }
    }
    5. 生产者和消费者操作的必须是同一个容器
    Container con = new Container();
    Producter p = new Producter(con);  Customer c = new Customer(con);
    p.start();  c.start();
3. 信号灯法
    1. 标志位为true，让生产者等待，消费者运行完成后，设置标志位为false，并唤醒生产者；
    2. 反之，让消费者等待，生产者运行完成后，设置标志位为true，并唤醒消费者；
    class Tv {
        private String show;   --&gt; 生产和消费的元素
        private boolean flag;  --&gt; 标志位
        public synchronized void play(String show) {
            if (this.flag) {
                this.wait();   --&gt; 生产者等待
            }
            this.show = show;
            this.flag = !this.flag;  --&gt; 标志位取反
            this.notifyAll();  --&gt; 唤醒消费者
        }
        public synchronized String watch() {
            if (!this.flag) {
                this.wait();   --&gt; 消费者等待
            }
            this.flag = !this.flag;  --&gt; 标志位取反
            this.notifyAll();  --&gt; 唤醒生产者
            return show;
        }
    }
    3. 生产者和消费者的线程
    class Actor extends Thread {
        private Tv tv;
        public Actor(Tv tv) {  this.tv = tv;  }
        public void run() {
            for (int i=0; i&lt;100; i++) {
                String show = i%2==0?&quot;跳舞&quot;:&quot;唱歌&quot;;
                this.tv.play(show);
                System.out.println(&quot;生产者：&quot; + show + &quot;::&quot; + i);
            }
        }
    }
    class Audience extends Thread {
        private Tv tv;
        public Audience(Tv tv) {  this.tv = tv;  }
        public void run() {
            for (int i=0; i&lt;100; i++) {
                System.out.println(&quot;消费者：&quot; + this.tv.watch() + &quot;::&quot; + i);
            }
        }
    }
    Tv tv = new Tv();
    Actor actor = new Actor(tv);  Audience audience = new Audience(tv);
    actor.start();  audience.start();
</code></pre><h2 id="定时调度"><a href="#定时调度" class="headerlink" title="定时调度"></a>定时调度</h2><pre><code>1. Timer和TimerTask
    class EvenTask extends TimerTask {  --&gt; 任务线程
        public void run() { ... }
    }
    Timer t = new Timer();  --&gt; 定时器
    EvenTask task = new EvenTask();
    1. t.schedule(task, 3000);  ----&gt; 3s后执行一次
    2. t.schedule(task, 3000, 1000);  ----&gt; 3s后每隔1s执行一次
    3. t.schedule(task, date);  -----&gt; 指定时间定时执行
2. 调度框架：quartz
</code></pre><h2 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h2><pre><code>1. HappenBefore：虚拟机优化代码顺序，导致执行顺序可能与编写代码的顺序不一致，称为指令重排
2. 指令重排是编译器或运行时环境为了优化程序性能而采取的对指令进行重新排序执行的一种手段
3. CPU执行指令的步骤
    从内存中获取一条指令 --&gt; 解码指令，取值 --&gt; 操作值，得到结果 --&gt; 把结果写回寄存器中
4. 编译器和处理器在重排指令时，遵守数据依赖性，不会改变存在数据依赖关系的两个操作的执行顺序
5. 在虚拟机层面和硬件层面，都可能出现指令重排
    1. 在虚拟机层面：内存操作速度远慢于CPU运行速度，为了避免CPU空置的影响；
    2. 在硬件层面：CPU速度比缓存速度快。
</code></pre><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><pre><code>1. volatile保证线程间的可见性，当线程A修改变量X后，其后的其他线程能看到变量X的变动；
2. 线程有自己的工作内存，且彼此独立、互补可见；
    1. 工作内存不仅包含了线程内部定义的局部变量，也包含了线程所需要使用的共享变量的副本；
    2. 为了提高效率，线程并不会每次都从主内存中读取共享变量。
3. volatile的变量符合两个规则
    1. 线程对变量修改之后，要立刻写到主内存
    2. 线程对变量读取的时候，要从主内存中读，而不是缓存(工作内存)
4. volatile不能保证原子性
    1. 比如x=x+1分为3步：从内存中获取x，对x加1，再把结果写回内存中
    2. volatile并不能保证这3步同时发生，只能保证变量x的结果发生变化后，对每个线程都可见
5. volatile是一个轻量级的synchronized
    private volatile static int num = 0;
    new Thread(()-&gt;{
        while (num==0) {} ---&gt; 不执行任何具体任务
    }).start();
    Thread.sleep(1000);
    num = 1;
    1. 如果不使用volatile修饰，1s后的num虽然已经置为1，但因为子线程执行空的while循环，
    造成CPU很繁忙，来不及把变量num同步给子线程的内存空间，所以子线程始终不会结束；
    2. 一旦while(num==0){}中执行了具体任务，CPU就有可能把num=1同步给子线程的内存空间，
    结束while循环；
    3. 变量num使用volatile修饰，子线程中的while(num==0){}每次都从主内存中读取num的值，
    所以在1s之后，num被置为1，也会立即被子线程的while(num==0)所感知，终止循环。
6. 单例模式之懒汉式的并发控制：双重检测、指令重排
    public class LittleBable {
        //volatile防止new对象的过程中指令重排，造成其他线程访问一个还有初始化完成的对象
        private static volatile LittleBable instance;
        private LittleBable() {}
        public static LittleBable getInstance() {
            if (null != instance) { return instance; } //双重检测，防止不必要的同步
            synchronized (LittleBable.class) {
                if (null == instance) {  instance = new LittleBable(); }
            }
            return instance;
        }
    }
</code></pre><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><pre><code>1. ThreadLocal是线程局部变量的存储空间，虽然被多个线程共享，但能使线程安全；
    private static ThreadLocal&lt;Interger&gt; tl = new ThreadLocal&lt;&gt;();
    1. JDK建议把ThreadLocal声明为private static
    2. 泛型为Integer，默认值为null   --&gt; tl.get(); --&gt; null
    3. 指定默认值
    new ThreadLocal&lt;&gt;(){ protected Integer initialValue(){ return 20; } };
    4. JDK8的新特性
    private static ThreadLocal&lt;Interger&gt; tl = ThreadLocal.withInitial(()-&gt;20);
    5. 设置新的值：tl.set(100);
2. 多个线程在获取/设置ThreadLocal时，相互不会影响；
    tl.set(100); --&gt; 在主线程中修改为100 --&gt; tl.get(); --&gt; 100
    new Thread(()-&gt;{
        tl.get(); --&gt; 在子线程中仍是默认值20 --&gt; tl.set(100);  --&gt; tl.get(); --&gt; 100
    }).start();
3. 上下文环境问题
    class TestRun implements Runnable {
        public TestRun() { tl.set(33); }
        public void run() { tl.get();  -----&gt; 20 }
    }
    new Thread(new TestRun()).start(); --&gt; 在主线程中执行
    1. 创建对象是在主线程中进行的，所以TestRun的构造函数也是在主线程中，tl.set(33); 设置
    的是主线程的ThreadLocal变量
    2. run()才是在子线程中执行的，所以获取ThreadLocal的变量仍是默认值20
</code></pre><h3 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h3><pre><code>1. InheritableThreadLocal：上下文环境的可继承ThreadLocal
2. 子线程会从当前上下文环境拷贝一份ThreadLocal，重新设置ThreadLocal也不会影响原上下文
    private static ThreadLocal&lt;Integer&gt; tl = new InheritableThreadLocal&lt;&gt;();
    tl.set(100);
    new Thread(()-&gt;{
        tl.get();  ---&gt; 100
        tl.set(200);  ---&gt; tl.get(); --&gt; 200
    }).start();
    tl.get();  --&gt; 100
3. ThreadLocal的应用
    1. 最常见的是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息...
    2. Hibernate的Session工具类：HibernateUtil
    3. 通过不同的线程对象设置Bean属性，保证各个线程Bean对象的独立性。
</code></pre><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><pre><code>1. 锁作为保证并发共享数据一致性的工具，大多数内置锁都是可重入的，也就是可以延续使用；
2. 可重入
    1. 如果某个线程试图获取一个已经由它自己持有的锁时，那么此请求会立即成功，且会将这个锁
    的计数值加1；
    2. 当线程退出同步代码块时，计数器会递减，当计数值为0时，锁释放。
    3. 如果没有可重入锁的支持，在第二次试图获得锁时，将进入死锁状态；
    synchronized(this) { --&gt; 第一次获取锁
        while(true) {
            synchronized(this) { } --&gt; 第二次获取同一把锁
        }
    }
    public synchronized void testA() { }
    public synchronized void testB() { }
    public synchronized void testAll() {
        this.testA();  --&gt; 第二次获取同一把锁
        this.testB();
    }
3. 不可重入锁
    class Lock {
        private boolean isLocked = false;
        public synchronized void lock() {
            while(isLocked){ --&gt; 锁已经被占用了，则等待
                wait();
            }
            isLocked = true;
        }
        public synchronized void unlock() {
            isLocked = false;
            notify();  ---&gt; 释放锁，唤醒一个等待的线程
        }
    }
    Lock lock = new Lock();
    public void doSomething() {
        lock.lock();
        // ......
        lock.unlock();
    }
    public void test() {
        lock.lock();  --&gt; 上锁
        doSomething(); --&gt; 内部继续上同一把锁，但lock是不可重入的，所以陷入死锁状态
        lock.unlock();
    }
4. 可重入锁的实现原理
    class Lock {
        private boolean isLocked = false;
        private Thread t = null;
        private int count = 0; ---&gt; 计数器
        public synchronized void lock() {
            //对同一个线程放行，同一个线程可以重复上同一把锁
            Thread currentT = Thread.currentThread()
            while(isLocked &amp;&amp; (t!=currentT)){
                wait();  --&gt; 不是同一个线程，且锁已经被占用时，则等待
            }
            isLocked = true;  t = currentT;  count++;
        }
        public synchronized void unlock() {
            if(Thread.currentThread() == t) {
                count--;
                if(count == 0) { --&gt; 计数器为0时，当前线程才能释放锁
                    isLocked = false;
                    notify();  ---&gt; 唤醒一个等待的线程
                    t = null;
                }
            }
        }
    }
</code></pre><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><pre><code>1. 悲观锁：synchronized是独占锁(悲观锁)，会导致其他所有线程挂起，等待持有锁的线程释放锁
2. 乐观锁：完成某项操作时，每次不加锁，而是假设没有冲突，如果因为冲突失败就重试，直至成功
3. CAS：Compare and Swap，比较并交换，乐观锁的实现，如购物时的秒杀功能
    1. 有三个值：一个当前内存值V，旧的预期值A，将更新的值B
    2. 先获取内存中的值V，再将V与原值A比较，如果相等，则修改为B，并返回true，否则不修改，
    返回false
    3. CAS是一组原子操作，不会被外部打断；
    4. CAS属于硬件级别的操作(利用CPU的CAS指令，同时借助JNI来完成的非阻塞算法)，效率比加锁
    操作高；
    5. ABA问题：如果变量V初次读取时是A，且在准备赋值时检查到它仍是A，此时并不能保证变量V
    没被修改过，如果在这期间曾被修改成B，然后又改回A，那CAS操作就会误认为它从来没有修改过。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/01/02/Java基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/02/Java基础/" itemprop="url">Java基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-02T00:00:00+08:00">
                2016-01-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><pre><code>1. 浮点数的精确计算：BigDecimal，java.math包中的类
    1. 相减
    BigDecimal db1 = BigDecimal.valueOf(1.0);  --&gt; 浮点数1.0
    db1 = db1.subtract(BigDecimal.valueOf(0.1));  --&gt; 1.0 - 0.1
    2. 相除
    BigDecimal db2 = BigDecimal.valueOf(0.1);
    BigDecimal db3 = BigDecimal.valueOf(1.0/10.0);
    System.out.println(db2.equals(db3)); --&gt; true
2. 自动类型转换：容量小的类型自动向容量大的类型转换
    1. 特例：byte b = 123;
    2. 123 本身是 int 类型(Java中的数值默认是int类型)，byte类型的范围为-128~127
    3. 所以，123 可以直接赋值给 byte类型(自动转为byte类型)。
3. 溢出
    1. int m = 1000000000;  int y = 20;
    2. int t = m * y; --&gt; 负数(溢出导致)
    3. long t = m * (long)y; --&gt; 20000000000
4. Java5提供了可变长参数
    public void print(int n, String... args){
        for(String temp: args){ } --&gt;遍历可变长参数
    }
    print(2, &quot;a&quot;);  print(2, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
5. TreeMap与TreeSet
    1. TreeMap：红黑二叉树的典型实现，按照key自增长的方向排序；
    2. TreeSet：内部维持了一个简化版的TreeMap，通过key存储Set的元素；
    3. 如果存储的是对象，此对象应实现 Comparable 接口，以便于对其进行排序。
6. lambda表达式：JDK8新特性
    1. 针对的是只包含一个方法的接口，如Runnable
    new Thread(new Runnable(){
        public void run(){ System.out.println(&quot;start Run&quot;); }
    }).start();
    new Thread(()-&gt; {
        System.out.println(&quot;start Run&quot;);
    }).start();
    2. Thread是Runnable的代理对象(静态代理)。
7. 静态代理
    1. 代理对象和原对象都实现同一个接口
    interface Task {  void work();  }
    2. 原对象
    class Stuff implements Sask {
        public void work() { }
    }
    3. 静态代理对象
    class StaticProxy implements Task {
        private Task target;
        public StaticProxy(Task target) {
            this.target = target;
        }
        public void work() {
            this.start();
            this.target.work();
            this.end();
        }
        private void start(){ }
        private void end(){ }
    }
    4. 通过代理对象，执行原对象的任务方法
    new StaticProxy(new Stuff()).work();
8. 多线程之Callable
    1. Callable是一个接口，包含方法call()，接收一个泛型，默认是Object，作为call()的
    返回值类型
    public class CLoader implements Callable&lt;Boolean&gt; {  --&gt; 泛型指定为Boolean
        public Boolean call() throw Exception {
            ...... //执行任务
            return true
        }
    }
    CLoader cd1 = new CLoader(); CLoader cd2 = new CLoader();
    2. 使用线程池，创建服务
    ExecutorService es = Executors.newFixedThreadPool(2);
    3. 提交执行
    Future&lt;Boolean&gt; ft1 = es.submit(cd1);  Future&lt;Boolean&gt; ft2 = es.submit(cd2);
    4. 获取结果
    boolean re1 = ft1.get();  boolean re2 = ft2.get();
    5. 关闭服务
    es.shutdownNow();
    6. 与Thread/Runnable的 run() 相比，call()可以抛出异常，而 run() 不能抛出异常，只能
    try-catch捕获。
</code></pre><h2 id="JDK10新特性"><a href="#JDK10新特性" class="headerlink" title="JDK10新特性"></a>JDK10新特性</h2><pre><code>1. 局部变量类型推断
    1. var：保留类型(不是关键字)，只针对局部变量
    public void test() {
        var i = 10;
        var s = &quot;abc&quot;;
        var list = new ArrayList&lt;&gt;();
        var user = new User();
    }
    2. 不允许对var变量赋值null，编译器认为毫无意义，因为null就是null类型
    var a = null; --&gt; 编译器报错
    3. 不允许对方法的参数使用var，因为参数没有值，无法推断类型
2. 垃圾收集器的优化
    1. JDK9：新生代使用ParNew收集器，老年代使用Parallel Obl收集器
    2. JDK10：G1(Garbage-First) 全收集器
3. 新增73个新功能扩展API
    1. java.util.list/Set/Map新增静态方法copyOf()，按照其迭代顺序返回一个不可修改的集合
    var list = new ArrayList&lt;String&gt;();  list.add(&quot;a&quot;);  list.add(&quot;b&quot;);
    var cl = List.copyOf(list);
    2. java.io.ByteArrayOutputStream新增方法toString(charset)，通过指定的字符集编码，
    将缓冲区的内容转为字符串
    3. java.io.PrintStream/PrintWriter，新增三个构造方法，方法参数上可以指定字符集
    4. java.io.Reader新增transferTo()，将Reader中读取的所有字符串，按照读取的顺序写入给
    指定Writer
    var r = new BufferedReader(new InputStreamReader(
        new FileInputStream(&quot;d:/a.txt&quot;), &quot;GBK&quot;));
    var p = new PrintWriter(new File(&quot;d:/c.txt&quot;));
    r.transferTo(p);
    p.flush();  p.close();  r.close();
    5. java.util.Formatter/Scanner 新增三个构造器，需要一个charset参数，解决乱码问题
</code></pre><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><pre><code>1. XML：可扩展标记语言
2. XML声明：定义XML的版本和编码信息
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
3. 注释：&lt;!-- 注释 --&gt;
4. DTD：Document Type Definition，用于约束XML的文档格式
5. XSD：XML Schema，DTD的替代者，XSD本身也是XML
</code></pre><h3 id="XML解析"><a href="#XML解析" class="headerlink" title="XML解析"></a>XML解析</h3><pre><code>1. DOM解析：官方解析方式，基于XML树，会加载整个文档，比较消耗资源，适用于多次访问XML
2. SAX解析：基于事件的流式解析，自顶向下，不会加载整个文档，解析速度快，占用内存少；
    1. SAX无法知道父子标签，也无法随机访问某个标签；只能读取XML，不能修改；
    2. SAXParserFactory、SAXParser、继承DefaultHandler自定义解析器、定义对应的JavaBean
    3. DOM和SAX都是原生解析方式，JDOM和DOM4J是第三方解析框架
3. JDOM：比DOM更快，仅使用具体类，而不使用接口
4. dom4j：JDOM的升级版，功能强大，性能优异，使用接口，而不使用实现类
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">大麦田怪圈</p>
              <p class="site-description motion-element" itemprop="description">敢做就能赢！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">58</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大麦田怪圈</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
