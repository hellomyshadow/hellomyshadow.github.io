<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="敢做就能赢！">
<meta property="og:type" content="website">
<meta property="og:title" content="大麦田程序猿">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="大麦田程序猿">
<meta property="og:description" content="敢做就能赢！">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="大麦田程序猿">
<meta name="twitter:description" content="敢做就能赢！">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/6/">





  <title>大麦田程序猿</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大麦田程序猿</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/25/linux命令入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/25/linux命令入门/" itemprop="url">linux命令入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-25T00:00:00+08:00">
                2017-07-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Linux-的目录结构"><a href="#Linux-的目录结构" class="headerlink" title="Linux 的目录结构"></a>Linux 的目录结构</h2><pre><code>不同于windows，Linux没有分盘，只有一个根目录 /：
</code></pre><p><img src="http://i.imgur.com/eNoIkyr.jpg" alt></p>
<pre><code>/bin：和程序相关；  /boot：和系统启动相关；  /cdrom：和光盘相关；  /dev：和设备相关；
/etc：程序和服务器配置相关；  /lib：存放库；  /home：存放家目录，即打开终端默认所在路径；
</code></pre><h2 id="linux常用命令"><a href="#linux常用命令" class="headerlink" title="linux常用命令"></a>linux常用命令</h2><pre><code>pwd：查看当前所在路径；
ls：列出当前目录下的文件和文件夹； ls /：列出根目录下的文件和文件夹；  
ls的常用参数：
    1. ls -a：显示隐藏文件及目录；
    2. ls -l：以列表形式显示详细信息；
    3. ls -lh：显示文件及目录的大小时，转换为合适的单位； 
touch 文件名：创建文件；
mkdir 目录名：创建文件夹；  mkdir a/b/c -p：如果c之前有不存在的目录，则创建；
tree：显示当前目录的内容结构；
rmdir：删除空目录；
rm：删除文件；  rm -r：可以删除非空的目录，-r，递归；  -f，强制删除；
命令名 --help：查询命令的文档；
man 命令名：分屏的方式查询命令，会进入一个新的界面显示查询结果，每次只显示一屏，支持上下键
    翻动，f:向下翻一屏，b：向上翻一屏，q：退出；
Tab：自动补全；
cat 文件名：查看文件的内容；    cat a.txt b.txt：同时查看文件a和b。
more 文件名：分屏的方式查看文件内容；
ls -alh /bin | more：以分屏的方式显示根目录下bin文件夹的内容；    |：管道，ls输出的内容
    先存入管道，more再从管道中取出，以分屏的方式显示；
history：查看输入过的命令；  !行号：执行行号对应的命令；
&gt;、&gt;&gt;：重定向
    ls &gt; a.txt，将ls命令显示的内容写入a.txt中，会先清空文件的内容；
    ls &gt;&gt; a.txt，追加内容，不会清空文件原内容；如果文件不存在，则会先创建文件；
    cat a.txt b.txt &gt; c.txt：合并文件a和文件b。
cd ./a：.代表当前目录，等效于 cd a；
cd ..：回到上一层目录；  cd ../..：回到上一层目录的上一层目录；
cd -：回到上一次所在的目录，不一定是上一层目录；
cd ~：回到家目录；
软连接、硬链接
    ln -s 文件名 自定义的软连接文件名：创建一个软连接，相当于快捷方式，如果删除了原文件，
        软连接文件无效；
    ln 文件名 自定义的硬链接文件名：创建一个硬链接，相当于为文件创建一个别名，删除原文件，
        硬链接仍有效；
    创建一个文件时，文件内容和文件名是分开存储的，文件名其实就是一个硬链接，当一个文件的硬
    链接数为 0 时，系统就会删除文件内容。
</code></pre><p><img src="http://i.imgur.com/2UC6GMc.jpg" alt></p>
<pre><code>mv：重命名、移动；如果目录不允许移动，则加 -r；
cp：复制并粘贴；如果目录不允许操作，则加 -r；
文本搜索：grep
    grep &quot;内容&quot; 文件名：-n，显示匹配的内容在文件中对应的行号；    -v，求反，搜索内容之外
        的其他内容；    -i，忽略大小写；
    grep &quot;^abc&quot; 文件名：以abc开头的内容；
    grep &quot;abc$&quot; 文件名：以abc结尾的内容。
搜索文件：find
</code></pre><p><img src="http://i.imgur.com/Hugd8Vp.jpg" alt></p>
<pre><code>    find ./ -name &quot;*name*&quot;：查找文件名中包含&quot;name&quot;的文件；
执行命令时，如果没有权限，可以在命令的开头使用 sudo；
归档管理：tar
    1. tar命令很特殊，其参数前可以不使用 &quot;-&quot;；
    2. tar -cvf abc.tar *.py：将所有.py后缀的文件打包成abc.tar；  
       tar -xvf abc.tar：解压缩；
    3. tar -zcvf abc.tar.gz *.py：压缩并打包成abc.tar.gz，占用空间比abc.tar小很多；  
       tar -zxvf abc.tar：解压缩；
       tar -zxvf abc.tar.gz -C workspace：解压到指定目录；
    4. tar -jcvf abc.tar.bz2 *.py：压缩并打包，占用空间比gz稍微大一点；  
       tar -jxvf abc.tar.bz2：解压缩；
    5. zip ab.zip *.py：打包成ab.zip，占用空间较大；
       unzip ab.zip：解压缩
       unzip -d ./test ab.zip：解压到指定目录。
    6. 常用 gz，bz2
which 命令名：查看命令所在目录；
cal：查看日历；
date：查看当前时间，自定义格式：date &quot;+%Y年%m月%d日&quot;；
查看进程信息
    ps -aux：查看所有进程的详细信息（windows的任务管理器）
    top、htop：在一个独立的界面显示进程的信息，q：退出。
kill PID：杀死指定PID的进程，kill -9 PID：强制杀死；
关机重启
    reboot：重启系统，等效于 init 6；
    shutdown -r now：重启系统，会提示给别的用户；
    shutdown -h now：立即关机，等效于 init 0；
    shutdown -h 20:25：定时今天20:25关机；
    shutdown -h +10：10分钟后关机；
df -h：查看当前内存的使用情况；
du -h：查看当前路径下的目录和文件的占用空间大小；
ifconfig -a：查看所有网卡的信息，主要用于查看IP地址信息；
    sudo ifconfig 网卡名(ens33) 新IP：修改指定网卡的IP；
    sudo dhclient：重新动态获取Ip；
ping IP地址：检测是否能与某个IP通信（连通性）；
对于虚拟机上的ubuntu系统，其网卡Ip必须和本机Ip设置在同一个网段，才能实现通信。
用户相关
    linux是多用户多任务的操作系统；
    useradd 用户名 -m：添加一个新的用户，在/etc/passwd文件中可以查看，在/home中会同时
        创建该账户的家目录；
    passwd 用户名：设置（修改）账户密码，新创建的账户默认没有密码；
    userdel -r 用户名：删除用户，并删除home下的家目录；
    whoami：查看当前用户；
    exit：退出当前用户；
    ssh 用户名@IP：远程登陆另一台电脑；
    who：查看登陆当前用户的电脑，显示IP的表示远程登陆的用户，没有IP的表示当前的终端登录；
    su 账户名：切换用户，需要输入该账户的密码；但是，并不会切换当前目录；
        su - 账户名：切换用户，并切换到该账户的家目录；
        su、 su root：切换到超级管理员root；
        su - 、 su - root：切换到root，同时切换到/root目录；
    sudo -s：切换到root权限，并不通用，只在ubuntu的Linux中；
    但是，普通用户会切换root失败，并且会报告给管理员。
用户组
    groupadd 组名：创建一个用户组，在/etc/group文件中可以查看；
    groupdel 组名：删除一个组；
    groupmod +多个Tab：查看当前所有用户组
    为创建的普通用户添加 root 权限
        能切换到 root 权限的组是 adm 和 sudo；
        普通用户不在 adm 和 sudo 组，也就不能通过 sudo -s 切换到root权限；
        cat /etc/group | grep sudo：查看在group文件中搜索出的、属于 sudo 组的用户；
        sudo usermod a -G adm 用户名：加入到 adm 组；
        sudo usermod -a -G sudo 用户名：加入到 sudo 组；
chown 用户名 文件：修改所有者；
chgrp 用户组 文件：修改用户组。
文件的权限
</code></pre><p><img src="http://i.imgur.com/MUFG2iL.jpg" alt></p>
<pre><code>r：读，w：写，x：可执行；
字母法修改文件的权限
    chmod u=rwx 文件名：修改所有者权限为可读、可写、可执行；
    chmod u=r 文件名：修改所有者权限为可读；
    chmod g=rx 文件名：修改所有组权限为可读、可执行；
    chmod o=x 文件名：修改其他人的权限为可执行；
    chmod u=w,g=r,o=x 文件名：同时修改三者的权限；
    chmod u=,g=,o= 文件名：三者都没有任何权限；
数字法修改文件的权限
    r --&gt; 4，w --&gt; 2，x --&gt; 1；
    rw --&gt; 6，rx -- &gt; 5，wx --&gt; 3，rwx --&gt; 7；
    chmod 777 文件名：三者可读、可写、可执行；
    chmod 000 文件名：三者没有任何权限。
</code></pre><h2 id="vi、vim"><a href="#vi、vim" class="headerlink" title="vi、vim"></a>vi、vim</h2><pre><code>vi、vim：进入命令模式，vim 是 vi 的升级版；
vi 文件名 +15：打开文件时，光标定位到15行；
i、I、A、a、O、o：命令模式进入编辑(插入)模式；
    编辑的位置：i，光标前； I，行首； a，光标后； A，行末； o，下一行； O，上一行；
在命令模式下，：--&gt; 进入末行模式；
Esc：退出编辑模式或末行模式；
命令模式下常用命令：
    yy：复制光标所在的行；  4yy：复制光标所在行开始向下的4行；  p：粘贴；
    dd：剪切(删除)光标所在的行；  3dd：剪切光标所在行开始向下的3行；
    D：从光标的位置开始剪切，一直到行末；  d0：从光标位置开始剪切，一直到行首；
    x：向后删除一个；  X：向前删除一个；
    h：控制光标向左；  j：向下；  k：向上；  l：向右；
    H：控制光标定位到当前屏幕的最上面一行；  M：当前屏幕的中间一行；
    L：当前屏幕的最下面一行；  G：整个文件的最后一行，  gg：整个文件的第一行，
    20G：光标定位到第20行；
    w：光标跳到下一个单词的开始处；  b：光标调到上一个单词的开始处；  dw：剪切整个单词；
    u：撤销回上一步操作；  Ctrl+r：反撤销；
    v、V：选中一片代码；v：选中光标经过的位置；  V：选中光标经过的行；
        选中之后， y：复制；  d：剪切；  &gt;：整体向右移动；  &lt;：整体向左移动；
        .：重复执行上一次的命令。
    Ctrl+d：向下翻半屏； Ctrl+u：向上翻半屏； Ctrl+f：向下翻一屏； Ctrl+b：向上翻一屏；
    {：光标向上移动到一块代码的开始；  }：向下移动到一块代码的结尾；
    r、R：替换；  r：替换光标所在的单个字符；  R：替换光标以及后面的字符；
    /：搜索；  /Hello + Enter：搜索“Hello”；
        n：光标移动到下一个搜索的内容；  N：移动到上一个；
    Shift+zz：保存并退出。
末行模式下常用的命令：
    %s/world/hello/g：将文件中的所有 “ world ” 替换为 “ Hello ”；
    %5,20s/world/hello/g：只替换5-20行的 “ world ”；
    w：保存；
    q：退出；  q!：强制退出；  wq：保存并退出；  wq!：保存并强制退出；
    x：保存并退出。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/01/08/JavaEE之Servlet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/08/JavaEE之Servlet/" itemprop="url">JavaEE之Servlet</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-08T00:00:00+08:00">
                2016-01-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="servlet"><a href="#servlet" class="headerlink" title="servlet"></a>servlet</h2><pre><code>1. HTTP的特点：快速连接、灵活、无连接、无状态；
    1. 无连接：限制每次连接只处理一个请求，可以节省传输时间；
    2. 无状态：HTTP协议是无状态协议，对于事物处理没有记忆能力，如果第二次请求用到了第一次
    请求响应的数据，仍然需要重新传递。
2. HTTP1.1版本后支持可持续连接：连接不立即断开，而是一段时间内没任何请求时，才会断开通道；
3. HTTP的请求方式
    1. HTTP1.0定义三种请求方法：GET、POST、HEAD
    2. HTTP1.1新增5种：OPTIONS、PUT、DELETE、TRACE、CONNECT
4. Tomcat
    1. 目录结构：bin(可执行文件目录)、conf(服务器配置文件目录)、lib(jar包目录)、log(日志)
    temp(缓存文件目录)、webapps(存放web应用的目录)、work(存放JSP转换后的servlet文件)
    2. windows系统启动Tomcat：bin/startup.bat，默认IP和端口号为localhost:8080
    3. Tomcat的运行依赖JDK，必须配置JDK环境。
5. log4j：打印日志，引入log4j.jar后，把log4j.properties放在项目的src目录下；
6. 在原生的HTML中，使用 &lt;frame&gt; 引入公共的html文件
    &lt;frameset cols=&quot;25%,50%,25%&quot;&gt;
        &lt;frame src=&quot;left.html&quot; /&gt;
        &lt;frame src=&quot;content.html&quot; /&gt;
        &lt;frame src=&quot;right.html&quot; /&gt;
    &lt;/frameset&gt;
    1. 在存在层级关系的HTML页面中，window.self表示自身的window对象;
    2. window.parent表示父级HTML的window对象;
    3. window.top表示最顶级HTML的window对象.
</code></pre><h3 id="Servlet技术"><a href="#Servlet技术" class="headerlink" title="Servlet技术"></a>Servlet技术</h3><pre><code>1. Servlet是Java实现的一个接口，任何实现Servlet接口的类都可以成为Servlet；
2. Servlet运行于支持Java的应用服务器中，理论上可以响应任何类型的请求，但一般只用于扩展基于
   HTTP协议的Web服务器；
3. Servlet的特点
    1. 运行在支持Java的应用服务器上，简单方便、可移植性强；
    2. 服务器会自动根据请求调用对应的Servlet，进行请求的处理。
4. Servlet的使用(MyEclipse)
    1. 继承HttpServlet，覆写service()，处理请求、响应数据；
    public class ServletTest extends HttpServlet {
        protected void service(HttpServletRequest req, HttpServletResponse resp) {
            // super.service(req, resp); -----&gt; 务必注释掉，否则会报405
            resp.getWriter().write(&quot;Hello ServletTest&quot;);
        }
    }
    2. 在WebRoot/WEB-INF/web.xml中，配置servlet
    &lt;servlet&gt;
        &lt;servlet-name&gt;ServletTest&lt;/servlet-name&gt;
        &lt;servlet-class&gt;it.test.cn.ServletTest&lt;/servlet-class&gt;
    &lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;ServletTest&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/test&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    3. 在Tomcat/webapps下新建目录servtest，把WebRoot目录中的文件复制到servtest目录中
    4. 启动Tomcat，访问ServletTest：http://localhost:8080/servtest/test
    5. webapps下的项目文件夹名称，又叫虚拟项目名；servlet的url-pattern又称为servlet别名
    6. 除了在web.xml中配置Servlet，还可以使用注解配置
    @WebServlet(name = &quot;ServletTest&quot;, urlPatterns=&quot;/test&quot;)
    public class ServletTest extends HttpServlet { ... }
    7. Servlet3.0部署 web.xml 的根节点 &lt;web-app&gt; 时，metadata-complete默认值为false，
    表示启用注解支持；设置为true时，表示只依赖 web.xml，忽略所有注解。
5. Servlet的生命周期
    1. Servlet的初始化函数：init()，第一次访问此Servlet时加载进内存，执行初始化，一直到
    关闭Tomcat服务，无论接受多少请求，都只会执行一次，即使删除本地文件，也能正常访问；
    2. service()：处理请求的方法，每次接收到请求都会执行；
    3. destory()：Servlet销毁的方法，关闭Tomcat服务时执行；
    4. 在 web.xml 中，在&lt;servlet&gt;中配置子节点&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;，
    那么此Servlet将在启动Tomcat服务时，加载进内存，执行 init() 初始化。
6. doGet()、doPost()
    1. doGet() 处理Get请求，doPost() 处理Post请求，service() 可以同时处理这两种请求;
    2. 如果Servlet中同时配置了 doGet()、doPost()、service()，那么优先执行service();
    3. service()中的 super.service() 会根据当前的请求方式，再去调用doGet()、doPost()
    所以在覆写 service() 时，通常注释掉super.service(); 否则会报405
7. HttpServletRequest：请求对象
    1. getMethod()：获取请求方法；
    2. getRequestURL()：获取请求的完整地址；
    3. getRequestURI()：请求接口地址，不包含域名和端口号；
    4. getHeader(&quot;key&quot;)：根据请求行的键获取值；
    5. Enumeration&lt;String&gt; e = req.getHeaderNames(); 所有请求行的键的枚举
    while(e.hasMoreElements()) {
        String s = e.nextElement();  --&gt; 键
    }
    6. getParameter(&quot;key&quot;)：获取用户数据(Get和Post)；
    7. getParameterValues(&quot;key&quot;)：类似Checkbox的一键多值；
8. HttpServletResponse：响应对象
    1. setHeader(&quot;key&quot;, &quot;value&quot;)：设置响应头，同键覆盖；
    2. addHeader(&quot;key&quot;, &quot;value&quot;)：添加响应头，同键不会覆盖；
    3. sendError(200, &quot;OK&quot;)：设置响应状态码；
    4. res.getWriter().write(...)：设置响应体；
    5. 中文乱码问题：
    res.setHeader(&quot;content-type&quot;, &quot;text/html;charset=utf-8&quot;);
    或 res.setContentType(&quot;text/html;charset=utf-8&quot;);
    6. text/html：表示响应体是HTML，让浏览器按照HTML进行解析；
    7. text/plain：响应体是普通字符串；
    8. text/xml：响应体是XML
</code></pre><h2 id="响应处理"><a href="#响应处理" class="headerlink" title="响应处理"></a>响应处理</h2><pre><code>1. 请求乱码问题
    1. 浏览器默认是iso8859-1编码，用户提交的数据为中文时，可能出现乱码，需要转为utf-8
    String a = new String(b.getBytes(&quot;iso8859-1&quot;), &quot;utf-8&quot;); --&gt; 通用解决方式
    2. GET请求的扩展方式：req.setCharacterEncoding(&quot;utf-8&quot;);
    同时配置Tomcat/conf/server.xml：&lt;Connector useBodyEncodingForURI=&quot;true&quot; .../&gt;
    3. POST请求的扩展方式：req.setCharacterEncoding(&quot;utf-8&quot;);
2. 请求转发
    1. 特点：一次请求，浏览器地址栏的信息不变；
    2. req.getRequestDispatcher(&quot;转发的地址&quot;).forward(req, resp);
    3. 在转发过程中，因为是同一个HttpServletRequest对象，可以从当前Servlet向目的Servlet
    传递数据：
    req.setAttribute(&quot;key&quot;, value); ---&gt; 当前Servlet设置数据
    value = req.getAttribute(&quot;key&quot;); ---------------------&gt; 目的Servlet获取数据
    4. session.removeAttribute(&quot;key&quot;); 移除键值数据。
3. 请求重定向
    1. 特点：两次请求，两个Request对象，浏览器地址栏信息改变；
    2. resp.sendRedirect(&quot;地址&quot;);
    3. 既然是两个Request对象，要实现数据传递，只能借助Session
</code></pre><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><pre><code>1. Cookie是浏览器端的数据存储，在服务器端响应数据时，告诉浏览器存储Cookie
2. 在服务器端声明Cookie
    Cookie ck = new Cookie(&quot;key&quot;, &quot;value&quot;);
    resp.addCookie(ck);
    1. 如果需要存储多个key-value，则创建多个Cookie对象；
    2. 默认情况下，Cookie临时存储在浏览器内存中，一旦关闭浏览器，Cookie将消失；
    3. 设置Cookie的有效期：ck.setMaxAge(3*24*3600); --&gt; 3天
    4. 设置有效期的Cookie会存储在浏览器本地，即使关闭了浏览器，只要未过期、就不会消失。
3. 默认情况下，每次请求都会携带当前域名下的Cookie，除非设置有效路径
    1. ck.setPath(&quot;/abc/xxx&quot;);
    2. 只有在请求 /abc/xxx 时才会携带此Cookie
4. 在服务器端获取请求对象中携带的Cookie
    Cookie[] cks = req.getCookies();
    for(Cookie c: cks) {
        String name = c.getName();
        String value = c.getValue();
    }
</code></pre><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><pre><code>1. 同一用户、不同请求的数据共享，如重定向的两个Servlet，可以使用Session存储共享数据；
2. Session存储在服务器端，标识不同用户的Session的唯一ID，会以Cookie的形式存储在浏览器端
    用户第一次访问服务器 --&gt; 服务器创建Session，并将此Session对象的JSESSIONID以Cookie
    的形式存储到浏览器中 --&gt; 同一个用户再次访问时，会携带此JSESSIONID --&gt; 通过JSESSIONID
    查找此用户的Session数据
3. Session的特点：存储在服务器端、由服务器端创建、依赖Cookie技术、一次会话
4. 创建/获取Session
    1. HttpSession hs = req.getSession();  --&gt; 没有Session对象则创建，有则获取
    2. 创建Session之后，会自动把JSESSIONID作为Cookie返回给浏览器存储；
    2. hs.getId(); --&gt; 获取Session的唯一标识JSESSIONID
5. JSESSIONID默认是临时存储，关闭浏览器则失效；
6. Session的默认存储时间是30分钟
    1. 关闭浏览器，JSESSIONID就失效了，但服务器并不知道，所以就不能及时删除对应的Session，
    这就需要设置Session的过期时间了，以免服务器端的Session数据过多；
    1. 设置Session的有效期：hs.setMaxInactiveInterval(60); --&gt; 60秒
    2. 不管是默认值还是自定义有效期，只要在有效期内发起了请求，Session有效期都会重新计时；
    3. hs.invalidate(); --&gt; 强制失效
    4. 如果Session失效了，req.getSession() 还会重新创建Session，并将ID存储到浏览器
7. Session的数据存储
    1. hs.setAttribute(&quot;key&quot;, value); --&gt; 在一个Servlet中存储Session数据
    2. value = hs.getAttribute(&quot;key&quot;);  ----&gt; 在其他Servlet中获取Session中的数据
8. 配置Session的默认有效期
    1. 在Tomcat/conf/web.xml中
    &lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt;
    2. 此配置对Tomcat下部署的所有项目有效；
    3. 在项目下的web.xml中配置 &lt;session-config&gt; , 只对本项目有效。
</code></pre><h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><pre><code>1. ServletContext：一个项目只有一个ServletContext对象；
2. ServletContext的生命周期：从服务器启动到结束；
3. 三种获取方式：
    1. ServletContext sc = this.getServletContext();
    2. ServletContext sc = this.getServletConfig().getServletContext();
    3. ServletContext sc = req.getSession().getServletContext();
4. 不同用户可以共享ServletContext数据
    1. sc.setAttribute(&quot;key&quot;, value);  --&gt; 设置
    2. value = sc.getAttribute(&quot;key&quot;); --&gt; 获取
5. 获取项目 web.xml 的全局配置数据
    1. 配置全局数据
    &lt;web-app ...&gt;
        &lt;context-param&gt;  ---&gt; 一组&lt;context-param&gt;只能存储一对键值数据，可以声明多组
            &lt;param-name&gt;key&lt;/param-name&gt;
            &lt;param-value&gt;value&lt;/param-value&gt;
        &lt;/context-param&gt;
    2. String param = sc.getInitParameter(&quot;key&quot;);
    3. sc.getInitParameterNames();  --&gt; 键的枚举
    4. 作用：将静态数据和代码进行解耦
6. 获取项目WebRoot目录下的资源路径(MyEclipse环境，WebRoot目录下文件会复制到Tomcat中)
    1. 在WebRoot下创建doc目录，在doc下新建文件a.txt
    2. String doca = sc.getRealPath(&quot;/doc/a.txt&quot;);  --&gt; 获取a.txt的路径
    3. InputStream is = sc.getResourceAsStream(&quot;/doc/a.txt&quot;);  --&gt; 获取流对象
    4. ServletContext只能获取资源文件，不能获取class文件(需要类加载器)
7. 比如，统计一段时间内的访问次数，可以使用ServletContext
</code></pre><h3 id="ServletConfig"><a href="#ServletConfig" class="headerlink" title="ServletConfig"></a>ServletConfig</h3><pre><code>1. ServletConfig是Servlet的专属配置对象，每个Servlet都单独拥有一个ServletConfig对象；
2. ServletConfig用于获取 web.xml 中的Servlet配置信息；
3. 获取Servlet的ServletConfig对象：
    ServletConfig config = this.getServletConfig();
4. 在 web.xml 的 &lt;servlet&gt; 下配置：
    &lt;init-param&gt;
        &lt;param-name&gt;key&lt;/param-name&gt;
        &lt;param-value&gt;value&lt;/param-value&gt;
    &lt;/init-param&gt;
5. 获取Servlet配置的键-值数据：String value = config.getInitParameter(&quot;key&quot;);
</code></pre><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><pre><code>1. Tomcat/conf/web.xml 与 Web项目/web.xml
    1. Tomcat下的web.xml为全局配置，对所有web项目有效，配置公共信息；
    2. web项目/web.xml为局部配置，只对当前项目有效；
    3. 对于相同的配置内容，web项目/web.xml的优先级更高。
2. web.xml的核心配置：
    1. 全局上下文ServletContext、Servlet配置context-param、过滤器filter、监听器listener
    2. 排列顺序是任意的，但加载顺序是固定的：
    ServletContext --&gt; context-param --&gt; listener --&gt; filter --&gt; Servlet
    3. web.xml都是在服务器启动时加载
</code></pre><h3 id="server-xml"><a href="#server-xml" class="headerlink" title="server.xml"></a>server.xml</h3><pre><code>1. Tomcat/conf/server.xml，核心节点&lt;Service&gt;，一个&lt;Server&gt;节点下可以配置多个&lt;Service&gt;
    1. HTTP协议的端口号配置
    &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; 
        connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;
    2. 服务器集群配置
    &lt;Connector port=&quot;8009&quot; protocol=&quot;AJP/1.3&quot; redirectPort=&quot;8443&quot; /&gt;
2. 引擎节点：&lt;Engine name=&quot;Catalina&quot; defaultHost=&quot;localhost&quot;&gt;
    1. 一个&lt;Service&gt;节点下只能配置一个&lt;Engine&gt;节点
    2. &lt;Host name=&quot;localhost&quot;  appBase=&quot;webapps&quot; ...&gt;，appBase属性指定项目所在的目录
    3. &lt;Engine&gt;的defaultHost属性指定了默认的host，指向子节点&lt;Host name=&quot;localhost&quot; ...&gt;
    4. 浏览器访问Tomcat服务器时，如果输入的host在&lt;Engine&gt;下没有配置，如本机的私有地址
    192.168.xxx.xxx，则执行默认的host
3. 在&lt;Host&gt;节点下配置热部署
    &lt;Context path=&quot;/abc&quot; reloadable=&quot;true&quot; docBase=&quot;F:/WebTest&quot; /&gt;
    1. path：项目的虚拟目录名；
    2. reloadable：是否自动加载；
    3. docBase：项目所在的绝对路径；
    4. 热部署不需要在Tomcat/webapps下为项目创建文件夹(项目的虚拟目录)，所以如果项目删除，
    对应的&lt;Context/&gt;也必须删除，否则Tomcat启动会报错。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/01/06/Java动态性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/06/Java动态性/" itemprop="url">Java动态性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-06T00:00:00+08:00">
                2016-01-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><h3 id="类的反射"><a href="#类的反射" class="headerlink" title="类的反射"></a>类的反射</h3><pre><code>1. 获取Class对象的三种方式
    1. 对象.getClass()
    2. 类名.class
    3. Class.forName(&quot;包名.类名&quot;);
2. 获取类名
    Class clz = Class.forName(&quot;com.sxt.serv.Channel&quot;);
    clz.getName(); --&gt; 获取完整路径(包名)的类名
    clz.getSimpleName(); --&gt; 只获取类名 
3. 获取构造器Constructor
    1. clz.getConstructor(参数类型.class...); 只能获取public构造器
    2. clz.getDeclaredConstructor(参数类型.class...); 获取任意构造器
    Constructor&lt;Channel&gt; cons = clz.getDeclaredConstructor(String.class);
    cons.setAccessible(true); --&gt;默认不允许访问private成员，必须跳过安全检查
    Channel cha = cons.newInstance(&quot;123&quot;); -- &gt;传递参数，创建对象
    3. 参数类型都是可变长参数，对于无参构造器，则不传任何参数
    Channel cha = clz.newInstance(); --&gt;使用public无参构造的创建对象，从JDK9开始废弃
    Channel cha = clz.getConstructor().newInstance();
4. 获取属性Field
    1. clz.getField(&quot;属性名&quot;); 只能获取public修饰的属性
    2. clz.getDeclaredField(&quot;属性名&quot;); 获取任意的属性
    3. 操作(私有)属性
    Field id = clz.getDeclaredField(&quot;id&quot;); //int id
    id.setAccessible(true);  --&gt;跳过安全检查
    id.set(cha, 10); --&gt;设置对象cha上的id属性
    int i = id.get(cha); --&gt;获取id属性值
5. 获取方法Method
    1. clz.getMethod(&quot;方法名&quot;, 参数类型.class...); 只能获取public修饰的方法
    2. clz.getDeclaredMethod(&quot;方法名&quot;, 参数类型.class...); 获取任意的方法
    3. 如果方法是无参的，参数类型通常传null，也可以什么不传
    4. 调用(私有)方法
    Method m = clz.getDeclaredMethod(&quot;setAge&quot;, int.class);
    m.setAccessible(true);
    m.invoke(cha, 12);  //cha.setAge(12)
</code></pre><h3 id="泛型的反射"><a href="#泛型的反射" class="headerlink" title="泛型的反射"></a>泛型的反射</h3><pre><code>1. 泛型仅仅是给编译器javac使用的，确保数据的安全性和免去强制类型转换的麻烦，一旦编译完成，
   所有和泛型相关的类型都会全部擦除；
2. 为了让反射可以操作泛型，Java新增ParameterizedType、GenericArrayType、TypeVariable、
    WildcardType来代表不能被归到Class类中的类型、但又和原始类型齐名的类型；
    1. ParameterizedType：表示参数化的类型，比如Collection&lt;String&gt;
    2. GenericArrayType：表示元素类型是参数化类型，或类型变量的数组类型
    3. TypeVariable：各种类型变量的公共父接口
    4. WildcardType：代表通配符类型表达式，比如 ?，? extends Number，? super Integer
3. ParameterizedType
    public class TestTable {
        public void test01(Map&lt;String, TableBean&gt; map, List&lt;TableBean&gt; list) { }
        public Map&lt;Integer, TableBean&gt; test02() { return null; }
    }
    1. 获取参数泛型
    Method m = TestTable.class.getMethod(&quot;test01&quot;, Map.class, List.class);
    Type[] paramTypes = m.getGenericParameterTypes(); //获取带泛型的参数类型
    for (Type t: paramTypes) {
        System.out.println(&quot;paramType: &quot; + t); //带泛型的参数类型
        if (t instanceof ParameterizedType) {
            //获取真正的泛型类型
            Type[] typeArgs = ((ParameterizedType) t).getActualTypeArguments();
            for (Type gt: typeArgs) {
                System.out.println(&quot;参数上的泛型类型：&quot; + gt);
            }
        }
    }
    2. 获取返回的参数泛型
    Method m = TestTable.class.getMethod(&quot;test02&quot;, null);
    Type at = m.getGenericReturnType(); //获取带泛型的返回值类型
    if (at instanceof ParameterizedType) {
        //获取真正的泛型类型
        Type[] typeArgs = ((ParameterizedType) at).getActualTypeArguments();
        for (Type gt: typeArgs) {
            System.out.println(&quot;返回值的泛型类型：&quot; + gt);
        }
    }
</code></pre><h2 id="动态编译"><a href="#动态编译" class="headerlink" title="动态编译"></a>动态编译</h2><pre><code>1. Java6.0引入动态编译，有两种方式
    1. Runtime调用javac，启动新的进程去操作
    Runtime run = Runtime.getRuntime();
    Process p = run.exec(&quot;javac -cp d:/workplace/ HelloWorld.java&quot;);
    2. JavaCompiler动态编译
2. JavaCompiler
    1. 动态编译Java文件
    JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
    int result = compiler.run(null, null, null, &quot;E:/workplace/HelloWorld.java&quot;);
    ---&gt; result为0，表示编译成功，生成class文件
    2. 动态编译java字符串
    String text = &quot;public class Hi { public static void main(String[] args)
        { System.out.println(\&quot;hi\&quot;); } }&quot;;
    ---&gt; 需要把这个字符串通过IO流存成一个临时文件(Hi.java)，再进行动态编译
3. Runtime运行编译好的class文件
    Runtime run = Runtime.getRuntime();
    Process p = run.exec(&quot;java -cp E:/workplace HelloWorld&quot;);
    InputStream is = p.getInputStream();
    BufferedReader br = new BufferedReader(new InputStreamReader(is));
    String info = &quot;&quot;;
    while (null != (info=br.readLine())) {
        System.out.println(info); //hi
    }
4. 反射运行编译好的class文件
    URL[] urls = new URL[] {new URL(&quot;file:/&quot; + &quot;E:/workplace/&quot;)};
    URLClassLoader loader = new URLClassLoader(urls);
    Class clz = loader.loadClass(&quot;HelloWorld&quot;);
    Method me = clz.getMethod(&quot;main&quot;, String[].class);
    //由于可变参数在JDK5.0才引入，传递数组时，如new String[]{&quot;a&quot;, &quot;b&quot;}，会被解析为
    //invoke(null, &quot;a&quot;, &quot;b&quot;)，所以需要使用Object强转类型
    me.invoke(null, (Object)new String[]{});
</code></pre><h2 id="动态执行JavaScript代码"><a href="#动态执行JavaScript代码" class="headerlink" title="动态执行JavaScript代码"></a>动态执行JavaScript代码</h2><pre><code>1. JDK6.0新增脚本引擎，使Java应用可以通过一套固定的接口与各种脚本引擎交互，从而在Java平台
   上调用各种脚本语言
2. JavaScript引擎：Rhino
    1. Rhino是一种使用Java编写的JS的开源实现，原由Mozilla开发，现已被集成到JDK6.0
    ScriptEngineManager sem = new ScriptEngineManager();
    ScriptEngine engine = sem.getEngineByName(&quot;JavaScript&quot;);
    2. 可以执行字符串形式的JS语句，也可以执行JS脚本文件。
</code></pre><h2 id="动态字节码操作"><a href="#动态字节码操作" class="headerlink" title="动态字节码操作"></a>动态字节码操作</h2><pre><code>1. 运行时操作字节码可以实现：
    1. 动态生成新的类
    2. 动态改变某个类的结构(增删改 新的属性/方法)
2. 优点：比反射开销小、性能高，与反射相辅相成；
3. 常见的字节码操作类库
    1. BCEL：可以深入JVM汇编语言进行类操作的细节，拥有丰富的JVM指令级支持；
    2. ASM是一个轻量级Java字节码操作框架，直接涉及到JVM底层的操作和指令；
    3. BECL和ASM的效率最高，因为是在JVM指令层次上进行操作，学习难度也比较大；
    4. CGLIB：一个强大的、高性能、高质量的Code生成类库，基于ASM实现；
    5. Javassist：一个开源的Java字节码类库，强调的是源代码级别，性能跟CGLIB差不多，
    但使用简单，应用于很多开源框架。
4. Javassist
    1. 最外层API与Java反射的API颇为相似，如CtClass，CtMethod，CtField
    2. 局限性：只适合常规操作
</code></pre><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><pre><code>1. 内置注解：@Override，@Deprecated，@SuppressWarnings，@Target...
2. @interface 自定义注解，自动继承Annotation接口
    public @interface 注解名 { ... }
3. 元注解：负责解释其他注解，Java定义了4个标准的meta-annotation类型(元注解)
    1. @Target、@Retention、@Documented、@Inherited
    2. 这些类型和它们所支持的类在java.lang.annotation包中。
4. @Target：声明注解的使用范围，由ElementType定义可取的值
    1. package包：PACKAGE，@Target(value=ElementType.PACKAGE)
    2. 类、接口、枚举、Annotation类型：TYPE
    3. 类成员(构造方法、成员变量、方法、枚举值)：CONSTRUCTOR描述构造器，FIELD描述域(字段)，
    METHOD描述方法
    4. 方法参数和本地变量：LOCAL_VARIABLE用于描述局部变量，PARAMETER用于描述参数
    @Target(value=ElementType.METHOD)  --&gt; 声明此注解只能在方法上使用
    public @interface TestAnnot { ... }
    5. value可以取多个值，扩大应用范围
    @Target(value={ElementType.METHOD, ElementType.TYPE})
    public @interface TestAnnot { ... }  --&gt;此注解可以同时修饰方法、类
5. @Retention：表示需要在什么级别保存该注释信息，用于描述注解的生命周期
    1. SOURCE：在源文件中有效
    2. CLASS：在class文件中有效
    3. RUNTIME：在运行时有效，被反射机制读取(反射在运行期有效)
    @Target(value={ElementType.METHOD, ElementType.TYPE})
    @Retention(RetentionPolicy.RUNTIME)
    public @interface TestAnnot { ... }
</code></pre><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><pre><code>1. 定义注解的成员
    @Target(value={ElementType.METHOD, ElementType.TYPE})
    @Retention(RetentionPolicy.RUNTIME)
    public @interface TestAnnot {
        String stuName() default &quot;&quot;;  --&gt;参数类型String，参数名stuName，默认值&quot;&quot;
        int age() default 0;
        String[] schools() default {};
    }
2. 使用自定义注解
    @TestAnnot
    public class TestMain {
        @TestAnnot
        public void test(){ }
    }
    1. 如果没有注解中的成员没有默认值，则必须在使用时赋予值，否则会报编译期错误
    @TestAnnot(uname = &quot;&quot;, age = -1, schools = {})
    public class TestMain {
        @TestAnnot(uname = &quot;abc&quot;, age = 0, schools = {&quot;a&quot;, &quot;b&quot;})
        public void test(){ }
    }
    2. 如果注解中只有一个成员(通常定义为value)，在使用赋值时，可以不指定参数名
    @Target(value=ElementType.TYPE)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface MyAnnot {
        String value();
    }
    @MyAnnot(&quot;abc&quot;)
    public class TestMain { ... }
3. 注解的解析，配合反射，以数据库表的ORM映射为例
    1. 表的注解
    @Target(value = {ElementType.TYPE})
    @Retention(RetentionPolicy.RUNTIME)
    public @interface Table {
        String value(); --&gt; 记录表名
    }
    2. 表的字段约束
    @Target(value = ElementType.FIELD)
    @Retention(RetentionPolicy.RUNTIME)
    public @interface Column {
        String columnName(); --&gt; 字段名
        String type(); --&gt; 字段类型
        int length(); --&gt; 长度
    }
    3. 表映射的JavaBean
    @Table(&quot;user&quot;)
    public class UserBean {
        @Column(columnName = &quot;id&quot;, type = &quot;int&quot;, length = 10)
        private int id;
        @Column(columnName = &quot;name&quot;, type = &quot;varchar&quot;, length = 10)
        private String username;
        @Column(columnName = &quot;age&quot;, type = &quot;int&quot;, length = 3)
        private int age;
        ......
    }
    Class clz = Class.forName(&quot;it.test.cn.UserBean&quot;);
    4. 获取类上的注解
    Annotation[] annots = clz.getAnnotations(); --&gt; 获取类UserBean上的所有注解
    Table tab = (Table) clz.getAnnotation(Table.class); --&gt; 获取指定的注解
    String val = tab.value();  --&gt; 获取注解成员的值&quot;user&quot;
    5. 获取类属性上的注解(类方法同理)
    Field f = clz.getDeclaredField(&quot;username&quot;); --&gt; 获取属性username
    Column col = f.getAnnotation(Column.class); --&gt; 获取属性上的注解
    col.columnName();//&quot;name&quot;  col.type();//&quot;varchar&quot;  col.length();//10
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/01/05/Java网络编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/05/Java网络编程/" itemprop="url">Java网络编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-05T00:00:00+08:00">
                2016-01-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Ip相关的类：InetAddress"><a href="#Ip相关的类：InetAddress" class="headerlink" title="Ip相关的类：InetAddress"></a>Ip相关的类：InetAddress</h2><pre><code>1. 获取本机的Ip、hostname
    InetAddress addr = InetAddress.getLocalHost();
    String ip = addr.getHostAddress();
    String hostName = addr.getHostName(); //计算机名
2. 根据域名获取Ip、hostname
    InetAddress addr = InetAddress.getByName(&quot;www.baidu.com&quot;); //内部是NDS解析
    String ip = addr.getHostAddress(); //Ip
    String hostName = addr.getHostName(); //域名www.baidu.com
3. 如果getByName(&quot;Ip地址&quot;)，getHostName()获取的仍是Ip，而不是域名；
4. 子类：Inet4Address、Inet6Address
</code></pre><h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><pre><code>1. 端口号表示一个16位的二进制整数，2个字节，对应十进制0-65535
    1. 公认端口0-1023，如80是http协议的默认端口
    2. 注册端口1024-49151(分配给用户进程/应用程序)
    3. 动态/私有端口49152-65535
2. windows命令
    1. netstat -ano  ---&gt; 查看所有的端口号
    2. netstat -ano|findstr &quot;808&quot;  ---&gt; 查看指定端口号
    3. tasklist|findstr &quot;808&quot;  ---&gt; 查看指定进程
</code></pre><ol start="3">
<li>InetSocketAddress：包含端口号，用于socket通信<br> InetSocketAddress s = new InetSocketAddress(“127.0.0.1/localhost”, 8080);<br> s.getHostName();  s.getAddress();  s.getPort();<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><ol>
<li>URL和URN都是URI的子集<ol>
<li>URI：统一资源标识符，表示一个资源，比如一个具体的人</li>
<li>URL：统一资源定位符，用地址定位一个资源，比如XX省XX市XX区…XX单元XX室的主人</li>
<li>URN：统一资源名称，用名称定位一个资源，但不明确资源的位置，比如身份证号+姓名去找人</li>
</ol>
</li>
<li>网络三大基石：HTML、HTTP、URL</li>
<li>URL由4部分组成：协议、资源所在的主机域名、端口号、资源文件名</li>
<li>URL url = new URL(“<a href="http://www.baidu.com:80/index.html#aa?xx=xxx&quot;)" target="_blank" rel="noopener">http://www.baidu.com:80/index.html#aa?xx=xxx&quot;)</a>;<ol>
<li>url.getProtocol()：协议名</li>
<li>url.getDefaultPort()：获取与此URL关联的协议的默认端口号</li>
<li>url.getHost()：主机名/域名</li>
<li>url.getFile()：端口号后的所有内容</li>
<li>url.getPath()：端口号后、参数前的内容</li>
<li>url.getQuery()：参数部分</li>
<li>url.getRef()：锚点</li>
</ol>
</li>
<li>相对路径构建URL<br> URL u1 = new URL(“<a href="http://www.baidu.com/aa/&quot;)" target="_blank" rel="noopener">http://www.baidu.com/aa/&quot;)</a>;<br> URL u2 = new URL(u, “b.html”); –&gt; <a href="http://www.baidu.com/aa/b.html" target="_blank" rel="noopener">http://www.baidu.com/aa/b.html</a></li>
<li>发起请求<ol>
<li>抓取网络数据，非浏览器访问<br>InputStream is = url.openStream();<br>BufferedReader br = new BufferedReader(new InputStreamReader(is, “UTF-8”));<br>String msg = null;<br>while(null != (msg=br.readLine())) {<br> System.out.println(msg);<br>}<br>br.close();</li>
<li>模拟浏览器访问<br>HttpURLConnection conn = (HttpURLConnection) url.openConnection();<br>conn.setRequestMethod(“GET”);  –&gt;设置请求方式<br>conn.setRequestProperty(“User-Agent”, “value”); –&gt;设置请求头<br>BufferedReader br = new BufferedReader(<br> new InputStreamReader(conn.getInputStream(), “GBK”));<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2></li>
</ol>
</li>
<li>DatagramSocket：用于发送/接受数据包的套接字；</li>
<li>DatagramPacket：数据包；</li>
<li>发送端<br> DatagramSocket client = new DatagramSocket(8888);<br> String data = “Hello I’m Client”;<br> byte[] bys = data.getBytes();<br> //发送给”127.0.0.1:9999”<br> DatagramPacket packet = new DatagramPacket(bys, 0, bys.length, <pre><code>new InetSocketAddress(&quot;127.0.0.1&quot;, 9999));
</code></pre> client.send(packet);<br> client.close();</li>
<li>接收端<br> DatagramSocket server = new DatagramSocket(9999); –&gt; 监听端口9999<br> byte[] container = new byte[1024*60];<br> DatagramPacket packet = new DatagramPacket(container, 0, container.length);<br> server.receive(packet);<br> byte[] bys = packet.getData();<br> int len = packet.getLength();<br> String data = new String(bys, 0, len);<br> server.close();<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2></li>
<li>服务端：ServerSocket<br> ServerSocket server = new ServerSocket(8889);<br> Socket client = server.accept(); –&gt;阻塞式，等待客户端连接<br> DataInputStream dis = new DataInputStream(client.getInputStream());<br> String data = dis.readUTF(); –&gt;客户端的数据<br> dis.close();<br> client.close();<br> server.close();<ol>
<li>通过每一次连接的client，向对应的客户端响应数据<br>DataOutputStream dos = new DataOutputStream(client.getOutputStream());<br>dos.writeUTF(“hello I’m Server”); –&gt;向客户端响应数据<br>dos.flush();<br>dos.close();</li>
</ol>
</li>
<li>客户端：Socket<br> //指定服务端的Ip和端口号，发起连接请求<br> Socket client = new Socket(“127.0.0.1”, 8889);<br> DataOutputStream dos = new DataOutputStream(client.getOutputStream());<br> dos.writeUTF(“hello I’m Client”); –&gt;向服务端写入数据<br> dos.flush();<br> dos.close();<br> client.close();<ol>
<li>client接收服务端的响应数据<br>DataInputStream dis = new DataInputStream(client.getInputStream());<br>String data = dis.readUTF(); –&gt;接收响应数据<br>dis.close();</li>
</ol>
</li>
<li>HTTP底层正是TCP，浏览器作为客户端，也可以直接访问TCP服务器端.</li>
</ol>
</li>
</ol>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/01/03/Java多线程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/03/Java多线程/" itemprop="url">Java多线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-03T00:00:00+08:00">
                2016-01-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><pre><code>1. 线程状态
</code></pre><p><img src="https://i.imgur.com/vLw2xgt.jpg" alt></p>
<pre><code>    1. Thread.State：线程的状态，NEW(尚未启动的线程)、RUNNABLE、BLOCKED、WAITING、
    TIMED_WAITING、TERMINATED(已退出的线程)
    2. RUNNABLE：包含就绪状态和运行状态；
    3. getState()：获取线程的状态。
2. 线程的 stop() 方法已经被废弃，因为线程的终止可以通过一个boolean型的标志位变量完成；
3. sleep() yield() join()
    1. sleep() 表示休眠，会阻塞线程，且不会释放锁，睡眠时间到了之后，重新进入就绪状态；
    常用于模拟网络延迟、倒计时...
    2. yield() 则礼让出CPU的执行权，线程进入就绪状态；
    3. join() 插队，待此线程执行完成后，再执行其他线程，这段时间内，其他线程处于阻塞状态；
4. 优先级：线程的优先级并不能决定哪个线程先执行，优先级高的线程被执行的概率相对会高一些；
    1. setPriority(priority)：设置线程的优先级，范围1-10，在 start() 之前设置有效；
    2. Thread.MIN_PRIORITY，Thread.MAX_PRIORITY，Thread.NORM_PRIORITY：1，10，5
5. 线程分为用户线程和守护线程，默认的线程都是用户线程
    1. 虚拟机JVM会确保所有的用户线程执行完毕，再退出程序，但不会等待守护线程执行完毕；
    2. 如后台记录操作日志、监控内存使用等
    3. setDaemon(true)：把线程设置为守护线程，在 start() 之前调用。
6. Thread.currentThread()：获取当前线程；
7. isAlive()：线程是否还活着。
</code></pre><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><pre><code>1. 线程同步：synchronized，队列
    1. 若将一个大的方法声明为synchronized，将会大大影响效率；
    2. 与大的synchronized方法相比，synchronized块能在一定程度上减少性能的损失；
    3. 使用 synchronized 的关键在于，第一要锁对目标，第二要取舍synchronized块的面积。
2. 同步块的锁：
    1. 同步方法的锁是this，表示当前对象，不可改变；
    2. 同步块的锁可以指定，锁住的目标更明确，还能减小锁的面积。
3. 并发容器：CopyOnWriteArrayList，加锁的ArrayList，保证在写入数据时的安全；
4. 死锁：相互持有对方的锁，需要避免锁的嵌套。
</code></pre><h3 id="并发协作"><a href="#并发协作" class="headerlink" title="并发协作"></a>并发协作</h3><pre><code>1. 生产者与消费者模式：线程同步问题，生产者和消费者共享同一资源，且生产者和消费者相互依赖；
    1. synchronized只是阻止并发更新同一共享资源，实现同步，但并不能实现线程间的通信；
    2. 管程法：利用并发缓冲容器实现；
    3. 信号灯法：借助标志位实现；
    4. wait()，notify()，notifyAll()
2. 管程法
    1. 容器满了，则生产者等待；容器为空时，则消费者等待；
    2. 容器中有元素时，唤醒消费者取出；消费者取出元素之后，唤醒生产者存入；
    class Food {  --&gt; 生产/消费的对象
        public int count;
        public Food(int c) { this.count = c; }
    }
    3. 容器具备同步的存入和取出方法
    class Container {
        private Food[] foodList = new Food[10];  private int count = 0;
        public synchronized void push(Food f) {  ---&gt; 同步方法的锁默认是this
            if ((this.foodList.length-1)==count) {
                this.wait(); --&gt; 容器满了，生产者进入等待
            }
            this.foodList[count] = f;  count++;
            this.notifyAll();   ----&gt; 容器中已经有了元素，唤醒消费者
        }
        public synchronized Food pop() {
            if (count &lt; 1) {
                this.wait(); --&gt; 容器为空，生产者进入等待
            }
            count--;  Food f = this.foodList[count];
            this.notifyAll();   ----&gt; 消费者取出了元素，唤醒生产者
            return f;
        }
    }
    4. 生产者和消费者的线程
    class Producter extends Thread {
        private Container con;
        public Producter(Container con) { this.con = con; }
        public void run() {
            for (int i=0; i&lt;100; i++) {
                this.con.push(new Food(i+1)); ---&gt; 生产者向容器中存入元素
                System.out.println(&quot;生产第 &quot;+(i+1)+&quot; 个&quot;);
            }
        }
    }
    class Customer extends Thread {
        private Container con;
        public Customer(Container con) { this.con = con; }
        public void run() {
            for (int i=0; i&lt;100; i++) {
                Food food = this.con.pop(); ---&gt; 消费者从容器中取出元素
                System.out.println(&quot;消费第 &quot;+(food.count)+&quot; 个&quot;);
            }
        }
    }
    5. 生产者和消费者操作的必须是同一个容器
    Container con = new Container();
    Producter p = new Producter(con);  Customer c = new Customer(con);
    p.start();  c.start();
3. 信号灯法
    1. 标志位为true，让生产者等待，消费者运行完成后，设置标志位为false，并唤醒生产者；
    2. 反之，让消费者等待，生产者运行完成后，设置标志位为true，并唤醒消费者；
    class Tv {
        private String show;   --&gt; 生产和消费的元素
        private boolean flag;  --&gt; 标志位
        public synchronized void play(String show) {
            if (this.flag) {
                this.wait();   --&gt; 生产者等待
            }
            this.show = show;
            this.flag = !this.flag;  --&gt; 标志位取反
            this.notifyAll();  --&gt; 唤醒消费者
        }
        public synchronized String watch() {
            if (!this.flag) {
                this.wait();   --&gt; 消费者等待
            }
            this.flag = !this.flag;  --&gt; 标志位取反
            this.notifyAll();  --&gt; 唤醒生产者
            return show;
        }
    }
    3. 生产者和消费者的线程
    class Actor extends Thread {
        private Tv tv;
        public Actor(Tv tv) {  this.tv = tv;  }
        public void run() {
            for (int i=0; i&lt;100; i++) {
                String show = i%2==0?&quot;跳舞&quot;:&quot;唱歌&quot;;
                this.tv.play(show);
                System.out.println(&quot;生产者：&quot; + show + &quot;::&quot; + i);
            }
        }
    }
    class Audience extends Thread {
        private Tv tv;
        public Audience(Tv tv) {  this.tv = tv;  }
        public void run() {
            for (int i=0; i&lt;100; i++) {
                System.out.println(&quot;消费者：&quot; + this.tv.watch() + &quot;::&quot; + i);
            }
        }
    }
    Tv tv = new Tv();
    Actor actor = new Actor(tv);  Audience audience = new Audience(tv);
    actor.start();  audience.start();
</code></pre><h2 id="定时调度"><a href="#定时调度" class="headerlink" title="定时调度"></a>定时调度</h2><pre><code>1. Timer和TimerTask
    class EvenTask extends TimerTask {  --&gt; 任务线程
        public void run() { ... }
    }
    Timer t = new Timer();  --&gt; 定时器
    EvenTask task = new EvenTask();
    1. t.schedule(task, 3000);  ----&gt; 3s后执行一次
    2. t.schedule(task, 3000, 1000);  ----&gt; 3s后每隔1s执行一次
    3. t.schedule(task, date);  -----&gt; 指定时间定时执行
2. 调度框架：quartz
</code></pre><h2 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h2><pre><code>1. HappenBefore：虚拟机优化代码顺序，导致执行顺序可能与编写代码的顺序不一致，称为指令重排
2. 指令重排是编译器或运行时环境为了优化程序性能而采取的对指令进行重新排序执行的一种手段
3. CPU执行指令的步骤
    从内存中获取一条指令 --&gt; 解码指令，取值 --&gt; 操作值，得到结果 --&gt; 把结果写回寄存器中
4. 编译器和处理器在重排指令时，遵守数据依赖性，不会改变存在数据依赖关系的两个操作的执行顺序
5. 在虚拟机层面和硬件层面，都可能出现指令重排
    1. 在虚拟机层面：内存操作速度远慢于CPU运行速度，为了避免CPU空置的影响；
    2. 在硬件层面：CPU速度比缓存速度快。
</code></pre><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><pre><code>1. volatile保证线程间的可见性，当线程A修改变量X后，其后的其他线程能看到变量X的变动；
2. 线程有自己的工作内存，且彼此独立、互补可见；
    1. 工作内存不仅包含了线程内部定义的局部变量，也包含了线程所需要使用的共享变量的副本；
    2. 为了提高效率，线程并不会每次都从主内存中读取共享变量。
3. volatile的变量符合两个规则
    1. 线程对变量修改之后，要立刻写到主内存
    2. 线程对变量读取的时候，要从主内存中读，而不是缓存(工作内存)
4. volatile不能保证原子性
    1. 比如x=x+1分为3步：从内存中获取x，对x加1，再把结果写回内存中
    2. volatile并不能保证这3步同时发生，只能保证变量x的结果发生变化后，对每个线程都可见
5. volatile是一个轻量级的synchronized
    private volatile static int num = 0;
    new Thread(()-&gt;{
        while (num==0) {} ---&gt; 不执行任何具体任务
    }).start();
    Thread.sleep(1000);
    num = 1;
    1. 如果不使用volatile修饰，1s后的num虽然已经置为1，但因为子线程执行空的while循环，
    造成CPU很繁忙，来不及把变量num同步给子线程的内存空间，所以子线程始终不会结束；
    2. 一旦while(num==0){}中执行了具体任务，CPU就有可能把num=1同步给子线程的内存空间，
    结束while循环；
    3. 变量num使用volatile修饰，子线程中的while(num==0){}每次都从主内存中读取num的值，
    所以在1s之后，num被置为1，也会立即被子线程的while(num==0)所感知，终止循环。
6. 单例模式之懒汉式的并发控制：双重检测、指令重排
    public class LittleBable {
        //volatile防止new对象的过程中指令重排，造成其他线程访问一个还有初始化完成的对象
        private static volatile LittleBable instance;
        private LittleBable() {}
        public static LittleBable getInstance() {
            if (null != instance) { return instance; } //双重检测，防止不必要的同步
            synchronized (LittleBable.class) {
                if (null == instance) {  instance = new LittleBable(); }
            }
            return instance;
        }
    }
</code></pre><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><pre><code>1. ThreadLocal是线程局部变量的存储空间，虽然被多个线程共享，但能使线程安全；
    private static ThreadLocal&lt;Interger&gt; tl = new ThreadLocal&lt;&gt;();
    1. JDK建议把ThreadLocal声明为private static
    2. 泛型为Integer，默认值为null   --&gt; tl.get(); --&gt; null
    3. 指定默认值
    new ThreadLocal&lt;&gt;(){ protected Integer initialValue(){ return 20; } };
    4. JDK8的新特性
    private static ThreadLocal&lt;Interger&gt; tl = ThreadLocal.withInitial(()-&gt;20);
    5. 设置新的值：tl.set(100);
2. 多个线程在获取/设置ThreadLocal时，相互不会影响；
    tl.set(100); --&gt; 在主线程中修改为100 --&gt; tl.get(); --&gt; 100
    new Thread(()-&gt;{
        tl.get(); --&gt; 在子线程中仍是默认值20 --&gt; tl.set(100);  --&gt; tl.get(); --&gt; 100
    }).start();
3. 上下文环境问题
    class TestRun implements Runnable {
        public TestRun() { tl.set(33); }
        public void run() { tl.get();  -----&gt; 20 }
    }
    new Thread(new TestRun()).start(); --&gt; 在主线程中执行
    1. 创建对象是在主线程中进行的，所以TestRun的构造函数也是在主线程中，tl.set(33); 设置
    的是主线程的ThreadLocal变量
    2. run()才是在子线程中执行的，所以获取ThreadLocal的变量仍是默认值20
</code></pre><h3 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h3><pre><code>1. InheritableThreadLocal：上下文环境的可继承ThreadLocal
2. 子线程会从当前上下文环境拷贝一份ThreadLocal，重新设置ThreadLocal也不会影响原上下文
    private static ThreadLocal&lt;Integer&gt; tl = new InheritableThreadLocal&lt;&gt;();
    tl.set(100);
    new Thread(()-&gt;{
        tl.get();  ---&gt; 100
        tl.set(200);  ---&gt; tl.get(); --&gt; 200
    }).start();
    tl.get();  --&gt; 100
3. ThreadLocal的应用
    1. 最常见的是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息...
    2. Hibernate的Session工具类：HibernateUtil
    3. 通过不同的线程对象设置Bean属性，保证各个线程Bean对象的独立性。
</code></pre><h2 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h2><pre><code>1. 锁作为保证并发共享数据一致性的工具，大多数内置锁都是可重入的，也就是可以延续使用；
2. 可重入
    1. 如果某个线程试图获取一个已经由它自己持有的锁时，那么此请求会立即成功，且会将这个锁
    的计数值加1；
    2. 当线程退出同步代码块时，计数器会递减，当计数值为0时，锁释放。
    3. 如果没有可重入锁的支持，在第二次试图获得锁时，将进入死锁状态；
    synchronized(this) { --&gt; 第一次获取锁
        while(true) {
            synchronized(this) { } --&gt; 第二次获取同一把锁
        }
    }
    public synchronized void testA() { }
    public synchronized void testB() { }
    public synchronized void testAll() {
        this.testA();  --&gt; 第二次获取同一把锁
        this.testB();
    }
3. 不可重入锁
    class Lock {
        private boolean isLocked = false;
        public synchronized void lock() {
            while(isLocked){ --&gt; 锁已经被占用了，则等待
                wait();
            }
            isLocked = true;
        }
        public synchronized void unlock() {
            isLocked = false;
            notify();  ---&gt; 释放锁，唤醒一个等待的线程
        }
    }
    Lock lock = new Lock();
    public void doSomething() {
        lock.lock();
        // ......
        lock.unlock();
    }
    public void test() {
        lock.lock();  --&gt; 上锁
        doSomething(); --&gt; 内部继续上同一把锁，但lock是不可重入的，所以陷入死锁状态
        lock.unlock();
    }
4. 可重入锁的实现原理
    class Lock {
        private boolean isLocked = false;
        private Thread t = null;
        private int count = 0; ---&gt; 计数器
        public synchronized void lock() {
            //对同一个线程放行，同一个线程可以重复上同一把锁
            Thread currentT = Thread.currentThread()
            while(isLocked &amp;&amp; (t!=currentT)){
                wait();  --&gt; 不是同一个线程，且锁已经被占用时，则等待
            }
            isLocked = true;  t = currentT;  count++;
        }
        public synchronized void unlock() {
            if(Thread.currentThread() == t) {
                count--;
                if(count == 0) { --&gt; 计数器为0时，当前线程才能释放锁
                    isLocked = false;
                    notify();  ---&gt; 唤醒一个等待的线程
                    t = null;
                }
            }
        }
    }
</code></pre><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><pre><code>1. 悲观锁：synchronized是独占锁(悲观锁)，会导致其他所有线程挂起，等待持有锁的线程释放锁
2. 乐观锁：完成某项操作时，每次不加锁，而是假设没有冲突，如果因为冲突失败就重试，直至成功
3. CAS：Compare and Swap，比较并交换，乐观锁的实现，如购物时的秒杀功能
    1. 有三个值：一个当前内存值V，旧的预期值A，将更新的值B
    2. 先获取内存中的值V，再将V与原值A比较，如果相等，则修改为B，并返回true，否则不修改，
    返回false
    3. CAS是一组原子操作，不会被外部打断；
    4. CAS属于硬件级别的操作(利用CPU的CAS指令，同时借助JNI来完成的非阻塞算法)，效率比加锁
    操作高；
    5. ABA问题：如果变量V初次读取时是A，且在准备赋值时检查到它仍是A，此时并不能保证变量V
    没被修改过，如果在这期间曾被修改成B，然后又改回A，那CAS操作就会误认为它从来没有修改过。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/01/02/Java基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/01/02/Java基础/" itemprop="url">Java基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-01-02T00:00:00+08:00">
                2016-01-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><pre><code>1. 浮点数的精确计算：BigDecimal，java.math包中的类
    1. 相减
    BigDecimal db1 = BigDecimal.valueOf(1.0);  --&gt; 浮点数1.0
    db1 = db1.subtract(BigDecimal.valueOf(0.1));  --&gt; 1.0 - 0.1
    2. 相除
    BigDecimal db2 = BigDecimal.valueOf(0.1);
    BigDecimal db3 = BigDecimal.valueOf(1.0/10.0);
    System.out.println(db2.equals(db3)); --&gt; true
2. 自动类型转换：容量小的类型自动向容量大的类型转换
    1. 特例：byte b = 123;
    2. 123 本身是 int 类型(Java中的数值默认是int类型)，byte类型的范围为-128~127
    3. 所以，123 可以直接赋值给 byte类型(自动转为byte类型)。
3. 溢出
    1. int m = 1000000000;  int y = 20;
    2. int t = m * y; --&gt; 负数(溢出导致)
    3. long t = m * (long)y; --&gt; 20000000000
4. Java5提供了可变长参数
    public void print(int n, String... args){
        for(String temp: args){ } --&gt;遍历可变长参数
    }
    print(2, &quot;a&quot;);  print(2, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;);
5. TreeMap与TreeSet
    1. TreeMap：红黑二叉树的典型实现，按照key自增长的方向排序；
    2. TreeSet：内部维持了一个简化版的TreeMap，通过key存储Set的元素；
    3. 如果存储的是对象，此对象应实现 Comparable 接口，以便于对其进行排序。
6. lambda表达式：JDK8新特性
    1. 针对的是只包含一个方法的接口，如Runnable
    new Thread(new Runnable(){
        public void run(){ System.out.println(&quot;start Run&quot;); }
    }).start();
    new Thread(()-&gt; {
        System.out.println(&quot;start Run&quot;);
    }).start();
    2. Thread是Runnable的代理对象(静态代理)。
7. 静态代理
    1. 代理对象和原对象都实现同一个接口
    interface Task {  void work();  }
    2. 原对象
    class Stuff implements Sask {
        public void work() { }
    }
    3. 静态代理对象
    class StaticProxy implements Task {
        private Task target;
        public StaticProxy(Task target) {
            this.target = target;
        }
        public void work() {
            this.start();
            this.target.work();
            this.end();
        }
        private void start(){ }
        private void end(){ }
    }
    4. 通过代理对象，执行原对象的任务方法
    new StaticProxy(new Stuff()).work();
8. 多线程之Callable
    1. Callable是一个接口，包含方法call()，接收一个泛型，默认是Object，作为call()的
    返回值类型
    public class CLoader implements Callable&lt;Boolean&gt; {  --&gt; 泛型指定为Boolean
        public Boolean call() throw Exception {
            ...... //执行任务
            return true
        }
    }
    CLoader cd1 = new CLoader(); CLoader cd2 = new CLoader();
    2. 使用线程池，创建服务
    ExecutorService es = Executors.newFixedThreadPool(2);
    3. 提交执行
    Future&lt;Boolean&gt; ft1 = es.submit(cd1);  Future&lt;Boolean&gt; ft2 = es.submit(cd2);
    4. 获取结果
    boolean re1 = ft1.get();  boolean re2 = ft2.get();
    5. 关闭服务
    es.shutdownNow();
    6. 与Thread/Runnable的 run() 相比，call()可以抛出异常，而 run() 不能抛出异常，只能
    try-catch捕获。
</code></pre><h2 id="JDK10新特性"><a href="#JDK10新特性" class="headerlink" title="JDK10新特性"></a>JDK10新特性</h2><pre><code>1. 局部变量类型推断
    1. var：保留类型(不是关键字)，只针对局部变量
    public void test() {
        var i = 10;
        var s = &quot;abc&quot;;
        var list = new ArrayList&lt;&gt;();
        var user = new User();
    }
    2. 不允许对var变量赋值null，编译器认为毫无意义，因为null就是null类型
    var a = null; --&gt; 编译器报错
    3. 不允许对方法的参数使用var，因为参数没有值，无法推断类型
2. 垃圾收集器的优化
    1. JDK9：新生代使用ParNew收集器，老年代使用Parallel Obl收集器
    2. JDK10：G1(Garbage-First) 全收集器
3. 新增73个新功能扩展API
    1. java.util.list/Set/Map新增静态方法copyOf()，按照其迭代顺序返回一个不可修改的集合
    var list = new ArrayList&lt;String&gt;();  list.add(&quot;a&quot;);  list.add(&quot;b&quot;);
    var cl = List.copyOf(list);
    2. java.io.ByteArrayOutputStream新增方法toString(charset)，通过指定的字符集编码，
    将缓冲区的内容转为字符串
    3. java.io.PrintStream/PrintWriter，新增三个构造方法，方法参数上可以指定字符集
    4. java.io.Reader新增transferTo()，将Reader中读取的所有字符串，按照读取的顺序写入给
    指定Writer
    var r = new BufferedReader(new InputStreamReader(
        new FileInputStream(&quot;d:/a.txt&quot;), &quot;GBK&quot;));
    var p = new PrintWriter(new File(&quot;d:/c.txt&quot;));
    r.transferTo(p);
    p.flush();  p.close();  r.close();
    5. java.util.Formatter/Scanner 新增三个构造器，需要一个charset参数，解决乱码问题
</code></pre><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><pre><code>1. XML：可扩展标记语言
2. XML声明：定义XML的版本和编码信息
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
3. 注释：&lt;!-- 注释 --&gt;
4. DTD：Document Type Definition，用于约束XML的文档格式
5. XSD：XML Schema，DTD的替代者，XSD本身也是XML
</code></pre><h3 id="XML解析"><a href="#XML解析" class="headerlink" title="XML解析"></a>XML解析</h3><pre><code>1. DOM解析：官方解析方式，基于XML树，会加载整个文档，比较消耗资源，适用于多次访问XML
2. SAX解析：基于事件的流式解析，自顶向下，不会加载整个文档，解析速度快，占用内存少；
    1. SAX无法知道父子标签，也无法随机访问某个标签；只能读取XML，不能修改；
    2. SAXParserFactory、SAXParser、继承DefaultHandler自定义解析器、定义对应的JavaBean
    3. DOM和SAX都是原生解析方式，JDOM和DOM4J是第三方解析框架
3. JDOM：比DOM更快，仅使用具体类，而不使用接口
4. dom4j：JDOM的升级版，功能强大，性能优异，使用接口，而不使用实现类
</code></pre><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><pre><code>1. JDBC：Java Database Connection，为Java使用数据库提供了统一的编程接口；
2. JDBC由一组Java类和接口组成，是Java程序与数据库系统通信的标准API；
3. 所谓数据库驱动就是数据库厂商对JDBC接口的实现；
4. ORM框架：Hibernate、mybatis
</code></pre><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><pre><code>1. Driver：由数据库厂商提供，引入相关数据库驱动jar包，装载数据库驱动
    1. 装载MySql驱动
    Class.forName(&quot;com.mysql.jdbc.Driver&quot;); --&gt; MySQL5.0
    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); --&gt; MySQL6.0+
2. DriverManager：JDBC的管理层，作用于用户和驱动程序之间，在数据库和驱动程序之间建立连接
3. Connection：与特定数据库的连接会话，执行SQL语句并返回结果
    1. 连接MySQL5.0数据库
    Connection conn = DriverManager.getConnection(
        &quot;jdbc:mysql://host:port/database&quot;, &quot;username&quot;, &quot;password&quot;);
    2. 连接MySQL6.0+数据库，需要指定时区serverTimezone
    jdbc:mysql://host:port/database?useUnicode=true&amp;characterEncoding=UTF-8
    &amp;serverTimezone=Asia/Shanghai
    &amp;useSSL=false&amp;zeroDateTimeBehavior=CONVERT_TO_NULL
    3. 连接的建立是比较耗时的，内部包含Socket，实际上是建立一个Socket远程连接;
    4. 关闭连接：conn.close();
4. Statement：执行静态SQL语句并返回结果的对象
    1. Statement用于发送简单的SQL语句(不带参数)，执行SQL时需要拼接参数，有SQL注入的危险
    Statement stat = conn.createStatement();
    2. PreparedStatement：继承Statement，用于发送含有任意多个参数的SQL语句，会预编译，
    所以效率比Statement高，且防SQL注入；
    String sql = &quot;insert into users(name, time) values(?, ?)&quot;; --&gt; ? 表示占位符
    PreparedStatement stat = conn.prepareStatement(sql);
    stat.setString(1, &quot;Mack&quot;);  --&gt; 设置字符串类型的占位符，占位符索引从1开始
    stat.setDate(2, new java.sql.Date(System.currentTimeMillis())); -&gt;设置日期时间
    stat.execute();  --&gt; 执行SQL语句
    3. 如果不想关心字段类型，则使用 setObject()
    4. CallableStatement：继承自PreparedStatement，由 conn.prepareCall(sql) 创建，
    用于调用存储过程。
5. 常用方法
    1. execute()：运行语句，返回是否有结果集(true/false)
    2. executeQuery()：运行select语句，返回 ResultSet 结果集
    3. executeUpdate()：运行insert/update/delete操作，返回更新的行数
    4. close(); 关闭
6. ResultSet
    String sql = &quot;select * from users where id&gt;?&quot;;
    PreparedStatement stat = conn.prepareStatement(sql);
    stat.setInt(1, 10);
    ResultSet rs = stat.executeQuery();
    while (rs.next()) {
        int id = rs.getInt(1); --&gt; 获取第一列的数据，且字段类型为int
        String name = rs.getString(2); --&gt; 获取第二列的数据，且字段类型为String
    }
    rs.close();  stat.close(); --&gt;关闭
    1. 如果不想关心数据类型，则使用 getObject()
    2. rs.next()：迭代下一行数据，如果没有了，则返回false
7. 时间相关
    1. java.sql.Date(年月日)
    2. java.sql.Time(时分秒)
    3. java.sql.Timestamp(年月日时分秒)
8. Properties
    1. 读取和处理配置资源文件中的信息，如数据库url、database、username、password等信息
    2. 如db.properties文件，用于存储数据的配置信息：
    driver=com.mysql.cj.jdbc.Driver
    url=jdbc:mysql://localhost:3306/db_test?serverTimezone=Asia/Shanghai
    user=root
    password=123456
    3. 加载db.properties文件
    static Properties pros = null;
    static {
        pros = new Properties();
        pros.load(Thread.currentThread().getContextClassLoader()
        .getResourceAsStream(&quot;db.properties&quot;));
    }
    4. 使用db.properties中的配置信息
    Class.forName(pros.getProperty(&quot;driver&quot;));
</code></pre><h3 id="批量处理"><a href="#批量处理" class="headerlink" title="批量处理"></a>批量处理</h3><pre><code>1. PreparedStatement的预编译空间有限，数据量特别大时会发生异常，所以建议使用Statement
2. JDBC中的事务默认是自动提交，还需要设置为手动提交
    conn.setAutoCommit(false); --&gt; 禁止自动提交
    Statement stat = conn.createStatement();
    for(int i=0; i&lt;20000; i++) {
        stat.addBatch(&quot;insert into ...&quot;); --&gt;一次性插入20000条数据
    }
    stat.executeBatch();
    conn.commit(); //手动提交事务
</code></pre><h3 id="大数据量处理"><a href="#大数据量处理" class="headerlink" title="大数据量处理"></a>大数据量处理</h3><pre><code>1. CLOB：Character Large Object，用于存储大文本数据
    1. 不同数据库对大文本(大字段)有不同的处理方式，通常以流的方式处理；
    2. MySQL中的相关类型及其最大长度(字符)：TINYTEXT(2^8-1)，TEXT(2^16-1)，
    MEDIUMTEXT(2^24-1)，LONGTEXT(2^32-1或4GB)
2. JDBC操作大文本
    1. 存储
    PreparedStatement stat = conn.prepareStatement(sql);
    stat.setClob(3, new FileReader(&quot;d:/a.txt&quot;)); //接受一个流对象
    2. 读取
    ResultSet rs = ...
    while (rs.next()) {
        Clob c = rs.getClob(&quot;desc&quot;); --&gt; 指定字段名获取值
        Reader r = c.getCharacterStream(); --&gt; 获取大文本流
    }
3. BLOB：Byte Large Object，用于存储大二进制数据
    1. 不同数据库对大二进制数据(大字段)有不同的处理方式，通常以流的方式处理；
    2. MySQL中的相关类型及其最大长度(字符)：TINYBLOB(2^8-1)，BLOB(2^16-1)
    MEDIUMBLOB(2^24-1)，LONGBLOB(2^32-1或4GB)
4. JDBC操作大二进制数据
    1. 存储
    PreparedStatement stat = conn.prepareStatement(sql);
    stat.setBlob(3, new FileInputStream(&quot;d:/b.jpg&quot;)); //接受一个流对象
    2. 读取
    ResultSet rs = ...
    while (rs.next()) {
        Blob b = rs.getBlob(&quot;avatar&quot;); --&gt; 指定字段名获取值
        InputStream is = b.getBinaryStream(); --&gt;获取大二进制流
    }
</code></pre><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><pre><code>1. 事务：一组要么同时执行成功，要么同时执行失败的SQL语句，是数据库操作的一个执行单元；
2. 事务开始于：
    1. 连接数据库，并执行一条DML语句(INSERT、UPDATE、DELETE)
    2. 前一个事务结束后，又输入另一条DML语句
3. 事务结束于：
    1. 执行COMMIT或ROLLBACK语句；
    2. 执行一条DDL语句，如CREATE TABLE，这种情况会自动执行COMMIT语句；
    3. 执行一条DCL语句，如GRANT，这种情况也会自动执行COMMIT语句；
    4. 断开与数据库的连接；
    5. 执行一条DML语句，但却失败了，这种情况会执行ROLLBACK语句。
4. 四大特性：
    1. 原子性：一个事务内的所有操作是一个整体，要么全部成功，要么全部失败；
    2. 一致性：一个事务内有一个操作失败时，所有更改过的数据都必须回滚到初始状态；
    3. 隔离性：查看数据状态时，要么是另一个事务修改之前的状态，要么是修改之后的状态，不会
    出现中间状态的数据，级别：读取未提交&lt;读取已提交&lt;可重复读&lt;序列化，通常是读取已提交；
    4. 持久性：对于系统的影响是永久性的；
    conn.setAutoCommit(false); --&gt; 禁止事务自动提交
    conn.commit(); --&gt; 手动提交事务
    conn.rollback(); --&gt; 提交失败后(发生异常)，执行数据回滚
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">大麦田怪圈</p>
              <p class="site-description motion-element" itemprop="description">敢做就能赢！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">56</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大麦田怪圈</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
