<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="敢做就能赢！">
<meta property="og:type" content="website">
<meta property="og:title" content="大麦田程序猿">
<meta property="og:url" content="http://hellomyshadow.github.io/page/2/index.html">
<meta property="og:site_name" content="大麦田程序猿">
<meta property="og:description" content="敢做就能赢！">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="大麦田程序猿">
<meta name="twitter:description" content="敢做就能赢！">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hellomyshadow.github.io/page/2/">





  <title>大麦田程序猿</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大麦田程序猿</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/06/05/JS-高级/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/05/JS-高级/" itemprop="url">JS-高级</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-05T00:00:00+08:00">
                2018-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JS高级"><a href="#JS高级" class="headerlink" title="JS高级"></a>JS高级</h2><pre><code>1. 访问对象属性(方法也是属性)的通用方式：obj[&apos;属性名&apos;]
    1. 属性名包含特殊字符，如&quot;-&quot;、空格，访问：obj[&apos;content-type&apos;]
    2. 属性名不确定：var name=&apos;age&apos;;  var value=18;  obj[name]=value
2. IIFE：立即执行函数，用于隐藏实现、避免污染全局命名空间、编写JS模块
    (function(){ ... })() ---&gt; 即匿名函数自调用
3. this的指向
    1. 任何函数本质上都是通过某个对象来调用的，如果没有显式指定，则默认是window；
    2. 所有函数内部都有一个变量this，指向当前调用函数的对象；
    3. functionName.call()/apply()：第一个参数用于指定函数内部this的指向。
4. JS语句可以不加分号，但有2种情况必须加分号：
    1. 小括号开头的前一条语句；
    var a = 3;
    (function() { ... })()
    2. 中方括号开头的前一条语句；
    var b = 4;
    [1, 3].forEach(function)
    3. 为了避免这2种错误，可以在行首加分号：;(function() { ... })()
</code></pre><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><pre><code>function Test() { ... }
1. prototype：显式原型(属性)
    1. 定义函数时自动添加一个prototype属性，默认指向一个Object空对象，即原型对象；
    Test.prototype instanceof Object --&gt; true
    Function.prototype instanceof Object --&gt; true
    Object.prototype instanceof Object --&gt; false，Object除外
    2. 原型对象中又有一个属性constructor，指向函数自身；
    Test.prototype.constructor === Test ---&gt; true
    3. 给原型对象添加属性/方法，函数的所有实例对象自动拥有原型对象中的属性/方法。
2. __proto__：隐式原型(属性)，ES6之前不能直接操作该属性
    1. 创建实例对象时自动添加一个__proto__属性，默认值为构造函数的prototype属性值；
    即：实例对象的隐式原型和构造函数的显式原型指向同一个原型对象；
    var tes = new Test();
    tes.__proto__ === Test.prototype ---&gt; true
    2. 函数也有隐式原型，而且所有函数(包括Object和Function)都是Function的实例；
    Test/Object/Function.__proto__ === Function.prototype ---&gt; true
3. 原型链：__proto__链
    1. 原型对象中也有隐式原型__proto__，指向当前构造函数的父构造函数的原型对象；
    tes.show() --&gt; 自身 --&gt; 沿着__proto__查找：tes.__proto__ 即Test.prototype 
    --&gt; Test.prototype.__proto__ 即Object.prototype --&gt; show()不存在，报错；
    2. 所有对象/构造函数，包括Function，都直接/间接派生自Object，它是JS的顶层父类，
    其原型对象就是原型链的尽头，因为Object.prototype.__proto__ === null
4. 访问对象属性/方法时，会自动到原型链上查找；而设置对象的属性值时，则不会涉及原型链，
   如果对象中没有该属性/方法，则添加，否则就修改；
5. 一般情况下，方法定义在原型中，属性直接定义在通过构造函数；
6. A instanceof B 的判断的标准：如果B的显示原型在A的原型链上，则返回true.
</code></pre><h3 id="函数高级"><a href="#函数高级" class="headerlink" title="函数高级"></a>函数高级</h3><pre><code>1. 全局执行上下文
    1. 在执行全局代码前，将window确定为全局执行上下文；
    2. 对全局数据进行预处理：var定义的全局变量会被提前声明(值为undefined)，全局函数
    会被提前定义，并把全局变量/函数添加为window的属性/方法；
    3. this指向window；
    4. 在执行代码时，才会对变量重新赋值，而定义函数的代码会直接跳过，因为在执行全局
    代码之前，函数已经被提前定义了。
    var test = 1;
    function test() { ... }
    test(); ---&gt; 报错：test is not a function
    5. 真正的执行过程：
    var test; --&gt; function test() { ... } --&gt; test = 1; --&gt; test();
2. 函数执行上下文
    1. 调用函数、准备执行函数之前，创建对应的函数执行上下文；
    2. 对局部数据做预处理：变量的提前声明，函数的提前定义，this的指向，形参的赋值等；
3. 闭包：内部函数引用外部函数的局部变量，外部函数执行完后，其局部变量仍存活于内存中；
    function out() {
        var a = 2;
        function inner() {
            console.log(++a);
        }
        return inner;
    }
    1. var f = out(); --&gt; 变量f持有内函数inner()的引用，所以局部变量a仍在内存中；
    2. out(); --&gt; 没有任何引用内函数指向inner()，那么inner将成为垃圾对象，并被GC；
    也即，局部变量a也不存在了；
    3. 闭包的生命周期：在函数内部定义时就已经产生了，在内部函数成为垃圾对象时死亡；
    var f = out(); --&gt; f(); --&gt; f = null; --&gt; 死亡，释放内存；
    4. 闭包容易造成内存泄露，应该及时释放。
4. 利用闭包自定义JS模块-1：myModule.js
    function myModule() {
        var msg = 1;
        function showMsg() { ... }
        return showMsg; --&gt; 向外暴露
    }
    在html中引用：&lt;script src=&quot;myModule.js&quot; type=&quot;text/javascript&quot;&gt;        
    var fn = myModule(); --&gt; fn指向内部函数showMsg() --&gt; 执行showMsg()：fn();
    如果暴露多个函数，则返回一个对象：return { showMsg: showMsg, }
    var module = myModule(); --&gt; 执行showMsg()：module.showMsg();
5. 利用闭包自定义JS模块-2：myModule.js
    (function(w) {  --&gt; 自执行函数
        var msg = 1;
        function showMsg() { ... }
        w.myModule = { showMsg: showMsg, } --&gt; 向外暴露
    })(window) --&gt; 为全局上下文window添加属性myModule
    在html中引用：&lt;script src=&quot;myModule.js&quot; type=&quot;text/javascript&quot;&gt;        
    myModule.showMsg(); --&gt; myModule是window的属性，可以直接使用；
</code></pre><h3 id="对象高级"><a href="#对象高级" class="headerlink" title="对象高级"></a>对象高级</h3><pre><code>1. 创建对象：
    1. Object构造函数模式：var obj = new Object(); --&gt; 然后为对象添加属性/方法；
    2. 对象字面量模式：var obj = { ...(属性/方法) }
    3. 工厂模式：动态返回一个对象的函数；
    4. 自定义构造函数模式：var obj = new Person(&apos;Mack&apos;)
    function Person(name) {
        this.name = name;
        this.show = function() { ... }
    }
    5. 构造函数+原型的组合模式：
    function Person(name) { this.name=name; }
    Person.prototype.show = function() { ... } --&gt; 公共的方法定义在原型对象中
2. 原型链继承：子类的原型是父类的一个原型对象；
    1. 定义父类构造函数，并在原型中添加方法；
    function Supper() { this.supProp = &apos;Supper property&apos;; }
    Supper.prototype.showSupper = function() { ... }
    2. 定义子类构造函数，让子类的原型指向父类对象，修正子类原型对象中的constructor，
    让其指向子类构造函数，然后为子类的原型添加方法；
    function Sub() { this.subProp = &apos;Sub property&apos;; }
    Sub.prototype = new Supper(); --&gt; 更改显示原型的指向
    Sub.prototype.constructor = Sub; --&gt; 修正constructor的指向
    //Sub.prototype.__proto__即new Supper().__proto__，指向Supper.prototype
    Sub.prototype.showSub = function() { ... }
    3. 创建子类的对象，可以调用父类的方法：var sub = new Sub();
    sub.showSubProp(); sub.showSupperProp();
</code></pre><h3 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h3><pre><code>cookie，H5新增的localStorage、sessionStorage
</code></pre><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><pre><code>1. 存储在浏览器的一段文本信息，最大容量4k，在同源的http请求时携带传递，损耗带宽；
2. cookie是在服务器端设置的，浏览器接收到cookie信息，便以键-值的形式存储在本地；
3. 出于安全考虑，跨域名请求不会携带cookie，这是由浏览器技术实现的安全策略；
4. 可设置访问路径和过期时间，只有此路径及其子路径才能访问此cookie。
</code></pre><h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><pre><code>1. 容量最小5M，不会在http请求时携带传递，不需要服务器环境；
2. 在所有同源窗口中共享，数据始终有效，除非人为删除，可作为长期数据；
3. 设置：localStorage.setItem(&apos;key&apos;, &apos;value&apos;);    localStorage.key = value;
4. 获取：localStorage.getItem(&apos;key&apos;);    localStorage.key;
5. 删除：localStorage.removeItem(&apos;key&apos;);
</code></pre><h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><pre><code>1. 容量最小5M，不会在http请求时携带传递，在同源的当前窗口关闭前有效；
2. 与localStorage合称为Web Storage，支持事件通知机制，可以将数据更新通知监听者；
3. iPhone的无痕浏览不支持Web Storage，只能用cookie.
</code></pre><h2 id="JS与后台通信"><a href="#JS与后台通信" class="headerlink" title="JS与后台通信"></a>JS与后台通信</h2><h3 id="AJAX：同源策略"><a href="#AJAX：同源策略" class="headerlink" title="AJAX：同源策略"></a>AJAX：同源策略</h3><pre><code>1. JS原生支持AJAX，目的是让JS发送HTTP请求，且AJAX通信的过程是异步的；
2. 同源策略：基于安全考虑，AJAX只能请求同一域名下的资源，通常是JSON数据；
报错特征：No &apos;Access-Control-Allow-Origin&apos; header is present 
on the requested resource. Origin &apos;null&apos; is therefore not allowed access.
3. AJAX执行的是同源策略，所以请求的url不需要域名，比如 url: &apos;js/user.json&apos;;
</code></pre><h3 id="JSONP：跨域请求"><a href="#JSONP：跨域请求" class="headerlink" title="JSONP：跨域请求"></a>JSONP：跨域请求</h3><pre><code>1. 原理：&lt;script src=&quot;...&quot;&gt; src链接的地址不受限制；
2. 在页面上定义的JS函数，script-src链接的外部JS文件也可以调用，那么，外部JS就可以
   把数据以回调参数的形式传递回当前页面。
</code></pre><h2 id="移动端JS事件"><a href="#移动端JS事件" class="headerlink" title="移动端JS事件"></a>移动端JS事件</h2><pre><code>1. 移动端主要用手指操作，在JS中对应Touch事件：
    1. touchstart/touchend/touchmove：手指放到屏幕上/离开屏幕/滑动时触发；
    2. touchcancel：系统取消Touch事件时触发；
    3. 移动端一般操作：点击、滑动、拖动，这三种操作一般组合使用Touch事件完成。
2. zeptojs：最初是为移动端提供一个精简的、类似jQuery的JS库，现在发展成一个轻量级的、
   针对现代高级浏览器的JS库；
    1. API类也似于jQuery，比如$(function(){ ... })、$(this)、$(&apos;#div&apos;) ...
    2. 其touch模块封装了移动端常用的Touch事件，针对开发移动端的特定效果。
3. swiper.js：一个成熟稳定的、应用于PC端和移动端的滑动效果插件；
    1. 一般用来触屏焦点图、触屏整屏滚动、幻灯片等效果；
    2. 2.x版本支持低版本浏览器IE7，3.x放弃低版本浏览器，适用于移动端。
</code></pre><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><pre><code>1. 作为浏览器脚本语言，JS主要与用户交互及操作DOM，这决定了JS是单线程的，效率高；
2. H5中的Web Workers可以多线程运行；
3. 浏览器是多线程运行的，Firefox、老版IE是单进程，新版IE、Chrome是多进程；
4. 浏览器内核：支撑浏览器运行的核心程序，由很多模块组成；
    1. Chrome/Safari：webkit   Firefox：Gecko   IE：Trident
    2. 360、搜狗等国内浏览器的内核：Trident+webkit
    3. 内核模块-主线程：JS引擎模块(JS的编译与运行)，HTML文档解析模块，DOM/CSS模块
    (DOM/CSS在内存中的相关处理)，布局和渲染模块(负责页面的布局和效果的绘制)...
    4. 内核模块-子线程：定时器模块(管理定时器)，事件响应模块(管理事件)，网络请求模块
    (AJAX请求)...
</code></pre><h3 id="JS是单线程"><a href="#JS是单线程" class="headerlink" title="JS是单线程"></a>JS是单线程</h3><pre><code>1. 定时器机制：
    1. 定时器并不能保证真正的定时执行，一般会延迟一点点，但也有可能延迟很长时间；
    2. 定时器其实是在主线程中执行的，因为JS是单线程的，如果定时器执行前做耗时/阻塞的
    操作，那么就可能造成定时器延迟很长时间。
2. JS代码分为初始化代码、回调代码，JS引擎执行代码的基本流程：
    1. 先执行初始化代码：包括设置定时器、绑定监听、发送AJAX请求
    2. 在后面的某个时刻才会执行回调代码；
    3. 弹出alert，JS代码是阻塞的，计时也会被暂停，定时器随之被延迟，直到关闭alert后
    才会恢复计时，执行定时器。
3. 事件驱动模型
</code></pre><p><img src="https://i.imgur.com/6RlAIZh.jpg" alt></p>
<pre><code>1. event loop：事件轮询，事件包括定时器、DOM事件、AJAX
2. callback queue：事件的回调队列，存放待处理的回调函数；
3. 当事件发生时，管理模块会将回调函数及其数据添加到回调队列中，等待主线程执行。
</code></pre><h3 id="Web-Workers"><a href="#Web-Workers" class="headerlink" title="Web Workers"></a>Web Workers</h3><pre><code>1. JS是单线程的，在做耗时的操作时，如大量计算，Web界面就会卡死；
2. Web Workers是H5提供的一个JS多线程解决方案，子线程完全受主线程控制，由子线程去执行
耗时的计算，避免冻结主线程，但H5不允许子线程操作DOM，所以并没有改变JS单线程的本质；
3. 使用Web Workers：
    1. 创建子线程执行的JS文件：worker.js
    var onmessage = function(event) {  --&gt; 接收主线程发来的消息，var可省略
        var data = event.data
        postMessage(&apos;Hello Main&apos;) --&gt; 向主线程发消息
    }
    2. 在主线程中的JS中发消息，并设置回调：
    var worker = new Worker(&apos;worker.js&apos;)
    worker.onmessage = function(event) { --&gt; 监听子线程发来的消息
        var data = event.data --&gt; 获取子线程发来的数据
    }
    worker.postMessage(&apos;Hello Worker&apos;); --&gt; 向子线程发送消息
4. 主线程的全局上下文是window，而子线程的全局上下文DedicatedWorkerGlobalScope
    1. DedicatedWorkerGlobalScope的属性/方法：
    onmessage: null，postMessage: function，close: function ...
    2. 子线程的全局上下文对象中没有alert()、document等，所以子线程中不能更新界面。
5. Web Workers的缺点：慢，不能跨域加载JS，不能操作DOM，有些浏览器不支持。
</code></pre><h2 id="自动化与优化"><a href="#自动化与优化" class="headerlink" title="自动化与优化"></a>自动化与优化</h2><pre><code>1. less、sass、stylus：三种样式动态语言，属于CSS预处理语言，便于CSS的编写和维护；
    1. 有类似于CSS的语法，赋予CSS动态语言的特性，如变量、继承、函数等；
    2. 文件后缀分别是：x.less、x.scss、x.styl，并不能直接使用，需要编译成CSS文件；
    3. 编译方式：软件编译如koala，或者用nodejs程序编译，如grunt、gulp
2. gulp比grunt更简洁、性能更高，gulp的常用插件：
    1. 压缩JS代码gulp-uglify、less的编译gulp-less、CSS的压缩gulp-minify-css.
    2. 自动添加CSS3前缀gulp-autoprefixer、文件重命名gulp-rename.
</code></pre><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><pre><code>1. 代码部署
    1. 代码的压缩与合并：去除空格、换行等，可利用gulp工具的插件完成；
    2. 图片、JS、CSS等静态资源存储在与主站不同的域名地址，避免在传输时携带cookie；
    3. 权衡DNS查找次数，使用不同域名会增加DNS查找；与上述相违背，权衡处理；
    4. 使用内容分发网络 CDN；使用GZIP压缩传输，压缩效率高；
    5. 为文件设置Last-Modified、Expires和Etag，即本地缓存数据；
    6. 避免不必要的重定向，在链接末尾手动加&quot;/&quot;，如https://www.baidu.com/
2. HTML：避免空的src和href，不要在HTML中缩放图片。
3. CSS
    1. 精简CSS选择器的层级，并把CSS放到顶部，避免@import的方式引入样式；
    2. 使用Base64编码的图片数据取代图片文件，减少请求次数；
    3. 使用CSS动画来取代JS动画，CSS动画是虚拟完成的，并不会改变页面结构；
    4. 使用字体图标：https://fontawesome.com/icons
    5. 使用CSS Sprite雪碧图，SVG图像；避免使用CSS表达式和滤镜。
4. JavaScript
    1. 减少引用库的个数，使用模块化概念的requerejs/seajs异步加载JS；
    2. JS在加载时会阻塞页面继续向下解析，理论上JS应该放在页面底部引用；
    3. 避免全局查找，约束范围去查找；减少属性查找；尽可能使用原生方法；
    4. 用switch代替复杂的if-else；减少语句数，比如多个变量声明可以合成一句；
    5. 使用字面量表达式来初始化数组/对象，比如arr=[1,2,3]取代new Array(1,2,3);
    6. 使用DocumentFragments/innerHTML取代复杂的元素注入；
    7. 使用事件代理/委托；高频触发的事件设置函数节流；
    8. 避免多次dom选择集，使用变量存储，var d = $(&apos;#div&apos;);
    9. 使用Web Storage缓存数据；使用Array的join()取代字符串的&quot;+&quot;连接。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/06/03/JS-事件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/03/JS-事件/" itemprop="url">JS-事件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-03T00:00:00+08:00">
                2018-06-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><h3 id="DOM查询"><a href="#DOM查询" class="headerlink" title="DOM查询"></a>DOM查询</h3><pre><code>1. 通过domcument对象获取元素节点：
    1. getElementById(&quot;id&quot;)：通过id属性获取一个元素节点对象；
    2. getElementsByTagName(&quot;tag&quot;)：通过标签名获取一组元素节点对象；
    2. getElementsByTagName(&quot;*&quot;)：支持通配符，获取所有节点对象；
    3. getElementsByName(&quot;name&quot;)：通过name属性获取一组元素节点对象。
    4. 获取元素节点的属性值：节点对象.属性名，但对于class属性，节点对象.className
1. 通过具体的元素节点对象获取其子节点：
    1. childNodes：获取其所有的子节点，包括文本节点、换行、标签间的空白等，但IE8不会；
    2. children：获取所有的子元素，只获取标签元素，且是直接子元素；
    3. firstChild/lastChild：获取第一个/最后一个子节点，也包括文本节点、换行，空白等；
    4. firstElementChild：获取第一个标签元素，不兼容&lt;=IE8；
2. 获取父节点和兄弟节点：
    1. parentNode：获取当前节点的父节点；
    2. previousSibling/nextSibling：获取前/后一个兄弟节点；
    3. previousElementSibling：获取前一个兄弟标签元素，也不兼容&lt;=IE8；
    4. innerText/innerHTML/textContent：都可以获取一个标签的内容，innerHTML的内容包含
    子标签，而innerText和textContent只获取标签内的字符串文本；
    5. 只获取标签内自己的字符串：firstChild.nodeValue，没有字符串文本，则返回空字符串；
    对于不能做父元素的标签，如&lt;img/&gt;, 其firstChild为null
3. 每个节点(包括文本节点)都具有的3个属性：nodeName、nodeType、nodeValse
    1. 文档节点：nodeName =&gt;#document、nodeType =&gt;9、nodeValse =&gt;null
    2. 元素节点：标签名、1、null
    3. 属性节点：属性名、2、属性值
    4. 文本节点：#text、3、文本内容
4. document.documentElement/body：获取&lt;html&gt;/&lt;body&gt;的元素对象；
5. document.all/document.getElementsByTagName(&quot;*&quot;)：获取所有节点的标签元素；
6. getElementsByClassName(&apos;选择器名称&apos;)：根据class属性值获取一组元素，兼容到&gt;=IE8
7. querySelector(&apos;CSS选择器&apos;)：根据CSS选择器获取标签元素，只返回第一个，兼容到&gt;=IE8；
8. querySelectorAll(&apos;CSS选择器&apos;)：返回一组标签元素；
9. HTML是自顶向下解析的，不能提前获取document节点
    1. 在&lt;body&gt;标签之后使用&lt;script&gt;，可以获取节点对象；
    2. window.onload = function(){ ... }：等待HTML文档加载并渲染完成再执行；
</code></pre><h3 id="DOM增删改"><a href="#DOM增删改" class="headerlink" title="DOM增删改"></a>DOM增删改</h3><pre><code>1. appendChild()/removeChild()/replaceChild()：添加/删除/替换子节点；
2. insertBefore(newNode, oldNode)：在指定的子节点前插入新的子节点；
3. createElement()/createAttribute()/createTextNode()：创建元素/属性/文本节点；
    var li = document.createElement(&quot;li&quot;); --&gt; 创建一个&lt;li&gt;
    var text = document.createTextNode(&quot;Mark&quot;); --&gt; 创建文本节点
    li.appendChild(text); --&gt; 把文本节点添加到&lt;li&gt;中
4. innerHTML也可以完成DOM的增删改：li.innerHTML=&quot;&lt;span&gt;Smith&lt;/span&gt;&quot;;
    var li = document.createElement(&quot;li&quot;);
    li.innerHTML = &quot;Mark&quot;; --&gt; create与innerHTML结合使用
5. setAttribute()/getAttribute()：设置/获取指定的属性；
6. confirm(str)：确认/取消提示框，带有确认和取消按钮，返回true/false；
    &lt;button&gt;Button-1&lt;/button&gt; &lt;button&gt;Button-2&lt;/button&gt;
window.onload=function(){
    var btns = document.getElementsByTagName(&quot;button&quot;)
    for (var i=0; i&lt;btns.length; i++) {
        btn[i].onclick=function(){
            confirm(this.innerHTML); --&gt; this指向当前button对象
            confirm(btns[i].innerHTML); --&gt;报异常undefined，此时的i=btns.length
        }; --&gt; 页面加载完成，首先执行的是for循环，而不会执行函数；
    } --&gt; 在点击按钮时，此时的i=btns.length，所以报异常；
}; --&gt; 而函数内的this始终指向调用者，所以可以正常执行。
</code></pre><h3 id="DOM操作CSS"><a href="#DOM操作CSS" class="headerlink" title="DOM操作CSS"></a>DOM操作CSS</h3><h4 id="JS修改元素样式"><a href="#JS修改元素样式" class="headerlink" title="JS修改元素样式"></a>JS修改元素样式</h4><pre><code>1. 选择器中的样式是无法获取，也无法修改的，但可以操作元素的内联样式，其优先级高于选择器；
2. 元素对象.style.样式名 = &quot;样式值&quot;，通用写法：元素对象.style[&quot;样式名&quot;] = &quot;样式值&quot;
3. 对于&quot;-&quot;连接的属性，则去掉&quot;-&quot;，并把后面的首字母大写：btn.style.fontSize=&quot;20px&quot;;
4. 通用形式则不需要去掉属性名中的连接符：btn.style[&quot;font-size&quot;]=&quot;20px&quot;;
5. &lt;style&gt;中的选择器应避免使用&quot;!important&quot;，它表示样式的最高优先级，内联样式也无法覆盖；
6. element.setAttribute(&apos;style&apos;, &apos;width:20px;height:30px;&apos;)：设置元素的style属性；
7. element.setAttribute(&apos;style&apos;)：移除元素的style属性，也即删除style样式；
8. 如果要修改多个样式，可以在&lt;style&gt;中预定义CSS样式选择器，再赋值给元素的className属性，
   这种方式的性能比较高，也使得JS和CSS更好的分离。
</code></pre><h4 id="JS获取元素样式"><a href="#JS获取元素样式" class="headerlink" title="JS获取元素样式"></a>JS获取元素样式</h4><pre><code>1. element.style：获取的是当前元素上的所有内联样式，包括默认存在的内联样式；
2. element.style.样式名、element.style[&quot;样式名&quot;]：根据属性名获取内联样式的属性；
    1. 获取的只是内联样式上的属性，如果内联样式上没有手动设置该属性，则获取的属性值为&apos;&apos;；
    2. element.style.cssText：只获取标签上手动设置的CSS样式，是一个字符串；
    element.style.cssText = &quot;width:100%;font-size:16px;&quot; --&gt;修改/添加内联样式
3. element.getAttribute(&apos;style&apos;)：获取标签上的style属性值，同element.style.cssText
4. element.currentStyle.样式名：IE独有的，获取元素当前正在使用的所有样式信息；
    1. 如果没有手动设置样式的默认值，则返回auto；
5. getComputedStyle(element, null)：window的方法，获取元素当前正在使用的的所有样式；
    let sty = getComputedStyle(btn, null)
    1. sty[&quot;background-color&quot;]返回的是rgb值，btn.style[&quot;background-color&quot;]返回的是
    当前样式中设置的background-color属性值；
    2. 不兼容&lt;=IE8
6. currentStyle和getComputedStyle()获取的属性都是只读的，不能修改；
7. 获取CSS样式属性的兼容方式：
    function getStyle(element, styleName) {
        if(window.getComputedStyle) {
            return getComputedStyle(element, null)[styleName];
        } else { --&gt; IE8的window中没有getComputedStyle，则返回undefined，即false
            return element.currentStyle[styleName];
        } --&gt; 属性styleName要显示设置一个默认值，否则浏览器可能返回auto
    }
</code></pre><h3 id="DOM属性事件"><a href="#DOM属性事件" class="headerlink" title="DOM属性事件"></a>DOM属性事件</h3><pre><code>1. clientWidth/clientHeight：获取元素的可见宽高，不带单位px，返回的是数值；
    1. clientWidth = width + paddingLeft + paddingRight
    2. clientWidth和clientHeight都是只读属性；
    3. 浏览器窗口的宽度/高度：document.documentElement.clientWidth/clientHeight
2. scrollWidth/scrollHeight：获取元素的滚动区域宽高；
    1. 如果元素区域带有滚动条，clientWidth/clientHeight只能获取滚动窗口内可见的宽高，
    而scrollWidth/scrollHeight获取的宽高，包含滚动窗口外的宽高；
    2. clientWidth/clientHeight获取的宽高包含滚动条的宽度/高度；
    3. scrollLeft/scrollTop：水平/垂直滚动的距离；
    4. 当垂直滚动条滚到底部时，clientHeight == scrollHeight-scrollTop
    5. element.onscroll = function(){}; --&gt; 绑定滚动条滚动事件
3. offsetWidth/offsetHeight：获取元素的整个宽度和高度，width+padding+border
4. offsetParent：获取距离最近的、使用了定位的父元素对象，如果都没有定位，则返回body；
5. offsetLeft/offsetTop：当前元素相对于其定位父元素的水平/垂直偏移量，都是只读的属性；
1. 上传图片
    &lt;input type=&quot;file&quot; accept=&quot;image/*&quot; onchange=&quot;uploadImg(this)&quot; /&gt;
    1. accept：指定上传文件的类型，打开资源管理器展示的文件类型；
    2. onchange：&lt;input/&gt;中的内容发生变化时的事件；
    3. 预览图片，FileReader是H5提供的，用于读取文件
    uploadImg(ev) {
        let file = ev.files[0]
        let reader = new FileReader() --&gt;创建FileReader对象
        reader.onloadstart = function (e) { //开始读取 }
        reader.onprogress = function (e) { //正在读取中 }
        reader.onabort = function (e) { //中断读取 }
        reader.onerror = function (e) { //读取异常 }
        reader.onload = function (e) { ---&gt;读取成功的回调
            let img = document.querySelector(&quot;input[type=file]&quot;)
            img.src = e.target.result
        }
        reader.readAsDataURL(file) ---&gt;开始读取本地选择的文件
    }
1. element.onmousemove = function(event){}：鼠标在元素中移动时被触发；
    1. 回调的参数event中封装了所有信息，如鼠标的水平/垂直坐标：clientX/clientY
    2. 但在IE8中不会回调event，而是将事件对象保存在window的属性中：window.event
    3. clientX/clientY只针对当前浏览器的可见窗口，窗口左上角的坐标始终是(0, 0)；
    4. pageX/pageY：鼠标相对于当前页面的坐标，页面左上角的坐标才是(0, 0)，不兼容IE8；
2. 页面垂直滚动时，scrollTop的兼容性：获取页面滚动的距离；
    1. document.body.scrollTop：只适用于Chrome浏览器，其他浏览器返回0；
    2. document.documentElement.scrollTop：适用于Foxfire、IE，但Chrome仍返回0；
    3. 水平方向滚动时，scrollLeft同理。
3. 事件冒泡：如果父节点和子节点绑定了相同的事件，那么触发子节点事件时，父节点也会触发；
    1. 事件只会向上传递父节点的相同事件，不会向下传递；
    2. 阻止事件冒泡：event.stopPropagation(); --&gt; 不兼容IE
    3. IE浏览器特有的阻止事件冒泡：window.event.cancelBubble = true;
4. 事件委托：多个子元素需要注册同一种事件时，给其共同的父元素注册该事件，事件响应时，通过
   回调参数event获取每个子元素，根据不同的子元素，执行不同的代码；
    &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;超链接一&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;超链接二&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;
    var uls = document.getElementsByTagName(&quot;ul&quot;)[0];
    uls.onclick = function(event) {
        event = event || window.event; --&gt; 兼容IE
        var node = event.target; --&gt; 获取当前点击的子元素节点对象
    };
    1. event.currentTarget 与 event.target：
    2. click事件实际注册到&lt;ul&gt;标签上，event.target获取的是实际点击标签的元素对象；
    点击&lt;li&gt;，则event.target就是&lt;li&gt;对象，点击&lt;a&gt;，则event.target就是&lt;a&gt;对象；
    3. event.currentTarget获取的是实际注册click事件的元素对象，点击&lt;a&gt;、&lt;li&gt;、&lt;ul&gt;，
    event.currentTarget都是&lt;ul&gt;对象。
5. 函数节流：
    1. JS中有些事件的触发频率特别高，比如：onresize，onmousemove
    2. 对于短时间内高频率触发的函数，可以在函数内使用定时器减少触发次数，实现函数节流；
    3. 在触发定时器之前，先清除一次定时器，只保留最后一次定时器任务；
    clearTimeout(timer); timer = setTimeout(function{ ... }, 200);
4. addEventListener(&quot;事件名&quot;, function, false)：事件绑定，事件名不带&quot;on&quot;；
    1. element.onclick=function(event){}; -&gt;属性的方式绑定事件，多次绑定同一事件时，
    最后一次绑定会覆盖之前的事件；
    2. addEventListener()可以重复绑定同一事件，响应事件时，从第一次绑定时开始响应；
    uls.addEventListener(&apos;click&apos;, function(){}, false); --&gt; 绑定click事件
    3. removeEventListener(&apos;事件名&apos;, callback)：移除绑定的事件，callback并不是移除
    事件的回调，而是addEventListener()的回调函数名，因为它可以对同一事件绑定多次；
    4. addEventListener()只兼容到IE9，而在IE8中，绑定事件使用attachEvent()
    5. attachEvent(&quot;事件名&quot;, function)：事件名中带&quot;on&quot;，也可以多次绑定同一个事件，
    但事件的响应顺序与addEventListener()相反；
    6. addEventListener()中的this指向绑定事件的对象，而attachEvent()中指向window；
    7. 兼容性：
    function bind(obj, event, callback) {
        if(obj.addEventListener) {
            obj.addEventListener(event, callback, false);
        } else {
            obj.attachEvent(&quot;on&quot;+event, function() {
                callback.call(obj);  --&gt; 让回调函数中的this指向绑定的对象
            });
        }
    }
5. 事件的传播：
    1. 微软公司认为事件应该从内向外，即事件冒泡的形式；而网景公司认为恰恰相反；
    2. W3C综合两种方案，将事件传播分为3个阶段：捕获阶段、目标阶段、冒泡阶段
    3. 捕获阶段：事件从最外层的父元素，向目标子元素进行事件的捕获，但默认此时不会触发事件；
    4. 目标阶段：事件捕获到目标元素，捕获结束，开始在目标元素上触发事件；
    5. 冒泡阶段：事件从目标元素向父元素传递，并依次触发父元素上的事件；
    6. 在捕获阶段也触发事件：addEventListener(&quot;事件名&quot;, function, true)
    7. IE&lt;=8没有事件捕获阶段。
6. 鼠标按下/移动/松开：onmousedown、onmousemove、onmouseup
    1. 拖拽网页中的内容时，浏览器默认会执行搜索内容，导致拖拽功能异常；
    2. return false; --&gt; 禁止默认行为，但不兼容IE8
    3. element.setCapture(); --&gt; 捕获element绑定的相关事件，优先响应；
    4. element.releaseCapture(); --&gt; 释放捕获；
    5. 但是，setCapture()只有IE支持，Firefox不会报错，Chrome会报错；
    element.setCapture &amp;&amp; element.setCapture(); --&gt; 有setCapture()方法，则执行
6. 鼠标拖拽标签：
    element.onmousedown = function(e){ --&gt; 给被拖拽的标签注册鼠标的按下事件
        if (event.button != 0) return; --&gt; 只有鼠标左键按下才有效
        element.setCapture&amp;&amp;element.setCapture() --&gt; 兼容IE
        document.onmousemove = function(e){ --&gt;把移动事件注册到document上，防止卡顿
            ...... ----------------&gt; 更改标签的left/top，达到移动效果
            e.preventDefault(); ---&gt; 阻止浏览器的默认行为
        }
        document.onmouseup = function(e){ --&gt;抬起事件也必须注册到document上，任何地方
            document.onmousemove = null; ----&gt; 都可以取消事件
            document.onmouseup = null;
            document.releaseCapture&amp;&amp;document.releaseCapture(); --&gt; 兼容IE
        }
        //屏蔽第二次拖拽时的鬼影，return false 无效
        event.preventDefault();
        event.stopPropagation();
    }
7. 鼠标滚轮：onmousewheel，但Firefox不支持，而是使用DOMMouseScroll，而且火狐必须通过
   addEventListener()绑定滚轮事件；
    1. event.wheelDelta：鼠标滚轮滚动的方向，只看正负，不管大小，负值表示向下滚动；
    2. FireFox也不支持event.wheelDelta，而是使用event.detail，正数表示向下滚；
    3. 如果浏览器有滚动条，滚动鼠标滚轮将执行浏览器的默认行为，而不会执行元素的滚轮事件；
    element.onmousewheel=function(event){
        return false; --&gt; 阻止浏览器的默认行为，执行元素的滚轮事件；
    };
    element.addEventListener(&quot;DOMMouseScroll&quot;, function(event){
        event.preventDefault &amp;&amp; event.preventDefault(); --&gt; 阻止浏览器的默认行为
    }, false);
    4. &quot;return false;&quot;在addEventListener()注册的事件中，无法阻止浏览器的默认行为，必须
    使用tevent.preventDefault();
8. 鼠标右击事件：oncontextmenu
9. 键盘事件：onkeydown(按下)、onkeyup(松开)、onkeypress(按下并松开)
    1. 键盘事件一般绑定给可以获取焦点的元素对象，或者document，比如&lt;input /&gt;输入框；
    2. 对于onkeydown，如果长时间按下一个按键，那么事件将一直触发，而且第一次和第二次
    触发的时间间隔会比第二次之后的时间间隔长一些，为了避免误操作；
    3. event.KeyCode：获取按键的编码，从而判断按键的类型，如y=89
    4. altKey、ctrlKey、shiftKey：判断Alt、Ctrl、Shift键是否被按下；
    event.keyCode===89 &amp;&amp; event.ctrlKey --&gt; Ctrl+y
    5. &lt;input /&gt;的onkeydown事件默认行为就是输入内容，&quot;return false;&quot;可以阻止输入。
9. 阻止默认行为：return false; 与 event.preventDefault();
    1. 在jQuery中，return false;相当于同时调用preventDefault()和stopPropagation()；
    2. IE不支持preventDefault()，需要使用：window.event.returnValue = false;
    3. 在原生JS中，addEventListener()/attachEvent()绑定的事件中，不支持return false
    阻止默认行为，必须使用preventDefault()、window.event.returnValue=false
    4. H5规范指出，在mouseover等几种特殊事件中，return false; 并不一定能终止事件，所以
    H5建议尽量不要使用return false来阻止事件的默认行为。
</code></pre><h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><pre><code>BOM：浏览器对象模型，可以让我们通过JS来操作浏览器；
1. BOM对象：Window、Navigator、Location、History、Screen
    1. Window：代表整个浏览器窗口，同时，window也是网页中的全局对象；
    2. Navigator：表示当前浏览器的信息，可以用来识别不同的浏览器；
    3. Location：浏览器的地址栏，可以获取地址栏信息，操作浏览器跳转页面；
    4. History：表示浏览器的历史纪录，但由于隐私原因，不能获取到具体的历史纪录，只能操作
    浏览器向前/后退，而且只在当次访问时有效，关闭之后再打开则无效；
    5. Screen：表示拥护的屏幕信息，可以获取显示器的相关信息，常用于移动端；
    6. 这些BOM对象在浏览器中都是作为window对象的属性保存的，又因为window是全局的对象，
    可以直接使用这些对象，而不用通过window.navigator调用；
2. Navigator
    1. 由于历史原因，navigator对象中的大部分属性都已经不能识别浏览器了；
    2. 一般只会使用userAgent来判断浏览器的信息：navigator.userAgent
    3. IE11中的userAgent已经去除了微软和IE的相关标识，不能通过userAgent来准确识别IE；
    4. window.ActiveXObject：IE特有的函数，根据这些特有的信息获取浏览器的类型；
    if(window.ActiveXObject) --&gt; 微软发现了这种判断方式，所以在IE11返回的是false
    但并不意味着IE11中没有该对象：if(&quot;ActiveXObject&quot; in window) --&gt; true
3. History
    1. length：浏览器历史列表中的URL数量；
    2. back()/forward()：加载前/下一个，回退/前进一个页面；
    3. go()：加载某个具体页面，go(1)相当于forward()，go(-1)相当于back()；
4. Location
    1. location可以获取地址栏的完成信息，也可以直接操作地址栏，同window.location
    2. 属性：hash、host、hostname、href、pathname、port、protocol、search
    5. location.href = &quot;https://www.baidu.com/&quot;：重定向到一个新的网站，会生成历史纪录
    6. location = &quot;/login/login.html&quot;：重定向到新的页面，当前域名/login/login.html
    1. window.location.search：获取地址的参数部分，?...
    2. window.location.hash：获取页面的锚点，#...
    1. assign()：加载新的文档，assign(&quot;https://www.baidu.com/&quot;)
    2. reload()：刷新，默认刷新带有缓存，reload(true)：强制清空缓存刷新
    3. replace()：用新的文档替换当前文档，不会生成历史纪录，即不能回退。
5. window.open()：开启一个新的窗口，加载文档
</code></pre><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><pre><code>setTimeout()、setInterval()、clearTimeout()、clearInterval()
1. 延迟任务：
    1. setTimeout(function, time)：time毫秒之后执行function，返回Number型的数据；
    2. clearTimeout(timer)：即使timer是undefined，也不会报错，什么也不做；
2. 定时任务
    1. setInterval(function, time)：每隔time毫秒执行一次function；
    2. clearInterval(timer)：清除定时器；
</code></pre><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><pre><code>1. JSON：JavaScript Object Notation，JS对象表示法
    1. JSON和JS对象的格式一样，只不过JSON字符串中的属性名必须加双引号；
    var str = &apos;{&quot;name&quot;: &quot;Mack&quot;, &quot;age&quot;: 18}&apos;;
    3. JSON类型：对象{}，数组[]
    4. JSON中允许的属性值：字符串、数值、布尔值、null、对象、数组
2. JSON字符串与JS对象相互转换：JSON
    1. JSON.parse(str)：JSON字符串转JS对象；
    2. JSON.stringify(obj)：JS对象转JSON字符串；
    3. IE7不支持JSON，可以使用eval(str)函数，将一个字符串转为有效的表达式；
    var obj = eval(&quot;(&quot; + str +&quot;)&quot;); --&gt;对字符串加&quot;()&quot;，告诉浏览器{}不是一个代码块；
    ==&gt; obj = {&quot;name&quot;: &quot;Mack&quot;, &quot;age&quot;: 18}
    4. 但是，eval()的性能比较低，而且存在安全隐患，转换的字符串可能是一段有害的JS代码.
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/06/01/JS-基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/01/JS-基础/" itemprop="url">JS-基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-01T00:00:00+08:00">
                2018-06-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JS基础"><a href="#JS基础" class="headerlink" title="JS基础"></a>JS基础</h2><pre><code>1. JS的特点：解释型语言、类似于C和Java的语法结构、动态语言、基于原型的面向对象；
2. document.write(str)：向body中写字符串文本；
3. console.log()：适用于所有浏览器；
4. 三种引入方式：
    1. 行间事件：&lt;input type=&quot;button&quot; name=&quot;&quot; onclick=&quot;alert(&apos;ok!&apos;);&quot; /&gt;
    2. 嵌入式：&lt;script type=&quot;text/javascript&quot;&gt; JS语句 &lt;script /&gt;
    3. 外链式：&lt;script src=&quot;js/set_root.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
    4. 外链式的标签内不能再写JS代码，是无效的，需要再添加一个&lt;script&gt;
5. JS代码可以编写在标签的onclick属性中，也可以写在&lt;a&gt;的href属性中；
    1. &lt;button onclick=&quot;alert(&apos;点击button&apos;);&quot;&gt;
    2. &lt;a href=&quot;javascript:alert(&apos;点击a&apos;);&quot;&gt;
    3. &lt;a href=&quot;javascript:;&quot;&gt; --&gt; 让超链接失效
6. JS一共有6种数据类型：
    1. 基本数据类型：string、number、boolean、null、undefined
    2. 引用数据类型：object
    3. typeof(var)：检查变量的类型，typeof(null) --&gt;object
    在JS的最初版本中，使用的是32位系统，出于性能考虑，使用低位存储变量的类型信息，000开头
    表示对象，而null表示为全0，所以会将null错误地判断为object，虽然现在内部类型判断的代码
    已经改变了，但这个JS的历史BUG却流传了下来。
    4. 数字的最大值：Number.MAX_VALUE，如果超过了最大值，则返回正无穷：Infinity
    5. NaN：not a number，一个特殊的Number类型；
    6. 数字的最小值：Number.MIN_VALUE
    7. 当声明一个变量，但并没有赋值时，该变量值就是undefined
    8. JS的浮点数运算可能得到一个不精确的结果，比如0.1+0.2=0.300···04
8. 类型转换：string、number、boolean
    1. var b = a.toString()：将a转为string，但不会影响a的数据类型，返回一个转换后的值，
    且null和undefined并没有toString()方法；
    2. b = String(a)：可以把任意类型的数据转为string，但也不会影响a的数据类型；
    3. 对于number和boolean，String()的底层仍然时调用toString()，而null和undefined直接
    转为&quot;null&quot;和&quot;undefined&quot;；
    4. Number(x)：将x转为number，如果x不是纯数字的字符串，则返回NaN；对于空字符串和纯空格
    的字符串，则返回0；
    5. Number(true/false/null)：true转为1，false和null转为0，undefined转为NaN；
    6. parseInt(s)/parseFloat(s)：把字符串转为整数/浮点数，都是针对字符串的函数，如果接收
    的不是字符串，则会先转为字符串，再尝试转为number
    7. parseInt(&quot;12ab&quot;) --&gt; 12，parseInt(&quot;ab12&quot;) --&gt; NaN，
    8. parseFloat(&quot;12.45.78ab&quot;)：12.45，只取有效的浮点数；
    9. Boolean(x)：0、NaN、空字符串、null、undefined都转为false，其它都转为true。
9. 十六/八/二进制数字以&quot;0x&quot;/&quot;0&quot;/&quot;0b&quot;开头，但在输出时仍以十进制输出；
    1. 不是所有浏览器都支持二进制数字，比如低版本的IE会报错；
    2. 八进制数的字符串在转为数字时，有些浏览器会当成十进制解析：parseInt(&quot;070&quot;)-&gt;70，
    3. parseInt()可以在第二个参数指定解析的基数，parseInt(&quot;070&quot;, 8)-&gt;56
</code></pre><h2 id="JS运算"><a href="#JS运算" class="headerlink" title="JS运算"></a>JS运算</h2><pre><code>1. 对于非number做运算时，都会先转为number，再做运算；
    1. true+false=1，2+null=2，但任何值和NaN做运算，结果都为NaN，2*undefined=NaN；
    2. 任何值和字符串做加法运算，都是在拼接字符串，而其他运算则会把字符串转为number；
    3. 任何值和空字符串做加法运算时，其底层其实是调用String(x)；
    4. &quot;12&quot;-0，&quot;12&quot;*1，&quot;12&quot;/1，其底层其实是调用Number(x)；
    5. 负号/正号的运算：+&quot;18&quot; =&gt; 18，-true =&gt; -1，1+ +&quot;2&quot;+3 =&gt; 1+2+3=6
2. 自增/自减：d=20
    1. d++ + ++d + d ==&gt; 20+22+22
    2. d = d++ ==&gt; var e=d++; d=e; ==&gt; d=20
3. 逻辑运算：&amp;&amp;、||、!
    1. !!x：如果x不是boolean，两次对x取反，其原理与Boolean(x)一样；
    2. &amp;&amp;/||都是短路的，一旦左边是成立的，则不会检查右边；
    3. 对非boolean参与的逻辑运算，会先转为boolean，但返回的结果仍是原值；
    4. 2&amp;&amp;3=&gt;3，true&amp;&amp;2=&gt;2，2&amp;&amp;true=&gt;true，0&amp;&amp;3=&gt;0，false&amp;&amp;0=&gt;false
    5. 单独使用&quot;&amp;&amp;&quot;时，如果左边是true，则返回右边的值；反之，则返回左边的值；
    6. 单独使用&quot;||&quot;时，如果左边是true，则返回左边的值；反之，则返回右边的值。
4. 比较运算：任何值和NaN做比较运算，结果都为false；
    1. 对于非number的比较，会将其转为number，然后比较：true&gt;false =&gt; 1&gt;0 =&gt; true
    2. 1&gt;&quot;0&quot; ==&gt; 1&gt;0 ==&gt; true，1&gt;&quot;hello&quot; ==&gt; 1&gt;NaN ==&gt; false
    3. 如果两边都是字符串，则比较Unicode编码，一位一位地比较，一旦两位不同，则停止比较，
    得出结果；如果前面的每一位都相同，但其中一方没有下一位，则位数更多的一方更大；
    4. 如果两边都是number型的字符串，会得到不可预期的结果，所以一定要转型为number比较；
    5. 对于&quot;==&quot;，大部分情况下会将两边的类型都转为number，然后再去比较；
    true==&quot;1&quot; --&gt; 1==1 --&gt; true，true==&quot;hello&quot; --&gt; 1==NaN --&gt; false
    6. 但是，null==0 --&gt; false，null并没有转为0；
    7. 而undefined衍生自null，undefined==null --&gt; true
    8. NaN不和任何值相等，包括它自己，判断一个值是不是NaN，使用函数：isNaN(x)
    9. ===/!==：不会做类型转换，&quot;123&quot;===123 -&gt; false，null===undefined -&gt; false
5. &quot;\u0000&quot;：&quot;\u&quot;和4位编码组合，表示Unicode编码输出，这4位编码是十六进制；
    1. 在标签中使用Unicode编码：&amp;#编码; ==&gt; 该编码是十进制，由Unicode的编码转换而来；
    2. &quot;\u2620&quot;等效于&amp;#9760; ==&gt; &lt;h1&gt;&amp;#9760;&lt;/h1&gt;
</code></pre><h2 id="JS代码块"><a href="#JS代码块" class="headerlink" title="JS代码块"></a>JS代码块</h2><pre><code>1. prompt(str)：弹出一个带有输入框的提示框，返回值也就是输入的内容；
2. switch(true)：JS的switch语句可以接收boolean，case是比较运算的表达式；
3. 计算一段代码执行的时间，性能测试：
    1. console.time(&quot;计时器的名字&quot;)：开启一个计时器；
    2. console.timeEnd(&quot;计时器的名字&quot;)：结束计时器，打印执行代码消耗的时间；
4.  JS函数
    1. var fun = new Function(); --&gt; 创建一个空的函数对象，函数语句则以字符串的形式传递
    给构造函数：var fun = new Function(&quot;console.log(&apos;Hello JS&apos;);&quot;)
    2. 函数声明的方式创建一个函数：function 函数名() { ... }
    3. 没有显式return的函数，默认返回undefined，即return undefined;
    4. 匿名函数：var fun = function() { ... }
    function() {...} --&gt;直接定义匿名函数会抛出异常，编译器会认为{...}是一个独立的代码块，
    与function()是两部分；
    (function() { ... }) --&gt; 告诉编译器这是一个整体，但无法调用这个匿名函数
    (function() { ... })(); -- &gt; 直接调用匿名函数，并立即执行；
5. 全局作用域：页面打开时创建，页面关闭时销毁；
    1. &lt;script&gt; ... &lt;/script&gt;：标签内的JS代码，都在全局作用域中；
    2. 全局作用域中有一个全局对象window，代表一个浏览器窗口，由浏览器创建，可以直接使用；
    3. 在全局作用域中，创建的变量都会作为window对象的属性保存，创建的函数都会作为window
    对象的方法保存：var n=10; window.n --&gt; 通过window也可以调用；
    4. 变量的声明提前：var声明的变量，会在代码执行之前被声明，如果没有用var，则不会提前；
    console.log(a); var a = 10; --&gt; 打印&quot;undefined&quot;，因为只是声明提前，赋值并没有；
    5. 函数定义的提前：function fun() {} 会在代码执行之前提前被创建；
    6. var fun = function(){}; --&gt; 这是一个函数表达式，fun被认为是一个变量。
6. 函数作用域：调用函数时创建函数作用域，函数执行完毕后，函数作用域自动销毁；
    1. 函数作用域可以视为一个小的全局作用域，var声明的变量也会被提前声明，函数中定义的函数
    也会被提前创建；
    2. 函数中没有使用var声明的变量，会被声明为全局变量；
    3. 形参就相当于在函数中声明了变量，默认值为undefined
7. Array：数组也是一个对象，它是通过角标操作元素；
1. 创建数组：var arr=new Array();  var arr=[]; --&gt; 数组元素的类型没有限制
    1. arr[0]=10; --&gt; 添加元素
    2. arr[8]=30; --&gt; arr[1]到arr[7]只是占位作用，默认为undefined
    3. arr.length：获取数组长度，直接为arr.length赋值，则会修改数组的长度；
    4. new Array(1,3)：创建一个包含2个元素的数组，new Array(5)：创建一个长度为5的数组。
2. 数组的常用方法：
    1. push/unshift(arg1, arg2, ...)：向数组的末尾/开头添加元素，并返回新的数组长度；
    2. pop/shift()：删除数组的最后一个/第一个元素，并返回该元素；
    3. slice(start, end)：截取数组的一部分并返回，原数组不变；
    4. splice(start, count, ...)：从start的位置开始，删除数组的一部分，返回删除的元素；
    count表示删除的个数，count后的参数表示在start位置添加的元素，count为0表示不删除元素
    5. concat()：连接数组，concat()可以接收数组，也可以直接接收元素，返回一个新的数组；
    6. join(str)：将数组元素转为一个字符串并返回，var arr=[1, 2, 3]
    arr.join() =&gt;&quot;1,2,3&quot;=&gt;默认使用&quot;,&quot;连接，arr.join(&quot;&quot;) --&gt; &quot;123&quot;
    7. reverse()：反转数组元素的位置，直接影响原数组；
    8. sort()：默认按照Unicode编码排序，包括数字；sort()可以接收一个函数，指定排序方式；
    该函数回调两个参数，表示数组的两个元素，返回大于0的值，则交换两个元素的位置，反之不变，
    返回0表示两个值相等，位置也不变。
    9. 反转字符串：str.split(&apos;&apos;).reverse().join(&apos;&apos;);
3. forEach：ES6新特性，用于遍历数组
    1. arr.forEach(function(item, index) { ... })：item表示数组元素，index表示角标
    2. Array.prototype.forEach.call(arr, function(item, index) { ... })
    3. 相比于for循环，forEach中不能使用break、continue、return，且forEach不兼容&lt;=IE8
4. 字符串操作
    1. 在底层存储时，字符串仍是数组的形式，每个字符作为一个元素；
    2. str.length：字符串长度，同时，字符串也可以使用角标获取字符；
    3. str.charAt(i)/charCodeAt(i)：根据角标获取字符，后者返回字符的Unicode编码；
    4. str.indexOf(c, i)：根据字符获取角标，参数2表示起始位置，默认为0；
    5. substring(start, end)/slice()：slice()的end可以接收负值，-1表示最后一个字符；
    而substring()的end为负值时，默认仍是0，且如果start小于end，会自动交换位置；
    6. substr(start, count)：也可以截取字符串，count表示截取的数量，但不属于ES标准；
    7. str.split(s)：根据指定的字串，拆分字符串，返回一个数组，split(&apos;&apos;)会拆分所有字符；
</code></pre><h2 id="JS对象"><a href="#JS对象" class="headerlink" title="JS对象"></a>JS对象</h2><pre><code>JS对象：内建对象、宿主对象、自定义对象
1. 内建对象由ES标准定义，如String、Number、Boolean、Math、Date、Function、Object
2. 宿主对象是由JS运行环境提供的对象，比如浏览器提供的对象有BOM、DOM
3. console、document都是浏览器提供的对象；
4. 使用new调用的函数，是构造函数constructor，构造函数是专门用来创建对象的函数；
    var obj = new Object(); --&gt; 创建对象
    1. 添加属性/方法：obj.name = &quot;Jack&quot;; obj.show = function(){ ... }
    2. 访问对象属性的方式：obj.name，obj[&quot;name&quot;] --&gt; 后者才更通用；
    3. 方法也可以视为属性，也可以使用&quot;[]&quot;访问：obj[&quot;show&quot;]() --&gt; 调用方法
    4. 删除对象的属性：deltele obj.name/obj[&quot;name&quot;];
1. 对象属性名不强制遵守变量标识符的规范，但对于特殊的属性名，必须使用&quot;[]&quot;去操作；
    obj[&quot;123&quot;] = 678 --&gt; 而且，[]可以接收变量，var n=&quot;123&quot;，obj[n] -&gt; 678
2. 对象的属性值可以是任意的数据类型，包括对象object；
3. var obj = { 属性名: 属性值, ... }; =&gt; 创建一个对象，一般属性名可以不显式使用字符串，
   但对于特殊的属性名，必须显示使用字符串，如&quot;123&quot;: 45
4. this：函数被调用时，会向函数内部传递一个隐含的参数this，它指向函数执行的上下文对象；
    1. 以函数的形式调用函数时，this始终指向window对象；
    function test(){ console.log(this) }
    test(); --&gt; Window
    2. 以方法的形式调用时，this指向调用的对象：obj.show() --&gt; this指向Object obj
5. 构造函数
    1. 构造函数与普通函数的定义方式一样，不同的时，构造函数需要使用new关键字来调用；
    function Persion() {} --&gt; 构造函数名的首字母通常大写，称为类
    var p = new Persion(); --&gt; 创建一个新的对象/实例，并执行函数中的代码
    2. new 函数的执行：创建一个新的对象 --&gt; 将新建的对象设置为函数中的this，在函数中
    可以使用this来引用新建的对象 --&gt; 逐行执行函数中的代码 --&gt; 将新建的对象作为返回值
    3. 使用this为构造函数添加成员：function Persion(){ this.name=&quot;Huck&quot;; }
    4. instanceof：检查一个对象是否属于一个类的实例：p instanceof Persion --&gt; true
    5. Object是JS的顶层父类，任何类都是派生自Object
    6. p.toString = function() { ... }; --&gt; 重写对象的toString()方法
6. 包装类：String、Number、Boolean
    1. String()：可以将基本数据类型字符串转为String对象；
    2. 同理，Number()将数字转为Number对象，Boolean将布尔值转为Boolean对象；
    var n=123;
    n.name=&quot;Mac&quot;; --&gt;临时把n转为对象，但执行完后会立即销毁，n仍是基本数据类型；
    console.log(n.name); =&gt;undefined，再一次把n转为对象，但该对象并没有name属性
7. for-in 与 for-of
    1. for-in 是ES5新特性，本用于遍历对象，但不适合遍历数组，因为数组的key就是角标；
    2. for-of 属于ES6，用于弥补 for-in 的缺陷，只能遍历可迭代对象，如数组、字符串、Set、
    Map、arguments... 但不能遍历普通对象，因为普通对象不具备Iterator接口；
    3. Object.keys(obj)可以获取对象的所有key，间接遍历普通对象
    for(let key of Object.keys(obj)) { var value = obj[key] }
1. call()、apply()：由函数对象调用的方法，用于修改函数内的this指向；
    1. 参数1都是this指向的上下文对象，不同的是，如果函数对象需要传递参数，call()是在第一个
    参数后依次传递，而apply()则会把参数封装成数组，作为第二个参数进行传递；
    2. function test(a, b) {} =&gt; test.call(obj1, a, b)，test.apply(obj2, [a, b])
2. arguments：也是浏览器在调用函数时传递的隐含参数，用于封装传递的所有实参；
    1. arguments是一个类数组对象，并不是真的数组，Array.isArray(arguments) =&gt; false
    2. arguments.length =&gt;长度； arguments[0] =&gt;角标操作； 
    3. arguments.callee：当前正在执行的函数对象；
</code></pre><h3 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h3><pre><code>1. 创建的每一个函数，解析器都会向函数中添加一个属性prototype
2. prototype属性对应一个对象，这个对象就是所谓的原型对象；
3. 如果函数作为普通函数调用prototype，不会有任何作用；如果以构造函数的形式调用函数，它所
   创建的对象中都会有一个隐含的属性__proto__，指向该构造函数的原型对象；
    function Persion() { ... }
    var p = new Persion();
    p.__proto__ == Persion.prototype --&gt; true
4. 原型对象就相当于一个公共的区域，同一个类的所有实例都可以访问到这个原型对象，所以，可以将
   对象中的共有内容，统一设置到原型对象中，节约开销，提高性能，不会污染全局作用域；
    1. 当访问对象的属性/方法时，会先在对象自身查找，如果没有，则会去原型对象中查找；
    Persion.prototype.name=&quot;Mark&quot;;  p.name; --&gt;&quot;Mark&quot;
    2. 在创建构造函数时，可以将对象共有的属性/方法，统一添加到函数的原型对象中。
5. prop in obj：检查对象obj是否有属性prop，如果对象中没有、而原型对象中有，也会返回true；
6. obj.hasOwnProperty(prop)：只检查对象自身中是否有某个属性；
7. 原型对象中也有原型属性__proto__，但Object的原型对象中没有原型；
8. 原型链：p.__proto__.__proto__
    1. 访问对象的属性/方法时，如果当前对象中没有，则查找该对象指向的原型对象；
    2. 如果原型对象仍没有，则继续查找该原型对象指向的原型对象，一直查找到Object指向的原型
    对象，如果仍没有，则返回undefined
</code></pre><h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><pre><code>当一个对象没有被任何变量/属性所引用，GC将自动从内存中回收该对象；
var obj=new Object(); obj=null; --&gt; GC将回收该对象
</code></pre><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><pre><code>1. var reg=new RegExp(&quot;pattern&quot;, &quot;mode&quot;);  var reg=/pattern/mode;
    1. pattern：正则表达式； mode：匹配模式，i=&gt;忽略大小写，g=&gt;全文匹配；
    2. 模式m：多行搜索，更改^和$的含义，分别在任意一行都匹配行首和行尾，而不仅只在整个
    字符串的开头和结尾才匹配；
    3. reg.test(str)：匹配成功，则返回true
2. String对象中支持正则表达式的方法：
    1. match(reg)：默认只匹配第一个，match(/[a-z]/g)：全文匹配；
    2. search(reg)：返回第一次匹配的索引，设置全局匹配也无效，如果不存在，则返回-1；
    3. replace(reg, newStr)：默认也只替换第一个，需要设置全局匹配；
    4. split(reg)：默认时全局匹配；
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/05/13/HTML5-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/13/HTML5-2/" itemprop="url">HTML5-2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-13T00:00:00+08:00">
                2018-05-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML/" itemprop="url" rel="index">
                    <span itemprop="name">HTML</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><h2 id="音视频标签"><a href="#音视频标签" class="headerlink" title="音视频标签"></a>音视频标签</h2><pre><code>1. H5之前对音视频没有一个标准，在网页中的音视频都是通过第三方插件的方式嵌入的；
2. 视频：&lt;video src=&quot;video/test.mp4&quot; controls width=&quot;500&quot; height=&quot;500&quot;&gt;
    1. controls：布尔值属性，显示/隐藏控制播放的控件，但不同浏览器上渲染的样式不同；
    2. src还可以加载网络视频资源：src=&quot;http://······&quot;
    3. poster：一个海报帧(图片)的地址，用于在用户播放或跳帧之前的展示；
    4. autoplay/loop/muted：是否自动播放/循环/静音；
    5. preload：none(告诉浏览器不要预加载该视频，点击播放时再加载)，metada(只抓取该视频的
    元数据，如长度、海报帧等，并显示给用户，但不会预加载该视频)，auto(预加载该视频)
    6. preload: &quot;&quot;; --&gt; 等效于 preload: auto;
    7. 这些都是attribute属性
    8. property属性：
3. 音频：&lt;audio src=&quot;res/test.mp3&quot; controls&gt;
    1. attribute属性：src、controls、autoplay、loop、muted、preload
    2. 对音视频标签支持最好的是FireFox；
    3. property属性：
4. 容器
    1. 实际上，.avi、.mp4并不是视频文件本身，而是容器的格式，它只是决定了视频存储的方式，
    而不关心存储的内容，类似于.zip
    2. 视频容器包含音频轨道、视频轨道和其他一些元数据，视频播放时，音频轨道和视频轨道是绑定
    在一起的，元数据包含了视频的封面、标题、子标题、字幕等相关信息；
    3. 主流容器格式(视频文件格式)：MPEG-4(以.mp4为扩展名)，Flash视频(.flv)，Ogg(.ogv)，
    WebM(.webm)，音频视频交错(.avi)
    4. 主流音频文件格式：MPEG-3(.mp3)，Acc音频(.acc)，Ogg音频(.ogg)
5. 编解码器
    1. 音频和视频的编码/解码是一组算法，用来对一段特定音频/视频进行解码和编码，使音频和视频
    能够播放；
    2. 原始的媒体文件体积非常巨大，如果不编码，数据量很大，在互联网上传输也会消耗大量时间；
    如果不解码，也无法将编码后的数据重组为原始的媒体数据；
    3. 视频编解码器：H.264(又称为MPEG-4的第十部份)、VP8、Ogg Theora
    4. 音频编解码器：ACC、MPEG-3、Ogg Vorbis
    5. 编解码器的配置分为基本配置、主配置、高级配置，手机上支持基本配置，电视机上支持基本配置
    和主配置，电脑上支持三种配置；
    6. 目前还没有一种编解码器和容器的组合能够适配所有浏览器，因此要对视频做格式转化；
    7. 音视频的格式转化工具：FFmpeg
6. 音视频的兼容模式
    1. &lt;video&gt;可以包裹&lt;source&gt;，提供不同格式的视频，不支持视频标签，则提供视频的下载链接；
    &lt;video width=&quot;800&quot; height=&quot;800&quot; controls&gt;
        &lt;source src=&quot;res/test.mp4&quot; type=&quot;video/mp4&quot;&gt;&lt;/source&gt;
        &lt;source src=&quot;res/test.ogv&quot; type=&quot;video/ogg&quot;&gt;&lt;/source&gt;
        &lt;source src=&quot;res/test.webm&quot; type=&quot;video/webm&quot;&gt;&lt;/source&gt;
        当前浏览器不支持video直接播放，点击下载：&lt;a href=&quot;res/test.mp4&quot;&gt;下载视频&lt;/a&gt;
    &lt;/video&gt;
    2. 浏览器通过检查&lt;source&gt;的type属性，查找所支持的视频格式，达到浏览器的兼容效果；
    3. 同理，&lt;audio&gt;也可以包裹&lt;source&gt;，提供不同格式的音频。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/05/12/HTML5-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/12/HTML5-1/" itemprop="url">HTML5-1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-12T00:00:00+08:00">
                2018-05-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML/" itemprop="url" rel="index">
                    <span itemprop="name">HTML</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><pre><code>1. HTML5：HTML标准的的最新版本，是一个更大的技术集，具有新的元素、属性、行为；
2. 跨平台：H5本身并不能跨平台，但浏览器是跨平台的，如Java语言不跨平台，但JVM是跨平台的；
3. HTML运行在浏览器上，是唯一可以通吃PC、MAC、iPhone、Android、Linux等主流平台的语言。
</code></pre><h3 id="H5与H4"><a href="#H5与H4" class="headerlink" title="H5与H4"></a>H5与H4</h3><pre><code>1. &lt;meta charset=&quot;UTF-8&quot;&gt;：告诉浏览器以utf-8渲染当前的html文档；
2. DOCTYPE
    1. DOCTYPE：Document Type Declaration，文档类型声明，简称DTD
    2. 通常情况下，DOCTYPE在HTML文档的首行位置，因为浏览器在解析HTML正文之前，必须确定
    当前文档的类型，再决定需要采用的渲染模式；
    3. 不同的渲染模式会影响浏览器对于CSS、JS的解析。
3. 浏览器的渲染模式
    1. 目前为止，浏览器主要包括三种渲染模式，在H5草案中规定了模式的定义；
    2. 现代主流浏览器，包括IE9以上的浏览器，三种模式在渲染方面几乎没有区别；
    3. IE7/8/9理论上存在怪异模式，但实际上只有标准模式；
    4. 在IE6中，标准模式和怪异模式的差别最大，而IE6以下的浏览器只有怪异模式。
4. document.compatMode：查看当前的渲染模式，返回两个值CSS1Compat、BackCompat
    1. 标准兼容模式：CSS1Compat，怪异模式：BackCompat
    2. H5文件的首行声明：&lt;!DOCTYPE html&gt; ==&gt;&gt;表示开启标准模式，必须放在首行才有效
    3. 如果不声明&lt;!DOCTYPE html&gt;，或者&lt;!DOCTYPE html&gt;的位置不正确，则开启怪异模式。
5. H4的声明、根标签、META
    &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; ······&gt;
    &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;&quot; charset=&quot;UTF-8&quot; /&gt;
    1. xmlns：XHTML1.0的概念，声明命名空间，而H5中的每个元素都具有此空间，不需要声明；
    2. H5中已经简化了根标签的声明：&lt;html&gt;&lt;/html&gt;
    3. META类型：Content-Type:text/html; 在网络传输声明当前数据类型为html；
    4. 在H5中，Content-Type的声明已经被移植到HTTP中，不需要在&lt;meta /&gt;上声明。
</code></pre><h3 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h3><pre><code>1. 常用的H5语义化标签：&lt;hgroup&gt;、&lt;header&gt;、&lt;nav&gt;、&lt;section&gt;、&lt;footer&gt;、&lt;article&gt;...
    1. 各大浏览器厂商在分析了大量的页面之后，发现&lt;div&gt;的id名称大量重复，如id=&quot;footer&quot;
    标记页脚内容，所以引入了语义化标签；
    2. 这些语义化标签其实也是&lt;div&gt;，它们也没有任何默认样式，除了会让文本另起一行之外；
    3. HTML5通过这些语义化、结构化的代码标签，代替无意义的&lt;div&gt;，提升了网页的质量和语义，
    对搜索引擎也更加友好。
2. 测试H5文档的语义化站点：https://gsnedders.html5.org/outliner/
3. &lt;hgroup&gt;：多个h1-h6的容器，比如文章的主标题和副标题
    1. 如果有连续多个h1-h6标签，就用&lt;hgroup&gt;包裹，如果只有一个h1-h6标签，则不需要；
    2. 如果有连续多个标题和其他数据，则标题放入&lt;hgroup&gt;，并和其他数据一起放入&lt;header&gt;
4. &lt;header&gt;：网页或&lt;section&gt;的页眉，没有个数限制，通常会包含h1-h6或者&lt;hgroup&gt;
5. &lt;nav&gt;：页面的导航区域，用于定义整个页面的主要导航部分
6. &lt;section&gt;：h5文档中的片段，节
7. &lt;article&gt;：表示一个文档，在页面中自成一体的内容
8. &lt;aside&gt;：可用于侧边栏、副导航、附属信息如名词解释
</code></pre><h2 id="prop与attribute"><a href="#prop与attribute" class="headerlink" title="prop与attribute"></a>prop与attribute</h2><pre><code>1. 以复选框为例，checked表示勾选，其属性值并没有类型之分，都是字符串，只要使用了此属性，
   复选框都会被勾选；
    &lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; /&gt;
    &lt;input type=&quot;checkbox&quot; checked=&quot;true&quot; /&gt;
    &lt;input type=&quot;checkbox&quot; checked=&quot;234&quot; /&gt; &lt;input type=&quot;checkbox&quot; checked /&gt;
2. 标签上固有的属性，称为html预定义属性，如type、check，除此之外，还有html自定义属性；
    &lt;input type=&quot;checkbox&quot; checked=&quot;true&quot; abc=&quot;abc&quot; /&gt; --&gt;abc就是自定义属性
    1. 预定义属性和自定义属性统称为attribute，在元素对象的attributes属性中管理；
    2. JS原生对象的直接属性，被称为property，如attributes
    3. 每一个预定义的attribute都会有一个property与之对应，即attributes中管理的预定义
    属性，在对象的直接属性上也会有一份，但自定义属性不会有；
    元素对象==&gt; {
        attributes: { type:&quot;checkbox&quot;, check:&quot;true&quot;, abc:&quot;abc&quot; },
        type:&quot;checkbox&quot;,
        check:&quot;true&quot;
    }
    4. attributes中管理的属性，是以对象的形式管理的，这些属性对象被称为属性节点，它们都
    具有3个通用的属性，分别是：nodeName、nodeType、nodeValue
    5. 属性节点的nodeType都是2，以type属性为例：&quot;type&quot;, 2, &quot;checkbox&quot;
    6. 操作attributes中的属性：setAttribute()、getAttribute()、removeAttribute()
3. 调试的关键字：debugger
4. attribute与property的关系
    &lt;input type=&quot;checkbox&quot; checked=&quot;true&quot; name=&quot;user&quot; /&gt;
    let pt = document.querySelector(&apos;input[type=checkbox]&apos;)
    1. pt.setAttribute(&apos;checked&apos;, false); --&gt; 操作的是attribute
    2. pt.checked=false; pt[&apos;name&apos;]=&apos;psd&apos;; ---&gt; 操作的是property
    3. 布尔值属性：property是布尔值类型，如checked
    pt.checked=&apos;123&apos;; --&gt;&apos;123&apos;会转为布尔型 --&gt;console.log(pt.checked)--&gt;true
    4. 非布尔值属性：property是非布尔值类型，如name、type
</code></pre><h3 id="attribute与property的同步"><a href="#attribute与property的同步" class="headerlink" title="attribute与property的同步"></a>attribute与property的同步</h3><pre><code>1. 非布尔值属性：attribute与property会立刻实时同步，修改任意一方，另一方也会随之改变；
2. 布尔值属性
    1. 改变property，不会同步修改attribute
    2. 在没有修改过property时，修改attribute，会同步修改property
    3. 一旦修改过property，则不会再同步给attribute
    4. property保存的始终是布尔值，而attribute中保存的则是当前设置的值
    pt.setAttribute(&apos;checked&apos;, &apos;abc&apos;) --&gt;attribute：checked:&apos;abc&apos;
3. 浏览器界面上的操作，影响的是property，还是attributes
    1. 对于非布尔值属性，property和attributes是相互同步的，相对来说，操作attribute的
    成本更低，因为操作property会有一个转换过程；
    2. 鼠标选中/取消复选框，即操作布尔值属性，改变的也是property，不会影响attribute
    3. 即：只有property变化了，浏览器界面上的属性效果才会随之变化，所以操作布尔值属性时，
    务必使用property
</code></pre><h2 id="新增功能"><a href="#新增功能" class="headerlink" title="新增功能"></a>新增功能</h2><pre><code>    &lt;div id=&quot;box&quot; data-test=&quot;123&quot; data-user-name=&quot;Mack&quot;&gt;&lt;/div&gt;
    let node = document.querySelector(&quot;#box&quot;)
1. classList：标签上的CSS选择器的集合
    1. node.classList.add(&quot;test&quot;); --&gt; 添加一个新的选择器test
    2. node.classList.remove(&quot;test&quot;); --&gt; 移出选择器test
    3. node.classList.toggle(&quot;test&quot;); --&gt; 如果有，则移出，反之则添加
2. dataset：标签上的自定义属性的集合
    1. 对于以 data- 开头的自定义属性，都会保存在元素的 dataset 中；
    2. node.dataset.test：获取自定义属性test的属性值，同时可以直接修改此属性值；
    3. 对于 - 连接的自定义属性，必须使用驼峰式操作：node.dataset.userName
    node.dataset[&apos;userName&apos;]，不能使用node.dataset[&apos;user-name&apos;]
    4. node.dataset.password=&apos;abcde&apos;; --&gt;在dataset中新增/修改自定义属性
    5. delete node.dataset[&apos;userName&apos;]; --&gt;删除dataset中的自定义属性
    6. for-in 可以遍历dataset，但for-of不能。
3. attribute操作dataset
    1. node.attributes：获取当前标签显式使用的属性，包括自定义属性；
    2. node.attributes中管理的标签属性，就是标签上的名称，即使是自定义属性，也不会改变
        node.attributes：NamedNodeMap{ id, data-test, data-user-name }
    3. attributes必须使用 for-of 遍历，不能用 for-in
    4. setAttribute()、getAttribute()：也可以操作自定义属性
        node.setAttribute(&apos;data-user-name&apos;, &apos;abc&apos;); --&gt;修改自定义属性
    5. setAttribute(&apos;data-evty&apos;, &apos;12&apos;)：添加自定义属性，因为是以&quot;data-&quot;开头的属性，
    所以该属性也会被 dataset 管理。
4. 让标签内的字符串文本可编辑：contenteditable=&quot;true&quot;
    &lt;div id=&quot;box&quot; contenteditable=&quot;true&quot;&gt;新增标签属性&lt;/div&gt;
</code></pre><h2 id="其他新增标签"><a href="#其他新增标签" class="headerlink" title="其他新增标签"></a>其他新增标签</h2><pre><code>1. &lt;meter&gt;：用于显示已知范围的标量值/分数值，默认样式类似于进度条
    1. value：当前数值
    2. min/max：最小/最大边界值，如果没有设置，默认为0/1
    3. low/high：定义了低值/高值区间的上限值/下限值，value处在低值与高值区间的样式不同
    4. optimum：用于指示最优/最佳的取值。
&lt;meter value=&quot;80&quot; min=&quot;0&quot; max=&quot;100&quot; low=&quot;40&quot; high=&quot;60&quot; optimum=&quot;50&quot;&gt;&lt;/meter&gt;
2. &lt;progress&gt;：用于显示一项任务的完成进度，默认样式为带有单元格的进度条
    1. max：总进度
    2. value：当前完成的进度，如果不设置，进度条不会显示任何进度。
3. 列表标签：datalist、detail、summary
    1. datalist：让input输入框具备可选列表，类似于&lt;select&gt;的列表
    &lt;input type=&quot;text&quot; list=&quot;zdy&quot; /&gt;
    &lt;datalist id=&quot;zdy&quot;&gt; -------------------&gt;通过id属性绑定input
        &lt;option value=&quot;1&quot;&gt;列表标签&lt;/option&gt;
    &lt;/datalist&gt;
    2. detail、summary：展开/折叠
    &lt;detail&gt;
        &lt;summary&gt;用于展开折叠的文本&lt;/summary&gt;
        &lt;p&gt;被折叠的内容&lt;/p&gt;
        &lt;p&gt;被折叠的内容&lt;/p&gt;
    &lt;/detail&gt;
4. 注释标签：ruby、rt，展示文字注音或字符注释
    &lt;span&gt;&lt;ruby&gt;注&lt;rt&gt;zhu&lt;/rt&gt;释单词&lt;/ruby&gt;&lt;/span&gt;  --&gt;&quot;注&quot;的上面会有注音&quot;zhu&quot;
5. 标记标签：&lt;mark&gt;着重内容&lt;/mark&gt;
</code></pre><h3 id="新增表单属性"><a href="#新增表单属性" class="headerlink" title="新增表单属性"></a>新增表单属性</h3><pre><code>1. placeholder：输入框的提示信息，&lt;input type=&quot;text&quot; placeholder=&quot;请输入账号&quot; /&gt;
2. autofocus：指定表单获取输入焦点，布尔值属性，&lt;input type=&quot;text&quot; autofocus /&gt;
3. required：必填项、必选项，不能为空；如果没有内容/选项，在提交表单时会弹框提示；
4. pattern：自定义正则校验，如果不符合正则，提交时会弹框提示；
    &lt;input type=&quot;text&quot; pattern=&quot;\d{1,5}&quot; /&gt;
5. formaction：自定义submit的提交地址；
&lt;form action=&quot;http://www.sina.com&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交1&quot; /&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交2&quot; formaction=&quot;http://www.baidu.com&quot; /&gt;
&lt;/form&gt;
6. list属性与&lt;datalist&gt;：为输入框构造一个选择列表。
</code></pre><h3 id="新增表单type类型"><a href="#新增表单type类型" class="headerlink" title="新增表单type类型"></a>新增表单type类型</h3><pre><code>1. type=&quot;email&quot;：email地址类型，type=&quot;tel&quot;：电话类型，type=&quot;url&quot;：URL地址类型
    1. 它们并不会限制输入内容，只是在输入的内容不符合指定的类型格式时，提交不会成功；
    2. 但是在移动端，它们获得焦点时会弹出对应类型的键盘。
2. type=&quot;range&quot;：可拖动的进度条
    1. min(最小值)、max(最大值)、value(当前值)
    2. step：一步跳动的值，如取值范围0-100，step=&quot;20&quot;，相当于分了5步，每一步跳动20
    &lt;input type=&quot;range&quot; min=&quot;0&quot; max=&quot;100&quot; value=&quot;20&quot; step=&quot;20&quot; /&gt;
3. type=&quot;search&quot;：输入框的内右侧会有一个&quot;x&quot;，用于便捷式清空输入的内容；
4. type=&quot;number&quot;：只允许输入数字，输入框获取焦点时，内右侧会有增大(+1)和减小(-1)的按钮；
5. type=&quot;color&quot;：颜色选择器，可以调出颜色选择的面板；
6. 日期时间：type=&quot;datetime&quot;、&quot;datetime-local&quot;、&quot;date&quot;、&quot;time&quot;、&quot;week&quot;、&quot;month&quot;
</code></pre><h3 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h3><pre><code>1. validity对象：通过注册 invalid 事件，查看验证是否通过；
    input.addEventListener(&quot;invalid&quot;, function(){ this.validity }, false)
    1. 提交表单时，如果验证失败，则会触发此事件；
    2. 在回调函数中，通过 this.validity 获取验证对象。
2. validity.valueMissing：输入内容为空时返回true
    &lt;input type=&quot;text&quot; required /&gt; --&gt;没有输入内容时，valueMissing为true
3. validity.typeMismatch：输入的内容与预期类型不匹配时返回true
    &lt;input type=&quot;email&quot; /&gt; --&gt;输入内容不是Email类型时，typeMismatch为true
4. validity.patternMismatch：输入内容不匹配pattern正则时返回true
5. 鸡肋的属性
    1. tooLong：maxLenght属性已经限制了输入内容的长度，所以不会触发此验证属性
    2. rangeUnderflow、rangeOverflow、stepMismatch：&lt;input type=&quot;range&quot; /&gt;相关
6. validity.customError：不符合自定义验证时，则返回true
    1. setCustomValidity()：用于设置自定义验证的提示内容；
    2. setCustomValidity(&quot;&quot;)：设置为空字符串，表示放行，验证通过；
    &lt;form&gt; &lt;input type=&quot;text&quot; name=&quot;user&quot; id=&quot;user&quot; /&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;/form&gt;
    let name = document.querySelector(&quot;#user&quot;)
    let submit = document.querySelector(&quot;input[type=submit]&quot;)
    submit.onclick = function() {
        if(name.value === &apos;123&apos;) { ---&gt; 当输入框中的内容为&quot;123&quot;时，会弹框提示
            name.setCustomValidity(&apos;请不要输入敏感词&apos;) ---&gt; 设置提示框的内容
            console.log(name.validity) --&gt; validity.customError返回true
        } else {
            name.setCustomValidity(&apos;&apos;)
        }
    }
    3. 验证失败时，会阻止表单继续提交。
7. 关闭验证：formnovalidate属性
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/05/09/CSS3-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/09/CSS3-3/" itemprop="url">CSS3-3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-09T00:00:00+08:00">
                2018-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML/" itemprop="url" rel="index">
                    <span itemprop="name">HTML</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="新增布局"><a href="#新增布局" class="headerlink" title="新增布局"></a>新增布局</h2><pre><code>1. table布局是CSS2中唯一为布局为生的，专门为做布局而生的一套属性；
    1. display:table; 可以将一个元素转为table
    2. 但是，table布局并不是流式的，而div布局是流式的；
    3. 网络数据是以流的形式进行传输，对于流式布局，浏览器接收到一段数据，就可以开始渲染；
    4. table布局则不然，必须等到接受完所有数据，浏览器才能开始渲染，性能极其低下；
    4. 而且，更改table布局中的任何一部分数据，整个table都要重新开始渲染。
2. CSS3为布局而生的扩展：flex布局，响应式布局，多列布局(分栏布局)
</code></pre><h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h2><pre><code>1. 弹性盒子/布局：使页面布局适应不同的屏幕尺寸和不同的显示设备，所以常用于移动端布局；
    1. 弹性盒子模型提供了对块盒子模型的改进，因为它不使用浮动；
    2. flex容器的边缘也不会与其内容的边缘发生折叠。
2. flex布局经历了2个版本：老版本display:box; 新版本display:flex;
    1. Android4.4之前只支持老版本，4.4开始支持新版flex；
    2. Less、Sass和Stylus是CSS预处理器，使CSS可以工程化开发；
    3. PostCSS是CSS后处理器，但它像是一种插件系统，用于处理CSS的兼容性问题；
    4. Autoprefixer就是PostCSS的一个非常受欢迎的插件。
3. flex布局在容器上声明，作用于容器中的子元素，且新版与老版的布局效果是不同的；
    &lt;div id=&quot;box&quot;&gt; ---&gt; 容器
        &lt;div class=&quot;item&quot;&gt;1&lt;/div&gt; ---&gt; 项目
        &lt;div class=&quot;item&quot;&gt;2&lt;/div&gt;
        ......
    &lt;/div&gt;
    #box {
        display: -webkit-box;  --&gt; 老版
        display: flex; --&gt; 新版
    }
    1. 容器内管理的子元素称为项目，容器与项目上分别使用不同的flex属性；
    2. flex布局中存在两条坐标轴：主轴、侧轴，由flex-direction/-webkit-box-orient控制
    3. 当指定X轴为主轴时，Y轴为侧轴，反之亦然！项目永远排列在主轴的正方向上！
4. 富裕空间：容器box的宽高为(400px,400px)，每个项目的宽高为(50px,50px)，共用4个项目；
    1. 假设项目的margin都是0px，X轴为主轴，那么主轴的富裕空间为(400-50*4=200px, 50px)
    2. 侧轴的富裕空间为(width:400px, height:400-50=350px)
</code></pre><h3 id="了解老版本的容器"><a href="#了解老版本的容器" class="headerlink" title="了解老版本的容器"></a>了解老版本的容器</h3><pre><code>1. 尽管PostCSS的插件系统可以处理大部分CSS3的兼容性问题，但仍需要了解以下老版flex布局；
2. 容器中的布局方向：-webkit-box-orient
    1. -webkit-box-orient的本质是确定X轴和Y轴中的哪一根为主轴，默认是X轴；
    2. -webkit-box-orient: horizontal(X轴)/vertical(Y轴);
    3. 项目排列在主轴上，主轴改变了，项目的排列位置也随之改变！
3. 容器中的排列方向：-webkit-box-direction，用于控制主轴的正方向
    1. -webkit-box-direction: normal/reverse(反向);
    2. 项目沿着主轴的正方向排列，主轴的正方向改变了，项目的排列方式也随之改变。
4. 富裕空间管理：-webkit-box-pack(主轴)，-webkit-box-align(侧轴)
    1. 它们不会给项目去分配任何空间，只是用于确定富裕空间的位置；
    2. 老版本管理富裕空间的位置与主轴/侧轴的正方向无关，造成新老版本的项目排列位置不同。
5. -webkit-box-pack: start/end/center/justify; --&gt; 管理主轴的富裕空间
    1. X轴是主轴：在主轴的右边(start)/左边(end)/两边(center)/项目之间(justify)
    2. Y轴是主轴：在主轴的下面(start)/上面(end)/两边(center)/项目之间(justify)
6. -webkit-box-align: start/end/center; --&gt; 管理侧轴的富裕空间
    1. X轴是侧轴：在侧轴的右边(start)/左边(end)/两边(center)
    2. Y轴是侧轴：在侧轴的下面(start)/上面(end)/两边(center)
</code></pre><h3 id="新版本的容器"><a href="#新版本的容器" class="headerlink" title="新版本的容器"></a>新版本的容器</h3><pre><code>1. 容器中的布局方向和排列方向：flex-direction
    1. flex-direction: row/column/row-reverse/column-reverse;
    2. row、row-reverse：主轴为x轴，正方向分别是从左往右、从右往左
    3. column、column-reverse：主轴为y轴，正方向分别是从上往下、从下往上
2. 富裕空间管理：justify-content，align-items
    1. justify-content、align-items分别管理主轴、侧轴的富裕空间；
    2. 富裕空间的位置与主轴/侧轴的正方向有关。
3. justify-content：管理主轴的富裕空间
    1. flex-start/flex-end：富裕空间在主轴的正方向上/反方向上；
    2. center：在主轴的两边，即项目会在主轴上居中显示；
    4. space-between：在项目之间，第一个和最后一个分别只有一边有富裕空间；
    5. space-around：富裕空间在项目两边，每个项目的两边都有富裕空间；
4. align-items：管理单行/列项目时侧轴的富裕空间
    1. flex-start/flex-end/center：富裕空间在侧轴的正方向/反方向/两边；
    2. baseline：按基线对齐，基线是line-height的相关概念；
    3. stretch：默认值，等高布局，如果项目没有设置高度，则把它们拉伸到相同的高度。
5. flex-wrap：当容器的主轴空间不足时，控制项目是否换行；
    1. nowrap：默认值，不换行，压缩项目的宽度/高度，不让它们超出容器；
    2. wrap/wrap-reverse：换行，以行为单位、沿着侧轴的正/反方向排列；
    3. 换行时，默认会等分侧轴的富裕空间，此时由align-content属性管理侧轴的富裕空间。
6. align-content：管理多行/列项目时的侧轴富裕空间，只有一行/列则无效；
    1. 属性值：flex-start/flex-end/center/space-between/space-around/stretch
    2. 只有在设置了flex-wrap:wrap/wrap-reverse; 设置的align-content才有效。
7. flex-flow：flex-direction和flex-wrap的简写形式，默认值row nowrap
</code></pre><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><pre><code>1. order：默认值为0，数值越大，项目越靠后排列，精确控制每个项目的排列顺序，如order:5;
2. align-self：管理单个项目的侧轴富裕空间
    1. 属性值：auto/flex-start/flex-end/center/baseline/stretch
    2. auto：默认使用容器上的align-items属性值，如果容器上没有设置，则使用stretch
    3. 多行项目时，align-self相对于当前行的侧轴富裕空间，且优先级小于align-content
    4. 单行时，align-self的优先级大于align-items
</code></pre><h4 id="弹性空间管理"><a href="#弹性空间管理" class="headerlink" title="弹性空间管理"></a>弹性空间管理</h4><pre><code>1. flex-grow、flex-shrink、flex-basis
2. flex-grow：定义弹性盒子(项目)的拉伸因子，默认值为0
    flex-grow: 1; --&gt;对应的老版本：-webkit-box-flex: 1;
    1. 把主轴上的富裕空间按比例分配到每个项目的width(X轴)/height(Y轴)上；
    2. 属性值为弹性因子，也就是分配富裕空间时所占的权重、比例，弹性因子越大，分配越多。
3. flex-shrink：收缩因子，容器空间不足时，指定项目被压缩的比例(项目不能换行)，默认值为1
4. flex-basis：项目在主轴的方向的初始大小，也就是伸缩的基准值
    1. 默认值是auto，但在flex简写属性中，默认值为0
    2. X轴为主轴时，如果没有设置项目的flex-basis，那么flex-basis的值为项目的width
5. flex-grow的拉伸规则(X轴为主轴)
    1. 可用空间 = 容器大小 - 所有相邻项目flex-basis的总和
    2. 可扩展空间 = 可用空间 / 所有相邻项目flex-grow的总和
    3. 每个项目伸缩后的真实大小 = flex-basis + 可扩展空间 x flex-grow
    &lt;div id=&quot;box&quot;&gt; ---------&gt; #box{ width:400px; height:300px; display:flex; }
        &lt;div&gt;11&lt;/div&gt; &lt;div&gt;22&lt;/div&gt; &lt;div&gt;33&lt;/div&gt; &lt;div&gt;44&lt;/div&gt; &lt;div&gt;55&lt;/div&gt;
    &lt;/div&gt; --------------&gt; #box &gt; div{ width:50px; height:50px; flex-grow:1; }
    #box &gt; div:nth-child(1){ flex-grow:4; }
    1. 可用空间 = 400 - 5*50 = 150px
    2. 可扩展空间 = 150/(1*4+4) = 18.75px
    3. 第1项伸缩后的width：50 + 18.75 * 4 = 125px
    4. 第2/3/4/5项伸缩后的width：50 + 18.75 * 1 = 68.75px
6. flex-shrink的收缩规则(X轴为主轴)
    1. 计算收缩因子与基准值乘的总和 = 所有项目的(flex-basis x flex-shrink)之和
    2. 计算收缩因数 = 项目的收缩因子 x 项目flex-basis / 收缩因子与基准值乘的总和
    3. 每个项目需要减去的大小 = 收缩因数 x 项目溢出容器的大小
    #box{ width:100px; height:300px; display:flex; }
    #box &gt; div{ width:50px; height:50px; flex-shrink:1; }
    #box &gt; div:nth-child(1){ width:200px; }
    1. 收缩因子与基准值乘的总和 = 200*1 + 50*1*4 = 400
    2. 第1项的收缩因数 = 1*200/400 = 1/2，第2/3/4/5项的收缩因数 = 1*50/400 = 1/8
    3. 第1项需要减去的大小 = 1/2 * (200 + 50*4 - 100) = 150px
    4. 第2/3/4/5项需要减去的大小 = 1/8 * (200 + 50*4 - 100) = 37.5px
    5. 第1项收缩后的width = 200 - 150 = 50px
    6. 第2/3/4/5项收缩后的width = 50 - 37.5 = 12.5px
7. flex-shrink收缩规则的前提(X轴为主轴)
    1. flex-shrink不会把项目的width缩减为0，flex布局会考虑项目的内容；
    2. 如果项目中的内容宽度大于最终收缩后的项目宽度，那么项目的实际宽度就是内容所占的宽度，
    至于多占用的宽度，会让其他项目一起承担；
    3. 所以，在设计flex布局时，需要精确考虑项目中的内容，不能太多；
    4. 老版本并没有这些专用控制伸缩的属性，在老版本上有可能把项目收缩为0
8. flex的简写属性
    1. flex: 1; --&gt; flex-grow:1; flex-shrink:1; flex-basis:0%;
    2. flex: 1; 实现等分布局，每个项目在主轴上的width/height是相同的；
    2. flex实现有规律的布局极其简单，如等比例、等分、居中... ，所以在移动端大行其道。
</code></pre><h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><pre><code>1. CSS3的媒体查询是响应式布局方案的核心技术，媒体查询选择器以 @media 开头；
2. 媒体查询选择器不会对CSS的特殊性有任何贡献，即不会影响选择器的优先级。
</code></pre><h3 id="媒体类型"><a href="#媒体类型" class="headerlink" title="媒体类型"></a>媒体类型</h3><pre><code>1. all(所有媒体，默认)，screen(彩色屏幕)，print(打印预览)
2. projection(手持设备)，tv(电视)，braille，embossed，speech，tty...
3. PC端、移动端都是彩色屏幕，属于screen的范围
    @media screen { --&gt;定义彩色屏幕上的选择器样式，类似于if-else条件表达式
        #wrap{ background:red; } --&gt;在彩色屏幕上，id选择器wrap上的背景色为red
    }
</code></pre><h3 id="媒体属性"><a href="#媒体属性" class="headerlink" title="媒体属性"></a>媒体属性</h3><pre><code>1. width、height：浏览器窗口的宽度、高度，可以加max、min前缀，height很少使用
    @media screen and (min-width:800px) {
        #wrap{ background:red; } --&gt;彩色屏幕且浏览器窗口的宽度&gt;=800px时，样式生效
    }
2. device-width：设备宽度，屏幕分辨率，如1280X720，可以加max、min前缀
    @media screen and (min-device-width:1280px) { ... }
    1. 彩色屏幕且设备分辨率的宽度&gt;=1280px时，样式生效
3. device-pixel-ratio：像素比，DPR，必须加webkit前缀，也可以加max、min前缀
    @media screen and (-webkit-min-device-pixel-ratio:1) { ... }
    1. 彩色屏幕且DPR&gt;=1时，样式生效
4. orientation：portrait(竖屏width=&lt;height)，landscape(横屏width&gt;height)
    @media screen and (orientation:landscape) { ... }
    1. 彩色屏幕且浏览器窗口为横屏时，样式生效
</code></pre><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><pre><code>操作符/关键字：only，and，or，not
1. and、or、not：连接媒体类型与媒体属性，分别表示与、或、非；其中，or用&quot;,&quot;表示
    @media screen and (max-width:800px), (orientation:landscape) { ... }
    1. 彩色屏幕且浏览器窗口的宽度&lt;=800px时生效，亦或者屏幕为横屏时生效；
    2. or(,)后面只有媒体属性，没有声明媒体类型，则默认媒体类型为all
2. only：与浏览器的兼容性有关，老版本浏览器只支持媒体类型，不支持带有媒体属性的选择器
    @media screen and (min-width:800px){ ... }
    1. 老版本浏览器会解析为：@media screen { ... } --&gt;在老版本浏览器中，不管浏览器窗口
    的宽度是否&gt;=800px，样式始终生效
    2. 老版本浏览器只识别到 @media 后的第一个标识符，如果该标识符不属于媒体类型，则忽略
    @media only screen and (width:800px){ } --&gt;老版本浏览器解析为：@media only { }
    3. only不属于媒体类型，该媒体查询会被老版本浏览器忽略，该媒体查询选择器不会生效；
    4. 防止老旧浏览器不支持带媒体属性的查询，所以建议在媒体查询时都加上only
3. not
    @media not screen and (width:800px), (orientation:landscape) { ... }
    1. 生效条件：(不是彩色屏幕 || 浏览器尺寸!=800px) || (屏幕为横屏)
    2. 老版浏览器会解析成 @media not{ }，而not不属于媒体类型，所以该媒体查询选择器也不会
    生效，也就不需要再加only
</code></pre><h2 id="多列布局"><a href="#多列布局" class="headerlink" title="多列布局"></a>多列布局</h2><pre><code>&lt;div id=&quot;box&quot;&gt;多列布局······分栏布局······多列布局······分栏布局&lt;/div&gt;
#box{ width:600px; border:1px solid #000000; }
1. 栏目宽度：column-width，指定每一列的宽度
    1. column-width: 100px; --&gt;每一列的宽度为100px
    2. 尽管指定了每一列的宽度，但很难均分容器的width，最后分出来的列数可能只有5列
2. 栏目列数：column-count，指定需要分成多少列
    1. column-count:3; --&gt;把容器的内容分为3列
    2. 比column-width更友好、更强大，只需要指定列数，每一列的宽度会自动配分
3. 列与列的间距：column-gap，列与列之间的距离
4. 列与列的分割线：column-rule，列与列之间添加分割线，并设置分割线的样式
    column-rule: 1px solid red;
</code></pre><h2 id="CSS3的兼容性前缀"><a href="#CSS3的兼容性前缀" class="headerlink" title="CSS3的兼容性前缀"></a>CSS3的兼容性前缀</h2><pre><code>1. -ms-：兼容IE
2. -moz-：兼容firefox
3. -o-：兼容opera
4. -webkit-：兼容chrome和safari
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/05/08/CSS3-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/08/CSS3-2/" itemprop="url">CSS3-2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-08T00:00:00+08:00">
                2018-05-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML/" itemprop="url" rel="index">
                    <span itemprop="name">HTML</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h2><pre><code>1. transition：过渡动画
    1. CSS的效率极高，速度极快，为此，CSS transition提供了一种在更改CSS属性时，控制动画
    速度的方法，它让属性变化持续一段时间，而不是立即生效；
    2. 比如，改变一个元素的颜色时，可以用transition逐渐从原色变为目标色；
    3. 对于transition作用的属性，不管以哪种方式发生了变化，即使是JS操作，也会执行；
    4. 但是，并不是所有的属性变化都支持transition，比如display:none;
    5. transition只关心元素的初始状态和结束状态，无法定制过渡动画中的每一帧状态。
2. transition-property：指定使用过渡的属性，可指定多个，默认为all(所有变化的属性)
3. transition-duration：动画执行的时间，必须以秒(s)和毫秒(ms)为单位，默认值为0s
    &lt;div id=&quot;wrap&quot;&gt; &lt;div id=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt;
    #wrap { width:600px; height:600px; border:1px solid red; }
    #inner { width:200px; height:200px; background:red; }
    1. 鼠标悬浮在wrap上时，让inner的宽高变小
    #wrap:hover #inner{ width:100px; height:100px; background:green; }
    2. 让wrap的宽度变化有过渡动画，且动画时间为5s
    #inner{ transition-property:width; transition-duration:5s; }
    3. 动画会执行两次，分别是悬停在wrap上(hover事件)、移出wrap(恢复初始状态)
    4. -duration的复制原理：当指定的属性列表大于时间列表时，时间列表会拷贝一份
    transition-property: width,height,background;
    transition-duration: 5s,2s; --&gt; 5s,2s,5s,2s --&gt; 最后一个2s会被裁剪
    5. 时间列表中有任何一个值不加单位，整个动画机制都会失效。
4. transition-timing-function：变化的过程，变化速率的曲线，默认ease(加速然后减速)
    1. 如果速率列表小于属性列表，缺少的速率会被设置为默认值ease，反之会被裁剪；
    2. liear(匀速)、ease-in(加速)、ease-out(减速)、ease-in-out(加速然后减速)
    3. cubic-bezier(贝塞尔曲线)、step-start、step-end、steps(number, ...)
    4. step-start、step-end分别等同于steps(1,start)、steps(1,end)
    5. steps(start, end)：第一个参数必须是正整数，表示函数的步数，第二个值表示每一步发生
    变化的时间点，默认值end
5. transition-delay：动画执行的延迟时间，复制原理与-duration相同；
6. 过渡动画的完成事件
    1. 标准浏览器下的完成事件是transitionend，而webkit下是webkitTransitionEnd
    2. 每一个拥有过渡动画的属性，在完成动画时都会分别触发一次transitionend事件；
    3. 在过渡动画完成之前，设置display:none; 不会再触发transitionend事件。
7. transition的天然缺陷
    1. 缺陷一：动画是浏览器的渲染机制进行渲染的，其渲染速度要小于CSS、JS的解析速度
    #inner { transition-property:width; transition-duration:2s; }
    #wrap:hover #inner{ transition-property:height; --&gt;修改过渡动画作用的属性
        width:100px; height:100px; }
    2. hover事件迅速修改了transition作用的属性，等到浏览器的渲染机制执行动画时，发现使用
    过渡动画的属性是height，所以对height执行transition动画；
    3. 鼠标移出wrap时，transition作用的属性又恢复为width，所以渲染机制对width执行动画。
    2. 缺陷二：transition在元素首次渲染还没有结束的情况下，是不会被执行的；
    let inner = document.querySelector(&quot;#inner&quot;)
    inner.style[&apos;width&apos;] = &apos;100px&apos; --&gt;虽然放在&lt;body&gt;之后执行，但也不会触发动画
    3. JS要触发transition，必须在window.onload的回调函数中执行，等待页面渲染完成。
8. transition的简写：transition: property,duration,timing-function,delay
    1. 同时设置多个属性：transition: 2s 3s width, 3s height;
    2. 第一个时间被解析为动画执行的时间，第二个时间被解析为动画的延迟时间；
    3. width的动画时间为2s，延迟时间为3s，height的执行时间为3s，延迟时间为0s
</code></pre><h2 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h2><pre><code>1. transform：变形，2D变换，只对块级元素有效；
2. transform是静态效果，并不会有过渡动画，需要配合transition属性；
3. 旋转：transform: rotate(360deg);
4. 平移
    1. 水平移动：transform: translateX(200px); --&gt; 向右平移200px
    2. 垂直移动：transform: translateY(400px); --&gt; 向下平移400px
    3. 指定坐标点的移动：transform: translate(100px,100px); --&gt;坐标(100,100)
    4. 设置为负值表示反向移动，translate()只设置一个值时，表示Y轴为0px
    5. translate(x,y)使用百分比时，分别参照自身的width和height
5. 斜切：skewX(45deg)、skewY(45deg)、skew(45deg, 45deg)
    transform: skewX(45deg); --&gt;沿X轴斜切45°，支持负值
6. 缩放：scale()、scaleX()、scaleY()
    1. 缩小的范围为0-1，放大的范围则大于1，负值有旋转效果，不推荐使用；
    transform: scaleX(.5); --&gt; 0.5, 缩小一倍
    2. scale(x, y)：只设置一个值时，表示x与y相等。
7. 基点的变换：transform-origin，改变元素变形的基点
    1. 支持关键字：left、right、top、bottom、center
    #inner{ transition:2s; transform-origin:left top; } -&gt;以盒子左上角为基点
    2. 也支持px值和百分比，以盒子的左上角为原点(0, 0)
    #inner{ transition:2s; transform-origin:10px 10px; } -&gt;基点(10,10)
    3. 旋转、斜切、缩放的基点默认都是盒子的中心点(50%,50%)
8. transform不会影响文档流，盒子的位移、缩放等不会改变相邻盒子的位置，性能更高。
</code></pre><h3 id="变换组合"><a href="#变换组合" class="headerlink" title="变换组合"></a>变换组合</h3><pre><code>1. 所有2D变换的底层实现都是依靠矩阵：transform: matrix(a,b,c,d,e,f);
    1. 平移对应的矩阵：transform: matrix(1,0,0,1,X,Y);
    2. transform: matrix(1,0,0,1,300,0); --&gt;平移300px
2. 变换组合的底层渲染就是矩阵计算，且矩阵计算的方向是从右向左
    transform: translateX(100px) scale(0.5); --&gt;平移与缩放的组合
    1. 原理：先计算缩放的矩阵，再计算位移的矩阵，且矩阵的运算是不可逆的；
    2. 组合变换的位置不同，矩阵的计算结果也不同，展现的过程和结果也不相同。
3. 在切换组合变换的样式时，必须保证组合变换的个数、位置相同，否则可能不会执行过渡；
    if(flag) {
        box.style.transform = &apos;rotate(-720deg) scale(1)&apos;
    } else {
        box.style.transform = &apos;rotate(0deg) scale(1)&apos;
    }
4. 扇形导航：定位、transform、勾股定理、三角函数、角度与弧度的转化
5. 时钟：通过JS批量处理HTML节点与style样式，transform-origin改变元素变换的基点
</code></pre><h2 id="3D变换"><a href="#3D变换" class="headerlink" title="3D变换"></a>3D变换</h2><pre><code>1. 3D变换：3D缩放、3D旋转、3D平移
2. 3D旋转
    1. transform: rotate(360deg); 默认就是按照Z轴旋转，等同于rotateZ(360deg);
    2. rotateX(360deg); rotateY(360deg); 分别按照X轴、Y轴旋转
    3. rotate3d(x,y,z,deg)：(x,y,z)表示3D空间的一个点，坐标原点到(x,y,z)形成一条射线，
    元素按照这条射线旋转。
3. 3D平移
    1. transform: translateZ(100px); Z轴不支持百分比，只有X轴和Y轴支持；
    2. translate3d(x,y,z);
4. 3D缩放：transform: scaleZ(2);
</code></pre><h3 id="景深"><a href="#景深" class="headerlink" title="景深"></a>景深</h3><pre><code>1. 景深：激活3D空间，元素会有近大远小的效果，营造立体空间感
    1. 简单讲，景深就是肉眼距离显示器的距离，景深越大，元素离眼睛越远，反之越近；
    2. 景深是不可继承属性，但其所有的后代元素都会受影响，应用景深的元素称为舞台元素。
2. 两种使用方式：transform:perspective(depth);  perspective:depth;
    1. transform:perspective(depth); 直接作用的当前元素本身，且必须放在transform的
    第一个位置，否则会被忽略；
    2. perspective:depth; 作用在子元素上，使用该属性的元素只是作为一个包裹器；
    3. depth的默认值为none，可以设置一个px值，表示沿着Z轴到坐标原点的距离。
3. 原理：景深越大，灭点越远，元素变形越小，反之亦然；
    1. 灭点：元素变形后，一直向远处的方向，会有一个交叉点，称之为灭点
    2. 以火车铁轨为例，一直沿着铁轨向远处眺望，会发现两条铁轨逐渐靠近，最终交叉成一个点。
4. perspictive-origin：控制景深的基点，默认值是盒模型宽高的(50% 50%)
5. 景深叠加
    1. 如果当前元素已经使用了景深，其后代元素也应用了景深，效果会叠加，而不是覆盖；
    2. 每款浏览器的景深叠加是不同的，所以尽量避免景深叠加，后代元素不要再使用景深。
</code></pre><h3 id="3d舞台"><a href="#3d舞台" class="headerlink" title="3d舞台"></a>3d舞台</h3><pre><code>1. 3D舞台：只有近大远小的效果是不够的，需要营造具有层级的3d舞台；
2. transform-style：3D舞台，不可继承，作用于子元素，而不是元素自身；
    transform-style: preserve-3d;
3. backface-visibility：是否显示元素的背面，默认值visible(显示)，hidden(隐藏)
    1. 对于立体的元素，设置了透明度后，可以看到其他位面，此属性可以隐藏其他位面；
    2. 以立方体为例，隐藏其他位面之后，只保留正向的位面。
</code></pre><h4 id="transition旧版"><a href="#transition旧版" class="headerlink" title="transition旧版"></a>transition旧版</h4><pre><code>待整理
1. transition-property：设置过度的属性，比如width、height、background-color；
2. transition-duration：设置过度的时间，比如 1s，500ms；
3. transition-timing-function：设置过度的运动方式；
    1. linear 匀速；ease 开始和结束慢速；ease-in/ease-out 开始/结束是慢速；
    2. ease-in-out 开始和结束时慢速；cubic-bezier(n,n,n,n) 设置曲线；
4. transition-delay：设置动画的延迟；
5. 复合属性的设置：transition:property duration timing-function delay;
6. 动画播放：
    1. 为盒子添加hover事件，当鼠标悬停在盒子上时，开始播放动画；
    1. width、height、background-color、border-radius的播放顺序与排列顺序有关；
    2. 每种动画同时播放：transition:all 500ms ease;
    3. 曲线设置的网站：https://matthewlein.com/tools/ceaser
</code></pre><h4 id="transform旧版"><a href="#transform旧版" class="headerlink" title="transform旧版"></a>transform旧版</h4><pre><code>待整理
1. translate(x, y)：盒子位移到(x, y)的像素坐标点，单位是px；
    1. 三维移动：translateX(10px)、translateY(10px)、translateZ(10px)
2. scale(x, y)：盒子缩放，x=y=1，表示原始大小，x=y=0.5，表示盒子大小的一半；
3. rotate(x)：盒子旋转，x表示角度，单位是deg，支持正负值，默认是Z轴旋转；
    1. 三维旋转：rotateX(30deg)、rotateY(30deg)、rotateZ(30deg)
4. skew(x, y)：斜切，x、y表示X轴和Y轴斜切的角度，单位是deg；
5. perspective(x)：设置透视距离，单位是px；
    1. 三维操作需要配合透视距离才能显现效果，特征：近大远小；
    2. 通常设置为800px，更容易欺骗眼睛。
6. transform-style：盒子是否按3D空间显示，flat/perserve-3d；
8. backface-visibility：设置盒子背面是否可见，默认可见visible，hidden表示不可见；
    1. rotateY(180deg)：盒子沿Y轴旋转180度，若设置背面不可见，盒子会隐藏；
</code></pre><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><pre><code>1. animation：动画，作用的元素一旦加载就会执行动画，不会等待页面完全渲染；
    1. 人类具有视觉暂留的特性，人的眼睛在看到一幅画或一个物体后，在0.34s内不会消失；
    2. 动画的原理：把人物的表情、动作、变化等分解后，画成许多动作瞬间的画幅，利用视觉暂留的
    特性，在一幅画消失之前，播放下一幅画，就会给人造成一种流畅的视觉变化效果。
    3. CSS3动画：将元素从一个样式逐渐过渡到另一种样式的效果。
2. @keyfrmes 关键帧(动画的标识) { from{ //动画的初始状态 }  to{ //动画的结束状态 } }
</code></pre><h3 id="动画属性"><a href="#动画属性" class="headerlink" title="动画属性"></a>动画属性</h3><pre><code>1. animation-name：关键帧的名称，none表示无关键帧；
2. animation-duration：动画的时间，默认值为0s，表示无动画，单位为s、ms
    &lt;div id=&quot;box&quot;&gt;&lt;/div&gt; --&gt;div{ width:100px; height:100px; }
    #box{ animation-name:move; animation-duration:3s; }
    @keyframes move { ---&gt; 旋转360°的动画关键帧
        from{ transform: rotate(0deg); }
        to{ transform: rotate(360deg); }
    }
3. animation-timing-function：动画的执行函数，默认是由慢变快再变慢
    1. linear：线性过渡，等同于贝塞尔曲线(0, 0, 1, 1)
    2. ease：平滑过渡，等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0)
    3. ease-in：慢-&gt;快，等同于贝塞尔曲线(0.42, 0, 1, 1)
    4. ease-out：快-&gt;慢，等同于贝塞尔曲线(0, 0, 0.58, 1)
    5. ease-in-out：慢-&gt;快-&gt;慢，等同于贝塞尔曲线(0.42, 0, 0.58, 1)
    6. steps(n, start|end)：第一个参数表示把动画分成n等分，第二个参数默认为end
4. animation-delay：动画执行的延迟时间，属于动画外的范畴；
5. animation-iteration-count：动画的执行次数，重复执行的是关键帧，from-&gt;to
    1. 与name、duration、function都是属于表示动画内的范畴；
    2. 动画的执行时间为1s，执行次数为3，延迟时间为1s，那么动画只会在开始时延迟1次，重复时
    不会再延迟；
    3. infinite：无限循环。
6. animation-direction：动画执行的方向，默认值normal，reverse表示反向
    1. reverse反向的是关键帧和执行函数，关键帧：to-&gt;from，ease-in：快-&gt;慢
    2. alternate：执行次数大于1时，让动画连续执行，from-&gt;to-&gt;from-&gt;to-&gt;from-&gt;...
    3. alternate-reverse：to-&gt;from-&gt;to-&gt;from-&gt;to-&gt;...
7. animation-fill-mode：元素在动画外的状态，默认情况下，动画执行完还会回到元素的初始状态
    1. backwards：元素的初始状态与from中定义的状态保持一致；
    2. forwards：动画执行结束后，元素的状态与to中定义的状态保持一致；
    3. both：元素的初始状态和结束状态分别与from、to中定义的状态保持一致。
8. animation-play-state：动画的执行与暂停，paused(暂停)，running(执行)
    #box:hover { animation-play-state:parsed; } --&gt;鼠标悬停在box上时，动画暂停
9. 简写属性：animation: name duration function delay count direction mode state;
    1. 第一个time会分配给duration，第二个time会分配给delay
    2. animation: 2s 3s; --&gt; 动画执行时间为2s，延迟时间为3s
</code></pre><h3 id="关键帧"><a href="#关键帧" class="headerlink" title="关键帧"></a>关键帧</h3><pre><code>1. 关键帧：@keyframes
    @keyframes name {
        keyframes-selector { css声明; }
    }
    1. name：动画的名称，必选项；
    2. keyframes-selector：动画持续时间的百分比，from相当于0%，to相当于100%
    @keyframes move {
        0% { transform: translateY(-100px); } --&gt;动画的初始状态
        50% { transform: translateY(-50px); } --&gt;动画时间执行50%时的状态
        100% { transform: translateY(100px); } --&gt;动画时间执行结束时的状态
    }
    1. animation-timing-function作用于一个动画周期，而非整个动画周期；
    2. 0% -&gt; 50%，50% -&gt; 100% 表示两个动画周期
2. animation-timing-function: steps(n, start|end);
    @keyframes move {
        0%{ transform: translateY(-100px); }
        25%{ transform: translateY(-90px); }
        50%{ transform: translateY(0px); }
        75%{ transform: translateY(90px); }
        100%{ transform: translateY(100px); }
    }
    animation: move 4s both running 3 alternate steps(1, end);
    1. n：表示把一个动画周期分成n步执行，1 表示一步执行完，跳变执行，没有过渡动画；
    2. 执行时间为4s，执行次数为3，那么总的动画执行时间为3*4s=12s
1. steps(1, end)的执行过程：
    0% 等待1s -&gt; 25% 等待1s -&gt; 50% 等待1s -&gt; 75% 等待1s =&gt; 动画执行1次=&gt; 75% 等待1s
    -&gt; 50% 等待1s -&gt; 25% 等待1s -&gt; 0% 等待1s =&gt; 执行2次=&gt; 0% 等待1s -&gt; 25% 等待1s-
    -&gt; 50% 等待1s -&gt; 75% 等待1s =&gt; 执行3次=&gt; 100% =&gt; 动画结束
    1. 动画执行1次结束、开始执行第2次时，还会在75%的状态等待1s，相当于在75%等待了2s
    2. 同理，第2次执行结束、开始执行第3次时，也会在0%再等待1s
    3. 其实，第3次执行结束后，动画已经结束了，但因为animation-fill-mode:both; 所以元素
    最后的状态必须处在最后一帧，即100%的状态；
    4. 综上所述，end是看不到最后一帧的，也就是100%时的状态。
2. steps(1, start)的执行过程：
    25% 等待1s -&gt; 50% 等待1s -&gt; 75% 等待1s -&gt; 100% 等待1s =&gt; 执行1次 =&gt; 100% 等待1s
    -&gt; 75% 等待1s -&gt; 50% 等待1s -&gt; 25% 等待1s =&gt; 执行2次=&gt; 25% 等待1s -&gt; 50% 等待1s
    -&gt; 75% 等待1s -&gt; 100% 等待1s =&gt; 动画结束
    1. 动画开始执行时，已经从0%跳变到25%，所以在这个动画的执行过程中，都没有0%的状态；
    2. 所以，start是看不到第一帧的，也就是0%时的状态。
3.steps()的跳变动画，可用于实现连环画的效果，比如GIF表情包
    1. 以微信的兔斯基表情为例，一张连续动作的静态图片，假设一共12个动作，加上最后一张空白
    2. 把图片设置为background-image的属性值，再通过animation修改background-position
    @keyframes move { from{} to{}}
    3. steps(12, end)：把 from-&gt;to 的一个周期划分为12步，即12帧，再设置次数为infinite
    4. end看不到最后一帧，但动作表情是12个，第13个是空白，用于占位，所以刚好看不到第13帧
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/05/07/CSS3-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/07/CSS3-1/" itemprop="url">CSS3-1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-07T00:00:00+08:00">
                2018-05-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML/" itemprop="url" rel="index">
                    <span itemprop="name">HTML</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><pre><code>1. 基本选择器的扩展
    1. E &gt; F { ... }：直接后代选择器，匹配E的直接后代F，第一层级的子元素；
    2. E + F：相邻兄弟选择器，只匹配与E相邻的下一个兄弟F；
    3. E ~ F：通用兄弟选择，匹配E的所有兄弟F；
    4. 测试时不能使用可继承的属性，如color，必须使用不可继承的属性。
2. CSS没有版本之分，只有级别，CSS3指的是CSS的第三个级别；
3. 属性选择器
    1. E[attr]：使用了选择器E，且使用了属性attr，如#box[name]{ color: #0000ff; }
    2. E[attr=&quot;val&quot;]：属性名为attr，且属性值为val，如div[name=&quot;box&quot;]{ ... }
    3. E[attr~=&quot;val&quot;]：属性值是一个以空格作为分割的列表，其中至少一个值为val
    &lt;div name=&quot;box cnb cty&quot; class=&quot;test&quot;&gt;&lt;/div&gt; ===&gt; .test[name~=&quot;cnb&quot;]{...}
    4. E[attr|=&quot;val&quot;]：attr的属性值为val，或以&quot;val-&quot;开头；
    5. E[attr^=&quot;val&quot;]：属性值以&quot;val&quot;开头；
    6. E[attr$=&quot;val&quot;]：属性值以&quot;val&quot;结尾；
    7. E[attr*=&quot;val&quot;]：属性值的字符串中包含&quot;val&quot;
    8. E并不是属性选择器的构成部分，也是选择器，是为了限制属性选择器的作用范围。
</code></pre><h3 id="伪类与伪元素选择器"><a href="#伪类与伪元素选择器" class="headerlink" title="伪类与伪元素选择器"></a>伪类与伪元素选择器</h3><pre><code>1. 伪类：并存在于DOM树中，只是为了让CSS有能力获取DOM节点以外的元素状态；
2. 链接伪类：只能应用与&lt;a&gt;，:link、:visited、:target(选中锚点URI对应的id样式)
    a:link{ color: black; } --&gt;未访问过的样式
    a:visited{ color: red; } --&gt;访问过的样式，必须清除浏览器的历史纪录才能还原样式
    1. :visited与浏览器地址栏上的URL有关，如果&lt;a href=&quot;javascript:;&quot;&gt;，点击&lt;a&gt;，
    地址栏的URL是不变的，即浏览器不认为&lt;a&gt;被访问过，那么:visited也不会相应；
    2. 与href=&quot;javascript:;&quot;不同，href=&quot;#&quot;虽然也能阻止&lt;a&gt;的默认跳转，但地址栏的URL
    尾部会添加&quot;#&quot;，:visited也会响应；
    3. :visited中只有3个样式属性有效：color、background-color、border-color
    4. :target：href=&quot;#box&quot;时，地址栏URL后会添加&quot;#box&quot;，:target则匹配id=&quot;box&quot;的
    元素，同理，点击&lt;a href=&quot;box2&quot;&gt;，:target又会重新匹配id=&quot;box2&quot;的元素；
    :target{ color: green; }
    &lt;div id=&quot;box&quot;&gt;BOX&lt;/div&gt; &lt;a href=&quot;#box&quot;&gt;ToBox&lt;/a&gt;
    &lt;div id=&quot;box2&quot;&gt;BOX2&lt;/div&gt; &lt;a href=&quot;#box2&quot;&gt;ToBox2&lt;/a&gt;
3. 动态伪类：:hover(鼠标悬停在元素上的样式)、:active(鼠标点击/按下时的元素样式)
    1. :hover和:active可以作用在任意元素上，使用的CSS属性也不受限制；
    &lt;div id=&quot;box&quot;&gt; &lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt; &lt;/div&gt;
    #box ul { display: none; } ------&gt; 正常情况下，&lt;ul&gt;是隐藏的
    #box:hover ul { display: block; } ---&gt; 当鼠标悬停在box上时，让&lt;ul&gt;显示
    2. :link、:visited、:hover、:active同时使用时，必须遵循一定的顺序：l-v-h-a
4. 表单相关伪类：:enabled、:disable、:checked、:focus
    1. :enabled、:disable分别匹配可编辑和被禁用的表单；
    2. :checked、:focus分别匹配被选中和获得焦点的表单；
    3. 自定义单选框：只用CSS实现，不借助JS
    label { float:left; width:100px; height:100px; border 2px solid;
    border-radius:50%; overflow:hidden; position:relative; } --&gt;label做单选框
    label &gt; span { position:absolute; left:0; top:0; right:0; bottom:0; }
    input { position:absolute; left:-50px; top:-50px; } --&gt; 隐藏掉原单选框
    input:checked + span { blackground:red; } --&gt;选中input时，让span模拟选中样式
    &lt;label&gt;
        &lt;input type=&quot;radio&quot; name=&quot;hobby&quot; /&gt; &lt;span&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;label&gt;
        input type=&quot;radio&quot; name=&quot;hobby&quot; /&gt; &lt;span&gt;&lt;/span&gt;
    &lt;/label&gt;
    ---&gt; &lt;label&gt;是内联元素，使用浮动是为了让其转为内联块元素，支持宽高
    4. 原理：&lt;label&gt;与&lt;input type=&quot;radio&quot; /&gt;一起使用时，点击&lt;label&gt;可会选中单选框，
    再利用同name的单选框是互斥的，隐藏&lt;input&gt;，选中用&lt;span&gt;的样式代替。
</code></pre><h4 id="结构性伪类"><a href="#结构性伪类" class="headerlink" title="结构性伪类"></a>结构性伪类</h4><pre><code>1. 类型：:nth-child(index)系列、:nth-of-type(index)系列、:not、:empty
2. 索引index从1开始计数，且可以设置为变量n或n的表达式，n从0开始计数，如偶数2n、奇数2n+1
3. E:nth-child(1){ ... }：匹配使用了E选择器的元素、且是其父元素下的第一个子元素；
    1. 如果不指定E，则匹配整个文档的、符合条件的元素；
    &lt;ul id=&quot;warpper&quot;&gt;
        &lt;li&gt;Test1&lt;/li&gt; &lt;li&gt;Test2&lt;/li&gt; &lt;li&gt;Test3&lt;/li&gt;
    &lt;/ul&gt;
    #wrapper li:nth-child(1){ color:red; } ---&gt;匹配Test1
    2. :nth-child(index)系列的其他类型：:first-child、:last-child、:only-child、
    :nth-last-child(index)
    3. E:first-child{ ... }、E:last-child{ ... } 分别匹配第一个和最后一个；
    4. E:nth-last-child(index){ ... } 表示倒序匹配；
    5. E:only-child{ ... } 匹配父元素只有一个子元素、且子元素类型为E
4. E:nth-of-type(1){ ... }：查找父元素下的所有类型为E的子元素，再匹配其中的第一个；
    &lt;ul id=&quot;warpper&quot;&gt;
        &lt;li&gt;Test1&lt;/li&gt; &lt;li&gt;Test2&lt;/li&gt; &lt;p&gt;Test4&lt;/p&gt;
    &lt;/ul&gt;
    #wrapper p:nth-of-type(1){ color:red; } --&gt;匹配Test4
    1. :nth-of-type系列的其他类型：:first-of-type、:last-of-type、:only-of-type、
    :nth-last-type(index)
5. 两种系列的区别：
    1. E:nth-of-type(index)以元素为中心，E始终是标签名，即使把E指定为class选择器，
    解析时也会被替换为元素的标签名；而E:nth-child(index)则不会；
    &lt;div id=&quot;wrap&quot;&gt;
        &lt;div class=&quot;inner&quot;&gt;div&lt;/div&gt;
        &lt;p class=&quot;inner&quot;&gt;p&lt;/p&gt;
        &lt;span class=&quot;inner&quot;&gt;span&lt;/span&gt;
    &lt;/div&gt;
    #wrap .inner:nth-of-type(1) { ... } ---&gt;相当于：#wrap div:nth-of-type(1),
    #wrap p:nth-of-type(1), #wrap span:nth-of-type(1) { ... }，所以都会匹配
6. E:empty{ ... }：E不能包含任何子元素、文本、空格，如&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;
7. E:not(F){ ... }：E和F都可以是选择器，匹配所有E，除了F
    &lt;div id=&quot;box&quot;&gt;
        &lt;p&gt;container&lt;/p&gt; &lt;p&gt;container&lt;/p&gt; &lt;p&gt;container&lt;/p&gt;
    &lt;/div&gt;
    #box &gt; p:not(:last-child){ ... } --&gt;除了最后一个&lt;p&gt;，其他子元素都匹配
</code></pre><h4 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h4><pre><code>1. 伪元素：仍是元素，只是不在DOM树中，是为了让CSS操作DOM树以外的元素；
    #box::before{ display:block; content:&quot;&quot;; width:80px; height:80px;
        border:1px solid black; position:absolute; left:0; top:20px; }
    1. 伪元素仍是元素，像使用普通DOM元素一样，对其使用定位，默认参照的仍是初始包含块；
    2. 伪元素建议使用双冒号：E::after{ ... }、E::before{ ... }
    3. 伪元素中必须使用content属性，用于添加文本内容，如果不需要，则设置为空字符串。
2. E::after、E::before：可以向DOM文档中插入新的元素，但并不存在于DOM树中；
    1. E::after、E::before分别是向元素E的末尾/开始插入一个子元素。
3. E::first-letter、E::first-line：分别匹配E中的第一个文字、第一行文字；
4. E::selection{ color:#ff0; background:red; }：文本被鼠标选中时的样式；
</code></pre><h3 id="CSS声明的优先级"><a href="#CSS声明的优先级" class="headerlink" title="CSS声明的优先级"></a>CSS声明的优先级</h3><pre><code>1. 选择器的特殊性：由选择器本身的组件确定，特殊性的值表述为4个部分，如 0,0,0,0
    1. id选择器的特殊性为：0,1,0,0 --&gt; #box{ ... }
    2. 类属性选择器、属性选择器、或伪类选择器的特殊性为：0,0,1,0
    3. 元素和伪元素选择器的特殊性为：0,0,0,1 ---&gt; div{ ... }
    4. 通配符选择器的特殊性为：0,0,0,0 --&gt; *{ ... }
    5. 结合符对特殊性没有任何贡献，如body,ul,li{ ... }
    6. 内联声明的特殊性都是1,0,0,0
    7. 继承没有特殊性，比0,0,0,0的优先级还要低；
    8. 特殊性的值可以累加，但不会进位，比如12个0,1,0,0的累加值为0,12,0,0
    9. 选择器的特殊性最终都会授予其对应的声明，构成CSS的优先级。
    div[id=&quot;test&quot;]{ ... } --&gt;0,0,1,1   #test{ ... } --&gt;0,1,0,0
2. 重要声明：对于某个比较重要的声明，超过了其他所有声明，CSS2.1称为重要声明；
    1. 在重要声明的结尾、分号之前插入 !important 来标志，如color: red !important;
    2. 实际上，浏览器会把重要声明和普通声明分别划分成一组，在各自的分组内部解决冲突；
    3. 重要声明虽然没有特殊值，但重要声明与普通声明产生冲突时，重要声明总是胜出。
3. CSS的来源决定了CSS的权重
    1. CSS样式的来源大致有三种：创作人员(开发者)、读者(用户)、用户代理(浏览器)
    2. 来源的权重：读者的重要声明&gt;创作人员的重要声明&gt;创作人员的普通声明&gt;读者的普通声明&gt;
    用户代理的声明，用户代理不会加重要声明，所以用户代理没有重要声明；
    3. 在浏览器的开发者模式下，查看样式时，用户代理的样式标识：user agent stylesheet
    4. 开发者模式下直接手动修改样式，也是属于创作人员的声明；
    5. Chrome和Firefox并没有提供读者的样式接口，需要借助插件(Stylish)导入样式表；
    6. IE提供了读者的样式接口，可以导入外部的CSS文件，属于读者的样式声明。
4. 层叠样式表：CSS声明优先级的真正体现
    1. 找出所有的相关规则，这些规则都包含一个CSS选择器；
    2. 计算声明的优先级：先按来源排序，如果来源相同，再按选择器的特殊性排序，如果特殊性也
    相同，则按排列的顺序.
</code></pre><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><pre><code>1. CSS3的自定义字体：@font-face
    1. @font-face：允许为网页指定在线字体，通过这种方式可以消除对用户电脑字体的依赖；
    @font-face { font-family: &quot;Test&quot;; src: url(font/BAUHS93.TTF) }
    #box { font: 16px &quot;Test&quot;; } ---&gt; 使用自定义字体Test
    2. font-family：指定字体的名称，用于font/font-family属性；
    3. src：字体资源的地址；把字体保存在服务器上，就不再依赖用户电脑上的字体，保持统一。
2. 字体图标：只需要下载一次字体包，降低了网络的负担，使得操作更加友好，而且是矢量图；
    1. 与位图相比，矢量图放大后不会失真，但矢量图的色调通常比较单一；
    2. 字体图标也是一种字体，通过color和font-size可以控制图标的颜色和大小。
    3. 制作矢量图(Ai) --&gt; 把矢量图与字符绑定，生成字体图标(FontLab Studio) --&gt; 把生成
    的字体图标制作成自定义字体(网站工具) --&gt; 引入自定义字体，使用该字符时，就会自动转为所
    绑定的矢量图
    4. www.fontsquirrel.com/tools/webfont-generator：字体兼容性处理网站，可以把字体
    转为自定义字体，生成stylesheet.css
3. 批量生成自定义字体：https://icomoon.io/#home，把矢量图与字符绑定，制作字体图标
    1. 生成style.css，其内部是伪元素选择器:before{ content: &quot;字体图标的绑定字符&quot; }
    2. 在使用style.css中的字体图标时，只需要使用其中的选择器即可。
</code></pre><h2 id="CSS3新增UI方案"><a href="#CSS3新增UI方案" class="headerlink" title="CSS3新增UI方案"></a>CSS3新增UI方案</h2><h3 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h3><pre><code>1. opacity：设置盒子的透明度，属性值的范围是 0-1
    1. 虽然不可继承，但透明度也会同时作用在其子元素上；
    2. 为了兼容IE浏览器，还必须设置filter: alpha(opacity=30);
2. rgba：同时设置颜色及颜色的透明度，如rgba(0, 0, 0, .8)，透明度为0.8
3. text-shadow：文字阴影，可以添加多层，每层用&quot;,&quot;隔开，第一个阴影在最上面
    text-shadow: 阴影色 水平偏移量 垂直偏移量 模糊值, 阴影色 水平偏移量 ...
    1. 浮雕文字：h1 { color: white; text-shadow: black 1px 1px 10px; }
    2. 文字模糊：h1:hover{ color:rgba(0,0,0,0); text-shadow:black 0 0 100px; }
4. -webkit-text-stroke：文字描边，不算是CSS3，只有webkit内核才支持
5. direction：控制文字的方向，一定要与 unicode-bidi:bidi-override; 配合使用；
    .content { direction:rtl; unicode-bidi:bidi-override; } --&gt;文字从右向左排列
6. text-overflow：未显示内容的溢出信号，显示省略号，但不支持内联元素；
    1. 配合 white-space:nowrap; overflow:hidden; 实现溢出内容显示省略号；
    .wraper { white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
</code></pre><h3 id="盒模型样式"><a href="#盒模型样式" class="headerlink" title="盒模型样式"></a>盒模型样式</h3><pre><code>1. box-shadow：盒模型阴影
    box-shadow: inset 阴影色 水平偏移量 垂直偏移量 模糊值 阴影扩展大小, inset ...
    1. 阴影的真实大小=盒子大小+阴影扩展大小，默认的阴影大小就是盒子大小；
    2. box-shadow默认是外阴影，在盒子的右下角，偏移量可以设置为负值，改变阴影的位置；
    3. inset表示设置内阴影，阴影扩展大小也可以设置为负值，阴影也可以叠加，用&quot;,&quot;隔开。
2. -webkit-box-reflect：元素的倒影，只有webkit内核支持
    1. -webkit-box-reflect: 倒影的方向(above,below,right,left) 倒影的距离 渐变
    2. 移动端的浏览器(IOS、Android)都是webkit内核，所以倒影和文字描边常用于移动端。
3. box-sizing：更改计算元素真实宽高的默认CSS盒子模型，默认属性值为content-box
    1. 默认情况下，设置盒子的padding会增大盒子的真实大小；
    2. box-sizing:border-box; --&gt;盒子的真实大小始终为width/height，设置的padding会
    占用width/height的大小，类似于Android上的EditText
4. resize：允许控制一个元素的可调整大小，必须与 overflow:auto/hidden; 配合使用；
    1. 不可继承，默认值为none，元素不能被缩放；
    2. horizontal/vertical：只允许在水平/垂直方向上调整元素的大小。
    3. both：允许在水平和垂直方向上调整元素大小，原理是在盒子上动态添加style样式。
</code></pre><h3 id="新增UI样式"><a href="#新增UI样式" class="headerlink" title="新增UI样式"></a>新增UI样式</h3><pre><code>1. border-radius：圆角，设置为百分比时参照盒子的width和height
    1. border-radius: 10px(左上角) 20px(右上角) 30px(右下角) 40px(左下角)
    2. border-radius: 10px(左上角、右下角) 30px(右上角、左下角)
    3. border-radius: 10px(左上角) 20px(右上角、左下角) 30px(右下角)
    4. border-radius: 50%; --&gt; 同时设置4个角，不支持负数
    5. 第二种语法：border-radius:10px/20px; 10px/20px 30px; 10px/20px 30px 40px;
    border-radius: 10px/20px 30px 40px 50px;
2. border-radius使用百分比的兼容性
    1. 在旧版本的Chrome和Safari中不支持使用百分比值(fixed in 09/2010)
    2. Opera11.50之前的版本中也不支持百分比值；
    3. Gecko2.0(Firefox4)版本之前的实现不标准：水平/垂直半轴都相对于盒子的宽度；
    4. IOS5之前、Android webkit532之前都不支持百分比值，所以移动端开发尽量使用px值。
3. border-image：边框图片，允许CSS属性在元素的边框上绘制图像，会替换掉border-style
    1. border-image-source：设置边框上的图片，替换border-style，默认值为none
    border-image-source: url(img/border.png); --&gt; 如果不设置，仍使用border-style
    2. border-image-slice：可以设置4个值，来控制切片线的位置，默认值100%，相对于图片；
    3. border-image-repeat：填充边框的模式，默认值stretch(拉伸)，repeat/round(平铺)
    单个值表示设置所有边框，两个值表示分别设置水平与垂直的边框；
    4. border-image-width：默认值为1，如果不指定，图像边框的宽度使用border-width
    5. border-image-outset：边框图像可超出边框盒的大小，放大边框。
4. background：背景新增属性
    1. background-image支持设置多张背景图，且前者叠加在后者之上；
    background-image: url(img/a.png) url(img/b.png) url(img/c.png);
    2. 默认从padding box开始绘制，从border box开始剪裁，超出盒子边框的部分被裁剪；
    3. background-origin：设置背景渲染的起始位置，默认值padding-box，不填充边框
    background-origin:content-box; --&gt; 从内容区开始渲染，不填充边框和内边距
    background-origin:border-box; --&gt; 从border box开始渲染，填充边框和内边距
    4. background-clip：设置背景的裁剪位置，默认值border-box，即超出盒子的部分被裁剪
    background-clip: padding-box; --&gt; 从padding box开始裁剪，即超出内边距就裁剪
    background-clip: content-box; --&gt; 从内容区开始裁剪，即超出内容区就裁剪
    5. background-origin和background-clip不只是设置背景图，对背景颜色也有效；
    6. -webkit-background-clip: text; --&gt;只支持webkit内核，让背景只在文字区域渲染
    文字要设置为半透明才能看到背景的效果；
    7. background-size：设置背景图的大小，默认值auto auto; 分别表示图片的宽度和高度；
    8. 图片的特性就是高宽自适应，保持图片不变形，设置单个值，表示宽度，高度为auto
    9. background-size设置为百分比：背景图相对于背景区域的百分比，真实渲染的背景区域由
    background-origin设置，默认为盒模型的内容区+内边距；
    background-size: 100% 100%; --&gt; 让图片完全填充背景区域，图片可能变形。
</code></pre><h3 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h3><pre><code>1. 渐变是CSS3新增的图片类型(不是颜色)，加快页面的载入时间，页面的缩放效果也比图片更好；
2. 浏览器支持两种类型的渐变：线性渐变(linear-gradient)，径向渐变(radial-gradient)
3. 渐变的方向
    1. 默认从上到下的渐变：background-image:linear-gradient(red, blue); red-&gt;blue
    2. 多颜色的渐变：background-image:linear-gradient(red, yellow, green);
    3. 渐变的方向：top、bottom、left、right
    background-image: linear-gradient(to right, red, blue); --&gt;由左向右的渐变
4. 使用角度：
    1. 以盒子的中心点为圆心，水平方向为-90°~90°(从左到右)，垂直方向为0~180°(从上到下)
    2. 45度方向的多色渐变：linear-gradient(45deg, red, yellow, green);
    3. 控制颜色的分布：linear-gradient(red 长度px/百分比, blue 长度px/百分比, ...)
    background-image: linear-gradient(90deg, red 10%, blue, gray);
    4. 10%的含义并不是red占10%，而是纯色的red占10%，从10%处开始渐变。
5. 渐变区间的判定
    1. 如果每个颜色上都是用了长度px或百分比，它们之间必须存在差值，否则不会发生渐变；
    1. linear-gradient(90deg, red 10px, blue 10px)：两个颜色值的占比相同时，并不会
    发生渐变，而是red占盒子的10%，而blue占盒子的90%；
    2. linear-gradient(90deg, red 10px, blue 20px)：10px的差值，则red占盒子的10%，
    渐变色占10%，blue占80%，即在red和blue之间的渐变色只有10px的长度。
6. 透明色的渐变：linear-gradient(90deg, rgba(0,0,0,0) 10px, rgba(0,0,0,1) 50px)
7. 重复的渐变：repeating-linear-gradient(90deg, blue, red 100px);
    1. 对于重复的渐变色，通常只指定最后一个颜色的长度/百分比，渐变色块的分布会更均匀；
    2. 如果每种颜色的长度/百分比设置的都一样，最后一种颜色会占据整个盒子，没有渐变。
8. 发廊灯效果
    &lt;div id=&quot;box&quot;&gt; &lt;div id=&quot;hear&quot;&gt;&lt;/div&gt; &lt;/div&gt;
    #box{ width:50px; height:300px; border:1px solid black; overflow:hidden; }
    #hear{ height:600px; background: repeating-linear-gradient(135deg, 
        black 0px, black 10px, white 10px, white 20px); }
    let hear = document.querySelector(&apos;#hear&apos;)
    let flag = 0
    setInterval(()=&gt;{
        flag++
        if(flag &gt;= 300) flag = 0
        hear.style[&apos;margin-top&apos;] = -flag + &apos;px&apos;
    }, 1000/60)
    1. hear的高度比父元素box更大，动态改变hear的margin-top，让hear向上移动；
    2. 缺陷：hear向上移动到临界值时，margin-top重置为0px，会造成瞬间的卡断问题。
9. 光斑动画：文字的闪亮效果
    body { background: black; }
    h1 {
        color: rgba(255,255,255, .3);  font: bold 80px &quot;microsoft yahei&quot;;
        background: linear-gradient(120deg, rgba(255,255,255,0) 100px, 
            rgba(255,255,255,1) 180px, rgb(255,255,255,0) 260px);
        background-repeat: no-repeat;
        -webkit-background-clip: text; --&gt; 让背景只渲染文字所在的区域
    }
    let h1 = document.querySelector(&apos;h1&apos;)
    let flag = -160
    setInterval(() =&gt; {
        flag+=10
        if(flag &gt;= 600) flag = -160
        h1.style[&apos;background-position&apos;] = flag + &apos;px&apos;
    }, 30)
    1. 让背景图(渐变色)只渲染文字区域，且不能重复平铺，同时设置文字为半透明；
    2. 通过改变背景图的background-position，以动态改变背景图的位置，达到闪亮效果。
</code></pre><h3 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变"></a>径向渐变</h3><pre><code>1. radial-gradient()由渐变中心点向四周辐射的颜色渐变，默认均匀分布；
    background-image:radial-gradient(red, blue, green); ==&gt; red-&gt;blue-&gt;green
2. 不均匀分布：radial-gradient(red 50%, blue 70%); --&gt;渐变色只有20%，50%为纯红色
3. 径向渐变默认是椭圆ellipse，指定为圆形：radial-gradient(circle, red, blue);
4. 改变渐变形状的大小
    1. 默认是最近角：radial-gradient(closest-corner circle, red, blue);
    2. farthest-side(最远边)、 closest-side(最近边)、farthest-corner(最远角)
5. 改变圆心(渐变中心)
    radial-gradient(closest-corner circle at 10px 10px, red, blue);
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2017/10/10/Scrapy-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/10/Scrapy-1/" itemprop="url">Scrapy-1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-10T00:00:00+08:00">
                2017-10-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Scrapy"><a href="#Scrapy" class="headerlink" title="Scrapy"></a>Scrapy</h2><pre><code>1. Scrapy是用纯Python实现的，用于爬取网站数据、提取结构性数据；
2. Scrapy使用Twisted(主要竞争者是Tornado)异步网络框架来处理网络通讯，加快下载速度；
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2017/10/07/爬虫基础-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/07/爬虫基础-3/" itemprop="url">爬虫基础-3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-07T00:00:00+08:00">
                2017-10-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="多线程爬虫"><a href="#多线程爬虫" class="headerlink" title="多线程爬虫"></a>多线程爬虫</h2><pre><code>1. 多进程通常应用于计算密集型，多线程通常应用于IO密集型，网络数据传输其实就是IO数据流，
   所以爬虫大多使用多线程，配合队列Queue实现线程间的数据交互；
2. 尽管多线程在Python中比较鸡肋，但对于多路IO复用，通常还是使用多线程；
3. from Queue import Queue：先进先出
    1. queue = Queue(10)：创建队列，并指定队列的最大容量；不指定，则表示无限大；
    2. queue.qsize()：查看队列的大小；
    3. queue.empty()：如果队列为空，则返回True；
    4. queue.full()：如果队列满了，则返回True；
    5. queue.put()：向队列中存放一个数据；
    6. queue.get([block[, timeout]])：获取队列中的一个数据，timeout等待时间；
    block默认值为True，当队列为空时，则进入阻塞状态，不会结束，直到队列中有新的值；
    block=False，当队列为空时，不会等待，直接报一个Queue.empty的异常。
</code></pre><h2 id="动态HTML"><a href="#动态HTML" class="headerlink" title="动态HTML"></a>动态HTML</h2><pre><code>1. 动态HTML的技术：JavaScript、jQuery、Ajax、DHTML
    1. jQuery可以动态创建HTML内容，只有在JS代码执行之后才会显示，而传统方法只能采集
    JS代码执行之前的内容；
    2. AJAX不是一门语言，而是用来完成网络任务的一系列技术，可以在网页不刷新的情况下，
    完成与服务器的网络交互，收发数据；
    3. DHTML：动态HTML，与AJAX一样，也是一系列用于解决网络问题的技术集合；
    DHTML是用客户端语言改变页面的HTML元素，比如页面上的按钮只有当移动鼠标之后才出现，
    背景色可能每次点击都会改变，或者用一个Ajax请求触发页面加载一段新内容；
    网页是否属于DHTML，关键是有没有用JS控制 HTML和CSS元素。
2. 解决动态HTML：
    1. 直接从JavaScript代码里采集内容，但过于费时费力；
    2. 用Python的第三方库运行JavaScript，直接采集在浏览器里看到的页面。
</code></pre><h3 id="Selenium与PhantomJS"><a href="#Selenium与PhantomJS" class="headerlink" title="Selenium与PhantomJS"></a>Selenium与PhantomJS</h3><pre><code>1. Selenium是一个Web的自动化测试工具，最初是为网站自动化测试而开发的；
    1. Selenium可以按指定的命令自动操作，可以直接运行在浏览器上，支持所有主流浏览器，
    包括PhantomJS这些无界面的浏览器。
    2. Selenium可以根据指定的命令，让浏览器自动加载页面，获取需要的数据；
    3. Selenium还提供页面截屏功能，查看浏览器当前的行为；
    4. Selenium本身并不带浏览器，不支持浏览器的功能，需要与第三方浏览器结合才能使用；
    但有时候需要让它内嵌在代码中运行，所以就可以使用PhantomJS代替真实的浏览器。
    5. 安装：pip install selenium
2. PhantomJS是一个基于Webkit的无界面浏览器，它会把网站加载到内存、并执行页面上的JS；
    1. PhantomJS不会展示图形界面，所以运行起来比完整的浏览器要高效；
    2. 尽管PhantomJS是无界面的，但Selenium的页面截屏功能可以查看页面的行为；
    3. 把Selenium和PhantomJS结合在一起，就可以运行一个非常强大的网络爬虫了，这个爬虫
    可以处理JS、Cookie、headers，以及任何真实用户需要做的事情。
    4. PhantomJS是一个功能完善的浏览器(无界面)，并不是一个python库，所以不能像py库
    一样安装，但可以通过Selenium调用PhantomJS来直接使用；
3. Selenium与PhantomJS虽然是很强大的工具，但性能上比真实浏览器要低，使用后及时关闭。
4. Selenium里有WebDriver API，WebDriver有点儿像可以加载网站的浏览器，但它也可以像
   BeautifulSoup或者其他Selector对象一样用来查找页面元素、与页面上的元素进行交互(发送
   文本、点击等)、执行其他动作来运行网络爬虫：from selenium import webdriver
    1. ubuntu下载PhantomJS，引用其bin目录下的phantomjs文件，创建浏览器对象；
    driver = webdriver.PhantomJS(executable_path=&quot;./phantomjs&quot;)
    2. 配置环境变量~/.bashrc，指定phantomjs文件的路径：
    PHANTOMJS_HOME=/home/python/phantomjs
    export PATH=$PATH:$PHANTOMJS_HOME
    3. 让环境变量生效：source ~/.bashrc --&gt; driver = webdriver.PhantomJS()
    4. 访问豆瓣网：driver.get(&apos;https://www.douban.com/&apos;)
    5. driver.title：获取页面标题；    driver.current_url：获取当前的URL；
    6. html = driver.page_source：获取页面源码；
    7. driver.save_screenshot(&quot;douban.png&quot;)：生成当前页面快照/截图并保存；
    8. driver.close()：关闭当前页面，如果只有一个页面，则关闭浏览器；
    9. driver.quit()：退出，关闭浏览器。
5. driver = webdriver.Chrome()/Firefox()/Ie() --&gt; 启动Chrome/Firefox/IE浏览器
   同理，也需要分别安装三大浏览器的驱动driver，并配置环境变量。
</code></pre><h4 id="页面操作"><a href="#页面操作" class="headerlink" title="页面操作"></a>页面操作</h4><pre><code>&lt;input type=&quot;text&quot; name=&quot;uname&quot; id=&quot;uname&quot; class=&quot;box&quot; /&gt;
1. 获取标签--&gt; driver.find_element_by...()，driver.find_elements_by...()
    1. driver.find_element_by...()：获取一个标签；
    2. driver.find_elements_by...()：获取一组标签；
    3. element = driver.find_element_by_id(&quot;uname&quot;)
    4. find_element_by_name(&quot;uname&quot;)、find_element_by_tag_name(&quot;input&quot;)
    5. find_element_by_class_name(&quot;box&quot;)、find_element_by_css_selector()
    6. find_element_by_xpath(&apos;//input[@id=&quot;uname&quot;]&apos;)
    7. find_element_by_link_text()、find_element_by_partial_link_text()
2. 获取标签--&gt; driver.find_element()、driver.find_elements()
    1. from selenium.webdriver.common.by import By
    2. find_element/find_elements： --&gt; 获取一个/一组标签
    3. element = driver.find_element(by=By.ID, value=&quot;uname&quot;)
    4. By.NAME、By.CLASS_NAME、By.TAG_NAME、By.XPATH
    5. By.LINK_TEXT、By.PARTIAL_LINK_TEXT、By.CSS_SELECTOR
3. 操作标签
    1. element.text：获取标签的文本内容；
    2. 对于输入框，输入内容：element.send_keys(&apos;abc&apos;)，输入中文：u&apos;中国&apos;
    3. 清空输入框：element.clear()
    4. 对于按钮，模拟点击：element.click() --&gt; 点击按钮也相当于发送一个请求
    driver.save_screenshot(&quot;a.png&quot;) --&gt; 查看当前的浏览器行为(最新的页面)；
    5. 通常在执行点击之后，会等待一段时间，待浏览器加载完成，再去执行其他操作。
4. 键盘操作：from selenium.webdriver.common.keys import Keys
    1. Ctrl+A/X全选/剪切输入框的内容：element.send_keys(Keys.CONTROL,&apos;a&apos;/&apos;x&apos;)
    2. 模拟Enter回车键：element.send_keys(Keys.RETURN)
5. 鼠标动作：from selenium.webdriver import ActionChains
    1. btn = driver.find_element_by_id(&quot;btn&quot;)
    2. ActionChains(driver).move_to_element(btn).perform()：鼠标移动到btn位置；
    3. ActionChains(driver).move_to_element(btn).click(btn).perform()：单击； 
    4. double_click(btn)：双击；    context_click(btn)：右击；
    5. click_and_hold(btn)：左键单击hold住；
    6. 将btn1拖拽到btn2的位置：
    ActionChains(driver).drag_and_drop(btn1, btn2).perform()
6. &lt;select&gt;下拉框：from selenium.webdriver.support.ui import Select
    1. select = Select(driver.find_element_by_name(&apos;status&apos;))：选取下拉框；
    2. select.select_by_index(1)：根据索引选取，索引从0开始；
    3. select.select_by_value(&quot;0&quot;)：根据&lt;option&gt;的value属性值选取；
    4. select.select_by_visible_text(u&quot;未审核&quot;)：根据&lt;option&gt;的字符串文本选取；
    5. select.deselect_all()：全部取消选择。
7. 页面弹窗：alert = driver.switch_to_alert()
8. 切换页面窗口：driver.switch_to.window(&quot;window name&quot;)
    for handle in driver.window_handles:
        driver.switch_to_window(handle) --&gt; 遍历每一个窗口的操作对象
9. 页面的前进和后退：driver.forward()、driver.back()
10. 操作Cookie
    1. driver.get_cookies()：获取当前页面的Cookie；
    for cookie in driver.get_cookies():    --&gt; 遍历页面的Cookie
        print &quot;%s: %s&quot; % (cookie[&apos;name&apos;], cookie[&apos;value&apos;])
    2. driver.delete_cookie(&quot;CookieName&quot;)：根据名称删除Cookie；
    3. driver.delete_all_cookies()：删除所有的Cookie；
11. 页面等待
    1. 采用AJAX技术的网页不确定何时加载完成，那么操作DOM就可能抛出空指针异常；
    2. Selenium提供了两种等待方式：显式等待、隐式等待；
    3. 隐式等待是等待特定的时间，显式等待是直到指定的某个条件成立时继续执行；
12. 显式等待：指定某个条件，并设置最长等待时间，如果仍没有找到某个元素，则抛异常；
    1. WebDriverWait：负责循环等待
    from selenium.webdriver.support.ui import WebDriverWait
    2. expected_conditions：负责条件触发
    from selenium.webdriver.support import expected_conditions as EC
    3. 执行等待：
    driver = webdriver.Chrome()
    driver.get(&quot;http://www.xxxxx.com/loading&quot;)
    try: --&gt; 页面一直循环，直到 id=&quot;uname&quot; 出现
        element = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.ID, &quot;uname&quot;)))
    finally:
        driver.quit()
    4. 如果不指定最长等待时间，程序默认会每隔0.5s查看一次元素是否已经生成；
    5. 内置的一些等待条件：title_is、title_contains、visibility_of ...
13. 隐式等待：设置一个等待时间，单位是秒，如果不设置，默认等待0s；
    driver = webdriver.Chrome()
    driver.implicitly_wait(10)    --&gt; 等待10s
    driver.get(&quot;http://www.xxxxx.com/loading&quot;)
    myDynamicElement = driver.find_element_by_id(&quot;uname&quot;)
</code></pre><h4 id="执行JS"><a href="#执行JS" class="headerlink" title="执行JS"></a>执行JS</h4><pre><code>1. JS修改标签样式：
   js = &apos;var q=document.getElementById(&quot;kw&quot;);q.style.border=&quot;2px solid red&quot;;&apos;
   driver.execute_script(js)
2. JS隐藏标签
    1. img = driver.find_element_by_xpath(&quot;//*[@id=&apos;lg&apos;]/img&quot;)
    2. driver.execute_script(&apos;$(arguments[0]).fadeOut()&apos;,img)
3. JS模拟滚动到底部
    1. js = &quot;document.body.scrollTop=10000&quot;
    2. driver.execute_script(js)
</code></pre><h2 id="测试模块"><a href="#测试模块" class="headerlink" title="测试模块"></a>测试模块</h2><pre><code>python的测试模块：import unittest
1. 定义测试类：class TestUnit(unittest.TestCase)
2. 测试模块的初始化方法：def setUp(self) --&gt; 固定名称
3. 定义具体的测试用例方法时，方法名必须以&apos;test&apos;开头，比如：def testDao(self)
4. 退出时的清理方法：def testDown(self) --&gt; 固定名称
5. 执行测试用例：
    if __name__ == &quot;__main__&quot;:
        unittest.main()
</code></pre><h2 id="Tesseract"><a href="#Tesseract" class="headerlink" title="Tesseract"></a>Tesseract</h2><pre><code>机器视觉：文字识别是其一个分支；
OCR：光学文字识别，将图像翻译成文字的技术，Tesseract就是一个OCR库；
1. Tesseract属于Google，是目前最优秀、最精确的开源OCR系统，同时具有很高的灵活性；
2. Tesseract可以通过训练识别出任何字体，也可以识别出任何Unicode字符；
3. linux系统的安装：sudo apt-get tesseract-ocr
    1. 要使用Tesseract的功能，必须设置环境变量$TESSDATA_PREFIX，让Tesseract知道训练
    的数据文件存储在哪里：export TESSDATA_PREFIX=/usr/local/share/Tesseract
    2. 还需要找一份tessdata数据文件，放到Tesseract目录下。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">大麦田怪圈</p>
              <p class="site-description motion-element" itemprop="description">敢做就能赢！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">54</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大麦田怪圈</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
