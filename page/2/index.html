<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="敢做就能赢！">
<meta property="og:type" content="website">
<meta property="og:title" content="大麦田程序猿">
<meta property="og:url" content="http://hellomyshadow.github.io/page/2/index.html">
<meta property="og:site_name" content="大麦田程序猿">
<meta property="og:description" content="敢做就能赢！">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="大麦田程序猿">
<meta name="twitter:description" content="敢做就能赢！">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hellomyshadow.github.io/page/2/">





  <title>大麦田程序猿</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大麦田程序猿</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2017/08/10/Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/10/Redis/" itemprop="url">Redis</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-10T00:00:00+08:00">
                2017-08-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><pre><code>Redis是一种key-value型的NoSQL数据库，配置文件的所在路径：/etc/redis/redis.conf
1. redis.conf的说明：
    1. port 6379：默认端口为6379
    2. daemonize yes：表示以守护线程运行，不会再命令行阻塞，类似于服务；
    3. databases 16：默认16个数据库，编号为0-15，默认使用的是0号数据库；
    4. dbfilename dump.rdb：数据文件；
    5. dir /var/lib/redis：数据文件的存储路径，默认路径为./
2. 启动Redis
    1. 查看Redis是否启动：ps ajx|grep redis
</code></pre><p><img src="https://i.imgur.com/nVUC452.jpg" alt></p>
<pre><code>    2. 配置文件的方式启动
        1. redis-server命令直接启动Redis，会阻塞当前终端；
        2. 如果配置文件所在路径为/usr/local/redis/redis.conf，则拷贝到/etc/redis
        目录下：sudo cp /usr/local/redis/redis.conf /etc/redis/
        3. 指定配置文件启动：sudo redis-server /etc/redis/redis.conf
    3. sudo service redis start/stop/restart：后台启动/停止/重启Redis服务。
3. Redis默认不允许远程访问，修改配置文件：
    1. bind 127.0.0.1  #注释掉 或者改为本机IP;
    2. protected-mode no  #开启远程访问
4. 连接Redis服务：redis-cli，默认连接本机的Redis
5. 切换数据库：select 编号，默认使用的是0号数据库。
</code></pre><h2 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h2><pre><code>1. Redis是key-value类型的数据，所以每个数据都是一个键-值对；
2. 键的类型为字符串；
3. 值的类型有5种：字符串string、哈希hash、列表list、集合set、有序集合zset
</code></pre><h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><pre><code>1. string是Redis最基本的类型，最大存储512MB的数据；
2. string类型是二进制安全的，即可以为任何数据，包括数字、图片、序列化对象等；
3. 设置
    1. set key value：设置键-值，比如set name &apos;python&apos;；
    2. SETEX key seconds value：设置键值及过期时间，以秒为单位，过期之后会被删除；
    3. 设置多个键-值：MSET key value key value ...
4. 获取
    1. GET key：根据键获取值，如果不存在，则返回nil；
    2. MGET key key ...：根据多个键获取多个值。
5. 运算
    1. 运算的前提：值必须是数字；
    2. INCR/DECR key：将key对应的value加/减1；
    3. INCRBY/DECRBY key number：对value加/减整数，number可以是正数/负数；
    4. 追加值：APPEND key value，相当于拼接字符串；
    5. STRLEN key：获取值的长度/字符个数。
</code></pre><h3 id="键操作"><a href="#键操作" class="headerlink" title="键操作"></a>键操作</h3><pre><code>1. KEYS pattern：查找键，参数pattern支持正则表达式，比如KEYS *，查找所有键；
2. EXISTS key key ...：判断某个/某些键是否存在，返回存在的个数，都不存在则返回0；
3. TYPE key：查看key对应的value的类型，虽然返回string，但并不一定代表的是字符串；
4. DEL key key ...：删除键-值；
5. EXPIRE key seconds：重新对键-值设置过期时间；
6. TTL key：查看有效时间，已过期/不存在的键-值返回-2，永久存在的键-值返回-1。
</code></pre><h3 id="hash操作"><a href="#hash操作" class="headerlink" title="hash操作"></a>hash操作</h3><pre><code>hash用于存储对象，对象的格式为键值对；
1. 设置
    1. 单个属性：HSET key field value，比如 HSET py name &apos;Mike&apos;
    2. 多个属性：HMSET key field value field value ...
    3. type key：hash
2. 获取
    1. 一个属性值：HGET key field
    2. 多个属性值：HMGET key field field ...
    3. 获取所有的属性和属性值：HGETALL key，比如 HGETALL py --&gt; &apos;name&apos;，&apos;Mike&apos;
    4. 获取所有属性：HKEYS key
    5. 获取所有属性值：HVALS key
    6. 获取属性的个数：HLEN key
3. 判断属性是否存在：HEXISTS key field，存在则返回1，不存在则返回0；
4. 删除属性及值：HDEL key field field ...
5. 获取属性值的长度：HSTRLEN key field
</code></pre><h3 id="list操作"><a href="#list操作" class="headerlink" title="list操作"></a>list操作</h3><pre><code>列表的元素类型为string，按照插入顺序排序，在列表的头部或尾部添加元素；
一个key对应一个列表，列表为空时，key也会被删除；
1. 设置
    1. 在头/尾部插入一个元素：LPUSH/RPUSH key value value ...
    插入多个元素时，其实也是一个个元素依次插入的，所以最后一元素会排列在头/尾部
    2. 在一个元素的前/后插入新元素：LINSERT key BEFORE/AFTER ref_value value
    3. LSET key index value：指定索引位置插入一个新元素；
        1. index是元素的索引，从 0 开始，索引不能越界；
        2. 索引可以是负数，-1表示列表的最后一个元素。
2. 获取
    1. LPOP/RPOP key：移除并返回列表key的第一个/最后一个元素，空列表则返回nil；
    2. LRANGE key start end：获取索引start到索引end的所有元素；
        1. start和end可以是任意大小，而不会角标越界；
        2. start和end可以是负数，-1表示最后一个元素。
3. LTRIM key start end：裁剪列表，只保留索引start到索引end的元素；
4. LLEN key：返回列表的长度；
5. LINDEX key index：返回索引index对应的元素。
</code></pre><h3 id="set操作"><a href="#set操作" class="headerlink" title="set操作"></a>set操作</h3><pre><code>set是无序集合，元素是string类型，元素具有唯一性，不重复；
1. 添加元素：SADD key member member ...
2. 获取元素：SMEMBERS key
3. SCARD key：返回元素个数；
4. SINTER key key ...：求集合的交集；
5. SDIFF key key ...：求某集合与其它集合的差集；
6. SUNION key key ...：求集合的并集；
7. SISMEMBER key member：判断元素member是否在集合中，存在则返回1，不存在则返回0
</code></pre><h3 id="zset操作"><a href="#zset操作" class="headerlink" title="zset操作"></a>zset操作</h3><pre><code>zset是有序集合，元素是string类型，元素具有唯一性，不重复；
每个元素都会关联一个double类型的score，表示权重，通过权重将元素从小到大排序；
元素的权重score是自定义的，也即可以指定元素的顺序，score可以相同；
1. 添加：ZADD key score member score member ...
2. ZRANGE key start end：返回指定范围内的元素；
3. ZCARD key：返回元素个数；
4. ZCOUNT key min max：返回score在min和max之间的元素个数；
5. ZSCORE key member：返回元素member对应的score，不存在则返回nil；
</code></pre><h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><pre><code>发布者不关心订阅者/接收者的类型，只是将消息发布到不同的频道，会自动推送给订阅者；
订阅者不需要主动请求/获取数据，只需要订阅频道，频道的消息内容就会被推送过来；
发布者和订阅者是解耦和的一种模式，使网络拓扑的扩展性更强、更加动态。
1. 消息的格式包含三个部分：
    1. 第一部分表示消息的类型：
        1. subscribe，表示订阅成功；
        2. unsubscribe，表示取消订阅成功；
        3. message，表示其它终端发布消息。
    2. 当第一部分为subscribe时，则第二部分表示频道，第三部分表示当前订阅频道的数量；
    3. 当第一部分为unsubscribe时，则第二部分表示频道，第三部分表示当前订阅的频道数，
       如果为0，则表示当前没有订阅任何频道；
    4. 当第一部分为message时，则第二部分表示来源频道的名称，第三部分表示消息的内容。
2. 订阅：SUBSCRIBE 频道名称 频道名称 ...
3. 取消订阅：UNSUBSCRIBE 频道名称 频道名称 ... 如果不加参数，则取消所有订阅；
4. 发布：PUBLISH 频道 消息
</code></pre><p><img src="https://i.imgur.com/vggtGkf.jpg" alt></p>
<h2 id="主从配置"><a href="#主从配置" class="headerlink" title="主从配置"></a>主从配置</h2><pre><code>一个主节点可以拥有多个从节点，一个从节点又可以拥有多个从节点，从而形成强大的多级服务器
集群架构；
比如：将Ip为192.168.1.10的机器作为主服务器，将Ip为192.168.1.11的机器作为从服务器
1. 修改主服务器的配置文件：bind 127.0.0.1 --&gt; bind 192.168.1.10
2. 设置从服务器的配置文件：
    1. bind 127.0.0.1 --&gt; bind 192.168.1.11
    2. 换行，再加上：slaveof 192.168.1.10 6379
3. 修改了配置文件之后，必须重启Redis服务；
4. redis-cli命令默认使用的Ip是127.0.0.1，修改了绑定的Ip之后，再次登录主/从服务器时，
   必须指定Ip：redis-cli -h Ip
5. 测试：在主服务器上操作数据库，可以在从服务器上获取到相同的数据。
</code></pre><h2 id="Redis与Python"><a href="#Redis与Python" class="headerlink" title="Redis与Python"></a>Redis与Python</h2><pre><code>1. 安装redis模块
    1. 联网安装：sudo pip3 install redis
    2. 源码安装：
        1. unzip redis-py-master.zip
        2. cd redis-py-master
        3. sudo python setup.py install
2. 导入redis模块：import redis
3. 连接Redis，获取客户端对象：r=redis.StrictRedis(host=&apos;Ip&apos;, port=6379)
</code></pre><h3 id="Python操作Redis的方式"><a href="#Python操作Redis的方式" class="headerlink" title="Python操作Redis的方式"></a>Python操作Redis的方式</h3><pre><code>1. 直接操作：读写方法会被立即执行；
    1. r.set(&apos;name&apos;, &apos;Hello Redis&apos;)：写入数据；
    2. r.get(&apos;name&apos;)：获取数据。
2. 管道操作：在内存中会维护读写操作，在调用管道的 execute() 之后，才会作用于数据库；
    1. pipe = r.pipeline()
    2. pipe.set(&apos;name&apos;, &apos;Hello Redis&apos;)：在管道中做写入操作；
    3. pipe.get(&apos;name&apos;)：在管道中做读取操作；
    4. pip.execute()：将管道中的所有读写操作一次性作用于数据库。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2017/08/09/MongoDB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/09/MongoDB/" itemprop="url">MongoDB</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-09T00:00:00+08:00">
                2017-08-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="NoSQL简介"><a href="#NoSQL简介" class="headerlink" title="NoSQL简介"></a>NoSQL简介</h2><pre><code>NoSQL：Not Only SQL，非关系型数据库，不基于E-R模型，没有统一的结构，不用维护复杂的关系；
    1. NoSQL拥有内存级的数据读写，比物理磁盘级的读写速度更快；
    2. 高可扩展性，分布式计算，低成本，架构灵活，半结构化数据，但没有标准化，程序不直观；
NoSQL的分类：
    1. 列存储：Cassandra、Hypertable
    2. 文档存储：MongoDB、CouchaDB ...
       一般用类似JSON的格式存储，可以为某些字段建立索引，实现关系型数据库的某些功能；
    3. key-value存储：Redis、MemcacheDB、Berkeley DB... 通过key可以快速查询到value；
    4. 图存储：Neo4J、FlockDB
       图形关系的最佳存储，而使用传统的关系型数据库，则性能低下；
    5. 对象存储：db4o、Versant
    6. xml数据库：baseX、Berkeley DB XML
用户在访问一个Web应用时，查找数据的过程：应用 --&gt; NoSQL --&gt; 关系型数据库；
    1. 从关系型数据库中查到的数据，会先缓存到NoSQL中，并设置数据的过期时间，其他用户再次
    访问时，就可以直接从NoSQL中获取数据，提高查询效率，也减轻了关系型数据库的压力；
    2. 比如taobao的主页，每个用户访问的页面都是相同的，在第一次被访问后，就缓存到NoSQL中。
高并发的处理策略：分布式、集群、缓存
    1. 分布式：对于10个服务器，如果一个任务可以分成10个小任务，则每个服务器完成一个小任务；
    2. 集群：后台同时接收10个任务，每个服务器独立完成一个任务；
    3. 缓存：NoSQL数据库做缓存。
</code></pre><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><pre><code>MongoDB：一个基于分布式文件存储的NoSQL数据库；
    1. 内存级的读写效率，在物理上以文件的形式存储数据，数据结构由键-值对组成；
    2. 由C++编写，稳定且性能高，为Web应用提供可扩展的高性能数据存储。
    3. 模式自由：可以不同结构的文档存储在同一个数据库；
    4. 面向集合的存储：适合存储JSON风格的文件形式；
    5. 完整的索引支持：对任何属性都可以索引；
    6. 复制和高可用性：支持服务器之间的数据复制，支持主-从模式及服务器之间的相互复制；
       复制的主要目的是提供冗余及自动故障转移。
    7. 自动分片：支持云级别的伸缩性，支持水平的数据库集群，可动态添加额外的机器。
1. MongoDB与MySQL的概念对比：
    1. database ---&gt; batabase：数据库，MongoDB和MySQL也都支持索引index；
    2. table ---&gt; collection：表 --&gt; 集合；
    3. row ---&gt; document：行 --&gt; 文档，比如 {&apos;name&apos;:&apos;Mike&apos;, &apos;gender&apos;:&apos;男&apos;}
       文档其实就是一个由键值对构成、BSON形式的对象，BSON是JSON的扩展；
    4. column ---&gt; field：列/字段 --&gt; 域/属性；
    5. primary key ---&gt; primary key：主键，MongoDB自动将_id字段设置为主键；
    6. MongoDB不维护复杂的关系，也就不支持表的连接查询。
2. 32位的MongoDB最大只能存储2G的数据，而64位的MongoDB则没有限制；
3. MongoDB也分为服务端mongod和客户端mongo；
    1. 服务端配置文件的目录为/etc/mongod.conf，默认Ip为127.0.0.1，默认端口为27017，
    默认数据库目录/data/db
        1. 显式启动：mongod，会显示启动过程，可以查看是否启动成功；
        2. 后台启动/重启/停止：sudo service mongod start/restart/stop；
        3. 后台启动之后，检查是否启动成功的命令：ps ajx|grep mongod
    2. mongod启动失败
        1. exception ... Data directory /data/db not found.
        解决：在根目录&apos;/&apos;下创建目录/data/db，并修改data的权限为777；
        2. failed to ... /tmp/mongodb ... not permitted.
        解决：1.chown root:root /tmp  2.chmod 777 /tmp
    3. 客户端启动连接：mongo，是一个shell脚本，同时也是一个JS的编辑器；
4. 图形界面的管理软件：robomongo
</code></pre><h2 id="操作MongoDB"><a href="#操作MongoDB" class="headerlink" title="操作MongoDB"></a>操作MongoDB</h2><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><pre><code>1. db：查看当前数据库名，默认数据库是test；
2. db.stats()：查看当前数据库的信息；
3. show dbs：查看所有数据库；
4. use 数据库名：切换数据库，切换一个不存在的数据库，虽然物理上不存在，但是会在新建集合或
    插入数据时自动创建；
5. db.dropDatabase()：删除当前操作的数据库。
</code></pre><h3 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h3><pre><code>1. 创建集合：db.createCollection(集合名, options)
    1. options是可选参数，用于指定集合的配置，限制集合的大小，不指定则表示不设置上限；
    db.createCollection(&apos;sub&apos;, {capped:true, size:10})
    2. capped的默认值为false，表示不设置集合的上限大小；capped设置为true时，size用于
       指定集合的大小，单位是字节，一旦存储的文档达到上限，之前的数据会被覆盖。
2. 查看所有集合：show collections
3. 删除集合：db.集合名.drop()
</code></pre><h3 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h3><pre><code>1. 数据类型
    1. Object ID：每个文档都有一个属性_id，保证文档的唯一性，类似于MySQL中的主键；
        1. _id的类型是Object ID，由MongoDB自动维护，也可以显式设置，但不允许重复；
        2. Object ID是一个12字节的十六进制数：前4个字节是当前时间戳，3个字节的机器ID，
        MongoDB的服务进程ID占2个字节，最后3个字节是简单的增量值。
    2. String：字符串，必须设置为utf-8才有效；
    3. Boolean：存储一个布尔值，true/false；
    4. Integer：整数可以是32位/64位，取决于服务器；  Double：浮点数；
    5. Arrays：数据/列表，一个键对应多个值；
    6. Object：用于嵌入式的文档，即一个文档作为一个值；  Null：存储Null值；
    7. Timestamp：时间戳；  Date：存储当前日期/时间的UNIX时间。
2. 查看集合中的文档：db.集合名.find()
3. 插入文档：db.集合名.insert(document)
    1. db.stu.({name:&apos;Mike&apos;,gender:1})，如果操作的集合不存在，则自动创建；
    2. doc={name:&apos;DD&apos;}，doc.gender=0 --&gt; db.stu.insert(doc)
4. 更新文档：db.集合名.update({query}, {update}, {multi:true/false})
    1. query：查询条件，比如匹配包含键-值为name:&apos;Mike&apos;的文档，条件为{name:&apos;Mike&apos;}；
        如果不设置条件，则用 {} 作占位符；
    2. update：更新的内容；
    3. multi：可选，默认为false，表示只更新匹配的第一条文档，设置为true表示全部更新；
    4. update默认会对除了_id属性之外的所有属性覆盖更新，修改掉整个文档的结构：
</code></pre><p><img src="https://i.imgur.com/ugdmhbD.jpg" alt></p>
<pre><code>5. $set：只修改指定的属性，如果该属性不存在，则相当于为匹配的文档添加一个新的属性；
        而且，multi 必须和 $ 配合使用才有效，单独使用 multi 会报异常；
</code></pre><p><img src="https://i.imgur.com/9LNzoX8.jpg" alt></p>
<pre><code>5. 保存(添加/修改)：db.集合名.save(document)
    如果文档的_id已经存在，则相当于修改文档，如果不存在，则添加一个新的文档。
6. 删除：db.集合名.remove({query}, {justOne:false})
    1. query：删除的文档条件；
    2. justOne：可选，默认为false，表示删除所有匹配的文档，设置为true/1，只删除第一条；
    3. remove({}) 表示删除所有文档。
</code></pre><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><pre><code>1. db.集合名.find({条件文档})：查询匹配条件的所有文档；
2. db.集合名.findOne({条件文档})：只查询第一条匹配的文档；
3. find({条件文档}).pertty()：格式化显示文档；
4. 比较运算符
    1. 没有显式的等于运算符，默认就是等于判断；
    2. $lt：小于，$lte：小于或等于，$gt：大于，$gte：大于或等于，$ne：不等于；
    3. find({age:{$gt:18}})：查询年龄age&gt;18的文档。
5. 逻辑运算符
    1. 默认就是逻辑与，没有显式的逻辑与运算符；
    find({age:{$lt:20},gender:1})：查询年龄小于20，且性别为1的文档；
    2. $or：逻辑或，对应一个文档数组[{...},{...},{...}]
    find({$or:[{age:{$lt:20}},{gender:1}]})：年龄小于20，或性别为1的文档；
    3. 逻辑与和逻辑或同时使用：find({$or:[{age:{$lt:20}},{gender:1}],name:&apos;Mike&apos;})
        年龄小于20，或性别为1，且姓名为Mike的文档。
6. 范围运算符
    1. $in：在指定的数组中[x,y,z]；
    2. $nin：不在某个范围内；
    3. find.({age:{$in:[10,18,20]}})：年龄为10/18/20的文档。
7. 支持正则表达式
    1. /正则/，&amp;regex
    2. find({name:/^李/})，find({name:{$regex:&apos;^李&apos;}})：查询姓李的文档。
8. 自定义查询
    1. $where：JavaScript结合Mongo进行查询，使用JS定义查询的函数，功能强大；
    2. find({$where:function(){return this.age&gt;20}})：年龄age&gt;20的文档。
</code></pre><h3 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h3><pre><code>1. limit与skip
    1. db.集合名.find().limit(number)：显示number条文档，不指定number则显示全部；
    2. db.集合名.find().skip(number)：跳过number条文档，默认值为0；
    3. limit()和skip配合使用(不分先后)，才可以实现MySQL中的分页limit；
    4. find().skip(5).limit(4)：跳过5条文档，取第6条到第9条文档。
2. 投影
    1. 在返回查询的结果时，只希望显示文档的指定字段，而不显示整个文档；
    2. 投影文档是 find() 的第二个参数：find({},{属性名:1,...})，设置为1，表示显示；
       设置为0 或不设置，则不显示；但是，_id默认是显示的，需要手动设置为0 才会不显示。
3. 排序：sort()
    1. 对结果集排序：db.集合名.find().sort({属性:1,...})，1 升序，-1 降序；
    2. 比如 db.stu.sort({gender:-1,age:1})：先根据性别降序，再根据年龄升序；
    3. 结果集默认是根据_id属性排序。
4. 统计：count()
    db.集合名.find({条件文档}).count() 等效于 db.集合名.count({条件文档})
5. 消除重复：distinct()
    1. db.集合名.distinct(&apos;属性名&apos;,{条件文档})，也可以结合 find() 使用；
    2. 比如 distinct(&apos;gender&apos;,{age:{$gt:18}})：查找年龄age&gt;18的性别，并去重；
    3. 查询的结果集是一个数组/列表，元素是gender的属性值。
</code></pre><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><pre><code>db.集合名.aggregate([{管道:{表达式}}])
1. 管道
    1. 在Unix和Linux中，管道一般用于将当前命令的输出结果，作为下一个命令的输入；
       比如 ps ajx | grep mongo：grep 从 ps ajx 得到的结果集中搜索 mongo
    2. 在MongoDB中，管道具有同样的作用，文档处理完毕后，通过管道进行下一次处理。
2. 常用的管道
    1. $group：对集合中的文档分组，可用于统计结果；
    2. $match：过滤数据，只输出匹配条件的文档；
    3. $project：投影，修改输入文档的结构，如重命名、增加、删除属性、创建计算结果...
    4. $sort：将输入文档排序后输出；
    5. $limit：限制聚合管道返回的文档数；
    6. $skip：跳过指定数量的文档，并返回剩下的文档；
    7. $unwind：将数组类型的属性进行拆分。
3. 表达式
    1. 表达式:&apos;$属性名&apos;
    2. 常用表达式
        1. $sum：计算总和，$sum:1 和 count() 都表示计数；
        2. $avg：计算平均数；
        3. $min/max：获取最小/最大值；
        5. $push：在结果文档中插入值到一个数组中；
        6. $first/last：根据资源文档的排序获取第一个/最后一个属性值。
</code></pre><h3 id="分组：-group"><a href="#分组：-group" class="headerlink" title="分组：$group"></a>分组：$group</h3><pre><code>1. _id 表示分组的依据，不能自定义，使用属性的格式：&apos;$属性名&apos;；
比如，统计男生女生的人数：
</code></pre><p><img src="https://i.imgur.com/R5ZPW3Q.jpg" alt></p>
<pre><code>$sum:1 表示计数，$sum:&apos;$属性名&apos; 则表示基于某个属性求和，比如对年龄求和：$sum:&apos;$age&apos;；
同理，$avg:&apos;$属性名&apos; 对某个属性求平均值，$last:&apos;$age&apos;获取本组中排序最后的一个年龄值。
2. 透视数据
$push:&apos;$age&apos; 将每一组年龄的属性值组成一个数组；
$push:&apos;$$ROOT&apos; 将每一组的整个文档组成一个数组；
</code></pre><p><img src="https://i.imgur.com/RCFAnAr.jpg" alt></p>
<pre><code>3. _id:null 则表示把集合分成一组，比如统计总人数和平均年龄：
</code></pre><p><img src="https://i.imgur.com/FOFObvH.jpg" alt></p>
<h3 id="过滤：-match"><a href="#过滤：-match" class="headerlink" title="过滤：$match"></a>过滤：$match</h3><pre><code>1. 支持MongoDB的标准查询操作
比如查询/过滤年龄大于20的文档：db.stu.aggregate([{$match:{age:{$gt:20}}}])
2. 对过滤后的文档进行聚合操作
比如，对过滤后的文档进行分组、统计：db.stu.aggregate([{$match:{age:{$gt:20}}},
{$group:{_id:&apos;$gender&apos;,count:{$sum:1}}}])
</code></pre><h3 id="投影：-project"><a href="#投影：-project" class="headerlink" title="投影：$project"></a>投影：$project</h3><pre><code>1. 与find()的投影功能相同
比如只输出属性name、age：db.stu.aggregate([{$project:{_id:0,name:1,age:1}}])
2. 对聚合后的文档做投影
比如只输出分组后的人数：aggregate([{$group:{_id:&apos;$gender&apos;,count:{$sum:1}}},
{$project:{_id:0,count:1}}])
</code></pre><h3 id="排序：-sort"><a href="#排序：-sort" class="headerlink" title="排序：$sort"></a>排序：$sort</h3><pre><code>1. 与sort()的功能相同
比如按年龄升序：db.stu.aggregate([{$sort:{age:1}}])
2. 对聚合后的文档做排序
比如对分组后的人数做降序：aggregate([{$group:{_id:&apos;$gender&apos;,count:{$sum:1}}},
{$sort:{count:-1}}])
</code></pre><h3 id="分页：-limit、-skip"><a href="#分页：-limit、-skip" class="headerlink" title="分页：$limit、$skip"></a>分页：$limit、$skip</h3><pre><code>在分页时，$skip必须在$limit的前面使用：aggregate([{$skip:2},{$limit:5}])
</code></pre><h3 id="拆分：-unwind"><a href="#拆分：-unwind" class="headerlink" title="拆分：$unwind"></a>拆分：$unwind</h3><pre><code>基于某一个数组类型的属性，将文档拆分成多个子文档，每个子文档包含该数组的一个元素；
1. db.集合名.aggregate([{$unwind:&apos;$属性名&apos;}])
</code></pre><p><img src="https://i.imgur.com/EgbuMyz.jpg" alt></p>
<pre><code>2. 如果拆分的属性是空数组、非数组类型、不存在、null，则拆分失败，数据丢失；
$unwind:{path:&apos;属性名&apos;,preserveNullAndEmptyArrays:true}：防止数据丢失；
</code></pre><p><img src="https://i.imgur.com/DYcOal2.jpg" alt></p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><pre><code>1. MongoDB也支持索引，以提升查询速度，索引的创建原则与MySQL的相同；
2. 查询性能分析：db.集合名.find({条件文档}).explain(&apos;executionStats&apos;)
    executionStats下的executionTimeMillis表示整体查询时间，单位是毫秒；
3. 创建索引
    1. 普通索引：db.集合名.ensureIndex({属性名:1})，1 升序，-1 降序；
    2. 唯一索引：ensureIndex({属性名:1},{unique:true})，属性值不能重复；
    3. 联合索引：ensureIndex({属性名:1,属性名:1})，基于多个属性，创建一个索引。
4. 查看集合中的所有索引：db.集合名：getIndexes()，同时会列出索引名称；
5. 删除索引
    1. 根据索引名称删除：db.集合名.dropIndex(&apos;索引名&apos;)
    2. 删除所有索引：db.集合名.dropIndexes()，_id是一个特殊的索引，不会被删除。
</code></pre><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><pre><code>1. MongoDB采用角色-用户-数据库的安全管理方式，为了安全性，需要访问者提供用户名和密码；
2. 常用的系统角色：
    1. root：只在admin数据库中可以使用，超级权限/账号；
    2. Read：允许用户读取指定的数据库；
    3. readWrite：允许用户读写指定的数据库。
</code></pre><h3 id="超级管理用户"><a href="#超级管理用户" class="headerlink" title="超级管理用户"></a>超级管理用户</h3><pre><code>mongo登录后，创建超级管理用户：
</code></pre><p><img src="https://i.imgur.com/4YilwiA.jpg" alt></p>
<pre><code>1. 设置角色和对应数据库的属性roles是一个数组，可以同时设置多个角色和对应数据库；
2. 角色设置之后，还需要修改配置文件：sudo vi /etc/mongod.conf，启用安全验证：
</code></pre><p><img src="https://i.imgur.com/jYs5Kj8.jpg" alt></p>
<pre><code>3. 修改了配置文件，必须重启MongoDB服务；
4. mongo命令登录后，并不能再查看所有数据库，必须使用身份验证的方式登录：
mongo -u 用户名(admin) -p 密码(123) --authenticationDatabase 验证的数据库(admin)
身份验证通过之后，就可以查看所有数据库，也可以切换到admin数据库进行操作。
5. 查看所有用户
    1. use admin：切换到admin数据库；
    2. db.system.users.find()：查看所有用户，以及用户的角色、对应的数据库。
</code></pre><h3 id="普通用户管理"><a href="#普通用户管理" class="headerlink" title="普通用户管理"></a>普通用户管理</h3><pre><code>1. 使用超级管理员登陆，查看当前数据库的用户：show users
2. 创建普通用户：
</code></pre><p><img src="https://i.imgur.com/dbIj8wu.jpg" alt></p>
<pre><code>3. 普通用户登录：mongo -u p1 -p 123 --authenticationDatabase py5
4. 该普通用户p1只对数据库py5有操作权限，是无法操作其他数据库的；
5. 在实际开发过程中，一个项目通常对应一个数据库，由超级管理员创建数据库，并分配数据库用户
   给项目开发者，保证开发者不能随便操作其他项目的数据库。
</code></pre><h2 id="复制-副本集"><a href="#复制-副本集" class="headerlink" title="复制-副本集"></a>复制-副本集</h2><pre><code>复制/副本集：提供数据的冗余备份，并在多个服务器上存储数据副本，提供数据的可用性，保证数据的
    安全性，允许从硬件故障和服务中断中恢复数据。
1. 主-从配置的服务器，应用程序访问A服务器(主)，B服务器定期从A服务器上读取数据，进行备份；
   如果A服务器宕机，应用程序会立即切换到B服务器(主)，待A服务器重启之后，则作为从服务器。
2. 复制的工作原理
    1. 复制至少需要两个节点A、B，常见的搭配方式：一主一从、一主多从；
    2. 主节点负责处理客户端请求，其他节点都是从节点，负责复制主节点上的数据；
    3. 从节点定期轮询主节点上记录的所有操作，然后对数据副本执行这些操作，保证从节点的数据
       与主节点一致；
3. 复制的特点
    1. N个节点的集群，任何节点都可以作为主节点，所有的写入操作都在主节点上；
    2. 自动故障转移，自动恢复，无宕机维护；
</code></pre><h3 id="设置复制节点"><a href="#设置复制节点" class="headerlink" title="设置复制节点"></a>设置复制节点</h3><pre><code>用xShell链接MongoDB服务器，完成节点设置，因为xShell支持对同一个ubuntu账户多开窗口；
1. 创建两个存放MongoDB数据库的文件夹t1、t2；
2. 在同一个Ip上启动两个MongoDB服务，指定不同的端口，使用不同的目录存放数据库，但既然做成
   一个副本集，replSet的名字必须要一致：
mongod --bind_ip 绑定Ip --port 绑定Port --dhpath 数据库的目录路径 --replSet 命名
3. 启动两个MongoDB服务：
</code></pre><p><img src="https://i.imgur.com/wBvqbAC.jpg" alt></p>
<pre><code>4. 重新指定了数据库目录，那么在启动MongoDB客户端连接时，也就不需要做身份验证了，但必须指定
   连接的Ip和Port：mongo --host Ip --port Port
5. 在终端上做初始化：rs.initiate()
    1. 在哪个终端上做初始化，那么它所连接的哪个MongoDB服务就设置成了主节点；
    2. 主节点设置成功之后，其命令提示符会发生变化；
    3. rs.status()：查看当前副本集的状态。
6. 在连接主节点的终端上添加副本集：rs.add(&apos;Ip:Port&apos;)，把另一个MongoDB服务作为从节点；
    1. 添加成功之后，连接从节点的终端提示符需要在Enter回车之后才会发生变化；
    2. 删除副本集：rs.remove(&apos;Ip:Port&apos;)
7. 自动备份数据
    1. 在主节点的终端上创建数据库，并插入数据；几秒钟之后，在从节点的终端上查询这些数据；
    2. 在从节点的终端上做查询操作，必须设置：rs.slaveOk()
8. 自动主从切换
    1. 重启主节点的服务，并退出主节点的终端和从节点的终端；
    2. 服务重启完成之后，再连接主节点和从节点，其命令提示符会交换，说明主从切换完成。
</code></pre><h2 id="数据备份与恢复"><a href="#数据备份与恢复" class="headerlink" title="数据备份与恢复"></a>数据备份与恢复</h2><pre><code>副本集可以实现自动数据备份，MongoDB也支持手动数据备份；
</code></pre><h3 id="数据备份"><a href="#数据备份" class="headerlink" title="数据备份"></a>数据备份</h3><pre><code>1. 无身份验证：mongodump -h db_host -d db_name -o db_directory
    1. db_host：服务器的地址，ip:port，如果是在服务器主机上直接操作，则省略-h部分；
    2. db_name：需要备份的数据库名称；
    3. db_directory：数据库的备份目录；
    4. 比如：mongodump -h 192.168.196.128:27017 -d test1 -o ~/Desktop/bak
2. 需要身份验证：mongodump -h db_host -u db_user(用户名) -p db_password(密码) 
    --authenticationDatabase db_name(验证的数据库) -d db_name -o db_directory
</code></pre><h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><pre><code>mongorestore -h db_host -d db_name --dir db_directory
1. mongoDB并不需要事先创建好数据库db_name，数据恢复时会自动创建；
2. 如果需要身份验证，可以直接使用超级管理员的账户，它能验证所有数据库。
</code></pre><h2 id="MongoDB与Python"><a href="#MongoDB与Python" class="headerlink" title="MongoDB与Python"></a>MongoDB与Python</h2><pre><code>1. 安装python包：sudo pip/pip3 install pymongo
2. 导入pymongo模块：from pymongo import *
3. 建立连接并创建客户端对象：
    1. 无安全认证：client=MongoClient(&apos;mongodb://Ip:Port&apos;)
    2. 有安全认证：client=MongoClient(&apos;mongodb://用户名:密码@Ip:Port/数据库名&apos;)
4. 获取数据库：db=client.数据库名
5. 获取集合：stu=db.集合名
</code></pre><h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><pre><code>1. 插入数据
    1. stu.insert_one({文档})，返回一个对象，其属性inserted_id可以获取文档的_id；
    2. stu.insert_many([{文档1}, {文档2}, {文档3} ...])，插入多条文档。
2. 修改数据
    1. stu.update_one({条件文档}, {&apos;$set&apos;:{新的文档}})：只更新第一条匹配的文档；
    2. stu.update_many({条件文档}, {&apos;$set&apos;:{新的文档}})：更新所有匹配的文档。
3. 删除数据
    1. stu.delete_one({条件文档})：只删除第一条匹配的文档；
    2. stu.delete_many({条件文档})：删除所有匹配的文档。
4. 查询数据
    1. find_one({条件文档})：返回匹配的第一条文档，字典类型；
    2. find({条件文档})：返回一个Cursor对象，直接对Cursor对象遍历，得到所有匹配的文档。
5. 排序：返回一个Cursor对象，ASCENDING 升序，DESCENDING 降序；
    1. 单属性：stu.find().sort(&apos;age&apos;, DESCENDING)，对查询的所有文档按照age降序；
    2. 多属性：stu.find().sort([(&apos;age&apos;, DESCENDING), (&apos;name&apos;, ASCENDING)])
6. 分页：stu.find().skip(2).limit(5)，返回一个Cursor对象；
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2017/08/08/MySQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/08/MySQL/" itemprop="url">MySQL</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-08T00:00:00+08:00">
                2017-08-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="数据库简介"><a href="#数据库简介" class="headerlink" title="数据库简介"></a>数据库简介</h2><pre><code>每一种数据库的核心区别：对硬盘的读写算法不同；
    1. 数据是存在本地硬盘上的，以实现数据的持久化存储；
    2. 数据库并不是简单的IO操作，其读写硬盘数据的算法是经过优化的，读写更加高效；
    3. 数据库保证了数据的有效性，比如身份证号是唯一的，不允许录入重复的号码。
数据库主要分为两类：
    1. 文档型，比如移动端使用的轻量级数据库Sqlite，其实就是一个文件，但读写算法做了优化；
    2. 服务型，比如Oracle、MySQL、PostgreSQL，分为客户端和服务端，数据存储在服务器端，
       客户端通过TCP/IP协议链接，进行数据库的读写操作；
</code></pre><h3 id="E-R-模型"><a href="#E-R-模型" class="headerlink" title="E-R 模型"></a>E-R 模型</h3><pre><code>E-R模型针对的是关系型数据库，E：Entry(实体)，R：Relationship(关系)；
1. 当前物理的数据库都是按照E-R模型设计的，将一个实体转换为数据库的一个表，实体的属性转换为
   表中的字段；
2. 关系用于描述两个实体之间的对应规则：一对一、一对多、多对多；
3. 关系转换为表中的一个列，在关系型数据库中，一行就是一个对象；
</code></pre><h3 id="三范式"><a href="#三范式" class="headerlink" title="三范式"></a>三范式</h3><pre><code>数据库的设计需要遵循一定的规则，这些规则称为范式；
1. 第一范式(1NF)：列不可拆分
    1. 比如&quot;学生&quot;作为一个实体，其属性&quot;姓名&quot;是两个信息，可以设计成一列，也可以设计成两列，
    但是，对于学生信息，只需要维护&quot;姓名&quot;作为一列就足够使用了，而对于公安系统来说，则需要
    单独维护&quot;姓&quot;和&quot;名&quot;作为两列(两个字段)；
    2. &quot;不可拆分&quot;的标准在于，&quot;够用就行&quot;，基于当前的实际需求。
2. 第二范式(2NF)：唯一标识
    每个实体(表)都可以通过一个属性唯一的查找到，该属性就是表的唯一标识；
3. 第三范式(3NF)：引用主键
    针对的是关系，主键是一个表的唯一标识，引用另一张表的数据时，必须通过主键引用；
说明：后一个范式，都是在前一个范式的基础上建立的。
</code></pre><h3 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h3><pre><code>数据的完整性：保证数据正确有效，在创建表时，添加一些强制性验证，包括数据字段的类型、约束；
1. 字段类型
    1. 数字常用的类型：
        1. 整数：int
        2. 浮点数：decimal(m, n)，m 表示浮点数的位数，n 表示小数点后的位数；
    2. 字符串：char，varchar，text
        1. char(n)：如果字符个数少于 n，则在右侧补空格，强制使字符个数保持在 n 个；
        2. varchar(n)：与char的不同，不会自动补空格，存放的是字符的真实个数；
        3. text：字符个数不固定时使用，不限制字符的个数，比如描述信息；
        4. 另外，只要使用了字符串，必须统一编码格式，比如 utf-8；
    3. 日期：datetime
    4. 布尔类型：bit
        1. bit：存放二进制的比特位，默认存放 1 个比特位(0，1)；
        2. bit(8)：存放 8 个比特位，即一个字节；
        3. bit 的空间开销更小，比如性别(male，female)，字符串类型所占用的空间开销更大，
           既然性别只有两种状态，就可以使用 0 和 1 表示，用bit进行存储。
2. 约束
    1. 主键约束：primary key，主键不能重复，数据库通过主键查找数据的速度很快；
    2. 非空约束：not null，比如约束字段name不能为空，保存name为空的数据时，就会报错；
    3. 唯一约束：unique，不能出现重复的值；
        1. 与主键的区别是，一个实体可以有多个唯一约束，但只有一个主键；
        2. 物理上的存储结构是按照主键进行维护的，而不是按照唯一约束；
    4. 默认约束：default，用于设置默认值；
    5. 外键约束：foreign key
</code></pre><h2 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h2><pre><code>1. 在设计表时，通常预留一定数量的字段，以适应后期的设计变化，避免修改表的结构；
   因为表一旦设计完成，一般不会再增删字段，即使字段不再使用，也不会删除；
2. 物理删除：在删除表中的数据时，把数据从硬盘上直接删除，数据也就被永久性删除了；
3. 逻辑删除：在表中增加一个标识性字段isDelete，类型为bit，默认值为0；
    1. isDelete的值为0 表示数据存在，值为1 表示数据被删除；
    2. 在删除数据时，只需要把该条数据的isDelete设置为1 即可；
    3. 从数据库中读取数据时，只读取isDelete的字段值为0 的数据；
    4. 逻辑删除可以保护重要的数据不会因为某种原因被永久性删除。
4. mysql的默认端口是：3306
</code></pre><h3 id="图形化管理MySQL"><a href="#图形化管理MySQL" class="headerlink" title="图形化管理MySQL"></a>图形化管理MySQL</h3><pre><code>在Windows系统上使用MySQL管理软件SQLyog/Navicat for MySQL，图形化管理MySQL数据库；
1. 本地连接
    在Windows系统上安装MySQL，并启动MySQL服务：net start MySQL；
    使用管理软件Navicat可以直接建立MySQL连接。
2. 远程连接
    一台主机模拟远程连接：
        1. 在Windows系统上安装VW虚拟机；
        2. VW虚拟机上安装ubuntu Linux；
        3. ubuntu Linux系统上安装MySQL。
    1. MySQL默认不允许远程连接，必须设置为可远程连接，并重启MySQL；
    2. 远程连接之前，先确认Window系统与Linux系统可以通信：ping，测试连通性；
    3. 如果ping 失败，可能是因为Linux系统的Ip 与Window系统的Ip 不在同一网段；
       1. 执行 sudo dhclient 命令，重新动态分配Ip；
       2. 如果 sudo dhclient 执行失败，可以将VW虚拟机的网络适配器设置为桥接模式；
       3. 这两种方式执行完之后，最好重启一下mysql。
    4. ping 成功之后，使用Windows系统中的Navicat，远程连接Linux系统中的MySQL。
</code></pre><h3 id="命令管理MySQL"><a href="#命令管理MySQL" class="headerlink" title="命令管理MySQL"></a>命令管理MySQL</h3><pre><code>1. mysql --help：查看mysql命令文档；
2. 本地登录MySQL：mysql -uroot -p
    1. root：登录的用户名；  -p：回车后输入密码；
    3. 不指定端口号，表示使用mysql的默认端口：3306
3. MySQL客户端远程登录：
    1. 在开发过程中，数据库通常统一搭建在一台服务器上，需要远程连接；
    2. 远程连接的命令：mysql -hIP -uroot -p
    3. IP：要连接的主机Ip；  root：登录的用户名；  使用默认端口：3306
4. 退出登录：quit/exit
5. 查看版本：select version();
6. 显示当前时间：select now();
7. 登录mysql之后，操作MySQL的命令语句都以分号&quot;;&quot;结尾。
</code></pre><h4 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h4><pre><code>1. 创建数据库：create database 数据库名 charset=utf8;
2. 删除数据库：drop database 数据库名;
3. 切换数据库：use 数据库名;
4. 查看当前操作的数据库：select database();
5. 查看所有的数据库：show databases;
</code></pre><h4 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h4><pre><code>1. 查看当前数据库中所有的表：show tables;
2. 创建一个表：create table 表名(列及类型);
    mysql&gt; create table student(
        -&gt; id int auto_increment primary key,
        -&gt; name varchar(10) not null,
        -&gt; gender bit default 1,
        -&gt; birthday datetime);
    1. auto_increment：设置为自动增长；
    2. primary key：设置为主键，一个表只能有一个字段设置为主键；
    3. not null：字段的值不能为空；
    4. default 默认值：设置字段的默认值。
3. 查询一个表的结构：desc 表名;
4. 修改表：
    1. 更改字段名：alter table 表名 change 旧字段名 新字段名 新类型;
       如果只修改字段类型，则新字段名与旧字段名设置为同名；
       如果不需要修改类型，则把新类型设置为原字段类型。
    2. 增加一个新字段：alter table 表名 add 列名 类型;
       增加一个标识性字段并指定默认值：alter table 表名 add isDelete bit default 0;
    3. 删除字段：alter table 表名 drop 列名;
    4. 修改字段类型：alter table 表名 modify column 字段名 新类型;
5. 删除表：drop table 表名;
6. 更改表的名称：rename table 原表名 to 新表名;
7. 查看表的创建语句：show create table 表名;
</code></pre><h4 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h4><pre><code>1. 查看表中所有字段的数据：select * from 表名;
2. 添加数据：insert
    1. 全字段添加：insert into 表名 values(字段1的值, 字段2的值, ...);
        1. 先使用 desc 命令查看表的结构(列的顺序)，字段的值与字段的顺序必须一一对应；
        2. 主键字段id 虽然设置为auto_increment，仍然需要根据字段的顺序设置 id 的值，
           但是，id 的真实数据会以自动生成的为准，手动设置的值只是作为占位符，比如 0；
        3. 字符串和日期类型的数据，用单引号标识。
    2. 指定字段添加：insert into 表名(字段1, ...) values(值1, ...);
    3. 同时插入多条数据：
        1. insert into 表名 values(字段1的值, ...), (字段1的值, ...), ...;
        2. insert into 表名(字段1, ...) values(值1, ...), (值1, ...), ...;
3. 修改数据：update
    1. update 表名 set 字段1=值1, 字段2=值2, ... where 条件;
    2. 逻辑删除 id=2 的数据：update students set isDelete=0 where id=2;
    3. 只查看 isDelete=1 的数据：select * from students where isDelete=1;
4. 删除数据
    1. delete from 表名 where 条件;
    2. 物理删除 id=3 的数据：delete from students where id=3;
5. 数据备份与恢复
    1. 更换开发使用的服务器时，就需要对数据进行备份，并在另一台服务器上恢复数据；
    2. 备份数据，其实就是生成一个sql脚本，但该脚本中不包含创建数据库的SQL语句，所以在恢复
       数据时，要先创建数据库；
    3. 备份数据库需要有管理员权限：sudo -s，进入mysql目录：cd /var/lib/mysql
    4. 备份到桌面：mysqldump -uroot -p 数据库名 &gt; ~/Desktop/copy.sql
       输入mysql的登陆密码；
    5. 先登录mysql，创建一个新的数据库，退出mysql；
    6. 恢复数据：mysql -uroot -p 新数据库名 &lt; ~/Desktop/copy.sql，输入mysql的密码。
</code></pre><h2 id="查询：select"><a href="#查询：select" class="headerlink" title="查询：select"></a>查询：select</h2><pre><code>1. 查询指定字段的数据：select 字段1,字段2,... from 表名;
2. distinct：去除数据重复的行；
    1. select distinct id,name from students;
    2. id 是自增长的主键字段，不会重复，所以，即使 name 有重复的数据，也不会被筛选。
3. as：为查询的字段/表名取一个别名，可以更直观地显示查询结果，也方便后续的语句使用；
    1. select name as &apos;姓名&apos;,sex as &apos;性别&apos; from students;
    2. 显示查询结果时，字段name 以&quot;姓名&quot;显示，字段sex 以&quot;性别&quot;显示。
</code></pre><h3 id="条件：where"><a href="#条件：where" class="headerlink" title="条件：where"></a>条件：where</h3><pre><code>1. 比较运算符：=，&gt;，&gt;=，&lt;，&lt;=，!=/&lt;&gt;
2. 逻辑运算符：and，or，not
3. 模糊查询：like
    1. %：匹配任意多个字符；
        1. select * from students where name like &apos;李%&apos; or name like &apos;%豪%&apos;;
        2. 查询姓&quot;李&quot;，或者名字中带&quot;豪&quot;的学生。
    2. _：只匹配一个字符；
4. 范围查询：in，between...and...
    1. in：在一个非连续的范围内，select * from students where id in(1,3,6);
    2. between...and...：在一个连续的范围内，where id between 3 and 8;
5. 空判断：is null，is not null
</code></pre><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><pre><code>1. 子查询：嵌套查询
    select *, (select count(*) from projects where user.id=projects.creator)
    as projectNum from user where delete!=1 limit 0,10
</code></pre><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><pre><code>(...) &gt; not &gt; 比较运算符 &gt; 逻辑运算符
1. and 的优先级大于 or，如果希望先运算or，需要使用小括号改变优先级；
2. in、between...and... 与比较运算符是同级的。
</code></pre><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><pre><code>聚合：为了快速得到统计数据，只显示统计的结果，而不展示统计出的原始数据；
1. count(*)：计算总行数，select count(*) from students; --&gt; 统计学生总数；
2. min/max(列名)：求此列的最小值/最大值；
3. sum(列名)：求和；
4. avg(列名)：求平均值；
</code></pre><h3 id="分组：group-by"><a href="#分组：group-by" class="headerlink" title="分组：group by"></a>分组：group by</h3><pre><code>1. select 列1,列2,聚合... from 表名 group by 列1,列2...
    1. 按照字段进行分组，在此字段的数据中，相同的数据被分为一组；
    2. 分组是为了更好的聚合，所以还会使用聚合函数统计数据。
2. 按照性别gender(bit类型)分类，并统计男女人数：
    select gender as &apos;性别&apos;,count(*) from students group by gender;
    count(*)：* 匹配的是每一类gender，计算每一类gender的数量。
3. 聚合与分组：当对表中的所有数据进行聚合时，通常不需要分组；如果是对表中的某些数据聚合，
    则需要考虑分组。
</code></pre><h4 id="数据筛选：having"><a href="#数据筛选：having" class="headerlink" title="数据筛选：having"></a>数据筛选：having</h4><pre><code>1. hanving 与 where
    1. where：对from 后面所指定的表进行数据筛选，属于原始数据的筛选；
    2. having：对 group by 的结果集进行筛选，having语句所使用的字段也必须在该结果集中；
    3. having 后面使用条件运算符与 where 的相同。
2. select 列1,列2,聚合... from 表名 group by 列1,列2... having 条件;
3. 统计男生的总人数：
    1. select count(*) from students where gender=1;
    2. select gender,count(*) from students group by gender having gender=1;
</code></pre><h3 id="排序：order-by"><a href="#排序：order-by" class="headerlink" title="排序：order by"></a>排序：order by</h3><pre><code>1. select * from 表名 order by 列1 asc/desc,列2 asc/desc...
    1. asc 升序，desc 降序，默认是升序排列；
    2. order by 是对最终的结果集进行排序的，所以必须放在 where、group by 的后面；
    3. 排序是为了更直观的查看数据。
2. 按照id 降序排列：select * from students where isDelete=1 order by id desc;
</code></pre><h3 id="分页：limit"><a href="#分页：limit" class="headerlink" title="分页：limit"></a>分页：limit</h3><pre><code>1. select * from 表名 limit start,count;
2. start 开始的索引(起始索引为0，与id无关)，count 条数；
3. 表中数据的索引是从 0 开始，而显示数据时，每一页的索引通常是从 1 开始的。
4. 一个完整的select语句，各个关键字的排列顺序如下：
    select distinct * from 表名 where ... group by ... having ... order by ...
    limit start,count;
5. 执行顺序：
    from 表名 --&gt; 获取最原始的数据集合 ==&gt; where --&gt; 对原始数据筛选，获取符合条件的行，
    组成新的结果集 ==&gt; group by --&gt; 对结果集进行分组，即合并行，得到一个新的结果集 ==&gt;
    select distinct * --&gt; 筛选出指定的字段，并去除重复的行，组成新的结果集 ==&gt; having
    --&gt; 再次对结果集筛选，得到新的结果集 ==&gt; order by --&gt; 对数据排序 ==&gt; limit ---&gt;
    分页显示数据
</code></pre><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><pre><code>1. 表与表之间的关系类型：一对一，一对多，多对多；
2. 关系字段：用于引用另一张表的主键；
    1. 表A--&gt;表B 是一对一的关系，则关系字段存储在表A和表B任意一个都可以；
    2. 表A--&gt;表B 是一对多的关系，则关系字段存储在表B中；
    3. 表A--&gt;表B 是多对多的关系，则新建一张表，存储关系字段；
3. 关系不能闭合，比如表A与表B、表B与表C、表A与表C 都有关系，在设计表之间的关系时，一定不能
   让关系闭合；根据实际的需求，把经常操作的两张表建立关系，比如 A--&gt;B--&gt;C，A和C不能再直接
   建立关系，而是通过表B进行关联。
4. 分析过程：确定两个实体是否存在关系 --&gt; 确定关系的类型 --&gt; 在哪个实体中创建关系字段；
5. 外键约束
    1. 创建外键的方式：
        1. 创建表时：foreign key(关系字段) references 被关联的表名(被关联的字段);
        2. 表已创建：alter table 表名 add constraint 外键名 foreign key(关系字段)
            references 被关联的表名(被关联的字段);
            外键名：为外键定义的名字，可以不指定，mysql会自动创建一个。
    2. 作用：建立关系字段之后，为了保证关系字段的数据正确、有效；
    mysql&gt; create table scores(
        -&gt; id int auto_increment primary key not null,
        -&gt; score decimal(4,1),
        -&gt; stuid int,
        -&gt; subid int,
        -&gt; foreign key(stuid) references students(id),
        -&gt; foreign key(subid) references subjects(id));
    3. 被关联的字段通常是被关联表的主键字段.
6. 外键的级联操作
    1. 表A 关联了表B，如果删除了表B 的相关数据时，会抛出异常；所以，通常使用逻辑删除。
    2. 级联操作的类型：
        1. restrict：限制，默认类型，会抛出异常；
        2. cascade：级联，如果删除/更新了表B 的相关数据，则表A中的记录也会被删除/更新；
        3. set null：将外键设置为空；
        4. no action：什么都不做。
    3. 创建了表之后，修改外键为cascade：alter table scores add constraint 外键名
    foreign key(关系字段) references 被关联的表名(被关联的字段) on delete cascade
    on update cascade;
    4. 在设计表时，如果表的某个字段被外界所关联，通常设置为逻辑删除即可，而不使用级联操作
</code></pre><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><pre><code>当查询的字段是外键时，需要使用连接查询；
    1. 表A inner join 表B on：只显示表A和表B匹配的字段；
    2. 表A left join 表B on：除了显示匹配的字段，还包括表A 中独有的数据，未匹配的数据用
       null占位；
    3. 表A right join 表B on：除了显示匹配的字段，还有表B 中独有的数据；
</code></pre><p><img src="https://i.imgur.com/1FIcRlR.jpg" alt></p>
<pre><code>1. inner join 表名 on 关系
    1. select students.name,subjects.title,scores.score from scores
    inner join students on scores.stuid=students.id
    inner join subjects on scores.subid=subjects.id;
</code></pre><p><img src="https://i.imgur.com/wL7rTfI.jpg" alt></p>
<pre><code>    2. 调换表名&quot;scores&quot;和&quot;students&quot;的位置，结果是等效的，只要保证表名和关系相对应即可；
    比如&quot;students&quot;和&quot;subjects&quot;是不能交换位置的，因为会造成 on 后面的关系不对应。
2. 计算平均分，并排序：
    select students.name as &apos;姓名&apos;,avg(score) as avg1 from scores
    inner join students on scores.stuid=students.id
    group by stuid order by avg1;
</code></pre><p><img src="https://i.imgur.com/7iV6Enj.jpg" alt></p>
<pre><code>1. group by stuid 等效于：group by students.id；
2. inner join 连接了students表，就可以通过 &quot;students.字段&quot; 使用students表的任意
字段，也就可以获取students表的任意字段值。
</code></pre><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><pre><code>视图是对 select 查询语句的封装；
1. 创建一个视图：create view 视图名 as select语句;
2. 修改视图：alter view 视图名 as select语句;
3. 执行视图：select * from 视图名;
4. show tables：可以查看所有的表和视图。
</code></pre><h3 id="自关联"><a href="#自关联" class="headerlink" title="自关联"></a>自关联</h3><pre><code>对于高性能的数据库，一个表可以存数十万条数据，如果相关联的两张表所存储的数据总量比较少，
则可以合成一张表，比如国内的省、市、县，其数量基本是固定的，设计成3个表会造成性能的浪费，
就可以使用自关联的方式，合并成一个表。
1. 自关联：表的外键关联自身的字段；
</code></pre><p><img src="https://i.imgur.com/KhGDLuq.jpg" alt></p>
<pre><code>省、市、县中，省是最高一级，其pid设置为null/0
2. 在当前使用的数据库中，导入一个sql脚本：source xx.sql;
</code></pre><p><img src="https://i.imgur.com/JDIztZW.jpg" alt></p>
<pre><code>3. 在查询省市县时，因为是在同一张表，可以使用嵌套查询/子查询，但语句逻辑会很混乱，所以仍然
   使用连接查询，只查询河南省的市：
</code></pre><p><img src="https://i.imgur.com/CMHLT69.jpg" alt></p>
<pre><code>4. 查询周口市的所有县区：
</code></pre><p><img src="https://i.imgur.com/TAfCbHY.jpg" alt></p>
<h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><pre><code>内置函数可以将字段名当作参数，MySQL提供了很多内置函数；
1. 字符串常用的内置函数
    1. select ASCII(str)：返回第一个字符在ASCII码表中对应的数值；
    2. select char(int)：数值在ASCII码表中对应的字符；
    3. select concat(12,&apos;ab&apos;,13)：拼接成字符串，12ab13；
    4. 截取字符串：对于字符串位置的操作，第一个字符的位置为 1
        1. select left(str, len)：字符串str左起截取len个字符；
        2. select right(str, len)：右起截取len个字符；
        3. select substring(str, pos, len)：从第pos个字符开始，截取len个字符；
    5. 去除空格
        1. ltrim(str)：返回一个去除了左边空格的新字符串；
        2. rtrim(str)：去除右边的空格；
        3. trim(str)：去除左右两边的空格；
        4. trim(orientation remstr FROM str)：指定删除某一侧的remstr；
        orientation：both(两侧的都删除)，leading(删除左侧的)，trailing(删除右侧的)
        select trim(both &apos;x&apos; from &apos;xxxxbaxlxxxx&apos;)：删除两侧的&apos;x&apos; --&gt; &apos;baxl&apos;
    6. select space(n)：返回一个由n个空格组成的字符串；
    7. replace(str, oldstr, newstr)：将str的字串oldstr替换成newstr；
    8. 大小写：lower(str)、upper(str)
2. 数学函数
    1. select abs(n)：求绝对值；
    2. mod(m, n)：求余数，等效于 select m%n;
    3. floor(n)：不大于n的最大整数，floor(2.3) --&gt; 2；
    4. ceiling(n)：不小于n的最小整数，ceiling(2.3) --&gt; 3；
    5. round(n, d=0)：四舍五入的值，n 表示原数，d 表示小数的个数；
    6. pow(m, y)：m 的 n 次幂；
    7. PI()：圆周率；
    8. rand()：随机数，0-1 之间的浮点数；
    9. log(x)，sin(x)，radians(x) ...
3. 日期时间函数
    1. year(data)、month(data)、day(data)：年份、月份、日期；
    2. hour(time)、minute(time)、second(time)：时0-23、分0-59、秒0-59
    3. date_format(date, format)：日期格式化；
    format：
        1. %Y：完整的年，比如2016；  %y：简略的年，只保留后两位；
        2. %m：月份1-12；   %d：日期
        3. %H：24小时制0-23；   %h：12小时制1-12；
        4. %i：分钟0-59；   %s：秒钟0-59；
    select date_format(&apos;2016-12-21&apos;, &apos;%Y年%m月%d日&apos;)：2016年12月21日；
    4. current_date()、current_time()：获取当前日期、时间，等效于 now();
    5. 时间日期也可以用 +、- 进行计算；
        1. SELECT &apos;2008-12-31 23:59:59&apos; + INTERVAL 1 SECOND; --&gt; 加1秒；
        2. SELECT &apos;2008-12-31 23:59:59&apos; + INTERVAL 1 DAY; --&gt; 加1天。
</code></pre><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><pre><code>1. select语句只是查询数据，并不会影响数据；当对数据进行更改操作时，为了保证执行的有效性，
   也即，要么成功，要么全部失败，不会只成功一部分，这就是事务。
2. 事务的四大特性：原子性、一致性、隔离性、持久性
3. 表的类型(引擎)必须是：innodb、bdb，才能使用事务；
    1. mysql创建的表，默认使用的是InnoDB；
    2. 不同的引擎，其性能的侧重点是不同的；
    3. show create table 表名：查看创建表的结构，也包括表的引擎；
    4. 修改表的引擎：alter table 表名 engine=innodb;
4. 使用事务：begin(开启)，commit(提交)，rollback(回滚)
    1. begin：开启事务，在内存中创建一个表，对数据的操作不会影响物理内存中的表；
    2. commit：提交事务，修改物理内存中的表；
    3. rollback：放弃操作，关闭事务；
</code></pre><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><pre><code>1. 当数据库中的数据量很大时，查找数据会变得很慢，索引用于提高数据访问的性能；
   比如，在一本汉语字典的前几页，标注有拼音/笔画查找，这就是索引；
2. 主键是一种特殊的索引，在数据库中，默认是按照主键存储的；
3. 索引的创建，也会增加物理开销，要合理选择字段/列的数据类型
    1. 越小的数据类型通常会更好，在磁盘、内存和CPU缓存中所占用的空间更少，处理更快；
    开销：bit &lt; int &lt; decimal
    2. 简单的数据类型更好：字符串在底层需要转换，整型数据则更简单，处理开销更小；
    3. 尽量避免NULL：尽量设置字段为NOT NULL，使用0、一个特殊值、空字符串代替NULL；
    在MySQL中，含有NULL的列很难进行优化，因为它使索引、索引统计信息以及比较运算更加复杂。
4. 索引通常并不是在设计数据库时添加的，而是在后期数据量太大、对数据库进行优化时添加，对那些
   where语句中频繁使用的字段创建索引；
5. where语句是从第一行开始筛选的，即使在中间遇到了匹配的数据，也会执行到最后一行，因为匹配
    的数据可能有多行；但是，一旦为 where语句中使用的字段增加了索引，它会直接找到匹配的行，
    而不会再继续执行；也即，优化数据库其实就是优化耗时的 where语句。
    1. 单列索引：为 where语句后的每个字段都创建一个索引；
    2. 组合索引：where后的所有字段只创建一个索引。
6. 语句的顺序也会影响索引的效果，比如 where gender=0 and isdelete=0 and id&gt;8;
    1. and 是与运算，= 表示唯一的值，&gt; 表示一个范围，索引只对gender和isdelete有效，所以
    只创建gender和isdelete的索引即可；
    2. where gender=0 and id&gt;8 and isdelete=0：会造成isdelete的索引无效；
    3. 尽量避免使用 or 运算符，因为 or 也会造成字段的索引无效。
</code></pre><h3 id="操作索引"><a href="#操作索引" class="headerlink" title="操作索引"></a>操作索引</h3><pre><code>1. 查看表的所有索引：show index from 表名;
2. 创建索引：create index 索引名 on 表名(字段(长度));
    1. 长度是创建字段时指定的长度，一般字符串需要显示指定长度，整型则不需要；
    2. 为多个字段创建一个索引： ... on 表名(字段1(长度),字段2(长度)...);
3. 删除索引：drop index 索引名 on 表名;
4. 索引虽然大大提高了查询速度，但同时也会降低更新表的速度；
    1. 执行INSERT、UPDATE和DELETE时，MySQL不仅要保持数据，还要保存索引文件；
    2. 索引文件也会占用磁盘空间。
</code></pre><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><pre><code>1. 开启执行时间的检测：set profiling=1;
2. 执行SQL语句之后，查看执行时间：show profiles;
</code></pre><p><img src="https://i.imgur.com/LMo4FE1.jpg" alt></p>
<h2 id="Python与MySQL的交互"><a href="#Python与MySQL的交互" class="headerlink" title="Python与MySQL的交互"></a>Python与MySQL的交互</h2><pre><code>1. 安装mysql模块：
    1. python2环境：sudo apt-get install python-mysqldb --&gt; import MySQLdb
    2. python3环境：安装pymysql模块 --&gt; import pymysql
2. python3环境下，操作数据库，插入一条数据：
</code></pre><p><img src="https://i.imgur.com/pEjXMMH.jpg" alt></p>
<pre><code>    1. connect连接数据库时，默认开启事务，必须执行 commit() 才有效。
    2. conn.rollback()：回滚，放弃之前的操作。
1. 参数化
    参数化是为了避免SQL语句的攻击，比如SQL注入；参数化会调用内置的函数，检查输入的数据；
    sql = &quot;insert into students(name) VALUES(%s)&quot;
    param = [&apos;LiLi&apos;]  --&gt;列表
    cursor.execute(sql, param)
    1. %s 只是用于占位，与格式化输出的 %s 并不相同；
    2. execute(sql, param)：param 可以是一个列表/元组/字典； 
2. 查询：与增/删/改不同，select语句还会返回查询的结果
    1. cursor.fetchone()：返回一行数据的查询结果，元组类型，数据不存在则返回None；
    2. cursor.fetchall()：多行数据的查询结果，元组类型，其元素也是元组类型；
    3. scroll(value, mode=&apos;relative&apos;)：将行指针移动到指定位置，mode表示移动的方式；
        1. relative 是默认值，表示基于当前行移动到value，value为正数，则指针向下移动，
        value为负数，则指针向上移动；
        2. mode=&apos;absolute&apos;，基于第一行的位置，第一条数据的位置为 0.
    cursor = conn.cursor()
    cursor.execute(&quot;select * from students&quot;)
    result = cursor.fetchall()
3. 在操作数据库时，尽量晚打开、尽量早关闭。
</code></pre><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><pre><code>有些数据并不是直接存入数据库的，比如用户的登录密码，必须加密之后再存入数据库。
1. python中的加密模块：import hashlib
2. hashlib模块包含多种加密：md5、sha1、sha224、blake2b ...
3. sha1 相当于是 md5 的加强版；md5加密后的字符固定是32个，sha1加密后的字符是40个。
    from hashlib import sha1
    pwd = &quot;abcd123&quot;   s1 = sha1()
    s1.update(pwd.encode(&apos;utf8&apos;))  --&gt; python3的字符串要先编码
    pwd2 = s1.hexdigest()  -------&gt; 加密完成
1. password使用sha1加密之后，生成的字符固定为40个，则password的类型定义为char(40)；
2. s1.digest()：生成的是byte类型数据，十六进制；
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2017/08/07/数据结构与算法2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/07/数据结构与算法2/" itemprop="url">数据结构与算法2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-07T00:00:00+08:00">
                2017-08-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><pre><code>排序算法的稳定性：排序前后的元素序列是一致的，则该排序算法是稳定的；反之，该排序算法不稳定；
</code></pre><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><pre><code>原理：
    1. 比较两个相邻的元素，如果第一个比第二个大(升序)，则交换位置；
    2. 每次遍历筛选出一个最值，下一次循环不再遍历筛选出的最值；
    3. 冒泡排序的算法是稳定的；
</code></pre><p><img src="https://i.imgur.com/tlAdZHD.jpg" alt></p>
<p><img src="https://i.imgur.com/MdvaVMb.jpg" alt></p>
<pre><code>时间复杂度：
    1. 最优：O(n)，数列本身就是有序的，第一次遍历不会有任何交换，则不再遍历；
    2. 最坏：O(n^2)
</code></pre><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><pre><code>原理：
    1. 第一次遍历，筛选出最大的元素(升序)，并与最后一个元素交换位置；
    2. 第二次循环只遍历剩下的元素，筛选出最大的，并与倒数第二个元素交换位置，依次类推；
</code></pre><p><img src="https://i.imgur.com/jiU8SOe.jpg" alt></p>
<pre><code>1. 时间负责度：最优和最差都是O(n^2)
2. 选择排序的算法是不稳定的：[46, 4, 6, 2, 46, 5, 1]
    在升序排列过程中，第一个46 会和 1 交换位置，所以第二个46 一定会排在第一个46 的后面，
导致排序前后的元素顺序不一致。
</code></pre><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2017/08/06/数据结构与算法1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/06/数据结构与算法1/" itemprop="url">数据结构与算法1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-06T00:00:00+08:00">
                2017-08-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><pre><code>例：a + b + c = 1000，a**2 + b**2 = c**2
1. 最直观的解决方式：
</code></pre><p><img src="http://i.imgur.com/a8NVFqV.jpg" alt></p>
<pre><code>这种方式的计算，消耗了超过4分钟的时间，效率极其低下；
2. 改进版：
</code></pre><p><img src="http://i.imgur.com/UB7DEN1.jpg" alt></p>
<pre><code>只消耗了1秒左右的时间，大大提高了效率！
</code></pre><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><pre><code>1. 计算机的配置不同，执行相同的代码所消耗的时间也就不同，但执行基本运算的数量是相同的；
   所以，通过对比执行基本运算的数量，就可以看出两种算法的优劣；
2. 时间复杂度
    1. 执行基本运算的数量，就是时间复杂度，表示方法：大&quot;O&quot;表示法
    2. 最优/最坏时间复杂度：算法完成工作最少/最多需要多少基本运算
    3. 时间复杂度的计算原则：
        1. 基本语句，即只有常数项，时间复杂度为 O(1)；
        2. 顺序结构，时间复杂度按加法计算；
        3. 循环结构，时间复杂度按乘法计算；
        4. 分支结构，时间复杂度取最大值；
        5. 判断一个算法的效率，通常只关注运算数量的最高次项，其他次要项和常数项可以忽略；
        6. 没有特殊说明时，分析一个算法的时间复杂度，指的都是最坏时间复杂度。
3. 方式1和方式2的时间复杂度：
    1. T1 = 1000 * 1000 * 1000 * 2 ---&gt; T(n^3) * 2 ---&gt; O(n^3)
    2. T2 = 1000 * 1000 * 3 ---&gt; T(n^2) * 3 ---&gt; O(n^2)
    3. O(n^3)是O(n^2)的n倍，所以方式2的效率更高。
4. 常见的时间复杂度
</code></pre><p><img src="http://i.imgur.com/RWZzjk3.jpg" alt></p>
<h3 id="Python内置性能分析"><a href="#Python内置性能分析" class="headerlink" title="Python内置性能分析"></a>Python内置性能分析</h3><pre><code>timeit模块：用来测试一小段python代码的执行速度；
1. class timeit.Timer(stmt=&quot;&quot;, setup=&quot;&quot;, timer=&lt;timer function&gt;)
    1. stmt：要测试的代码语句，比如一个函数；
    2. setup：运行代码时需要的设置，比如导入被测试的函数，即使测试的是当前模块的函数，也是
            需要导入的，因为timeit的测试其实是在一个独立的模块内进行的；
    3. timer：可选参数，是一个定时器函数，与系统平台有关；
2. Timer().timeit(number=1000000)：执行测试，number设置的是测试次数，默认值为1000000，
    返回的是平均耗时；
3. 列表、字典、元组、集合，其实是python封装后的工具，测试列表操作的时间复杂度：
</code></pre><p><img src="http://i.imgur.com/ZI7yOww.jpg" alt></p>
<pre><code>从测试结果可以看出：
    1. &quot;+&quot; 的效率是极低的，而 &quot;+=&quot; 是优化后的运算符，效率很高，所以尽量避免使用&quot;+&quot;；
    2. 函数并不是基本运算，函数体的数据结构，决定了函数效率的高低，比如：append() 的效率要
       比insert()高很多，是因为append() 的时间复杂度为 O(1)，insert()的时间复杂度为O(n)
</code></pre><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><pre><code>1. 数据结构是指数据元素之间的关系，是数据的组织方式，比如python中内置的列表、字典；
2. 算法是为了解决实际问题而设计的，数据结构是算法需要处理问题的载体；
3. 程序 = 数据结构 + 算法
4. 抽象数据类型(ADT)：指一个数学模型以及定义在此模型上的一组操作，也就是把数据类型和数据运算
   进行封装；
5. 常见的数据运算：插入、删除、修改、查找、排序。
</code></pre><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><pre><code>内存：是一个连续的存储单元，以字节为基本单位，1字节对应8个比特位，每个字节又对应一个十六进制
    的地址编号；计算机在读取数据时，是先找到数据对应的内存地址，再按照字节读取数据；
类型本质：
    1. 任何数据在内存中都是以二进制形式存储的，类型决定了一个数据在内存中占多少个字节；
    2. 计算机从内存中读取到二进制数据时，该怎么转换，然后输出到屏幕上。
所有的高级数据结构都是由基本的数据类型构成的，python中的列表、字典等都是封装后的高级数据结构。
</code></pre><h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><pre><code>1. 在程序中，经常需要将一组数据元素作为整体管理和使用，这样一组数据元素可以看作是一个序列，
用元素在序列中的位置和顺序，表示数据之间的某种关系，这样的数据组织形式，就可以抽象为线性表；
2. 线性表是最基本的一种数据结构，根据线性表的实际存储方式，又可以分为顺序表和链表；
</code></pre><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><pre><code>顺序表：将元素有序地存放在一块连续的存储区里，元素间的顺序关系由它们的存储顺序表示。
</code></pre><h4 id="顺序表的基本形式"><a href="#顺序表的基本形式" class="headerlink" title="顺序表的基本形式"></a>顺序表的基本形式</h4><pre><code>1. 基本形式之一：
    1. 用顺序表存储一组整型数据：Li = [2, 390, 78, 1212]，在32位机上，一个整型占4个字节，
       1字节占8个比特位，也即一个整型占32位；
    2. 存储4个整型，需要向操作系统申请16Byte，操作系统会一次性返回一段连续的存储空间；
    假定起始地址是0x23，那么存储每个整数的起始地址为：0x23 --&gt; 0x27 --&gt; 0x31 --&gt; 0x35
    3. 顺序表的引用Li，指向的就是存储空间的起始地址：0x23； Li[0]获取元素时，先查看Li指向的
    内存地址0x23，角标表示内存地址的偏移量，角标为0 表示取值的内存地址为0x23+0*4Byte=0x23；
    同理，Li[3]取值的内存地址为0x23+3*4Byte=0x35；
2. 基本形式之二：元素外置的顺序表
    顺序表在存储不同数据类型的数据时，元素的地址是随机的，所以连续的存储空间存放的不再是元素，
    而是元素的地址；
    1. 用顺序表存储一组不同数据类型的数据：Li = [12, &quot;ab&quot;, 1.11]，虽然不同的数据类型占用的
    字节是不同的，但是内存地址占用的字节是一定的，32位机上的内存地址占用4个字节；
    2. 假定元素12、&quot;ab&quot;、1.11在内存中的起始地址分别为 0x100、0x200、0x53，那么，在顺序表向
    操作系统申请的连续存储区里，所存储的数据就是：0x100，0x200，0x53；
    3. 假定连续存储区的起始地址是0x23，那么存储每个元素地址的起始地址依次为：0x23 --&gt; 0x27
    ---&gt; 0x31； Li指向连续存储区的起始地址：0x23； Li[0]的指向：0x23 --&gt; 0x100 --&gt; 12
</code></pre><h4 id="顺序表的结构"><a href="#顺序表的结构" class="headerlink" title="顺序表的结构"></a>顺序表的结构</h4><pre><code>1. 一个完整的顺序表包括两部分：表头，数据区；
    1. 表头用于记录关闭顺序表的整体信息，主要包括顺序表的总容量和当前的元素个数；
    2. 数据区也就是存储元素的部分；
2. 顺序表的两种基本结构：一体式结构、分离式结构
</code></pre><p><img src="http://i.imgur.com/csOu5lo.jpg" alt></p>
<pre><code>1. 一体式结构的整体性更强，易于管理；缺点在于，顺序表一旦创建，元素存储区就固定了，假定顺序表
   的最大容量是5，如果要继续存入第6个元素，就需要重新申请数据区，又因为表头和数据区在一段连续
   的存储区，就只能搬迁整个顺序表，表头的内存地址也随之变化；
2. 分离式结构的顺序表，数据区在另一个独立的存储空间里，表头信息除了总容量和元素个数，还存储了
   数据区的起始地址；对于总容量为5的顺序表，继续存储第6个元素时，只需要搬迁数据区、修改表头中
   的起始地址即可，不必搬迁表头；所以，分离式结构的顺序表又称为动态顺序表。
3. 动态顺序表的扩充策略：
    1. 线性增长：每次重新申请数据区时，固定扩充一定的数目，比如每次都是在原来的基础上申请10个
       元素位置；这种方式虽然节省空间，但扩充操作频繁；
    2. 倍数增长：每次扩充都是加倍，空间换时间：虽然浪费了空间，但避免了频繁扩充，节省了时间。
</code></pre><h4 id="顺序表的操作"><a href="#顺序表的操作" class="headerlink" title="顺序表的操作"></a>顺序表的操作</h4><pre><code>1. 增加元素
</code></pre><p><img src="http://i.imgur.com/blQf5zl.jpg" alt></p>
<pre><code>    时间复杂度依次为O(1)、O(1)、O(n)，非保序的并不常见；
2. 删除元素
</code></pre><p><img src="http://i.imgur.com/TwUnFOS.jpg" alt></p>
<pre><code>时间复杂度依次为O(1)、O(1)、O(n)
</code></pre><h4 id="Python中的顺序表"><a href="#Python中的顺序表" class="headerlink" title="Python中的顺序表"></a>Python中的顺序表</h4><pre><code>1. Python中的列表和元组，采用的都是顺序表技术实现的，而且都是保序的；
2. 元组是不可变类型，虽然不支持改变其内部的任何操作，但其他方面与列表类似；
2. 列表是一种采用分离式结构实现的动态顺序表，所以append()的效率比insert()要高，pop()的效率
   比pop(index)的效率要高；
3. 列表采用的策略：
    1. 在创建一个空列表或者很小的一个列表时，系统会分配一块能容纳8个元素的存储区；
    2. 在执行append()/insert()时，如果存储区已满，则重新申请一块4倍大的存储区；
    3. 如果列表的容量已经很大了，则采用1倍大的策略进行申请，避免出现过多空闲的存储位置。
</code></pre><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><pre><code>1. 链表的存储区不是连续的，也不会因为扩充存储区而搬迁数据；
2. 每增加一个元素，就创建一个节点，节点其实就一块存储区；
3. 链表可分为单链表和双链表。
</code></pre><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><pre><code>单链表节点的构成：数据区和链接区，分别存储数据元素和下一个元素的内存地址；
1. 在python中，引用的本质就是，保存值的内存地址，比如 a=10，内存a 保存的是10 的内存地址；
2. 链接区就相当于是一个引用，指向下一个节点；
3. 当前节点指向的下一个节点，称为后继节点；
</code></pre><p><img src="https://i.imgur.com/qFWwe2p.jpg" alt></p>
<pre><code>变量p 指向链表的头节点，从p 出发，能找到链表的任意节点；

1. 节点的实现：
</code></pre><p><img src="https://i.imgur.com/2C7UTHH.jpg" alt></p>
<pre><code>2. 单链表的实现：
</code></pre><p><img src="https://i.imgur.com/tG8Nqbo.jpg" alt></p>
<pre><code>3. 链表与顺序表
    1. 链表失去了顺序表随机读取的有点，同时链表的节点指针域cursor也增加了空间开销，但链表
       对存储空间的使用相对灵活；
    2. 时间复杂度
</code></pre><p><img src="https://i.imgur.com/ZkKuEoX.jpg" alt></p>
<pre><code>    1. 链表和顺序表在插入/删除时，虽然时间复杂度都是O(n)，但其原理是完全不同的；
    2. 链表的主要耗时操作是遍历查找，插入/删除操作的时间复杂度为O(1)；
    3. 顺序表查找快，主要耗时操作是插入/删除时的拷贝覆盖。

单向循环链表
    1. 对于一个单链表，让其尾节点的链接区指向头节点，称之为单向循环链表；
    2. 如果只有一个节点，其链接区指向自身。
</code></pre><h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><pre><code>双链表节点的构成：前驱链接区(指向前一个节点)，数据区，后继链接区(指向下一个节点)
1. 当前节点指向的前一个节点，称为前驱节点，指向的下一个节点，称为后继节点；
2. 与单链表的操作相比，在插入和删除时，双链表还需要修改前驱链接区。
</code></pre><h3 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h3><pre><code>栈和队列都是一种数据结构，可以使用顺序表/链表实现；
</code></pre><h4 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h4><pre><code>栈：LIFO，后进先出，只允许在容器的一端(栈顶)进行操作，确定了一种默认的访问顺序；
使用Python中已有的顺序表：列表，实现栈结构：
</code></pre><p><img src="https://i.imgur.com/JVWbZhg.jpg" alt></p>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><pre><code>队列：FIFO，先进先出，只允许在一端(队尾)进行插入，在另一端(队头)进行删除；
使用列表实现队列结构：
</code></pre><p><img src="https://i.imgur.com/NmNwfwj.jpg" alt></p>
<pre><code>1. append() 和 pop() 的时间复杂度是O(1)，而insert() 和 pop(index) 的时间复杂度是O(n)，
   也即，出队和入队总有一个操作的时间复杂度是O(n)；
2. 如果入队的操作大于出队，则选择 append() 和 pop(index) 的组合；反之，则选择 insert() 和
   pop() 的组合。

双端队列：同时具有队列和栈的特性，队头和队尾都能入队和出队。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2017/08/05/Web服务器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/05/Web服务器/" itemprop="url">Web服务器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-05T00:00:00+08:00">
                2017-08-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><pre><code>1. HTTP协议规定的是：客户端与服务器端之间的数据传输规则，也即，规定的是数据内容的格式；
2. 对于客户端，除了浏览器，一些手机APP，如淘宝，京东等，在访问服务器时，也应用了HTTP协议，
   也即，HTTP协议已经超越了浏览器网页的应用；
3. HTTP协议的底层使用的还是TCP协议，也即，服务器的数据处理工作就在clientSocket.recv()与
   clientSocket.send() 两个函数之间；
4. HTTP协议规定的换行符是：\r\n
5. HTTP是无状态的：同一个客户端请求完数据，四次挥手断开链接，再次建立链接时，HTTP并不知道
   是不是同一个客户端，HTTP服务器并不关心是哪个客户端访问的。
6. 为了减少TCP的3次握手和4次挥手，HTTP1.1版本开始，默认使用长连接；
    1. 使用长链接的HTTP协议，会在请求头/响应头加入：Connection: keep-alive
    2. 但是，keep-alive 并不会永久保持链接性，可以在Server端设置链接的时间；
    3. 长连接的HTTP虽然复用了传输通道，但仍然是无状态的。
</code></pre><h3 id="请求头和响应头"><a href="#请求头和响应头" class="headerlink" title="请求头和响应头"></a>请求头和响应头</h3><pre><code>访问百度baidu.com时，客户端发送的请求头与服务器端发送的响应头：
</code></pre><p><img src="http://i.imgur.com/RoVYhU0.jpg" alt></p>
<pre><code>1. HTTP四种基本的请求方式：GET、POST、PUT、DELETE，分别对应：查、改、增、删
2. 增、删、改、查的操作，其实都可以通过GET/POST完成；
3. 其他请求方式：OPTION(获取选项)、HEAD(获取头) ...
</code></pre><p><img src="http://i.imgur.com/tnQ9jFK.jpg" alt></p>
<pre><code>1. 请求头和响应头都是一个字符串，通过&quot;\r\n&quot;实现每一项的换行；
2. 客户端的请求内容在请求体中，请求体位于请求头下面，中间用一个空行(&quot;\r\n&quot;)进行分割；
3. 请求头的数据类型是字符串，而且是字典的格式，但请求体的数据类型和数据大小都是不固定的，
   所以在请求头中，会用&quot;Content-Length&quot;指定请求体的数据大小；
4. 同理，响应体也在响应头的下面，中间用一个空行(&quot;\r\n&quot;)进行区分。
</code></pre><h3 id="URL、URI、URN"><a href="#URL、URI、URN" class="headerlink" title="URL、URI、URN"></a>URL、URI、URN</h3><pre><code>URL和URN是URI的子集
1. URI：Web地址的基本形式，资源标识符；
2. URL：L代表Location，资源的位置定位，域名后面的部分就是请求的资源在服务器端存放的位置；
3. URN：N代表Name，资源的名字定位，根据资源的名字查找，不再受资源位置的限制，URL的升级版。

用百度搜索&quot;abc&quot;的地址栏：https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=0&amp;...
1. URL：https://www.baidu.com/s，请求的资源在服务器端的 s 目录下；
2. &quot;?&quot;后面是GET请求方式需要提交给服务器的参数，因为GET请求不会把参数放在请求体中；
3. &quot;&amp;&quot;：用于连接多个参数;
4. HTTP协议并没有规定URL的长度，GET请求可提交的数据大小是浏览器与服务器约定的，因为浏览器上的
   地址栏长度是有限的。

Spider：蜘蛛，爬虫，也就是一个客户端，接收一个链接地址，向链接地址对应的服务器发送HTTP请求，
    分析响应的数据，获取其中的所有超链接，然后继续向这些超链接地址发送HTTP请求... 通过特定的
    算法，一层一层地爬遍所有的超链接，获取特定的数据；
</code></pre><h2 id="Web静态服务器"><a href="#Web静态服务器" class="headerlink" title="Web静态服务器"></a>Web静态服务器</h2><pre><code>早期的Web服务器资源都是静态的，也即，在服务器上存放开发好的HTML网页等资源，供客户端访问；
静态Web的交互性差；

1. 创建server socket服务
</code></pre><p><img src="http://i.imgur.com/VIgI32F.jpg" alt></p>
<pre><code>2. 为客户端服务的进程target=handle_client
</code></pre><p><img src="http://i.imgur.com/9YDKCAL.jpg" alt></p>
<pre><code>3. 处理数据的函数handle_data()
</code></pre><p><img src="http://i.imgur.com/hPqiJpI.jpg" alt></p>
<pre><code>1. 在当前项目的res目录下，创建index.html文件，并把res目录设置为静态网页的根目录；
2. 在本机上访问：127.0.0.1:8899，设置为访问默认主页，等效于：127.0.0.1:8899/index.html
</code></pre><h3 id="文件读写方式的区别"><a href="#文件读写方式的区别" class="headerlink" title="文件读写方式的区别"></a>文件读写方式的区别</h3><pre><code>open() 规定的读写模式：&quot;r&quot;/&quot;w&quot; 表示文本方式打开/写入，&quot;rb&quot;/&quot;wb&quot; 表示二进制方式打开/写入；
不同系统的换行符可能是不同的：
    1. Unix/Linux： \n
    2. Mac：老版本是 \r，新版本是 \n
    3. windows： \r\n
1. 文本方式写入(w)时，会识别数据中的换行符，并替换成当前系统的换行符，比如写入数据&quot;HI\nDD&quot;，
在windows系统下，数据中&quot;\n&quot;会被替换成&quot;\r\n&quot;；虽然以文本方式读取(r)时，&quot;\r\n&quot;又被转为&quot;\n&quot;，
也即，读取的数据仍是&quot;HI\nDD&quot;，但以二进制方式读取(rb)时，可以发现数据却是&quot;HI\r\nDD&quot;；
2. 二进制方式写入(wb)是，则不会识别任何转义字符，统一作为二进制流进行读写。
</code></pre><h2 id="Web动态服务器"><a href="#Web动态服务器" class="headerlink" title="Web动态服务器"></a>Web动态服务器</h2><pre><code>1. URL地址请求的不再是一个静态网页，而是运行一个python脚本，生成响应的数据；
2. 为了让python-web服务器便于统一调用，python脚本的编写必须符合WSGI规范。
3. WSGI：Python Web Server Gateway Interface
    1. 用于约束python-web服务器和python-web框架的对接规则；
    2. 所有的现代python-web框架都已具备了WSGI接口，web服务器也必须具备WSGI接口，才能确保在
       不修改服务器代码的情况下，可以让web服务器和不同的web架构协同工作。
</code></pre><p><img src="http://i.imgur.com/6qhfqDi.jpg" alt></p>
<pre><code>python脚本中，WSGI标准的HTTP处理函数：
</code></pre><p><img src="http://i.imgur.com/XGFDuaI.jpg" alt></p>
<pre><code>1. 函数的参数：
    environ：必须是字典类型，脚本程序可能需要一些客户端的请求数据，比如客户端的请求方式、提交
            的参数等等，web服务器解析请求数据之后，组织成一个字典，传递给该函数；
    start_response：一个定义在web服务器中的WSGI接口函数，用于接收python脚本传递的响应码和
                部分响应头，从而在web服务器中组织成完整的响应头；
        形参1：响应的状态码，必须是字符串类型
        形参2：部分响应头，必须是一个列表[(键, 值), (键, 值), ...]
2. 函数必须要有返回值，作为响应体；
3. application() 函数就是由web服务器调用的接口，它把底层web服务器的解析部分和应用程序的逻辑
   部分进行分离，只专注于处理程序的逻辑，而程序的逻辑又决定了响应码、部分响应头、以及响应体；
4. 函数名和参数名都是自定义的，但所代表的意义必须符合WSGI标准，web服务器才能正确调用；
5. application() 不一定是函数，重写类中的 __call__() 方法，类对象也可以像调用函数一样使用。
</code></pre><h3 id="改造静态Web"><a href="#改造静态Web" class="headerlink" title="改造静态Web"></a>改造静态Web</h3><pre><code>在静态web服务器的基础上，增加WSGI标准的接口，判断客户端请求的资源是不是一个python脚本，改造成
一个动态Web服务器：
1. 在Web服务器的根目录下，创建存放python脚本的目录wsgipy，并设置 ./wsgipy 目录为脚本资源的
   根目录；在wsgipy目录下创建一个python脚本m_time.py，提供WSGI标准的接口：
</code></pre><p><img src="http://i.imgur.com/E4HrXkT.jpg" alt></p>
<pre><code>2. 在Web服务器中提供WSGI标准的接口，用于拼接完整的响应头：
</code></pre><p><img src="http://i.imgur.com/fVMI2AL.jpg" alt></p>
<pre><code>3. 在Web服务器中处理请求数据时，先判断请求的资源是哪种类型：python脚本，html网页
   如果是python脚本，表示客户端访问的是动态web数据；如果是html网页，表示访问的是静态web数据
</code></pre><p><img src="http://i.imgur.com/dKrFHI4.jpg" alt></p>
<pre><code>在本机的浏览器上输入：127.0.0.1:8899/m_time.py，访问一个动态的web
</code></pre><h2 id="Web框架的编写"><a href="#Web框架的编写" class="headerlink" title="Web框架的编写"></a>Web框架的编写</h2><pre><code>1. 一个web服务器下可能有很多个python脚本和静态HTML网页，每个资源脚本又都有自己的WSGI接口，
   web框架也是python脚本，它提供了WSGI接口，作为所有资源文件的入口；
2. web服务器不关心web框架的实现过程，只需要解析客户端的请求数据，把请求方式、请求的资源路径、
   提交的参数等数据组装成一个字典，并提供WSGI接口，就可以调用web框架的接口，获取响应数据；

4. web框架使用一个类作为WSGI接口，重写类的 __call__()方法，就可以把类的对象改造成一个标准的
   WSGI接口函数；
5. 为了便于区分脚本资源和静态资源，在客户端访问web服务器的静态资源时，资源路径必须以/static为
   根路径，比如：127.0.0.1:8899/static/index.html；
</code></pre><h3 id="web框架"><a href="#web框架" class="headerlink" title="web框架"></a>web框架</h3><p><img src="http://i.imgur.com/o1Nq0Pu.jpg" alt></p>
<p><img src="http://i.imgur.com/DVcxCnM.jpg" alt></p>
<p><img src="http://i.imgur.com/VXJ4DyE.jpg" alt></p>
<pre><code>1. 客户端访问脚本文件时，指定为 urls 中的路径即可，比如：127.0.0.1:8899/ctime；
2. web服务器需要增加新的脚本文件时，只需要在web框架中增加相应的处理函数，并在 urls 中添加相应
   的路径即可，不需要再创建新的脚本，也不需要修改web服务器和web框架的接口Application。
</code></pre><h3 id="web服务器"><a href="#web服务器" class="headerlink" title="web服务器"></a>web服务器</h3><pre><code>面向对象的方式设计web服务器：
</code></pre><p><img src="http://i.imgur.com/e9rpJ2A.jpg" alt></p>
<p><img src="http://i.imgur.com/RfCqlMf.jpg" alt></p>
<pre><code>启动web服务器：
</code></pre><p><img src="http://i.imgur.com/iYtZQR1.jpg" alt></p>
<pre><code>1. getattr(object, name, [default])：反射机制，获取对象object中的成员；
    1. object：一个对象，动态导入的模块，也被看做是一个对象；
    2. name：字符串类型，object中的成员；
    3. default：可选参数，默认为None，用于设置默认值。
2. hasattr(object, name)：判断object中是否存在成员name；
3. setattr(object, name, value)：设置成员name的值为value。
</code></pre><h3 id="不同web框架的启动"><a href="#不同web框架的启动" class="headerlink" title="不同web框架的启动"></a>不同web框架的启动</h3><pre><code>1. 运行python程序时，可以动态传递参数：python3 python.py arg1 arg2 arg3 ...
2. import sys： sys.argv，获取所有参数[&quot;python.py&quot;, &quot;arg1&quot;, &quot;arg2&quot;, &quot;arg3&quot;, ...]
3. 在启动web服务器时，把web框架的模块名和接口对象名作为参数，就可以在不修改web服务器的情况下，
   运行不同的web框架：
</code></pre><p><img src="http://i.imgur.com/rrSE7Kp.jpg" alt></p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2017/08/04/python正则表达式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/04/python正则表达式/" itemprop="url">python正则表达式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-04T00:00:00+08:00">
                2017-08-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="re-模块基础"><a href="#re-模块基础" class="headerlink" title="re 模块基础"></a>re 模块基础</h2><pre><code>re 模块：正则表达式模块；
1. result = re.match(pattern, string)：匹配操作
    1. pattern：正则表达式；    string：要匹配的字符串；
    2. match() 匹配的规则：从左向右，返回一个符合规则的Match对象；
    3. 如果匹配成功，则返回一个匹配对象(Match Object)，否则返回None
2. result.group()：获取匹配的数据
    1. result = re.match(&quot;abc&quot;, &quot;abcdef&quot;)
    2. result.group() --&gt; &quot;abc&quot;，匹配成功
</code></pre><h3 id="单字符匹配"><a href="#单字符匹配" class="headerlink" title="单字符匹配"></a>单字符匹配</h3><pre><code>. ：匹配任意一个字符，除了&quot;\n&quot;
    1. re.match(&quot;.&quot;, &quot;abc&quot;) --&gt; &quot;a&quot;
    2. re.match(&quot;..&quot;, &quot;abc&quot;) --&gt; &quot;ab&quot;
[] ：匹配[]中列举的任意一个字符
    1. re.match(&quot;[H]&quot;, &quot;Hello Python&quot;)  --&gt; &quot;H&quot;
    2. re.match(&quot;[012]&quot;, &quot;12345&quot;) --&gt; &quot;1&quot;
    3. 在[]中，&quot;-&quot;代表一个连续的范围，比如：&quot;0-9&quot;，&quot;3-6&quot;，&quot;a-z&quot;
    3. re.match(&quot;[0-9]&quot;, &quot;789&quot;) --&gt; &quot;7&quot;；
[^...] ：对[]中列举的字符取反
    1. re.match(&quot;[^123]&quot;, &quot;789&quot;) --&gt; &quot;7&quot;
    2. re.match(&quot;[^abc]&quot;, &quot;python&quot;) --&gt; &quot;p&quot;
\d ：匹配数字0-9，等价于 &quot;[0-9]&quot;
    1. re.match(&quot;\d&quot;, &quot;123&quot;) --&gt; &quot;1&quot;
    2. re.match(&quot;阿波罗\d号&quot;, &quot;阿波罗3号登月&quot;) --&gt; &quot;阿波罗3号&quot;
\D ：匹配非数字的字符，等价于 &quot;[^0-9]&quot;
\s ：匹配空白，即空格、tab键、\n、\t、\r等，但不包括空字符串
    1. re.match(&quot;\s&quot;, &quot; abc&quot;) --&gt; &quot; &quot;
    2. re.match(&quot;\s&quot;, &quot;\n123&quot;) --&gt; &quot;\n&quot;
\S ：匹配非空白
\w ：匹配 a-z、A-Z、0-9、_、汉字 中的任意一个字符
    1. re.match(&quot;\w&quot;, &quot;abc&quot;) --&gt; &quot;a&quot;
    2. re.match(&quot;\w&quot;, &quot;_Python&quot;) --&gt; &quot;_&quot;
\W ：匹配非\w的字符
</code></pre><h3 id="数量的表示"><a href="#数量的表示" class="headerlink" title="数量的表示"></a>数量的表示</h3><pre><code>* ：匹配前一个字符 &gt;=0 次
    1. re.match(&quot;\d*&quot;, &quot;123&quot;) --&gt; &quot;123&quot;，全部匹配
    2. re.match(&quot;\d*&quot;, &quot;abc&quot;) --&gt; &quot;&quot;，0-9的数字出现了 0 次
+ ：匹配前一个字符 &gt;=1 次
    1. re.match(&quot;\d+&quot;, &quot;abc&quot;) --&gt; None，不匹配
    2. re.match(&quot;\d+&quot;, &quot;123&quot;) --&gt; &quot;123&quot;，全部匹配
? ：匹配前一个字符出现 0 或 1 次
    1. re.match(&quot;[0-9]?[1-9]&quot;, &quot;2&quot;) --&gt; &quot;2&quot;
    2. re.match(&quot;[2-8]?[0-9]&quot;, &quot;123&quot;) --&gt; &quot;1&quot;
{m} ：匹配前一个字符出现 m 次
{m,} ：匹配前一个字符至少出现 m 次
{m,n} ：匹配前一个字符出现 [m-n] 次
</code></pre><h3 id="边界的表示"><a href="#边界的表示" class="headerlink" title="边界的表示"></a>边界的表示</h3><pre><code>^ ：匹配字符串开头的第一个字符；
    因为match()本身就是从左向右开始匹配的，所以match()的效果并不明显。
    1. re.match(&quot;^[0-9]abc&quot;, &quot;3abc&quot;) --&gt; 等价于：re.match(&quot;[0-9]abc&quot;, &quot;3abc&quot;)
$ ：匹配结尾的最后一个字符
    1. re.match(&quot;12[0-9]$&quot;, &quot;123&quot;) --&gt; &quot;123&quot;
    2. re.match(&quot;[0-9]$&quot;, &quot;123&quot;) --&gt; None，不匹配
    3. 手机号的正则表达式：&quot;^1[35678]\d{9}$&quot;，匹配的第一个字符为&quot;1&quot;，结尾是9个数字；
    4. re.match(&quot;^1[35678]\d{9}$&quot;, &quot;18111111111&quot;) --&gt; 匹配
    5. re.match(&quot;^1[35678]\d{9}$&quot;, &quot;181111111112&quot;) --&gt; 不匹配
\b ：匹配一个单词边界
    1. 在正则中，所谓的单词，就是由&quot;\w&quot;定义的字符所组成的子串；
    2. &quot;\b&quot; 表示所在位置的一侧为单词字符，另一个为非单词字符、字符串的开始/结束位置；
    3. re.match(&quot;ve\b&quot;, &quot;ve&quot;) --&gt; &quot;ve&quot;
    4. re.match(&quot;ve\b&quot;, &quot;vee&quot;) --&gt; None，不匹配
    5. re.match(&quot;ve\b&quot;, &quot;ve#&quot;) --&gt; &quot;ve&quot;
    6. re.match(&quot;ve\b&quot;, &quot;ve abc&quot;) --&gt; &quot;ve&quot;
\B ：匹配非单词边界
    1. re.match(&quot;.+\Bve\B&quot;, &quot;hove&quot;) --&gt; None，不匹配
    2. re.match(&quot;.+\Bve\B&quot;, &quot;hover&quot;) --&gt; &quot;hove&quot;
</code></pre><h3 id="原始字符串"><a href="#原始字符串" class="headerlink" title="原始字符串"></a>原始字符串</h3><pre><code>原始字符串：在字符串前加 r ，忽略&quot;\&quot;对字符的转义，其实 r 内部对转移字符做了处理；
1. r&quot;\n123&quot; --&gt; 等价于：&quot;\\n123&quot;，print输出：\n123
2. 对于正则中自带的&quot;.&quot;、&quot;*&quot;、&quot;?&quot;等，如果要使用其原生意义，还是需要加&quot;\&quot;；
3. re.match(r&quot;\w+@163\.com&quot;, &quot;isummer@163.com&quot;)
</code></pre><h3 id="匹配分组"><a href="#匹配分组" class="headerlink" title="匹配分组"></a>匹配分组</h3><pre><code>| ：匹配左右任意一个表达式
    1. 匹配0~100之间的数字：&quot;[1-9]?\d$|100&quot;，&quot;[1-9]\d?$|0$|100$&quot;
(ab)：将()中的字符作为一个分组
    1. re.match(r&quot;\w{4,20}@(163|126|qq)\.com$&quot;, &quot;test@163.com&quot;) --&gt; 匹配邮箱；
    2. 提取分组
        1. result = re.match(r&quot;&lt;h1&gt;(.*)&lt;h1&gt;&quot;, &quot;&lt;h1&gt;test&lt;h1&gt;&quot;)
        2. result.group(0) --&gt; 等效于 result.group()
        3. result.group(1)：获取第一个匹配的分组，&quot;test&quot;
        4. result.groups()：获取所有匹配的分组，并返回一个元组；
\num ：与(ab)配合使用，引用第num组匹配的字符串
    1. 匹配超文本字符串：s = &quot;&lt;html&gt;&lt;h1&gt;python&lt;/h1&gt;&lt;/html&gt;&quot;
    2. result = re.match(r&quot;&lt;(.+)&gt;&lt;(.+)&gt;.+&lt;/\2&gt;&lt;\1&gt;&quot;, s)
    3. result.groups() --&gt; (&quot;html&quot;, &quot;h1&quot;)
(?P&lt;name&gt;···)：为分组定义一个名字name
(?P=name)：按照名字name引用分组所匹配的字符串
    1. 匹配超文本字符串：s = &quot;&lt;html&gt;&lt;h1&gt;python&lt;/h1&gt;&lt;/html&gt;&quot;
    2. re.match(r&quot;&lt;(?P&lt;key1&gt;\w*)&gt;&lt;(?P&lt;key2&gt;\w*)&gt;.*&lt;/(?P=key2)&gt;&lt;/(?P=key1)&gt;&quot;, s)
</code></pre><h2 id="re-模块高级"><a href="#re-模块高级" class="headerlink" title="re 模块高级"></a>re 模块高级</h2><pre><code>1. search(pattern, str)
    1. 从左向右，查找出符合pattern的第一个子串，也返回Match对象；
    2. re.search(r&quot;\d+&quot;, &quot;read 9999 times 2222&quot;) --&gt; &quot;9999&quot;
    3. re.match(r&quot;\d+&quot;, &quot;read 9999 times 2222&quot;) --&gt; None
    4. 区别：match()从字符串开头进行匹配，如果匹配失败，则返回None；而search()会查找
    字符串中符合规则的字串，如果没有，才返回None；
    5. 共同点：只匹配一次，返回匹配成功的第一个字串。
1. Match.span()：返回一个元组，元素是成功匹配的开始角标和结束角标；
2. findall(pattern, str)：查找出str中所有符合pattern的子串，返回一个列表；
    1. re.findall(r&quot;\d+&quot;, &quot;read 9999 times 2222&quot;) --&gt; [&quot;9999&quot;, &quot;2222&quot;]
    2. finditer()：与findall()的区别，返回一个迭代器，元素是Match对象。
3. sub(pattern, repl, str)
    1. 批量替换：查找出符合pattern的所有子串，替换成repl，返回一个新的字符串；
    2. re.sub(r&quot;\d+&quot;, &quot;50&quot;, &quot;read 99 times 22&quot;) --&gt; &quot;read 50 times 50&quot;
    3. repl 可以接收一个函数：
        1. 函数必须要有一个形参，用于接收每次匹配成功所返回的Match对象；
        2. 匹配的子串会被替换成函数的返回值，所以函数的返回值必须是字符串；
        3. 如果函数没有return，默认返回为空字符串；
</code></pre><p><img src="http://i.imgur.com/UmS62S4.jpg" alt></p>
<pre><code>4. split(pattern, string)
    1. 根据pattern切割字符串，返回一个列表；
    2. re.split(r&quot;:| &quot;, &quot;python:Java php C&quot;) --&gt; [&quot;python&quot;, &quot;Java&quot;, &quot;php&quot;, &quot;C&quot;]
</code></pre><h3 id="贪婪模式"><a href="#贪婪模式" class="headerlink" title="贪婪模式"></a>贪婪模式</h3><pre><code>1. 在Python中，数量词默认是贪婪的，总是尝试匹配尽可能多的字符；非贪婪模式则相反，总是尝试
   匹配尽可能少的字符；
2. 正则表达式中的数量词：&quot;*&quot;，&quot;?&quot;，&quot;+&quot;
3. 贪婪模式转为非贪婪模式：在数量词后加上 &quot;?&quot;
</code></pre><p><img src="http://i.imgur.com/f0D1bUD.jpg" alt></p>
<pre><code>s = &quot;&lt;p&gt;Hello Python&lt;/p&gt;&quot;
1. 贪婪模式：re.sub(r&quot;&lt;.+&gt;&quot;, &quot;==&quot;, s) --&gt; &quot;==&quot;
2. 非贪婪模式：re.sub(r&quot;&lt;.+?&gt;&quot;, &quot;==&quot;, s) --&gt; &quot;==Hello Python==&quot;
</code></pre><h3 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h3><pre><code>compile(pattern)：创建一个pattern对象，可以调用match(str)，search(str) ...
1. match/search(str, begin, end)：可以指定匹配的范围，返回Match对象；
2. re.S：全文匹配；    re.I：忽略大小写；
    1. p = re.compile(&apos;&lt;div\sclass=&quot;content&quot;&gt;(.*?)&lt;/div&gt;&apos;, re.S)
    2. p.findall(htmlstr)：自动提取匹配成功后的分组，返回的列表元素是分组(.*?)
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2017/08/03/单任务并发服务器与协程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/03/单任务并发服务器与协程/" itemprop="url">单任务并发服务器与协程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-03T00:00:00+08:00">
                2017-08-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="并发服务器"><a href="#并发服务器" class="headerlink" title="并发服务器"></a>并发服务器</h2><pre><code>1. setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)：允许重复使用绑定信息；
    如果TCP-Server因为某些情况先调用close() 关闭与TCP-Client的链接，TCP-Server会等待
    2MSL的时间；在这段时间之内，如果Server程序重启，会导致无法绑定端口。
2. 多进程和多线程实现并发服务器时，因为多进程占用的资源相对较高，如果服务器的配置比较一般，
   尽量使用多线程实现。
</code></pre><h3 id="单任务并发服务器"><a href="#单任务并发服务器" class="headerlink" title="单任务并发服务器"></a>单任务并发服务器</h3><pre><code>单进程、单线程、非阻塞的并发服务器
1. setblocking(False)：将TCP Socket变为非阻塞的，即accpet()、recv() 变为非阻塞；
2. 在执行accept()/recv()时，如果恰巧没有客户端链接/没有收到数据，会抛出异常；
3. try-except-else：没有异常时才会执行else语句；
</code></pre><p><img src="http://i.imgur.com/8cBPkWW.jpg" alt></p>
<pre><code>如果客户端较多，单任务并发服务器的效率会明显小于多任务并发服务器。
</code></pre><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><pre><code>1. 多路复用：单个线程通过记录跟踪每一个I/O流的状态，来同时管理多个I/O流；
2. 多路复用也是为了在单任务模式下，尽可能多的提高服务器的吞吐量；
3. 常用的多路复用模型：select模型和epoll模型。
</code></pre><h4 id="select-单任务并发服务器"><a href="#select-单任务并发服务器" class="headerlink" title="select 单任务并发服务器"></a>select 单任务并发服务器</h4><pre><code>select 可以检测套接字，它是系统提供的接口，执行效率更高，而且select是跨平台的。
Python的select模块对原始的select做了更高级的封装：select.select()
select(rlist, wlist, xlist, [timeout])：
    1. rlist：读-套接字列表，检测rlist中，哪些套接字接收到了数据；
    2. wlist：写-套接字列表，检测wlist中，哪些套接字要发送数据；
    3. xlist：套接字列表，检测xlist中，哪些套接字产生了异常。
    4. select() 是阻塞的，以轮询的方式遍历检测每个列表中的套接字，一旦rlist中有套接字接收
        到了数据，或者wlist中有套接字要发送数据，或者xlist中有套接字产生了异常，select()
        就停止阻塞，返回一个元组(rl, wl, xl)：rl、wl、xl也是列表，分别是存储对列表rlist、
        wlist、xlist的检测结果。
    5. timeout：设置超时时间；
</code></pre><p><img src="http://i.imgur.com/L8Ce2P2.jpg" alt></p>
<pre><code>FD：文件描述符
    1. 在Linux中，一切皆可以看成文件，文件又分为：普通文件、目录文件、链接文件和设备文件；
    2. FD是系统内核为了高效管理已被打开的文件所创建的索引，是一个非负整数(通常是小整数)，
       用来代指被打开的文件，所有执行I/O操作的系统调用都通过文件描述符。
    3. f = open(&quot;x.py&quot;, &quot;w&quot;) --&gt; f.fileno()：获取x.py对应的文件描述符；
    4. 网络通信也被Unix/Linux系统抽象为文件的读写，一个socket对应一个FD；
    5. socket.fileno()：获取socket对象对应的文件描述符。
import sys
    1. sys.stdin：标准输入 --&gt; 键盘；  sys.stdin.fileno()：FD为 0；
    2. sys.stdout：标准输出 --&gt; 屏幕；  sys.stdout.fileno()：FD为 1；
    3. sys.stderr：标准错误 --&gt; 屏幕；  sys.stdout.fileno()：FD为 2。
select 的缺点：
    1. 在32位系统中，单进程能够监视的最大FD的数量为1024，也即：除了Server socket，只能
       接受1023个客户端同时访问；64位系统默认的最大FD数量为2048；
    2. select检测socket时，采用的是轮询的方式，效率低下。
poll模型：与select的区别是，解决了监听套接字的上限问题。
</code></pre><h4 id="epoll-单任务并发服务器"><a href="#epoll-单任务并发服务器" class="headerlink" title="epoll 单任务并发服务器"></a>epoll 单任务并发服务器</h4><pre><code>epoll模型：与select的区别，没有监听套接字的上限限制，检测方式使用的是事件通知机制，不会因为
    套接字的增多而降低效率。
1. 创建epoll对象
    epoll = select.epoll()
2. 对socket FD注册事件(重复注册会报异常)：register(FD, events)
    epoll.register(socket FD, select.EPOLLIN|select.EPOLLET)
    1. select.EPOLLIN：events的读事件，表示检测socket是否接收到了数据；
    2. select.EPOLLOUT：events的写事件，表示检测socket是否要发送数据；
    3. select.EPOLLET：注册socket FD为ET模式；
    epoll对文件描述符操作的两种模式：
        1. LT模式：默认模式，当epoll检测到FD事件发生、并将事件通知应用程序时，应用程序可以
            不立即处理该事件，下次调用poll()时，会再次响应、并通知此事件；
        2. ET模式：应用程序必须立即处理该事件，如果不处理，下次再调用poll()时，不会再通知。
3. epoll.poll()：阻塞方法，等价于select()，区别是：接收到数据的套接字、要发送数据的套接字、
    发生异常的套接字，是以事件通知的方式响应给poll()，以元组(FD, events)的形式存入列表，
    并返回列表[(FD, events), ...]；
4. 对FD取消注册
    epoll.unregister(FD)
</code></pre><p><img src="http://i.imgur.com/DGN1lV6.jpg" alt></p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><pre><code>协程：微线程，纤程，是比线程更小的执行单元
1. 进程是资源分配的单位，线程是CPU调度的单位，协程是线程中的一个执行单位。
2. CPU在切换线程时，会用一块内存存储当前线程的状态，以便于再次执行时，能恢复上次的执行状态，
   即恢复CPU上下文；
3. 存储和恢复线程的上下文都是消耗时间的，而协程自带CPU上下文，不需要切换，只要当前线程正在被
   CPU执行，那么线程中的函数就可以在任何地方保存运行的状态，然后切换到另一个函数；所以，在完
   成特定的多任务时，协程的执行效率要大于线程和进程。
4. 计算密集型与IO密集型
    1. 计算密集型：比如执行多层for循环，占用大量的CPU资源；所以，计算密集型更适合使用多进程，
            因为Python中的多线程是由GIL控制的，同一时刻，只能有一个CPU在执行，而多进程可以
        有效利用多核CPU；
    2. IO密集型：网络通信中，其实大量的时间都在等待接收网络数据，也即，CPU在等待IO操作；
                所以，IO密集型更适合使用占用资源较少的多线程和协程。
    3. yield 实现一个协程：
</code></pre><p><img src="http://i.imgur.com/qAL0zMK.jpg" alt></p>
<h3 id="greenlet"><a href="#greenlet" class="headerlink" title="greenlet"></a>greenlet</h3><pre><code>greenlet模块需要手动安装：sudo pip/pip3 install greenlet
1. greenlet是实现协程的一种方式，使用的是C语言，底层调用的也是yield；
2. 多进程和多线程是根据操作系统的调度算法，切换要执行进程/线程，而greenlet协程，可以手动切换
   要执行的任务(函数)；
</code></pre><p><img src="http://i.imgur.com/B291aQa.jpg" alt></p>
<h3 id="gevent"><a href="#gevent" class="headerlink" title="gevent"></a>gevent</h3><pre><code>gevent模块安装：sudo pip/pip3 install gevent
1. gevent相当于对greenlet做了再次封装，功能更加强大，可以自动切换要执行的任务(函数)；
2. gevent的原理：当一个greenlet遇到耗时操作时，比如访问网络、等待接收数据时，就会自动切换到
        其他的greenlet，等到IO操作完成后，再适时切换回来，保证总有greenlet在执行，而不是
        让CPU等待IO操作完成。
3. 如果没有遇到耗时操作(sleep，IO操作等)，gevent不会切换。
</code></pre><p><img src="http://i.imgur.com/DDh6GOx.jpg" alt></p>
<h4 id="gevent-单任务并发服务器"><a href="#gevent-单任务并发服务器" class="headerlink" title="gevent 单任务并发服务器"></a>gevent 单任务并发服务器</h4><pre><code>gevent模块封装IO操作，在实现网络通信时，不能使用socket模块，否则gevent无法识别；
from gevent import socket, monkey
1. monkey.patch_all()：必须在程序的第一行调用，下面的代码会按照gevent的方式编译；
2. socket.socket()：创建一个TCP socket对象，操作方式和socket模块相同；
</code></pre><p><img src="http://i.imgur.com/SuviMQw.jpg" alt></p>
<pre><code>1. accept() 第一次执行时，还没有TCP-Client子协程；等到TCP-Client链接时，gevent.spawn()
   开启一个Client的子协程，用于接收TCP-Client发来的数据；
2. 有多少个TCP-Client链接，就会创建多少个Client子协程，每个协程中都有耗时IO操作，保证协程
   之间不断地切换。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2017/08/02/TCP与网络通信过程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/02/TCP与网络通信过程/" itemprop="url">TCP与网络通信过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-02T00:00:00+08:00">
                2017-08-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="TCP-socket"><a href="#TCP-socket" class="headerlink" title="TCP socket"></a>TCP socket</h2><pre><code>TCP：传输控制协议；
1. 面向连接的、可靠的通信协议；相对UDP，传输速度要慢一些；
2. TCP更稳定，web服务器使用的都是TCP。
</code></pre><p><img src="http://i.imgur.com/Ln6b6hY.jpg" alt></p>
<h3 id="TCP-服务器"><a href="#TCP-服务器" class="headerlink" title="TCP 服务器"></a>TCP 服务器</h3><pre><code>1. 创建TCP对象：socket(AF_INET, SOCK_STREAM)
2. bind((&quot;&quot;, port))：绑定Ip和端口号，&quot;&quot; 表示本机任意Ip；
3. listen(max)
    1. socket对象默认属性是主动地发送消息，listen() 将其变为被动地等待接收消息；
    2. max 表示可以同时接受客户端访问的最大数量。
4. accept()
    1. 阻塞方法，等待客户端来访问，返回一个元组(clientSocket, clientAddr)
    2. clientSocket：为当前客户端服务的socket对象；    clientAddr：客户端的地址。
5. clientSocket.recv(1024)：接收客户端发来的数据，1024表示一次性接收的最大字节；
6. clientSocket.send(data)：向客户端发送数据；
7. clientSocket.close()：服务器主动关闭当前客户端的服务；
    当客户端tcp socket主动调用close()关闭链接时，TCP服务器的recv()收到的数据长度为0，
    此时TCP服务器也会结束对该客户端的服务。
8. close()：关闭tcp socket服务；
        只是accept()不再接受新的客户端进行链接，并不影响已链接的clientSocket。

TCP服务器的大体框架：
</code></pre><p><img src="http://i.imgur.com/mC9Gd8m.jpg" alt></p>
<pre><code>如果开启的是线程，则不能关闭当前进程的client socket，因为在同一个进程中的传递，
是引用传递；而进程间传递参数，是值传递，拷贝了一份数据。
</code></pre><h3 id="TCP-客户端"><a href="#TCP-客户端" class="headerlink" title="TCP 客户端"></a>TCP 客户端</h3><pre><code>1. 创建TCP对象：socket(AF_INET, SOCK_STREAM)
2. connect(serverAddr)：连接TCP服务器，且只需要链接一次；
        serverAddr：是一个元组(Ip, port)，表示服务器的Ip和port。
3. send(data)：向TCP服务器发送数据；
4. recv(1024)：接收TCP服务器发来的数据；
5. close()：关闭socke。
</code></pre><h2 id="网络通信过程"><a href="#网络通信过程" class="headerlink" title="网络通信过程"></a>网络通信过程</h2><pre><code>Packet Tracer：模拟网络通信的软件，思科公司出品；
五层网络通信的层次：
</code></pre><p><img src="http://i.imgur.com/Wu4zibo.jpg" alt></p>
<h3 id="交换机与集线器"><a href="#交换机与集线器" class="headerlink" title="交换机与集线器"></a>交换机与集线器</h3><pre><code>1. 两台主机可以通过一根网线连接，并将两台主机的Ip设置成同一网段，在不借助外网的情况下，
   两台主机就可以实现直接通信，这样的网络就是一个小型局域网；
2. 两台以上的主机要组成网络，就需要设备连接主机间的网线，比如集线器与交换机。
</code></pre><h4 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h4><pre><code>集线器(hub)的主要作用：连接多台电脑；但是因为交换机的出现，集线器基本已经被淘汰了。
缺点：每个数据包都是以广播的形式发送的，同一个网络中的其他所有主机都会受到数据包，
    容易造成网络堵塞。
</code></pre><h4 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h4><pre><code>交换机会有一个自动学习的过程：
    同一个局域网下，主机A第一次向主机B发数据包，交换机会在自己的MAC地址表中记录下主机A的
    Mac地址，然后以广播的形式向其他主机都发送一份数据包，因为数据包中的目的Ip是主机B的Ip，
    所以只有主机B会解析数据包，并附加上自己的Mac地址，回复给交换机，交换机又记录下主机B的
    Mac地址，再将数据包转发给主机A；
    交换机学习完成，主机A和主机B再次发送数据包时，就会以点对点的形式单播。
交换机的转发过滤：
    交换机学习完成之后，在MAC地址表中就会存有通信双方的MAC地址，只要在MAC地址表中有映射，
    交换机就会把数据包转发给目的节点，而不是所有主机。
</code></pre><h3 id="MAC-地址"><a href="#MAC-地址" class="headerlink" title="MAC 地址"></a>MAC 地址</h3><pre><code>MAC地址：物理地址、实际地址、硬件地址，比如40-8D-5C-88-F0-81，其实是网卡号；
网卡号一共有6个字节，分为前三组和后三组，前三组表示厂商，后三组表示厂商所生产的网卡序列号。
MAC地址是唯一的。
</code></pre><h3 id="ping-Ip"><a href="#ping-Ip" class="headerlink" title="ping Ip"></a>ping Ip</h3><pre><code>ping Ip：进行通信时，使用的是ICMP协议，即发送的是ICMP数据包。
ping通信过程：
    对于交换机组成的局域网，第一次 ping 目标主机Ip时，其实是先发送ARP协议数据包，携带了
    源主机的IP和MAC地址，以及目的主机的IP，用于获取目的主机的MAC地址 --&gt; 交换机接收到
    ARP数据包 --&gt; 转发给其他所有主机，即发送ARP广播 --&gt; 其他主机解析数据包中的目标Ip，
    在网络层判断是否与自身的Ip一致，如果不一致，就会丢弃；如果Ip一致，就会在ARP数据包中
    填写上自己的Mac地址，回复给交换机，交换机再回复给源主机；
    在次过程，交换机会记录下双方的Mac地址，然后才会以单播形式发送ICMP数据包，进行通信；
</code></pre><p><img src="http://i.imgur.com/M50FULx.jpg" alt></p>
<pre><code>ARP协议：根据Ip找MAC地址，ARP数据包是OSI Model，七层协议模型；
RARP协议：根据MAC地址找Ip。

windows系统命令行：
    arp -a，查看一台主机上的MAC地址表；MAC地址表，也就是ARP缓存表。
    arp -d：删除ARP缓存表。
</code></pre><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><pre><code>集线器和交换机只能链接同一网段的主机，对于不同网段的主机，交换机和集线器都无法完成通信。
TCP/IP协议规定：
    同一网段的主机通过ARP协议查找MAC地址，通过MAC地址进行通信；
    不同网段的主机，不能直接通信，也就是说：两个不同网段的的网卡，不能直接发送数据包。
    不同网段的主机要进行通信，必须设置主机的网关Ip，将数据包发给指定的网关，由网关通过
    路由查找目的主机的Ip地址。
网关(Gateway)：
    网关其实就是具有路由功能的设备，比如：路由器、启用了路由协议的服务器(相当于路由器)、
    代理服务器(也相当于路由器)。
    通常情况下，把路由器设置为默认网关。
路由器的作用：
    路由器中实际上至少有两个串口网卡，正是因为两个网卡在同一台设备上，才可以实现两个不同
    网段的网卡进行直接通信，从而链接两个不同网段的网络，实现不同网段间的主机通信。
</code></pre><h4 id="单个路由器组网"><a href="#单个路由器组网" class="headerlink" title="单个路由器组网"></a>单个路由器组网</h4><pre><code>两个不同网段的主机(A/B)通过一个路由器进行通信：
    1. 路由器有两个串口网卡(Card1，Card2)，对应两个Mac地址(Mac1，Mac2)；
    2. Card1的Ip与主机A的Ip在同一个网段，Card2的Ip与主机B的Ip在同一个网段；
    3. 设置主机A的默认网关Ip为Card1的Ip，设置主机B的默认网关Ip为Card2的Ip。

配置路由器串口网卡的Ip：
</code></pre><p><img src="http://i.imgur.com/SliT3hk.png" alt></p>
<pre><code>开始第一次通信：
    主机A ping 主机B --&gt; 主机A发送ARP数据包，经交换机广播给所有端口，包括默认网关 --
--&gt; 默认网关转发给路由器 --&gt; 路由器Card1 解析ARP数据包，并填上自己的MAC地址，经交换机
回复给主机A --&gt; 主机A再发送ICMP数据包，经交换机转发给默认网关 --&gt; 默认网关转发给路由器
--&gt; Card1在路由器内部转发给Card2 --&gt; 路由器Card2发送携带了自身Mac地址和数据包目的IP的
ARP数据包，经交换机转发给主机B所在网络的所有主机 --&gt; 因为目的Ip是主机B，所以只有主机B才
会解析ARP数据包，并填写上自己的Mac地址，回复给默认网关 --&gt; 默认网关原路转发给主机A --&gt;
通信建立完成，开始以单播的形式发送ICMP数据包。
</code></pre><h4 id="多个路由器组网"><a href="#多个路由器组网" class="headerlink" title="多个路由器组网"></a>多个路由器组网</h4><pre><code>两台不同网段的主机，经由多个路由器进行通信：
    1. 两个路由器之间必须设置成同一网段的Ip，组成单独的网络，实现路由器之间通信；
    2. 路由器之间第一次通信，也是发送ARP广播，获取下一个路由器的Mac地址；
    3. 配置路由器的Ip地址：
</code></pre><p><img src="http://i.imgur.com/9UANOjr.jpg" alt></p>
<pre><code>4. 在整个转发数据包的过程中，数据包的源Ip和目的Ip不会变化，数据包的转发是根据Mac地址
   寻找下一个转发设备的；
5. 路由器之间的通信使用的是路由协议，比如，路由器Router0要向Router1转发数据包，就必
   须配置Router0的路由表：
    1. Network：配置数据包的目的Ip；因为路由器会对配置的目的Ip和子网掩码进行与运算，
            最终得到数据包所在的网段，所以配置为数据包目的Ip所在的网段即可。
    2. Next Hop：配置下一个要转发的路由器的Ip，即配置为路由器Router1的Card1 Ip；
    3. Add：添加进路由器，可以添加多个。
</code></pre><p><img src="http://i.imgur.com/FfaVua7.jpg" alt></p>
<pre><code>    192.168.1.x网络的主机 ping 192.168.2.x的主机，路由器的Network设置为192.168.2.0；
    反之，2.x的主机向1.x的主机发送数据包，路由器的Network设置为192.168.1.0。
如果不配置路由器的路由表，或者配置错误，它会丢弃掉接收到的数据包。
</code></pre><h3 id="Mac-与-Ip-的作用"><a href="#Mac-与-Ip-的作用" class="headerlink" title="Mac 与 Ip 的作用"></a>Mac 与 Ip 的作用</h3><pre><code>Ip地址和Mac地址都是唯一标识一个网卡，之所以同时设计Ip地址和Mac地址，通过演示 “不同网段的
两台主机、经由多个路由器进行通信” 发现：
    在整个通信过程中，数据包中的源主机Ip与目的主机Ip始终是不变的，而Mac地址是在变化的；
    数据包中的Mac地址是当前设备和下一个要转发的设备的Mac地址。
1. Ip地址用于标记逻辑上的地址，记录发送端和接收端；
2. Mac地址用于标记当前实际转发的设备地址，记录下一次应该转发给哪台设备。
</code></pre><h3 id="服务器组网"><a href="#服务器组网" class="headerlink" title="服务器组网"></a>服务器组网</h3><pre><code>服务器其实就是配置较高的主机，也需要配置Ip和默认网关(Gateway)。
</code></pre><h4 id="http服务器"><a href="#http服务器" class="headerlink" title="http服务器"></a>http服务器</h4><pre><code>用主机上的浏览器访问另一个网段的http服务器：
    1. 配置主机、http服务器的Ip地址和默认网关；
    2. 配置路由器；
    3. 除了HTTP服务，关闭服务器上的其他服务，可以编辑Http服务的index.html页面；
</code></pre><p><img src="http://i.imgur.com/k8X9R6l.png" alt></p>
<pre><code>TCP的三次握手、4次挥手：
    主机192.168.1.1的浏览器上，输入http服务器的地址192.168.2.1，开始访问 --&gt; 浏览器
先发送ARP数据广播，获取默认网关的Mac地址 --&gt; .....(获取Mac地址的过程) --&gt; 浏览器发送
TCP数据包到http服务器 -- (不考虑超时重发) --&gt; http服务器回复TCP数据包 --&gt; 浏览器发送
TCP数据包，紧接着又发送HTTP数据包 --&gt; http服务器收到数据包，解析浏览器请求的数据 ----
-- 浏览器与Web服务器完成3次TCP握手，TCP链接建立完成，可以进行数据交互 ---- http服务器
回复TCP数据包和HTTP数据包 --&gt; 浏览器收到TCP数据包和HTTP数据包 ----web浏览器使用的正是
HTTP协议，所以浏览器能解析响应的HTTP数据包，加上渲染效果，展示数据 --- 数据请求完成 --&gt;
浏览器再次发送TCP数据包 --&gt; http服务器回复TCP数据包 --&gt; 浏览器再次发送TCP数据包 ----&gt;
http服务器收到TCP数据包 ---- 浏览器与Web服务器完成4次TCP挥手，成功断开TCP链接。
</code></pre><h4 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a>DNS服务器</h4><pre><code>1. 域名：其实就是服务器Ip地址的别名，便于记忆，如 https://www.baidu.com/
2. DNS协议用于解析域名对应的Ip地址；一个Ip地址，可以对应多个域名；
3. 因为域名的数量过于庞大，所以就用一个服务器专门解析域名：DNS服务器。
4. 主机访问一个域名时，比如baidu.com --&gt; 先访问的是DNS服务器 --&gt; DNS服务器解析域名，
   返回对应的Ip地址给主机 --&gt; 主机通过Ip地址访问百度的服务器。
5. 用主机浏览器通过域名访问http服务器：
    1. 配置主机、DNS服务器、http服务器的Ip地址和默认网关；
    2. 配置主机上的DNS服务器Ip：DNS Server；
    3. DNS服务器：除了DNS服务，关闭服务器上的其他服务；
    4. 在DNS服务中，自定义http服务器的Ip对应的域名，一个Ip可以添加多个域名；
</code></pre><p><img src="http://i.imgur.com/1oFDt5d.png" alt></p>
<pre><code>在主机192.168.1.1的浏览器上，输入DNS服务中保存的域名，开始访问：
    浏览器发送ARP广播，获取默认网关的Mac地址 --&gt; ...(获取Mac地址的过程) --&gt; 浏览器
发送DNS数据包到DNS服务器 -- DNS协议底层使用的也是UDP协议，没有确认收到的回复过程 --&gt;
NDS服务器收到DNS数据包，解析数据包中的域名，回复带有相应Ip的DNS数据包 --&gt; 浏览器收到
DNS数据包，获取域名对应的Ip，开始发送TCP数据包，与http服务器建立通信...
</code></pre><h3 id="DHCP-协议"><a href="#DHCP-协议" class="headerlink" title="DHCP 协议"></a>DHCP 协议</h3><pre><code>DHCP协议：
    一个局域网的、基于UDP协议的网络协议，用于给局域网内的主机自动分配Ip地址、子网掩码、
    默认网关地址、DNS服务器地址等TCP/IP参数。
DHCP服务器：启用DHCP服务的主机；用于检测同一局域网中没有TCP/IP参数的主机，并为其分配。
应用：
    DHCP服务器通常应用于主机数量比较多的大型局域网，因为主机数量比较多，手动设置众多主机
    的TCP/IP参数会很麻烦；而且，一旦主机的TCP/IP参数发生了变化，还需要重新手动修改；
    所以，只需要为主机配置好DHCP服务器的Ip地址，DHCP服务器会为主机自动分配TCP/IP参数；
    如果TCP/IP参数有所变动，也只需要修改DHCP服务器上的TCP/IP参数即可。
</code></pre><h3 id="访问百度的过程"><a href="#访问百度的过程" class="headerlink" title="访问百度的过程"></a>访问百度的过程</h3><pre><code>1. 先解析baidu.com对应的Ip地址；
    1. 浏览器先发送ARP广播，获取默认网关的MAC地址；
    2. 浏览器组织DNS数据包，发送给默认网关；
        1. DNS数据包：携带的源Ip是客户端主机Ip，目的Ip是主机配置的DNS服务器Ip；
        2. DNS数据包：携带的目的Mac地址是下一个转发设备的MAC地址，即默认网关的MAC地址。
    3. 默认网关具有转发数据的能力，把DNS数据包转发给路由器；
    4. 路由器根据自己的路由协议，选择一个较快的路径转发数据包到目的网关；
    5. 目的网关，即DNS服务器的默认网关，把DNS数据包转发给DNS服务器；
    6. DNS服务器解析查询出baidu.com对应的Ip地址，组织成DNS数据包，原路转发给浏览器。
2. 浏览器解析DNS数据包，得到baidu.com对应的Ip地址，即Web服务器的Ip地址；
3. 浏览器开始向Web服务器发送TCP的3次握手，进行TCP链接；
4. 链接成功之后，浏览器使用HTTP协议发送数据请求给Web服务器；
5. Web服务器收到HTTP请求后，查询自己的主机，将相应的数据组织成Http数据包，转发给客户端；
6. 浏览器收到响应的Http数据包后，通过自己的渲染功能，将数据展示到网页上；
7. 浏览器关闭TCP链接，发送TCP数据包到Web服务器；
8. Web服务器收到TCP数据包，回复一个TCP数据包，然后关闭对该客户端的服务，同时又发送一个
   TCP数据包到浏览器；
9. 浏览器收到TCP数据包，回复给Web服务器一个TCP数据包 --&gt; 访问完成。
百度服务器的访问量很大，如果客户端接收到数据后，没有关闭TCP链接，百度服务器会强制断开。
</code></pre><h3 id="TCP的3次握手与4次挥手"><a href="#TCP的3次握手与4次挥手" class="headerlink" title="TCP的3次握手与4次挥手"></a>TCP的3次握手与4次挥手</h3><pre><code>1. TCP客户端通过connect() 链接TCP服务器，TCP服务器通过accept() 接收TCP客户端；
2. TCP客户端调用close() 关闭链接，TCP服务器的recv() 会收到一个长度为0的数据，随之也
   调用close()，关闭对该TCP客户端的服务。
</code></pre><h4 id="3次握手"><a href="#3次握手" class="headerlink" title="3次握手"></a>3次握手</h4><pre><code>TCP-Client 调用connect()，底层发送一个类型为SYN的TCP数据包，数据包中还带有ACK NUM和
SEQUENCE NUM --&gt; TCP-Server收到TCP数据包，并将ACK NUM的值+1，回复一个类型为SYN+ACK
的TCP数据包 --&gt; TCP-Client收到TCP数据包，如果ACK NUM数值是正确的，则发送ACK确认包，
紧接着又会发送一个请求数据的HTTP数据包 --&gt; TCP-Server 收到TCP数据包，如果各项数值都是
正确的，则表示3次握手完成。
</code></pre><p><img src="http://i.imgur.com/xK9A3Me.jpg" alt></p>
<pre><code>3次握手成功，也就意味着，双方都准备好了进行通信的所有条件，比如内存、网络拥堵等。

listen(max)：max指的是半链接数和已链接数的总和；
    1. 半链接与已链接：TCP-Client调用connect() 链接TCP-Server，底层TCP先向Server
       发送一个SYN类型的TCP数据包，即第一次握手，Server的accept() 底层会有一个队列
       存储申请链接的Client，此时的Client就是半链接状态，即处于阻塞等待状态；
       等到第三次握手时，Server收到Client回复的ACK确认包，从半链接状态的队列中取出发送
       ACK确认包的Client，存储在一个新的队列，此时的Client处于已链接状态。
    2. 在Mac系统和Windows系统中，同时链接Server的最大Client数量就是max；
    3. 而在Linux系统中，系统会自动计算一个max值，不会以开发者设置的max为准；
    4. 正是因为Linux系统会自动计算一个max值，所以Web服务器的开发通常使用Linux系统。
</code></pre><h4 id="4次挥手"><a href="#4次挥手" class="headerlink" title="4次挥手"></a>4次挥手</h4><pre><code>TCP客户端调用 close() 关闭链接，底层的TCP会发送一个类型为FIN+ACK的TCP数据包，用于通知
TCP服务器：TCP客户端已经关闭了链接 --&gt; TCP服务器收到TCP数据包，然后回复一个ACK确认包；
TCP服务器底层解析数据包，给recv() 返回一个长度为0的数据，然后也调用close() 关闭链接，
底层的TCP也会发送一个类型为FIN+ACK的TCP数据包，通知TCP客户端：TCP服务器也关闭了对其服
务的链接 --&gt; TCP客户端收到数据包，回复给一个ACK确认包 --&gt; 4次挥手完成。
</code></pre><p><img src="http://i.imgur.com/N0Z0Z4J.jpg" alt></p>
<pre><code>4次挥手成功，表示TCP-Client与TCP-Server之间成功断开了链接，释放了占用的端口等资源；
浏览器的表现：
    浏览器加载过程中，标签上会有正在加载的转圈图标，4次挥手成功之后，转圈图标会
停止加载，浏览器的刷新图标也会停止刷新。

TCP稳定、而UDP不稳定的底层核心区别：
    TCP通信过程中，如果一方收到了对方的数据，一定会给对方回复ACK确认包；
    而UDP通信则没有这个过程。因此，TCP通信稳定，而UDP通信不稳定。
</code></pre><h3 id="长连接与短链接"><a href="#长连接与短链接" class="headerlink" title="长连接与短链接"></a>长连接与短链接</h3><pre><code>1. 长链接：3次握手一次，源源不断地传送数据，传送完成之后，再调用close()，完成4次挥手；
    1. 长连接适用于频繁请求资源的客户端，比如观看在线视频、数据库操作，使用长连接可以省
       去较多的TCP建立和关闭的操作，减少浪费；
    2. 但是，TCP-Client与TCP-Server之间的链接如果长时间不关闭，随着TCP-Client的增加，
       TCP-Server可能会崩溃，所以TCP-Server就会采取一些策略，比如关闭一些长时间没有
       数据传输的链接，避免一些恶意链接导致Server端的服务受损；再或者以Client机器为颗
       粒度，限制每个Client的最大长链接数，避免某个Client连累Server。
2. 短链接：每传输一次数据，就3次握手、4次挥手一次。
    1. 短链接对TCP-Server来说管理较为简单，存在的链接都是有效连接，不需要额外控制手段；
    2. 比如Web网站的Http服务，只是展示一个网站的页面，同时访问的TCP-Client数量巨大，
       即并发量大，但每个用户又无需频繁操作，一般都用短链接。
3. HTTP1.0 默认使用的是短链接，从HTTP1.1 开始，默认使用的是长链接。
    1. HTTP协议的短链接和长链接，底层其实就是TCP的短链接和长链接；
    2. 使用长链接的HTTP协议，会在响应头加入：Connection:keep-alive
    3. 但是，keep-alive 并不会永久保持链接性，可以在Server端设置链接的时间。
</code></pre><h3 id="TTL-与-MSL"><a href="#TTL-与-MSL" class="headerlink" title="TTL 与 MSL"></a>TTL 与 MSL</h3><h4 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h4><pre><code>TTL：一个数据包在网络上允许经过的最大网段个数。
1. 因为连接两个不同网段的设备是路由器，所以TTL也是经过路由器的最大个数；
2. 数据包每经过一个网段，即路由器转发一次，TTL会减1，所以TTL可用于检测经过路由器的个数；
3. 当数据包的TTL值为0时，路由器就会丢弃该数据包。
</code></pre><p><img src="http://i.imgur.com/dfTikPd.jpg" alt></p>
<pre><code>主机192.168.1.1 ping 同一网络的主机192.168.1.2，TTL的值是128；
主机192.168.1.1 ping 远程主机192.168.2.1，中间经过3个路由器转发，TTL的值是125；
</code></pre><h4 id="MSL"><a href="#MSL" class="headerlink" title="MSL"></a>MSL</h4><pre><code>MSL：一个数据包在网络上的最长存活时间；2MSL：2倍的最长存活时间。
1. TCP-Client先调用close() 关闭链接
    TCP-Client 最后一次回复ACK确认包之后，会等待2MSL，然后才会将TCP的状态置为CLOSED；
因为TCP是可靠的连接，如果TCP-Server没有收到ACK确认包，会给Client再发一次FIN通知包，
而数据包的最长存活时间是MSL，也就是：Client发送的ACK确认包+Server重发的FIN通知包的存活
时间=2MSL；TCP-Client等待2MSL之后，如果仍没有重新收到FIN通知包，说明Server一定收到了
ACK确认包，Client的状态就可以设置为CLOSED。
2. TCP-Server因为某些原因，先调用close() 关闭链接
    TCP-Server 最后一次回复ACK确认包之后，等待2MSL，在这段时间之内，Server socket是
不会被释放的，而TCP-Server程序是绑定端口的，所以如果重启了Server程序，操作系统会提示
端口被占用，绑定失败；过了2MSL的时间，端口被释放了，Server程序才能启动成功。
因为TCP-Client往往不会绑定端口，使用的是系统分配的动态端口，所以Client先调用close()，
不会出现TCP-Server绑定端口失败的问题；而实际应用中，也是TCP-Client先关闭链接。
</code></pre><h2 id="常见网络攻击"><a href="#常见网络攻击" class="headerlink" title="常见网络攻击"></a>常见网络攻击</h2><h3 id="DOS攻击"><a href="#DOS攻击" class="headerlink" title="DOS攻击"></a>DOS攻击</h3><pre><code>DOS攻击：拒绝服务式攻击，也称为TCP半链接攻击、SYN Flood(SYN洪水攻击)
    TCP-Server调用listen(max) 设置半链接和已链接的最大TCP-Client数量max，DOS攻击就是
大量向Server发送第一次握手，进入半链接状态，但不回复给Server第三次握手的ACK确认包，即长期
占用半链接状态的队列，那么其他正常Client就无法访问Server，造成服务器无法正常使用。
</code></pre><h3 id="DNS攻击"><a href="#DNS攻击" class="headerlink" title="DNS攻击"></a>DNS攻击</h3><pre><code>nslookup baidu.com：查看当前网络中，baidu.com对应的服务器Ip
CDN：内容分发，baidu.com对应多个服务器Ip，每个地区的baidu.com对应的服务器Ip都是不同的。
</code></pre><h4 id="DNS服务器被劫持"><a href="#DNS服务器被劫持" class="headerlink" title="DNS服务器被劫持"></a>DNS服务器被劫持</h4><pre><code>攻击一个DNS服务器，篡改其中的域名所对应的服务器Ip，比如篡改taobao.com对应的Ip，再用爬虫
爬取taobao.com的数据，制作一个钓鱼网站，Client访问taobao.com进入的就是该钓鱼网站。
</code></pre><h4 id="DNS服务器欺骗"><a href="#DNS服务器欺骗" class="headerlink" title="DNS服务器欺骗"></a>DNS服务器欺骗</h4><pre><code>修改路由器中的DNS服务器Ip，分配给Client假的DNS-Ip，Client访问的是钓鱼网站，或者在真网站
上增加广告。
</code></pre><h3 id="ARP攻击"><a href="#ARP攻击" class="headerlink" title="ARP攻击"></a>ARP攻击</h3><pre><code>ARP攻击：中间人攻击，伪造ARP数据包，通过Python使用原始套接字组织数据包；
</code></pre><p><img src="http://i.imgur.com/u1rSxTU.jpg" alt></p>
<pre><code>主机A和路由器C要进行通信，必须先发送ARP数据包，以获取路由器C的Mac地址，但是黑客B组织两个
伪造的ARP数据包：一个携带路由器C的Ip地址、主机B的Mac地址，回复给主机A，另一个携带主机A的
Ip地址、主机B的Mac地址，发送给路由器C；
由此，主机A与路由器C进行通信时，数据包一定会经过主机B，主机B把数据拷贝并存入数据库，再迅速
把数据包转发给下一级。
</code></pre><h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><pre><code>NAT：网络地址转换器
路由器上有WAN口(Internet口)和LAN口(可能有多个)；
    1. WAN口用于连接外网(公网)，电话线上网时，WAN口用来连接调制解调器(猫)；光纤上网时，
       WAN口用来连接光猫；网线入户上网时，WAN口用来连接入户网线。
    2. LAN口则用来连接内网(局域网)中的设备，比如电脑、交换机等。
国外的路由器就是用来链接两个不同的网段，而国内家庭上网时使用的路由器，则是一种NAT；
    国内家庭中的电脑等设备使用的是私有Ip，不能直接访问外网；NAT内部有一张转换表，家庭电脑
的浏览器访问百度服务器时，NAT会将私有Ip转换成公有Ip，并为浏览器进程重新分配一个Port，再用
NAT内部的转换表记录下两者的映射关系；百度服务器回复数据后，NAT收到百度服务器回复的数据后，
查询映射转换表，将数据发给对应的设备和进程。
</code></pre><p><img src="http://i.imgur.com/U17h8Jy.jpg" alt></p>
<pre><code>这也就是为什么在家庭电脑上搭建的服务器，外网的设备不能直接访问；
就是因为在经过NAT时，转换表上并没有对应的映射关系。
想要被直接访问，需要借助其他工具，比如托管到阿里云，使用花生壳软件等。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2017/08/01/网络基础与UDP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/01/网络基础与UDP/" itemprop="url">网络基础与UDP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-01T00:00:00+08:00">
                2017-08-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h2><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><pre><code>协议是进程间通信的一种规范；
TCP/IP 协议是一个协议族，常用的网络协议：
</code></pre><p><img src="http://i.imgur.com/067loRu.jpg" alt></p>
<pre><code>五层划分：物理层、链路层、网络层、传输层、应用层；
七层划分：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。
</code></pre><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><pre><code>端口：用于区分数据接收方的进程；
     PID虽然也可以区分进程，但只适合同一台计算机，在不同的计算机上，很难获取对方的PID，
     所以约定使用端口，系统会为每个启动的进程分配唯一的端口。
端口号：用于标记端口的整数，在Linux系统上，端口号的范围：0 ~ 65535，2的16次方个端口；
    端口号又分为知名端口、动态端口等类别；
    知名端口：固定分配给某些服务，不能随意使用，范围0 ~ 1023，80端口分配给HTTP服务，
            21端口分配给FTP服务；
            一般情况下，如果一个程序需要使用知名端口，需要有root权限。
    动态端口：动态分配，不固定分配给某种服务，范围1024 ~ 65535。
Linux系统，netstat -an：查看端口状态。
</code></pre><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><pre><code>IP地址：用于逻辑上标记一台唯一的计算机；
IP地址分为A、B、C、D、E五大类；
</code></pre><p><img src="http://i.imgur.com/AlfHqjc.jpg" alt></p>
<pre><code>A类：由1个字节的网络地址和3个字节主机地址组成；
    网络地址的最高位必须是0，所以IP地址范围：1.0.0.1 ~ 126.255.255.254；
    也即，可用的A类网络有126个，每个网络能容纳1677214个主机；
B类：由2个字节的网络地址和2个字节的主机地址组成；
    网络地址的最高位必须是10，所以IP地址范围：128.1.0.1 ~ 191.255.255.254；
    也即，可用的B类网络有16384个，每个网络能容纳65534个主机； 
C类：由3个字节的网络地址和1个字节的主机地址组成；
    网络地址的最高位必须是110，所以IP地址范围：192.0.1.1 ~ 223.255.255.254；
    也即，C类网络有2097152个，每个网络能容纳254个主机；
D类地址用于多点广播，第一个字节以1110开始，范围：224.0.0.1 ~ 239.255.255.254；
    多点广播地址用于一次寻址一组计算机，比如视频会议；
E类地址仅用作实验和开发，IPV6的出现，E类已经废了。

1. 网络号相同的主机，表示在同一个网段；
    1. 网络正常的情况下，同一网段的主机可以直接通信；
    2. ping Ip：ping对方的Ip，测试网络是否正常。
2. 同一个网段的IP地址不允许相同，否则会报IP地址冲突。
3. 同一个网段，比如192.168.119，主机号 0 和 255 不允许使用；
   因为192.168.119.0表示的就是网络号，192.168.119.255是广播地址；
   所以，对于192.168.119网段，可用范围也就是：1 ~ 254。
</code></pre><h4 id="私有IP"><a href="#私有IP" class="headerlink" title="私有IP"></a>私有IP</h4><pre><code>公有IP能访问全球网络；私有IP只能在局域网中进行通信，比如一个公司的内网，不能访问公网；
    A类私有IP的范围：10.0.0.0 ~ 10.255.255.255
    B类私有IP的范围：172.16.0.0 ~ 172.31.255.255
    C类私有IP的范围：192.168.0.0 ~ 192.168.255.255
</code></pre><h4 id="特殊IP"><a href="#特殊IP" class="headerlink" title="特殊IP"></a>特殊IP</h4><pre><code>127.0.0.1：回环地址，也代表本机地址，可用于回路测试；
    ping 127.0.0.1：测试自身计算机上的网络协议是否正常；
</code></pre><h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><pre><code>子网掩码必须配合Ip一起使用，否则没有任何作用；
子网掩码的作用：与Ip按位与，得到主机的网络号，即判断两台主机是否在同一网段；
A类Ip的默认子网掩码：255.255.255.0
B类Ip的默认子网掩码：255.255.0.0
C类Ip的默认子网掩码：255.0.0.0
</code></pre><h3 id="网络通信的过程"><a href="#网络通信的过程" class="headerlink" title="网络通信的过程"></a>网络通信的过程</h3><p><img src="http://i.imgur.com/3v8S80Y.jpg" alt></p>
<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><pre><code>socket 是进程间通信的一种方式，它能实现不同主机上的进程间通信；
Python提供了 socket 模块，用于实现socket通信；
</code></pre><h3 id="创建socket对象"><a href="#创建socket对象" class="headerlink" title="创建socket对象"></a>创建socket对象</h3><pre><code>socket(Address, Type)：返回创建的套接字对象；
    Address：通信类型，AF_INET 与 AF_UNIX；
        AF_INET：用于IPV4 Internet进程间的通信；
        AF_UNIX：用于同一台主机上的进程间通信。
    Type：套接字类型，SOCK_STREAM 与 SOCK_DGRAM；
        SOCK_STREAM：流式套接字，用于TCP协议通信；
        SOCK_DGRAM：数据报套接字，用于UDP协议通信。
UDP和TCP都是全双工，即发送消息的同时，也可以接收消息。
</code></pre><h3 id="udp-socket"><a href="#udp-socket" class="headerlink" title="udp socket"></a>udp socket</h3><pre><code>UDP：用户数据报协议，无连接的、面向数据报的传输层协议，没有超时重发等机制，传输速度快，
    但不可靠；
应用：语音广播，视频，TFTP(简单文件传输)，SNMP(简单网络管理协议)，RIP(路由信息协议)...
</code></pre><p><img src="http://i.imgur.com/RMIZbKp.jpg" alt></p>
<pre><code>from socket import *
1. 创建 UDP Socket 对象
   socket(AF_INET, SOCK_DGRAM)
2. 关闭socket： close()
3. 发送数据
sendto(data, [flags], address)
    data：要发送的数据，数据大小必须在64KB之内；python2可以直接发送字符串类型，
          python3必须是bytes类型(b&quot;hello&quot;：字符串转bytes)，或者对字符串编码；
    address：一个元组(Ip, port)，指定接收方的IP地址(字符串)和端口号(int)。
4. 接收数据
recvfrom(buffersize, [flags])：会阻塞，等待接收消息；
        buffersize：指定一次接收数据的最大字节数，常用1024个字节；
        返回一个元组(data, (Ip, port))：
            data：接收的字符串数据，如果是乱码，则需要解码；
            (Ip, port)：发送方的Ip和端口号，通过该Ip和port向对方回复消息。
5. 编码与解码
    1. str.encode(&quot;utf-8&quot;)：对字符串str编码成国际通用的utf-8格式；
    2. str.decode(&quot;utf-8&quot;)：按照utf-8对字符串str进行解码；
    3. 中文常用码表：gb2312
</code></pre><p><img src="http://i.imgur.com/3SPQJKj.jpg" alt></p>
<h3 id="udp-绑定端口"><a href="#udp-绑定端口" class="headerlink" title="udp 绑定端口"></a>udp 绑定端口</h3><pre><code>1. 在同一个系统中，端口不能重复使用，因为端口用于标识一个进程，其他主机上的进程必须获取
   该端口的端口号，才能向该进程发送消息；
2. 一个程序每次运行，系统分配的端口是不固定的，也即每次的端口号都在变化；对于一个服务器
   程序，往往需要固定的端口号，以便于接受终端发来的消息；所以，服务性程序需要绑定端口；
   绑定之后，每次程序启动，操作系统都会为其分配固定的端口号。
3. 一个网卡就对应一个Ip地址，如果一台计算机上配置了有线网卡和虚拟网卡，就会有多个Ip；
   如果有线网卡和虚拟网卡同时连接网络，网络中会路由选择网速更优的一方连接。
3. 绑定端口
bind(addr)
     addr：是一个元组(Ip, port)，Ip一般不指定(空字符串)，表示本机的任何一个Ip；
绑定端口必须放在socket发送/接收消息之前。
</code></pre><h3 id="udp-广播"><a href="#udp-广播" class="headerlink" title="udp 广播"></a>udp 广播</h3><pre><code>网络节点之间的通信方式：
    单播：点对点；    多播：一对多；    广播：一对所有；

setsockopt(SOL_SOCKET, SO_BROADCAST, 1)：设置当前socket对象允许发送广播数据；

sendto()发送的Ip必须设置为广播地址，比如 192.168.1.255，网段在192.168.1以内的主机，只要
监听sendto()使用的port，都可以收到广播数据；如果没有监听，即没有进程使用该port，广播数据只
传输到网络层，在运输层判断到主机中没有任何进程使用该端口，就会丢弃该广播数据；
但是对于其他网段的主机，也就收不到数据了，更通用的方式是，把Ip设置为：&quot;&lt;broadcast&gt;&quot;
</code></pre><h3 id="echo服务器"><a href="#echo服务器" class="headerlink" title="echo服务器"></a>echo服务器</h3><pre><code>核心逻辑：接收到数据之后，原封不动地回给发送方；
</code></pre><p><img src="http://i.imgur.com/v35N4aP.jpg" alt></p>
<h2 id="TFTP"><a href="#TFTP" class="headerlink" title="TFTP"></a>TFTP</h2><pre><code>TFTP：简单文件传输协议，一种基于UDP协议的应用，C/S架构；
1. 简单，占用资源小；
2. 适合在局域网中进行小文件传输；
3. 端口号默认为69
</code></pre><h3 id="TFTP的交互过程"><a href="#TFTP的交互过程" class="headerlink" title="TFTP的交互过程"></a>TFTP的交互过程</h3><p><img src="http://i.imgur.com/alrQze3.jpg" alt></p>
<pre><code>1. TFTP服务器默认监听的端口号是69，TFTP客户端通过69端口发起读写(上传与下载)请求；
2. UDP是不安全的，如果客户端接收到数据包，会回复给服务器一个应答包(ACK)；
3. 如果文件过大，服务器会分批传输，每一个数据包设置一个编号，编号从1开始；
   接收的数据包可能会重复，对于编号相同的数据包，应该舍弃；
4. 如果传输错误，比如文件不存在，服务器会发送一个包含错误信息的差错包；
5. 为了区分不同的数据包，在数据包的前面会带有操作码：
</code></pre><p><img src="http://i.imgur.com/UKZO5r0.jpg" alt></p>
<h3 id="TFTP的数据包"><a href="#TFTP的数据包" class="headerlink" title="TFTP的数据包"></a>TFTP的数据包</h3><p><img src="http://i.imgur.com/gbrpThl.jpg" alt></p>
<pre><code>1. 数据包最前面是操作码，占2个字节；
2. 请求数据包的模式：octet
3. 0 表示终止，占1个字节；
4. 数据包的块编号就是数据包的编号，占2个字节，最大编号是65535；
   如果文件过大，致使编号大于2个字节，即 编号==65536 时，数据包会从0开始编号；
5. 数据包中的数据内容最多占512个字节，当数据内容的长度小于512B时，表示传输完成；
6. ACK是应答包，回复确认已收到数据包，块编号表示当前收到的数据包编号，也是占2个字节；
   服务器收到ACK之后，继续发送下一个数据包；
7. ERROR是差错包，差错码表示错误类型，占2个字节；收到差错包，不需要回复ACK；
8. TFTP是基于UDP协议，数据包的发送和接收通过udp socket完成；对于TFTP下载，socket发送读请
   求到69端口，TFTP服务器响应发送第一个数据包，TFTP终端接收到数据包，如果编号为1，表示响应
   成功，可以创建文件，开始解析数据包，执行写操作。

注意：69端口是TFTP客户端向TFTP服务器发送读写请求的端口，而服务器发送数据包使用的是一个新
    的随机端口，回复ACK时，也必须发送给该随机端口，否则无效。

传输完成的标识
    一个完整的数据包：操作码2B + 块编号2B + 数据内容512B = 516B
   当操作码为3、且数据包的字节长度小于516B时，表示数据传输完成：len(data) &lt; 516
</code></pre><h3 id="组包与解包"><a href="#组包与解包" class="headerlink" title="组包与解包"></a>组包与解包</h3><pre><code>struct 模块：
    1. 组包：设置数据占用的字节数，将各个数据组织成协议规定的网络数据包；
    2. 解包：解析接收到的网络数据包，拆出各个数据。
</code></pre><h4 id="大端与小端"><a href="#大端与小端" class="headerlink" title="大端与小端"></a>大端与小端</h4><pre><code>大端与小端：CUP在内存中存储数据的模式；比如十六进制数据 0x11223344
1. 大端模式
    低地址---&gt;高地址：0x11 0x22 0x33 0x44，低地址存储数据的高位
2. 小端模式
    低地址---&gt;高地址：0x44 0x33 0x22 0x11，低地址存储数据的低位

在存储同一个数据时，对于不同的CPU，有的先存储数据的高位(小端)，有的先存储数据的低位(大端)；
个人PC一般是小端，大型服务器如IBM 一般是大端；
所以，在网络协议中规定，对于多字节数据，在网络上发送时，必须转为大端模式。
</code></pre><h4 id="组包"><a href="#组包" class="headerlink" title="组包"></a>组包</h4><pre><code>pack()：组包，返回一个字符串
    pack(&quot;!H8sb5sb&quot;, 1, &quot;test.jpg&quot;, 0, &quot;octet&quot;, 0)：组一个TFTP请求下载的数据包；
        !：大端模式组织数据；
        H：表示占2个字节，存储的数据是操作码 1；
        s：表示占1个字节，8s 表示占8个字节，存储数据&quot;test.jpg&quot;，8个字符占8个字节；
           同理，5s 表示占5个字节，存储数据&quot;octet&quot;，5个字符占5个字节；
        b：表示占1个字节，存储的数据是 0。
</code></pre><h4 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h4><pre><code>unpack()：解包，返回一个元组
    unpack(&quot;!H&quot;, data[:2])：
        !：大端模式解包；
        H：data[:2]返回data的前两个字符，python中的字符用1个字节存储，H 表示对这两个字符
           按照2个字节解析成一个数据；也即，获取数据包的操作码。
    unpack(&quot;!HH&quot;, data[:4])：
            data[:4]返回4个字符，HH 表示每两个字符按照2个字节拆出一个数据；
            如果是数据包，获取的是操作码和块编号；如果是差错包，则是操作码和错误码。

数据包中的数据内容data[4:]，以及差错包中的差错信息，都是有效内容，不需要unpack解包。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">大麦田怪圈</p>
              <p class="site-description motion-element" itemprop="description">敢做就能赢！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">64</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大麦田怪圈</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
