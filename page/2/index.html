<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="敢做就能赢！">
<meta property="og:type" content="website">
<meta property="og:title" content="大麦田程序猿">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="大麦田程序猿">
<meta property="og:description" content="敢做就能赢！">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="大麦田程序猿">
<meta name="twitter:description" content="敢做就能赢！">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>大麦田程序猿</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大麦田程序猿</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/01/nodejs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/01/nodejs/" itemprop="url">nodejs</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-01T00:00:00+08:00">
                2018-07-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="NodeJs"><a href="#NodeJs" class="headerlink" title="NodeJs"></a>NodeJs</h2><pre><code>Node.js：一个能够在服务器端运行JavaScript的开源代码、跨平台JavaScript运行环境；
    1. 采用Google开发的V8引擎运行JS代码，使用事件驱动、非阻塞、异步I/O模型等技术提高性能，
    可优化应用程序的传输量和规模；
    2. Node大部分基本模块都是采用JS编写的，由一个高性能的Web服务器形成一个Node生态环境。
1. Node的服务器是单线程的
    1. Node处理请求时是单线程，但在后台拥有一个I/O线程池；
    2. Node有专门处理请求的线程，还有专门处理I/O的线程。
2. JS没有模块的概念，而Node遵循CommonJS规范，将模块划分为：核心模块、文件模块
    1. 核心模块：node引擎提供的模块，可以直接引用，不用指定模块路径；
    2. 文件模块：第三方模块，文件模块的标识就是文件的路径；
    3. require()：引入外部模块的函数，返回值就是引入模块的对象；
    4. 如果是相对路径，必须以&quot;./&quot;或&quot;../&quot;开头，如require(&quot;./req.js&quot;)，后缀名&apos;.js&apos;可省略
3. 模块的作用域：在Node中，每一个JS文件中的JS代码都独立运行在一个函数中，而不是全局作用域
    1. 模块之间不能直接共享数据，即require()返回的对象无法访问模块内的变量/方法；
    2. 在执行的模块中使用：console.log(arguments.callee + &quot;&quot;);
    会发现，当前正在执行的模块代码被node放在了一个函数中：
    function (exports, require, module, __filename, __dirname) {
        //模块的JS代码
    }
    1. exports：用于将变量/函数暴露到外部的对象，每个模块文件中都有一个exports对象；
    2. require：用来引入外部模块的函数，只要是作为exports的属性/方法，该函数返回的对象都可
    以直接访问：req.js：exports.x = &quot;Hello&quot;; exports.fn = function(){}
    3. 其他模块中引用req.js模块：
    var r = require(&quot;./req&quot;); ==&gt; r: {x: &apos;Hello&apos;, fn: [Function]}
    r.fn(); ==&gt;执行模块中的方法，r.x; ==&gt;获取模块中的变量
    4. module：每个模块都有一个内置的对象属性module，包含了当前模块所拥有的一些信息；
    5. module的属性信息：id(模块的唯一标识)、filename(文件的路径名)、loaded、children、
    paths、exports、parent、require() --&gt; require()也来自module对象
    6. exports是module的属性，即module也可以用于导出：module.exports.x = &quot;Hello&quot;;
    7. __filename：当前模块的绝对路径； __dirname：当前模块所在目录的绝对路径。
4. exports与module.exports的区别：
    1. exports只是一个指向module.exports的引用，module.exports才是一个对象；
    exports.a=10;  ---&gt; 等同于：module.exports.a=10;
    2. 真正具有向外暴露能力的是module.exports，而不是exports，比如exports={ a: 10 }
    --&gt;exports指向了一个新的对象，不再指向module.exports，也就失去了可以向外暴露的能力
    3. exports只能通过 exports.x 的方式向外暴露，而module.exports={ a: 10 }可以暴露
    4. require()得到的其实也是module.exports对象的引用。
5. 在浏览器端的JS中，全局变量/函数都作为window对象的属性/方法保存的；在node中，也有类似于
   window作用的全局对象：global
    1. 所谓node环境，也就是ECMAScript，global是ECMAScript标准提供的；
    2. 本质上，浏览器端的window其实就是扩展自ECMAScript中的global
6. 包：package，由包结构和包描述文件组成，其实就是一个压缩文件，解压还原为目录；
    1. 包结构：用于组织包中的各种文件；
    2. 包描述文件：描述包的相关信息，以供外部读取分析；
    3. 目录文件包括：描述文件(package.json)、可执行二进制文件(bin)、js代码(lib)
    doc(文档)、test(单元测试)，其中package.json是必需的；
    4. package.json是一个JSON格式的文件，不能有任何注释，它是配置文件。
</code></pre><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><pre><code>npm：Node Package Manager，node的包管理器，用于node的第三方模块的发布、安装、依赖等；
1. 借助npm，Node与第三方模块之间形成了一个很好的生态系统；
2. npm search 包名：搜索模块包；
3. npm install/i 包名：在当前目录安装模块包；
    1. 执行：npm init --&gt; 当前目录会生成一个package.json
    2. 安装依赖包，如npm install math：math包会在安装到当前目录下；
    3. 在当前目录下会生成一个node_modules目录，存放安装的模块，使用这些模块时，不需要指定
    模块路径：var math = require(&quot;math&quot;);
    4. npm i 包名 --save：在项目或模块包的 package.json 中会生成相关模块的依赖信息；
    npm i math --save ===&gt; package.json -&gt; &quot;dependencies&quot;: { &quot;math&quot;: &quot;0.0.3&quot; }
    5. 依赖信息的作用：将当前目录(即项目)上传到开源站时，并不会上传node_modules目录，因为
    会影响上传/下载的速度，而且不能保证依赖的模块包一定是最新版本；那么下载并使用该项目后，
    也就不能直接运行，需要先在该项目的根目录下执行：npm install =&gt;安装依赖
4. npm install/i 包名 -g：全局模式安装模块包，一般都是一些工具；
    1. npm root -g：查看全局安装的根目录；
    2. npm list：查看当前目录下已安装的node包；
    3. npm info 包名：查看包的所有版本；--&gt; npm i jquery@1.8.2：指定版本安装。
5. npm update：升级依赖包
6. npm remove/r 包名：删除模块包，同理，--save也会删除package.json中的依赖信息；
7. 镜像服务器：npm服务器不在国内，所以npm下载时可能会很慢，镜像服务器的作用就是把npm服务器
   的数据拷贝一份，通过国内的镜像服务器下载模块包，就会很快；
    1. 淘宝NPM镜像：同步npm服务器数据的频率为10分钟，定制的cnpm代替默认的npm命令；
    2. npm install -g cnpm --registry=https://registry.npm.taobao.org
    3. cnpm与npm的命令一模一样，但下载的模块目录结构可能不同，也是为了避免相互覆盖。
8. require(&quot;math&quot;)的查找路径：当前目录的node_modules--&gt;上一级目录的node_modules
    --&gt; 再上一级目录的node_modules --&gt; ... --&gt; 磁盘根目录 --&gt; 仍没有则报错
</code></pre><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><pre><code>1. package.json中的一些节点
    1. name：包名
    2. version：版本，x.x.x
    3. main：包的入口主文件
    4. scripts：自定义脚本，通过 npm run 脚本名 执行脚本定义的命令
    5. dependencies：生产环境下必需的依赖包
    6. devDependencies：只在开发环境下使用的依赖包
2. dependencies 与 devDependencies 中的依赖包版本：
    1. ^2.3.4：表示在执行 npm install 时，第一位版本号不变，后两位取最新的；
    2. ~2.3.4：前两位不变，最后一位取最新；
    3. *2.3.4：表示全部取最新的。
</code></pre><h2 id="开发方向"><a href="#开发方向" class="headerlink" title="开发方向"></a>开发方向</h2><pre><code>1. GUI：Graphical User Interface，图形用户界面，如office、vscode、浏览器、播放器...
2. CLI：Command Line Interface，命令行界面，也称为CUI(字符用户界面)
    1. 相比于GUI，CLI更节省计算机资源，一般用于服务器环境，如babel、vue-cli、webpack...
    2. Node第三方命令行框架：commander、chalk、inquirer
    3. commander：命令行开发工具
    4. chalk：命令行样式风格控制器
    5. inquirer：交互式命令行工具
3. Server：提供服务，如Web Server、IM...
</code></pre><h2 id="JS模块化"><a href="#JS模块化" class="headerlink" title="JS模块化"></a>JS模块化</h2><pre><code>模块化规范：CommonJs、AMD、CMD、ES6
1. CommonJs规范
    1. 在服务器端：模块的加载是运行时同步加载的；
    2. 在浏览器端：模块需要提前编译打包处理，因为浏览器不识别 require() 的引入模块方式；
    3. 暴露模块的两种方式：module.exports = value，exports.xxx = value
    4. 引入模块：let xxx = require(&apos;xxx&apos;);
    5. 服务器端的实现：Node.js
    6. 浏览器端的实现：Browserify，用于对js模块的提前打包处理，&lt;script&gt;引入处理后的js
2. AMD规范：专门用于浏览器端，模块的加载是异步的
    1. CommonJs最初是基于服务器端的Js模块化规范，AMD针对浏览器端出了一套JS模块化规范之后，
    CommonJs才有了基于浏览器端的实现；
    2. 暴露模块--&gt;定义没有依赖的模块：define(function(){ return 模块 })
    3. 暴露模块--&gt;定义有依赖的模块：
    define([&apos;module1&apos;, &apos;module2&apos;], function(m1, m2){ --&gt;回调的形参与依赖的模块相对应
        return 模块
    })
    4. 浏览器端的实现：RequireJs，使用时，&lt;script&gt;引入require.js，并指定主模块入口
    &lt;script data-main=&quot;js/main.js&quot; src=&quot;js/libs/require.js&quot;&gt;&lt;/script&gt;
    5. 在主模块中声明要引入的其他模块，这样只用一个&lt;script&gt;就能引入所有需要的模块
3. CMD规范：CMD是阿里的JS规范，也是专门用于浏览器端，后来出售给了国外，很少用；
    1. CMD规范其实就是把CommonJs和AMD进行结合，定义模块使用AMD，暴露模块使用CommonJS；
    2. 浏览器端的实现：SeaJs，使用时，一个&lt;script&gt;引入sea.js，一个&lt;script&gt;引入主模块；
    &lt;script type=&quot;text/javascript&quot; src=&quot;js/libs/sea.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt; seajs.use(&apos;./js/modules/main&apos;) &lt;/script&gt;
4. ES6规范：依赖模块需要编译打包处理
    1. 导出模块：export，引入模块：import，Vue.js2.0就是基于ES6规范
    2. 浏览器端的实现：Babel、Browserify
    3. Babel：有的浏览器不支持ES6的语法，Babel可以将ES6编译为ES5
    4. Browserify：用于编译打包JS
    5. 常规暴露：export { fun1, fun2 }，引入：import {fun1, fun2} from &apos;./module&apos;
    6. 默认暴露：可以暴露任意数据类型，而且暴露的数据与引入的数据是一致的；
    export default () =&gt; { ... } ---&gt; 暴露一个方法
    引入： import fun from &apos;./module&apos; ---&gt; fun就是module.js中默认暴露的方法
5. 自动化打包工具：webpack、Grunt、Gulp，用于简化编译打包JS/Sass/Less、压缩、合并等过程
</code></pre><h2 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs"></a>CommonJs</h2><pre><code>1. CommonJs规范主要是为了弥补JS没有标准的缺陷，终极目标是提供一个类似Python、Ruby和Java的
   标准库，而不只是停留在小脚本程序的阶段；
2. CommonJs就是模块化的标准，nodeJs就是CommonJs的一种实现；
3. NodeJs中的模块分为两类：
    1. NodeJs本身提供的核心模块，如http、url、fs，可以直接引入使用；
    2. 自定义模块：依照CommonJs中的规定，实现的第三方模块。
</code></pre><h3 id="自定义模块的规定"><a href="#自定义模块的规定" class="headerlink" title="自定义模块的规定"></a>自定义模块的规定</h3><pre><code>1. 一个JS文件作为一个模块，通过 exports 或者 module.exports 暴露属性/方法；
2. 自定义模块的查找过程：
    1. 如果当前目录下没有，则去当前目录下的node_modules目录中查找；
    var foo=require(&apos;foo&apos;) --&gt; ./node_modules/foo.js
    2. 如果node_modules目录中没有foo.js，但有foo文件夹，且foo.js在foo目录中；
    var foo=require(&apos;foo/foo.js&apos;) --&gt; ./node_modules/foo/foo.js
3. 如果希望 require(&apos;foo&apos;) 能直接引用 ./node_modules/foo/foo.js
    1. 在foo目录下执行 npm init --yes，生成package.json文件，--yes表示强制生成；
    2. require(&apos;foo&apos;)在node_modules中查找到foo目录，那么就查找foo/package.json，
    如果不存在，则提示没有foo.js模块；
    3. 如果package.json存在，则查找main节点，此时的foo目录被视为一个模块，main节点表示
    模块的入口，也就是真正暴露的模块；
    4. 如果main节点指向 foo.js，则查找foo/foo.js，如果指向 index.js，则require(&apos;foo&apos;)
    实际引用的是foo/index.js
4. 通过 npm 下载第三方模块时，也会自动下载到node_modules目录中，下载的其实也是目录；
    1. npm i md5-node --save 与 --save-dev：都会把md5-node写入package.json中；
    2. --save：写入到package.json中的 &quot;dependencies&quot; 中；
    3. --save-dev：写入到package.json中的 &quot;devDependencies&quot; 中；
5. &quot;dependencies&quot; 与 &quot;devDependencies&quot; 的区别：
    1. 正常执行 cnpm install 时，dependencies和devDependencies中的模块都会下载；
    2. --save：运行时依赖，如vue、react等，没有这些依赖，打包的项目无法运行；
    3. --save-dev：开发时依赖，即开发环境所需的依赖，如构建工具，测试工具等等，打包发布时
    不需要这些工具，如less-loader、webpack、babel
</code></pre><h3 id="模块的加载机制"><a href="#模块的加载机制" class="headerlink" title="模块的加载机制"></a>模块的加载机制</h3><pre><code>1. 模块的分类：文件模块、文件夹模块、核心模块
    1. 文件模块其实就是一个JS文件，通过 module.exports 暴露模块的功能；
    2. 文件夹模块可分为 node_modules Folders 和 global Folders
    3. global folders 是全局模块，由node的环境变量NODE_PATH控制所在路径。
2. 路径加载模式：require(&apos;./m3&apos;)引入模块时，以 ./、../、/ 开头，表示路径模块加载模式
3. 非路径加载模式：require(&apos;m3&apos;)在引入时不指定模块的路径
    1. module.paths是一个数组，保存的是查找此模块的路径列表；
    2. 核心模块是node的内置模块，require()引用时也不需要指定路径；
    3. 但是，如果自定义的模块名与核心模块名相冲突，则默认加载核心模块。
4. 模块文件的后缀名处理机制：require(&apos;./m3&apos;) --&gt; m3 -&gt; m3.js -&gt; m3.json -&gt; m3.node
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/21/React-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/21/React-2/" itemprop="url">React-2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-21T00:00:00+08:00">
                2018-06-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h2><pre><code>1. React中没有提供专门的网络请求模块，只能使用原声JS的网络请求，或者第三方网络请求模块；
2. axios
    1. npm官网查看文档，npm/cnpm install axios --save
    2. axios不支持跨域请求，也不支持jsonp格式的请求；
    3. jsonp虽然可以实现跨域请求，但axios的作者认为jsonp不太友好，推荐用CORS方式更干净，
    即让后台设置接口允许跨域，直接用axios请求跨域接口。
3. fetch-json：如果后台接口不允许设置跨域，则使用json相关的第三方网络请求模块；
    1. 安装：npm/cnpm install fetch-jsonp --save
    2. 服务器端提供的接口必须支持jsonp格式，测试方式：在接口后追加一个参数callback
    http://www.phone101.com/app.php?a=getList&amp;callback=xxx ---&gt;参数值可以是任意的
    3. 如果在浏览器上访问此接口时，正常获取到了数据，则说明该接口支持jsonp格式；
    4. fetch-json会自动在接口后面追加callback参数，不需要再手动追加；
    import fetchJsonp from &apos;fetch-jsonp&apos;
    let url = &apos;http://www.phonegap100.com/appapi.php?a=getPortalList&amp;catid=20&apos;
    fetchJsonp(url).then(response =&gt; { return response.json(); })
    .then(json =&gt; { ...//请求成功，且json已经被转为js个数的数据 })
    .catch(err =&gt; { ...//请求失败 })
</code></pre><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><pre><code>1. 组件加载过程中触发的函数
    constructor --&gt; componentWillMount --&gt; render --&gt; componentDidMount
    1. componentWillMount()：组件将要挂载
    2. render()：数据/模板渲染
    3. componentDidMount()：组件加载完成
    4. constructor()和render()在组价加载时会被触发，但并不属于生命周期函数
2. 组件更新过程中触发的函数
    shouldComponentUpdate --&gt;componentWillUpdate --&gt;render --&gt;componentDidUpdate
    1. shouldComponentUpdate()：是否更新组件，返回true则更新，返回false则不更新
    shouldComponentUpdate(nextProps, nextState) {
        //nextProps：表示父组件向当前组件传递的数据
        //nextState：当前组件更新后的数据，只是还没有重新渲染DOM
    }
    2. componentWillUpdate()：将要更新组件
    3. render()：更新数据/模板
    4. componentDidUpdate()：数据更新完成
3. 在父组件中改变props传值时触发的函数：componentWillReceiveProps()
    1. 当父组件中改变了向子组件传递的数据，会先触发componentWillReceiveProps()，然后才会
    触发组件更新的函数。
4. 组件销毁时触发的函数：componentWillUnmount()
    1. 父组件
    this.state = { flag:true }
    setFlag() {
        this.setState({ flag:!this.state.flag })
    }
    render() {
        return(&lt;div&gt;
            { this.state.flag ? &lt;Header /&gt; : &apos;&apos; } --&gt; flag为false时，则销毁Header
            &lt;button onClick={this.setFlag}&gt;挂载与销毁&lt;/button&gt;
        &lt;/div&gt;)
    }
    2. 子组件Header
    componentWillUnmount(){ console.log(&apos;Header被销毁&apos;) }
</code></pre><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><pre><code>1. react-router：React路由，让父组件动态去挂载不同的子组件，以目前最新的4.x为例；
2. 基本配置
    1. 安装react-router-dom模块：cnpm/npm install react-router-dom --save
    2. 在根组件App.js中引入路由相关的组件：
    import { BrowserRouter as Router, Route, Link } from &apos;react-router-dom&apos;
    3. 在根组件中使用路由，加载的子组件包括Home.js、News.js、Product.js
    render() {
        return(&lt;Router&gt;
            &lt;div&gt;
                &lt;header&gt;
                    &lt;Link to=&quot;/&quot;&gt;首页&lt;/Link&gt;
                    &lt;Link to=&quot;/news&quot;&gt;新闻&lt;/Link&gt;
                    &lt;Link to=&quot;/product&quot;&gt;商品&lt;/Link&gt;
                &lt;/header&gt;
                &lt;Route exact path=&quot;/&quot; component={Home} /&gt;
                &lt;Route path=&quot;/news&quot; component={News} /&gt;
                &lt;Route path=&quot;/product&quot; component={Product} /&gt;
            &lt;/div&gt;
        &lt;/Router&gt;)
    }
2. &lt;Link&gt;和&lt;Route&gt;必须包裹在一个&lt;Router&gt;中，且&lt;Router&gt;只能有一个直接子节点；
3. Link：to属性指定跳转的路由，&lt;Link&gt;最终被解析为HTML中的&lt;a&gt;
4. Route：path指定路由，component指定路由对应的组件；
5. &lt;Link&gt;和&lt;Route&gt;可以不在同一个组件中，只要路由匹配，都可以实现路由跳转；
6. exact：表示严格匹配模式，如果设置为false，每次都会匹配 path=&quot;/&quot; 的路由；
7. 在根组件中，把Home组件的路由配置为path=&quot;/&quot;，表示默认加载Home组件。
</code></pre><h3 id="路由传值"><a href="#路由传值" class="headerlink" title="路由传值"></a>路由传值</h3><pre><code>1. 动态路由传参：&lt;Route path=&quot;/info/:id&quot; component={Info} /&gt;
    this.state = { id:12 }
    1. :id表示占位符，对应的Link：
    &lt;Link to={`/info/${this.state.id}`}&gt;详情&lt;/Link&gt;
    2. 在Info.js组件中获取动态路由的参数id：this.props.match.params
    componentDidMount() {
        let { id } = this.props.match.params
    }
2. get方式传参
    1. &lt;Route path=&quot;/info&quot; component={Info} /&gt;
    2. &lt;Link to={`/info?id=${this.state.id}`}&gt;详情&lt;/Link&gt;
    3. 在Info.js组件中获取get参数：this.props.location.search
    4. 但是，get参数并没有被解析，仍是一个原始字符串：?id=12
    5. 借助第三方模块url解析get参数：cnpm install url --save
    import url from &apos;url&apos; --&gt;url模块是nodeJs上的内置模块，npm上的url模块并不是nodeJs的
    componentDidMount() {
        let { id } = url.parse(this.props.location.search, true).query
    }
3. React解析原始HTML字符串：dangerouslySetInnerHTML属性
    this.state = { content: &apos;&lt;p&gt;原始HTML字符串&lt;/p&gt;&apos; }
    &lt;div dangerouslySetInnerHTML={{__html: this.state.content}}&gt;&lt;/div&gt;
</code></pre><h3 id="JS控制路由跳转"><a href="#JS控制路由跳转" class="headerlink" title="JS控制路由跳转"></a>JS控制路由跳转</h3><pre><code>1. 引入Redirect：import { Redirect } from &apos;react-router-dom&apos;
2. 原理：更新state --&gt; 触发render() --&gt; 通过&lt;Redirect&gt;实现路由的重定向
this.state = { flag: false }
doLogin = ()=&gt; { this.setState({ flag: true }) }
render() {
    if(this.state.flag) {
        return &lt;Redirect to={{pathname:'/'}} /&gt; ==&gt;重定向到根路由对应的组件
    }
    return(&lt;div&gt;
        &lt;button onClick={this.doLogin}&gt;登录&lt;/button&gt;
    &lt;/div&gt;)
}
3. 简化写法：&lt;Redirect to=&apos;/&apos; /&gt;
</code></pre><h3 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h3><pre><code>1. User.js组件是根路由App.js的动态子组件，路由名称为&quot;/user&quot;
    1. 在User组件中再配置两个动态子组件：Main.js和Info.js
    import { Route, Link } from &apos;react-router-dom&apos;
    render() {
        return(&lt;div&gt;
            &lt;div className=&quot;left&quot;&gt;
                &lt;Link to=&quot;/user/&quot;&gt;个人中心&lt;/Link&gt;
                &lt;Link to=&quot;/user/info&quot;&gt;用户详情&lt;/Link&gt;
            &lt;/div&gt;
            &lt;div className=&quot;right&quot;&gt;
                &lt;Route exact path=&quot;/user/&quot; component={Main} /&gt;
                &lt;Route path=&quot;/user/info&quot; component={Info} /&gt;
            &lt;/div&gt;
        &lt;/div&gt;)
    }
    2. User组件的路由为&quot;/user&quot;，则把子组件Main的路由设置为&quot;/user/&quot;，表示默认加载Main组件
2. 动态获取父级路由
    &lt;Route exact path={`${this.props.match.url}/`} component={Main} /&gt;
    &lt;Route path={`${this.props.match.url}/info`} component={Info} /&gt;
</code></pre><h3 id="路由的模块化"><a href="#路由的模块化" class="headerlink" title="路由的模块化"></a>路由的模块化</h3><pre><code>1. 用一个数组管理项目中的所有路由，在把这个数组放在一个独立的JS文件中
    1. 在router.js中引入相关组件，管理路由
    const routes = [
        { path:&apos;/&apos;, component:Home, exact:true },
        { path:&apos;/user&apos;, component:User }
    ]
    export default routes;
    2. 在根组件App中引入路由模块
    import routes from &apos;./route/router.js&apos;
    render(){
        return(&lt;Router&gt;
            &lt;header&gt;
                &lt;Link to=&quot;/&quot;&gt;首页&lt;/Link&gt;
                &lt;Link to=&quot;/user&quot;&gt;用户&lt;/Link&gt;
            &lt;/header&gt;
            {
                routes.map((route, key) =&gt; {
                    if(route.exact) {
    return &lt;Route key={key} exact path={route.path} component={route.component} /&gt;
                    } else {
    return &lt;Route key={key} path={route.path} component={route.component} /&gt;
                    }
                })
            }
        &lt;/Router&gt;)
    }
2. 嵌套路由的管理
    1. 在router.js中
    const routes = [
        { path:&apos;/&apos;, component:Home, exact:true },
        { path:&apos;/user&apos;, component:User,
            routes:[
                { path:&apos;/user/&apos;, component:Main }, 
                { path:&apos;/user/info&apos;, component:Info }
            ]
        }
    ]
    2. 在根组件App中，通过&lt;Route&gt;的 render 属性，把子路由传递给子组件
    &lt;Route key={key} path={route.path} render={props =&gt; (
        &lt;route.component {...props} routes={route.routes} /&gt;
    )} /&gt;
    3. 在User组件中获取子路由：this.props.routes
    render() {
        return(&lt;div&gt;
            &lt;div className=&quot;left&quot;&gt;
                &lt;Link to=&quot;/user/&quot;&gt;个人中心&lt;/Link&gt;
                &lt;Link to=&quot;/user/info&quot;&gt;用户详情&lt;/Link&gt;
            &lt;/div&gt;
            &lt;div className=&quot;right&quot;&gt;
                {
                    this.props.routes.map((route, key) =&gt; {
                        return &lt;Route key={key} exact path={route.path} 
                            component={route.component} /&gt;
                    })
                }
            &lt;/div&gt;
        &lt;/div&gt;)
    }
3. 子路由的&lt;Route /&gt;上可以都加上 exact 属性，而根路由的&lt;Route /&gt;上不行！
</code></pre><h2 id="Ant-Design"><a href="#Ant-Design" class="headerlink" title="Ant Design"></a>Ant Design</h2><pre><code>1. Ant Design：阿里旗下的一款UI框架，采用React封装的一套组件库，适合开发React企业级项目
2. Ant Design还可以在AngularJS中使用，即支持TypeScript
3. Ant Design的使用方式与创建React项目的方式有关，它甚至提供了自己的一套创建项目的脚手架
4. 与Vue的组件库iView和Element-UI类似，Ant Design也可以按需引入组件和CSS样式，提高性能
5. 对 create-react-app 创建的项目，借助 react-app-rewired 实现按需引入
    1. 安装Ant Design：cnpm install antd --save
    2. 安装react-app-rewired：cnpm install react-app-rewired --save
    3. 修改package.json：把scripts节点下react-scripts 都改为 react-app-rewired
    4. 安装用于按需加载组件代码和样式的babel插件：cnpm i babel-plugin-import --save
    5. 在根目录下新建config-overrides.js，添加如下内容：
    const { injectBabelPlugin } = require(&apos;react-app-rewired&apos;);
    module.exports = function override(config, env) {
        config = injectBabelPlugin(
        [&apos;import&apos;, { libraryName:&apos;antd&apos;, libraryDirectory:&apos;es&apos;, style:&apos;css&apos; }],
        config,
        );
        return config;
    }
    6. 不需要再引入全量的antd.css，直接引入需要的组件即可，会自动加载组件相关的CSS
    import { Button } from &apos;antd&apos;
    &lt;Button type=&quot;primary&quot;&gt;Primary&lt;/Button&gt;
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/20/React-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/20/React-1/" itemprop="url">React-1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-20T00:00:00+08:00">
                2018-06-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><pre><code>1. React是Facebook公司的开源项目，用于开发单页面应用；
    1. 声明式、模块化、组件化的开发模式，通过对虚拟DOM实现数据绑定，最大限度的减少DOM操作；
    2. React可以和其他的库/框架很好地配合，但强烈不建议在React中引入JQuery；
    3. JSX是React的核心组成部分，它是一种HTML和JS的混合模式，使用XML标记的方式声明界面。
2. 搭建React开发环境
    1. 安装NodeJs、npm/cnpm
    2. 用yarn代替npm：cnpm/npm install -g yarn
    3. 安装脚手架：npm install -g create-react-app
    4. 创建项目：create-react-app reactdemo
    5. 运行项目：cd reactdemo --&gt; npm start
    6. 打包/发布项目：npm run build
    7. NodeJs&gt;=6.0和npm&gt;=5.2，支持 npx 命令创建项目，不需要手动安装脚手架；
    npx create-react-app demo --&gt; npx是npm5.2的新特性
    8. npx create-react-app demo 的执行过程：安装脚手架--&gt;创建项目--&gt;删除脚手架
3. 创建项目的报错：npm ERR! Unexpected end of JSON input while parsing near...
    1. 由于网络原因，某些依赖包加载失败，设置 npm 镜像为 cnpm
    npm config set registry https://registry.npm.taobao.org
    2. 清除 npm 缓存，即删除 npm-cache 目录下的所有文件，重启create-react-app
    C:\Users\Administrator\AppData\Roaming\npm-cache
4. 目录结构
    1. 默认入口文件：src/index.js
    import React from &apos;react&apos; ---&gt; 引入react的核心库
    import ReactDOM from &apos;react-dom&apos; ---&gt; 引入react-dom.js，提供与DOM相关的功能
    import &apos;./index.css&apos; ---&gt; 项目的公共CSS
    import App from &apos;./App&apos; ---&gt; 引入App.js组件，也就是项目的根组件
    1. registerServiceWorker.js：用于加快react的运行项目
    2. ReactDOM.render(&lt;App /&gt;, document.getElementById(&apos;root&apos;))：把根组件App渲染到
    root节点上
    1. src/index.test.js：用于测试
    2. src/App.css：App组件中使用的css，import &apos;./App.css&apos;
5. 新建组件Home.js
    import React, { Component } from &apos;react&apos;
    class Home extends Component {
        render() { return &lt;div&gt;Hello Home&lt;/div&gt; }
    }
    export default Home; --&gt; 暴露Home组件
    1. 挂载到根组件App上
    import Home from &apos;./components/Home&apos;
    render() { return(&lt;div&gt; &lt;Home /&gt; &lt;/div&gt;) }
    2. render() 返回的JSX语句称为模板，最外层必须由一个根节点包裹，对于多行JSX节点，则必须
    使用 return( ... )
    3. 在模板中使用的HTML节点，必须严格遵循HTML的标准格式，如&lt;img /&gt;不能写作&lt;img&gt;
</code></pre><h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><h3 id="绑定数据"><a href="#绑定数据" class="headerlink" title="绑定数据"></a>绑定数据</h3><pre><code>import &apos;../assets/css/home.css&apos; ---&gt;引入CSS
class Home extends Component {
    constructor(props) {  ----&gt; 参数props用于父子组件的数据传递
        super(props); ---&gt; 必须先初始化父类Component的构造方法
        this.state = { ---&gt; state 是react用于管理数据的对象，类似于vueX的state
            name:&apos;Mack&apos;, age:20, color:&apos;red&apos;, -------&gt; .red{ color:red; }
            styles: { color:&apos;red&apos;, fontSize:&apos;20px&apos; }
        }
    }
    render() { 
        return (&lt;div&gt;
            &lt;h2&gt;{this.state.name} --- {this.state.age}&lt;/h2&gt;
        &lt;/div&gt;)
    }
}
1. 模板中的 { ... } 是JS语句的标识，可以数值、JS变量、JS表达式等；
2. state 中的属性
    1. 获取方式：this.state.name
    2. 更新方式：this.setState({ name: &apos;Jack&apos; }) --&gt; React会更新DOM
3. 节点属性的变更
    1. 使用class选择器时，建议使用 className
    &lt;span className={this.state.color}&gt;{this.state.name}&lt;/h2&gt;
    2. 对于&lt;label&gt;上的 for 属性，建议使用 htmlFor
    &lt;label htmlFor=&quot;uname&quot;&gt;用户名&lt;/label&gt;&lt;input id=&quot;uname&quot; /&gt;
    3. 行内样式：style属性绑定的其实是一个对象
    &lt;div style={{ color:'red' }}&gt;&lt;/div&gt;&lt;div style={this.state.styles}&gt;&lt;/div&gt;
4. 引入图片
    1. ES6的 import 导入本地图片
    import logo from &apos;../asseets/img/logo.png&apos;
    &lt;img src={logo} /&gt;
    2. 使用ES5的 require 语法：&lt;img src={require(&apos;../asseets/img/logo.png&apos;)}&gt;
    3. 引入远程图片与HTML的标准格式一致，直接引入即可。
6. 循环数组：必须使用 key 属性标识唯一性
    1. 模板中支持直接循环数组
    this.state = { lists:[&lt;h2 key={1}&gt;11&lt;/h2&gt;, &lt;h2 key=&apos;2&apos;&gt;22&lt;/h2&gt;] }
    render() {
        return (&lt;div&gt;
                {this.state.lists}  ---&gt; 循环数组中的标签元素
        &lt;/div&gt;)
    }
    2. 拼接&lt;li&gt;标签数组
    this.state = { nums:[11, 22, 33] }
    render() {
        let result = this.state.nums.map((item, index) =&gt; { 
            return &lt;li key={index}&gt;{item}&lt;/li&gt;
        })
        return &lt;ul&gt; {result} &lt;/ul&gt;
    }
    3. 直接在模板中使用JS语句
    render() {
        return (&lt;ul&gt;
            {
                this.state.nums.map((item, index) =&gt; { 
                    return &lt;li key={index}&gt;{item}&lt;/li&gt;
                })
            }
        &lt;/ul&gt;)
    }
7. 模板中的注释：{ /* 注释内容 */ }
</code></pre><h3 id="绑定事件"><a href="#绑定事件" class="headerlink" title="绑定事件"></a>绑定事件</h3><pre><code>1. 事件的方法就是在组件内定义的方法
    class Home extends React.Component {
        onTest() { ... }
        render() { 
            return &lt;div&gt;&lt;button onClick={this.onTest}&gt;点击事件&lt;/button&gt;&lt;/div&gt;
        }
    } -----&gt; 绑定事件时，不能写作 this.onTest()，这种方式表示直接调用方法
2. 事件方法中的this指向问题与三种解决方式
    1. 方法中的 this指向默认由调用者决定的，模板的this是未定义的，所以在绑定的事件方法中，
    其this也指向undefined，它也不能再调用当前组件内的属性和方法；
    2. 在render()中使用的this指向当前组件，函数的 bind 方法又可以修改this的指向
    &lt;button onClick={this.onTest.bind(this)}&gt;点击事件&lt;/button&gt;
    3. 在组件的构造函数中修改事件方法的this指向
    constructor() { this.onTest = this.onTest.bind(this) }
    4. 把事件方法定义为箭头函数，因为箭头函数的this由上一级作用于决定，而模板的上一级作用域
    正是 render()，其this指向组件对象：onTest = ()=&gt;{ ... }
    5. 如果事件方法需要接受参数，还是通过调用 bind() 传递实参；
    onTest(name, age) { ... }
    &lt;button onClick={this.onTest.bind(this, &apos;Mack&apos;, 20)}&gt;点击事件&lt;/button&gt;
3. 事件对象event：在绑定事件方法时，方法的最后一个形参默认为事件对象
    1. 无实参时
    &lt;button onClick={this.onTest}&gt;点击事件&lt;/button&gt;
    onTest(event) { let btn = event.target; --&gt; 获取当前点击的DOM节点 }
    2. 有实参时
    &lt;button onClick={this.onMove.bind(this, 1, 2)}&gt;点击事件&lt;/button&gt;
    onMove(a, b, event) { let btn = event.target; }
4. ref：react提供了 refs 管理标签上的自定义属性ref，它可以直接获取DOM对象；
    &lt;input type=&quot;text&quot; ref=&quot;uname&quot; /&gt; ---&gt; this.refs.uname
5. 双向数据绑定MVVM
    1. react的数据是单向绑定的，即model变化引起view变化，this.setState()更新model
    2. react没有提供双向数据绑定，只能通过表单节点的 onChange 事件，间接实现MVVM
    this.state = { uname: &apos;Mack&apos; }
    &lt;input type=&quot;text&quot; value={this.state.uname} onChange={this.inputChange} /&gt;
    inputChange = (event)=&gt; {
        this.setState({ uname:event.target.value }) ---&gt;view变化引起model变化
    }
    3. 如果只是使用 value 绑定数据，而没有绑定 onChange 事件，会报错；
    4. 如果只希望绑定数据，而不绑定onChange事件，则使用defaultValue={this.state.uname}
6. 约束性组件和非约束性组件：React中提出的概念
    1. 非约束性组件：&lt;input type=&quot;text&quot; defaultValue=&quot;123&quot; /&gt;
    2. defaultValue属性其实就是原声DOM中的value属性，对于这样的组件，其value值就是用户的
    输入内容，React完全不管理输入的过程；
    3. 约束性组件：&lt;input type=&quot;text&quot; value={this.state.uname} onChange={...} /&gt;
    4. value属性绑定了一个变化的数据，它又由onChange事件的方法负责管理，此时的value不再是
    用户输入的内容，而是onChange事件触发之后，由this.setState()引发的一次重新渲染；
    5. 不同的是，React会通过操作虚拟DOM，优化整个渲染过程。
</code></pre><h2 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h2><pre><code>1. 父组件向子组件传递数据
    1. 父组件
    import Header from &apos;./Header&apos;  --&gt; 引入子组件Header
    this.state = { msg:&apos;123&apos; }
    render() {
        return(&lt;div&gt;
            &lt;Header msg={this.state.msg} /&gt;
        &lt;div&gt;)
    }
    2. 子组件Header.js中接收数据
    constructor(props) { super(props) } ---&gt; props是一个对象，用于接收父组件的数据
    &lt;span&gt;{this.props.msg}&lt;span&gt;
2. 父组件向子组件传递方法
    1. 父组件
    run= ()=&gt; { ... }
    render() {
        return(&lt;div&gt;
            &lt;Header run={this.run} /&gt;
        &lt;div&gt;)
    }
    2. 子组件
    &lt;button onClick={this.props.run}&gt;&lt;/button&gt;
3. 父组件还可以把整个父组件传递给子组件，让子组件可以访问父组件中的所有数据
    1. 父组件
    getChildData = (data)=&gt; { ...//接收子组件传递的数据 }
    &lt;Header parent={this} /&gt;
    2. 子组件
    &lt;button onClick={this.props.parent.getChildData.bind(this, 123)}&gt;&lt;/button&gt;
4. 父组件主动获取子组件的数据
    1. 在父组件中为子组件定义ref属性：&lt;Header ref=&quot;header&quot; /&gt;
    2. 父组件获取子组件的引用：this.refs.header，从而可以访问子组件的数据
5. defaultProps与propTypes
    1. 父组件在调用子组件时，如果不给子组件传值，则子组件可以使用defaultProps定义默认值；
    class Header extends React.Component { ... }
    Header.defaultProps = {
        msg: &apos;0&apos;  ---&gt; 如果父组件没有传递msg，则使用此默认值
    }
    export default Header;
    2. propTypes：用于验证父组件传值类型的合法性；
    import PropTypes from &apos;prop-types&apos; --&gt; react的一个内置模块
    Header.propTypes = {
        msg: PropTypes.number  --&gt; 父组件传递msg的数据类型必须是number
    }
</code></pre><h2 id="React表单"><a href="#React表单" class="headerlink" title="React表单"></a>React表单</h2><pre><code>&lt;form onSubmit={this.handleSubmit}&gt;
    &lt;input type=&quot;submit&quot; defaultValue=&quot;提交&quot;/&gt;
&lt;/form&gt;
1. 提交事件onSubmit会刷新界面，必须要阻止其默认行为
    handleSubmit = (e)=&gt;{ e.preventDefault(); ...... }
2. 单选框
    this.state = { sex: 1 }
    &lt;input type=&quot;radio&quot; value=&quot;1&quot; checked={this.state.sex===1} 
    onChange={handleSex} /&gt;男
    &lt;input type=&quot;radio&quot; value=&quot;2&quot; checked={this.state.sex===2} 
    onChange={handleSex} /&gt;女
    handleSex = (e)=&gt; { this.setState({ sex: parsetInt(e.target.value) }) }
3. 下拉框
    this.state = { city:&apos;&apos;, citys:[&apos;上海&apos;, &apos;北京&apos;, &apos;杭州&apos;] }
    &lt;select value={this.state.city} onChange={this.handleCity}&gt;
        {
            this.state.citys.map((value, key) =&gt; {
                return &lt;option key={key}&gt;{value}&lt;/option&gt;
            })
        }
    &lt;/select&gt;
    handleCity = (e)=&gt; { this.setState({ city: e.target.value }) }
4. 多选框
    this.state = { hobby:[{title:&apos;sleep&apos;, checked:true}, 
        {title:&apos;travel&apos;, checked:false}, {title:&apos;study&apos;, checked:false}] }
    {
        this.state.hobby.map((value, key) =&gt; {
            return (&lt;div key={key}&gt;
                &lt;input type=&quot;checkbox&quot; checked={value.checked} 
                onChange={this.handleHobby.bind(this, key)} /&gt;{value.title}
            &lt;/div&gt;)
        })
    }
    handleHobby(key) {
        let hobby = this.state.hobby
        hobby[key].checked = !hobby[key].checked
        this.setState({ hobby:hobby })
    }
5. 大文本输入框
    &lt;textarea value={this.state.info} onChange={this.handleInfo} /&gt;
    1. 在JSX中，大文本框必须是自闭合标签的形式：&lt;textarea /&gt;
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/15/Vue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/15/Vue/" itemprop="url">VUE</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-15T00:00:00+08:00">
                2018-06-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><pre><code>1. render(h)：渲染函数
    new Vue({
        el: &apos;#app&apos;,
        components: { App },
        template: &apos;&lt;App /&gt;&apos;,
    })
    简写形式：
        new Vue({
            el: &apos;#app&apos;,
            render: h =&gt; h(App),
        })
2. this.$nextTick(callback)：等待下一次事件轮询时执行，下一次Event Loop
    1. 比如，v-html渲染html字符串是需要时间的，JS不能直接操作其中的DOM节点，需要等待下次
    事件轮询； &lt;div v-html=&quot;data&quot;&gt;&lt;/div&gt;
    data = &apos;&lt;span id=&quot;test&quot;&gt;HTML字符串&lt;/span&gt;&apos;
    this.$nextTick(()=&gt;{
        let test = document.getElementById(&apos;test&apos;);
    })
    2. $nextTick()与Vue钩子函数的实现原理是由浏览器的渲染机制决定的。
3. 便捷访问static目录下的图片：&lt;img :src=&quot;&apos;./static/img/a.png&apos;&quot; /&gt;
4. 动态挂载组件
    1. 创建Vue实例
    let MyComponent = Vue.extend({
        template: &apos;&lt;div&gt;{{uname}}&lt;/div&gt;&apos;,
        data: function(){
            return { uname:&apos;Mack&apos; }
        },
        method: { ... }
    })
    2. 动态挂载到指定DOM节点上：
    new MyComponent().$mount(&apos;#home&apos;); ---&gt; 方式一
    new MyComponent({ el:&apos;#home&apos; }) ---&gt; 方式二
    3. 在文档之外渲染，随后再动态挂载
    let component = new MyComponent().$mount()
    document.getElementById(&apos;home&apos;).appendChild(component.$el)
</code></pre><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><pre><code>1. Vue作为一个MVVM框架的基本实现原理：数据代理、模板解析、数据绑定
2. Vue涉及的核心技术：虚拟DOM、Diff算法
3. 关键性方法：Object.defineProperty(obj, prop, descriptor)
</code></pre><h3 id="DocumentFragment"><a href="#DocumentFragment" class="headerlink" title="DocumentFragment"></a>DocumentFragment</h3><pre><code>1. DocumentFragment：文档碎片，虚拟DOM对象，表示一个没有父级文件的最小文档对象；
2. 被当作一个轻量版的Document使用，用于存储已排好版的或尚未打理好格式的XML片段；
3. Document对应显示的页面，包含N个Element，更新Document内部的元素，界面也会更新；
4. DocumentFragment并不是真实DOM树的一部分，而是内存中保存N个Element的容器对象，
不与界面关联，它的变化不会引起DOM树的重新渲染，界面不变，且不会导致性能等问题；
</code></pre><h3 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h3><pre><code>1. 数据代理：通过一个对象代理操作另一个对象中的属性；
2. Vue的数据代理：通过vm对象来代理data对象中的所有属性操作；
3. Vue数据代理的实现：vm中的_data属性代理了data对象
    1. 通过Object.defineProperty()给vm添加与data对象的属性对应的属性描述符，监视
    vm的属性变化；
    2. Object.defineProperty()会为vm中所有添加的属性提供getter/setter，它们内部
    去操作data中对应的属性数据。
</code></pre><h3 id="模板解析"><a href="#模板解析" class="headerlink" title="模板解析"></a>模板解析</h3><pre><code>1. 创建DocumentFragment对象，递归遍历DOM树，将DOM节点添加进DocumentFragment中，
也即，将DOM节点映射到虚拟DOM对象中；
2. 解析大括号表达式({{name}})、一般指令、事件指令。
</code></pre><h3 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h3><pre><code>1. 一旦更新了data对象中的某个属性数据，所有界面上直接/间接使用此属性的节点都会更新；
2. 数据劫持：Vue中用来实现数据绑定的一种技术；
3. 劫持的基本思想：也是通过Object.defineProperty()为data对象中的属性添加setter/
getter，来监视所有属性数据的变化，并随之更新界面；
4. vm --&gt; data --&gt; 更新界面
5. 双向数据绑定：建立在单向数据绑定的基础之上；
    1. 在解析v-model指定时，给当前元素添加input监听；
    2. 当input的value发生变化时，将最新的指赋给当前表达式对应的data对象中的属性。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/09/JS-ES6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/09/JS-ES6/" itemprop="url">JS-ES6</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-09T00:00:00+08:00">
                2018-06-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><pre><code>1. 声明变量：let、const
    1. let：块级作用域，不能重复声明，不会预处理，不存在变量提升；
    2. const：与let类似，但它定义的是常量，不能修改；
2. 变量的结构解析(解构赋值)：从对象/数组中提取数据，并赋值给一个/多个变量；
    1. 对象：let obj = { name: &apos;Mack&apos;, age: 12 }
    let {name, age} = obj; --&gt;变量名必须与对象中的属性名保持一致，位置可以任意排列
    console.log(name, age); --&gt; name=&apos;Mack&apos;, age=12
    let {name} = obj; --&gt; 需要哪些属性，就获取哪些属性
    2. 数组：let arr = [ 1, 3, 5, false, &apos;hello&apos; ]
    let [ a, b ] = arr; --&gt; 变量值与位置有关，与数组的下标对应
    let [,,, a, b] = arr; --&gt; a=false, b=&apos;hello&apos;
3. 模板字符串：``和${xxx}
    1. `` 是模板字符串的标识，${xxx} 是变化的部分，简化字符串的拼接
    2. let str = `My name is ${obj.name}`  --&gt; &apos;My name is Mack&apos;
4. 对象属性/方法的简写方式：let name = &apos;Mack&apos;
    let obj = { name,  ---&gt; 等同于 name: name，同名属性可以省略
        getName() { ... }, --&gt; 等同于 getName: function() { ... }
    }
5. 形参默认值：function test(x=1, y=2, z) { ... }
</code></pre><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><pre><code>1. 箭头函数：(arg1, arg2,) =&gt; { ... }，类似于lambda表达式
    1. 无参数：let fun = () =&gt; console.log(&apos;Hello JS&apos;);
    fun(); --&gt; fun指向箭头函数，fun()调用箭头函数
    2. &quot;=&gt;&quot;后是单条语句时，可省略&quot;{}&quot;，且该语句执行的结果会作为函数的返回值；
    3. 一个参数：let fun = a =&gt; console.log(a);
    4. 多个参数：let fun = (a, b) =&gt; console.log(a, b);
    5. 多条语句时，&quot;{}&quot;不能省略，函数的返回值仍默认为undefined
    let fun = () =&gt; {
        return &apos;Hello World&apos;;  --&gt; 手动指定返回值
    }
2. 箭头函数的this：
    1. 箭头函数没有自己的this，它的this不是调用时决定的，而是在定义时所处的环境决定的；
    2. 如果箭头函数直接定义在一个对象/函数中，那么箭头函数的this就是该对象/函数的this，
    否则，箭头函数的this指向window；
    3. 也就是说，箭头函数的this取决于箭头函数所定义的外层空间；
    element.onclick = function() { ...// this就是element对象 }
    element.onclick = () =&gt; {
        // 箭头函数定义在全局作用域，也即定义在window中，那么this指向window
    }
3. 可变参数：...rest，用于取代arguments
    1. arguments只是类似于数组，但并不具备数组的方法，如forEach()
    2. ...rest只接收多余的实参，而且是一个数组；
    function(a, b, ...rest) { --&gt; 必须放在参数的最后位置
        rest.forEach((item, index) =&gt; { ... }) --&gt; 遍历多余参数
    }
    3. 扩展应用-三点运算符：let arr = [2, 3, 4];
    let arr2 = [1, ...arr, 5] --&gt; [1, 2, 3, 4, 5]
    console.log(...arr2) --&gt; 1 2 3 4 5，三点运算符会自动遍历数组元素
    4. 三点运算符还可以浅拷贝复制数组和对象
    let copyArr = [...arr]
    let obj = { name:&apos;Mack&apos; } ---&gt; let copyObj = { ...obj }
</code></pre><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><pre><code>1. Promise对象：表示未来某个将要发生的事件，通常是一个异步操作；
2. Promise可以将异步操作以同步的方式表达出来，避免了层层嵌套的回调(回调地狱)；
3. 使用Promise：Promise是ES6的一个构造函数
    1. 创建Promise对象：
    let promise = new Promise((resolve, reject) =&gt; {
        //Promise为初始化状态：pending
        ...... //执行异步操作
        if(异步操作成功) { resolve(value); } --&gt;修改Promise为成功状态：fullfilled
        else { reject(errMsg); } --&gt; 修改Promise为失败状态：rejected
    });
    2. 调用Promise的then()
    promise.then(result =&gt; { --&gt;执行resolve()，则回调then()的第一个函数
            console.log(result);
        }, errMsg =&gt; {  --&gt; 执行reject()，则回调then()的第二个函数
            console.log(errMsg);
        }
    ) --&gt; 回调参数result、errMsg分别是resolve()、reject()传递的value、errMsg
    3. 封装AJAX请求：
    fuction getNews(url) {
        let promise = new Promise((resolve, reject) =&gt; {
            let http = new XMLHttpResponse();
            http.onreadystatechange = function() {
                if(http.readyState!==4) return;
                if(http.status == 200) {
                    resolve(http.responseText); --&gt;请求成功，修改状态
                } else {
                    reject(&apos;暂时没有数据&apos;); ---&gt;请求失败，修改状态
                }
            };
            http.open(&apos;GET&apos;, url);  http.send(); --&gt;发送请求
        })；
        return promise;
    }
    getNews(&apos;http://&apos;).then(res =&gt; { ······
            return getNews(res.url); --&gt;发送第二次AJAX请求，必须返回一个
        }, error =&gt; { ······ }   --------&gt; Promise对象，then()可以链式回调;
    ).then(res =&gt; {  ----&gt; 回调第二次AJAX的结果
        ······
    }, error =&gt; { ······ });
</code></pre><h2 id="Symbol属性"><a href="#Symbol属性" class="headerlink" title="Symbol属性"></a>Symbol属性</h2><pre><code>1. ES5中对象的属性名都是字符串，容易重名，污染环境；
2. Symbol是ES6新增的一种数据类型，它对应的值是唯一的；
3. 不能与其他数据计算，包括字符串拼接，for-in/for-of不会遍历Symbol属性；
    let sym = Symbol();  --&gt; Symbol不是构造函数，不用new创建
    let obj = { name: &apos;Mack&apos; }
    obj[sym] = &apos;Hello&apos;; --&gt; 为对象添加Symbol属性，其属性值为&apos;Hello&apos;
4. 创建Symbol时还可以传递参数，作为Symbol的标识；
    let sym = Symbol(&apos;Hello&apos;)
    const SYM = Symbol(&apos;key&apos;) ---&gt; 定义为常量
5. ES6还提供了11个内置的Symbol值，指向内部使用方法，如Symbol.iterator
</code></pre><h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><pre><code>1. Iterator：一种接口机制，为各种不同的数据结构提供统一的访问机制；
2. ES6提供了一种新的遍历方式：for-of，Iterator主要供for-of消费；
3. 模拟Iterator的原理：let arr = [1, 4, 27, &apos;abc&apos;]
    function myIterator(arr) {
        let index = 0;  ---&gt; 记录指针的位置
        return {  -----&gt; 遍历器对象
            next: function() {
                return index &lt; arr.length ? {value:arr[index++], done:false}
                 : { value: undefined, done: true }
            }
        }
    }
    let iter = myIterator(arr);
    console.log(iter.next()); --&gt; { value: 1, done: false }
    ......
    console.log(iter.next()); --&gt; { value: &apos;abc&apos;, done: false }
    console.log(iter.next()); --&gt; { value: undefined, done: true }
4. 将Iterator接口部署到指定的数据类型上，则可以用for-of遍历；
    1. JS的原生数据类型中具备Iterator接口的有：String、Array、arguments、Set、Map
    2. for(let i of [1,2,3]) { ...//i就是每次循环的元素 }
5. Symbol.iterator
    1. String、Array、arguments等对象具备Iterator接口，但普通对象并没有Iterator接口，
    所以不能使用for-of遍历；
    2. 为普通对象添加Symbol.iterator属性，指向其默认遍历器方法，for-of就能遍历该对象；
    3. Symbol.iterator属性添加给对象，就等同于为该对象部署了Iterator接口；
    let data = {
        [Symbol.iterator]: function() {
            let index = 0; ---&gt; 记录指针的位置
            return { ... } ---&gt; 遍历器对象
        }
    }
    4. 三点运算符和解构赋值，默认调用的就是Iterator接口。
</code></pre><h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><pre><code>1. Generator函数：ES6提供的解决异步编程的方案之一；
    function* test() {
        yield &apos;test1&apos;
        yield &apos;test2&apos;
    }
2. 调用Generator函数，返回一个指针对象，由该对象调用next()，遇到yield返回；
    let gen = test();
    console.log(gen.next());  --&gt; {value: &quot;test1&quot;, done: false}
    console.log(gen.next());  --&gt; {value: &quot;test2&quot;, done: false}
    console.log(gen.next());  --&gt; {value: undefined, done: true}
3. 为普通对象添加Symbol.iterator属性，指向一个Generator函数；
    let obj = { name: &apos;Mack&apos; }
    obj[Symbol.iterator] = function* gen() { --&gt;为对象部署Iterator接口
        yield 1
        yield 2
    }
    for(let i of obj) {  ---&gt; 具备Iterator接口的对象，for-of都可以遍历
        console.log(i)  --&gt; 1 2
    }
4. let result = yield &apos;test1&apos;  --&gt; yield的返回值默认是undefined
5. next(arg)：参数arg会先赋值给当前指针所在的yield，再向下移动；
    function getNews(url) {
        $.get(url, function(data) { --&gt; jQuery-GET请求成功的回调
            HTTP.next(data.url);  ---&gt; 获取新的URL，发送第二次请求
        });
    }
    function* sendHttp() {
        let url = yield getNews(&apos;http://...&apos;) --&gt; 第一次next()
        yield getNews(url)  --&gt; 第二次next()，需要传递参数
    }
    let HTTP = sendHttp(); ---&gt; 获取遍历器对象
    HTTP.next();  --&gt; 发送第一次GET请求
</code></pre><h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><pre><code>1. async函数：真正意义上解决回调地狱的问题，同步的方式表达异步操作；
2. async函数的本质是Generator的语法糖，源自ES2016(ES7)；
    1. async函数返回的总是Promise对象，用then()进行下一步操作；
    async function test() {  ---&gt; 函数test变成一个异步函数
        return &apos;hello async&apos;;
    }
    test().then(res=&gt;{
        console.log(res); --&gt;hello async
    })
    2. async取代Generator函数的&quot;*&quot;，await取代Generator函数的yield；
    async function test() {
        await 异步操作; --------&gt; 该异步操作总是返回一个Promise对象
        await 异步操作;
    }
    3. async函数不需要像Generator函数那样去调用next()，遇到await就会等待，当前的异步操作
    完成后，则继续向下执行。
3. async的使用方式
    1. 基本使用
    async function test() { return &apos;hello async&apos;; }
    async function exec() {
        let t = await test(); --&gt; 阻塞程序，等待异步方法test() 执行完成
        console.log(t)
    }
    2. async函数返回一个Pormise对象，await总是配合Promise使用，返回值由resolve()决定
    async function test() {
        let res = await new Promise((resolve, reject) =&gt; {
                setTimeout(() =&gt; { resolve(&apos;Mack&apos;); }, 2000);
            })
        console.log(res); --&gt; 2000ms之后打印 Mack
    }
    3. await语句默认返回undefined，resolve()可以为awiat传递参数，reject()表示异步任务
    失败，会终止继续向下执行。
4. 发送AJAX请求：
    function getNews(url) {
        return new Promise((resolve, reject) =&gt; {
            $.ajax({ method: &apos;GET&apos;, url,
                success: data =&gt; resolve(data), --&gt; GET请求成功
                error: error =&gt; resolve(error) --&gt; 请求失败不使用reject()
            }) ------&gt; 那么await会继续向下执行，由此判断成功还是失败
        })
    }
    async function sendHttp() {
        let res = await getNews(&apos;http://...&apos;)
        if(res) { --&gt; 判断res的状态
            res = await getNews(res.url) --&gt; 继续执行异步任务
        } else { alert(&apos;请求失败&apos;) --&gt; 请求失败，则提示给用户 }
    }
    sendHttp();
</code></pre><h2 id="其他新增"><a href="#其他新增" class="headerlink" title="其他新增"></a>其他新增</h2><pre><code>1. class：可以定义类、实现类的继承，通过类中的constructor定义构造方法；
    1. new 创建类的实例对象，extends实现类的继承，super调用父类的构造方法；
    class Person {
        constructor(name, age) {  ---&gt; 构造函数
            this.name = name;  this.age = age; --&gt; 定义属性
        }
        showName() {   -------------&gt; 类的方法必须是简写形式
            console.log(this.name);
        }
        static run() {  -----------------&gt; 静态方法
            console.log(&apos;static method&apos;);
        }
    }
    2. 创建实例对象：let p = new Person(&apos;Mack&apos;, 18)
    3. 静态方法可以直接通过类名调用：Person.run();
    4. extends：类的继承
    class Stu extends Person {
        constructor(name, age, job) {
            super(name, age);  ------&gt; 必须先初始化父类的构造方法
            this.job = job;
        }
        showName() {  ...... } ---&gt; 重写父类的方法
    }
2. 字符串的扩展
    1. includes(str)：判断是否包含某个字符串；
    2. startsWidth(str)/endsWidth(str)：判断是否以某个字符串开头/结尾；
    3. repeat(count)：把当前字符串拼接count次，并返回；
3. number的扩展
    1. 二进制与八进制的数值表示：0b、0o
    2. Number.isFinite(num)：判断num是否是一个有限大的是数字；
    3. Number.isNaN(num)/isInteger(num)：判断num是否是NaN/整数；
    4. Number.parseInt(str)：把字符串转为数值；
    5. Math.trunc(num)：取整，去除小数部分。
4. Array的扩展
    1. Array.from(v)：将伪数组/可遍历对象转为真实的数组，包括Set、Map、字符串
    低于ES6的版本：Array.prototype.slice.call(v)
    2. Array.of(v1, v2, v3)：将一系列的值转为一个数组[v1, v2, v3]
    3. find/findIndex((value, index, arr) =&gt; { return true })
    查找第一个满足条件返回true的元素/元素下标：let arr = [2, 3, 5, 7, 1]
    let res = arr.find(function(v, i) { return v &gt; 4 }) --&gt; 5
5. 对象方法的扩展
    1. Object.is(v1, v2)：判断2个数据是否完全相等；，Object.is(NaN, NaN) --&gt;true
    Object.is(0, -0) --&gt; false，其实该方法是按照字符串的标准比较的
    2. Object.assign(target, s1,s2,...)：将源对象s1、s2...的属性复制给目标对象target
    let s1 = { name:&apos;Mack&apos;, job:&apos;Teacher&apos; };  let s2 = { name:&apos;JJJ&apos;, age:20 };
    let target1 = {}
    let target2 = Object.assign(target, s1,s2); ---&gt; s2的name属性会覆盖s1的name属性
    --&gt; target1和target2：{ name:&apos;JJJ&apos;, age:20, job:&apos;Teacher&apos; }
    3. 直接操作隐式原型__proto__，ES6之前不能访问隐式原型。
6. 深度克隆
    1. 浅拷贝：拷贝的是引用，修改拷贝后的数据，会影响原数据；
    2. 深拷贝对象/数组：JSON.parse(JSON.stringify(data))
    3. 三点运算符、Object.assign(target, s1,s2) 都是浅拷贝
</code></pre><h2 id="Set、Map"><a href="#Set、Map" class="headerlink" title="Set、Map"></a>Set、Map</h2><pre><code>1. Set：无序、不可重复的、多个value的集合体；
    1. let set = new Set(); --&gt; set.size：value的个数
    2. let set = new Set(array); --&gt;会去除array中的重复数据；
    3. 添加、删除、清空：add(value)、delete(value)、clear()
    4. has(value)：判断value是否存在。
2. Map：无序的、key不重复的、多个key-value的集合体；
    1. let map = new Map(); --&gt; set.size：key的个数
    2. new Map([[1], [4,5], [7,8,9]]) --&gt;{ 1=&gt;undefined, 4=&gt;5, 7=&gt;8 }
    3. 添加/修改、获取value、删除：set(key, value)、get(key)、delete(key)
    4. has(key)：判断key是否存在；  clear()：清空。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/07/JS-新特性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/07/JS-新特性/" itemprop="url">JS-新特性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-07T00:00:00+08:00">
                2018-06-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ES"><a href="#ES" class="headerlink" title="ES"></a>ES</h2><pre><code>JS包含三个部分：ECMAScript(核心)、扩展浏览器端、扩展服务器端
1. ECMAScript：2009年发布ES5，2015年发布ES6，2016年发布ES7
2. 扩展浏览器端：BOM(浏览器对象模型)、DOM(文档对象模型)
3. 扩展服务器端：Node.js
</code></pre><h3 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h3><pre><code>1. 严格模式：除了正常运行模型(混杂模型)，ES5增加了严格模式(strict mode)
    1. 消除JS语法的一些不合理、不严谨、不安全之处，减少一些怪异行为；
    2. 使用：在全局/函数的首行定义&apos;use strict&apos;; 即使不支持，也没有任何副作用；
2. 严格模式的语法和行为：
    1. 变量必须用var声明，混杂模式下，如果不使用，则升级为全局变量，即添加给window
    2. 禁止自定义函数中的this指向window
    function Person(name) { this.name = name; }
    Person(&apos;Mack&apos;) --&gt; 直接调用构造函数，则this指向window，严格模式不允许
    new Person(&apos;Mack&apos;) --&gt; 创建实例对象，则this指向当前的实例对象
    3. 创建eval作用域：var str = &apos;Mack&apos;;
    eval(&apos;var str = &quot;Any&quot;; alert(str);&apos;); --&gt; var str = &quot;Any&quot;; alert(str);
    alert(str); --&gt; 非严格模式下，str=&apos;Any&apos;，那么就可以借助eval()攻击
    4. 对象不能有重名的属性。
3. 为Object扩展一些静态方法，如create()、defineProperties()、defineProperty()
    var obj = { name: &apos;Mack&apos;, age: 30 }
    1. create(prototype, [descriptors])：以指定对象为原型，创建新的对象；
    var obj2 = {};  var obj4 = {};
    obj2 = Object.create(obj); --&gt; obj2仍是空的，但其隐式原型指向obj
    obj4 = Object.create(obj, {
        sex: {  --------------&gt; 扩展属性
            value: &apos;Male&apos;, ---&gt; 属性值
            writale: true, ---&gt; 当前属性值是否可修改，默认为false
            configurable: true, ---&gt; 当前属性是否能被删除，默认为false
            enumerable: true ------&gt; 当前属性能否被for-in遍历，默认为false
        }
    })
    2. defineProperties(object, props)：为指定对象定义扩展属性。
    Object.defineProperties(obj, {
        job: { ---&gt; 扩展新的属性
            get: function() {  --&gt; 访问扩展属性时回调，计算当前属性值
                return this.name + &apos;:&apos; + this.age;
            },
            set: function(data) { --&gt; 修改属性时回调，用于监视属性的变化
                var n = data.split(&apos;:&apos;)
                this.name = n[0];  this.age = n[1]
            },
        }
    })
    console.log(obj.job) --&gt; 回调get()：&apos;Mack:30&apos;
    obj.job = &apos;Any:16&apos; --&gt; 回调set()：name=&apos;Any&apos;，age=16
    2. getter和setter都是惰性执行的，只有在访问/修改属性时才会调用，直接打印obj并不会
    直接显示job的属性值。
    3. 对象本身也有getter和setter，其实defineProperties()中调用的也是它们；
    var obj = { name: &apos;Mack&apos;, age: 30,
        get job() {
            return this.name + &apos;:&apos; + this.age;
        },
        set job(data) {
            var n = data.split(&apos;:&apos;)
            this.name = n[0];  this.age = n[1]
        }
    }
    4. defineProperty(obj, prop, descriptor)：参数3为将被定义或修改的属性描述符
4. 数组Array扩展的方法
    1. indexOf(value)/lastIndexOf(value)：返回元素的索引；
    2. forEach(function(item, index){ ... })：遍历数组；
    3. map(callback)：计算每一个数组元素，并不会影响原数组，而是返回一个新的数组；
    4. reduce(function(arg1, arg2){ ... })：两两计算，返回最终结果；
    5. filter(callback)：过滤数组的元素，返回一个新的数组。
5. 函数扩展的方法：call()，apply()，bind()
    1. call/apply/bind()都能修改函数中的this指向；
    2. bind(obj)：让函数内的this指向obj，但不会执行函数，而是将函数返回；
    3. bind()传递参数的方式与call()相同，通常用于修改回调函数中的this指向。
</code></pre><h2 id="ES7"><a href="#ES7" class="headerlink" title="ES7"></a>ES7</h2><pre><code>1. 指数运算符：3**3 = 27
2. Array.prototype.includes(value)：判断数组中是否包含value
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/05/JS-高级/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/05/JS-高级/" itemprop="url">JS-高级</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-05T00:00:00+08:00">
                2018-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JS高级"><a href="#JS高级" class="headerlink" title="JS高级"></a>JS高级</h2><pre><code>1. 访问对象属性(方法也是属性)的通用方式：obj[&apos;属性名&apos;]
    1. 属性名包含特殊字符，如&quot;-&quot;、空格，访问：obj[&apos;content-type&apos;]
    2. 属性名不确定：var name=&apos;age&apos;;  var value=18;  obj[name]=value
2. IIFE：立即执行函数，用于隐藏实现、避免污染全局命名空间、编写JS模块
    (function(){ ... })() ---&gt; 即匿名函数自调用
3. this的指向
    1. 任何函数本质上都是通过某个对象来调用的，如果没有显式指定，则默认是window；
    2. 所有函数内部都有一个变量this，指向当前调用函数的对象；
    3. functionName.call()/apply()：第一个参数用于指定函数内部this的指向。
4. JS语句可以不加分号，但有2种情况必须加分号：
    1. 小括号开头的前一条语句；
    var a = 3;
    (function() { ... })()
    2. 中方括号开头的前一条语句；
    var b = 4;
    [1, 3].forEach(function)
    3. 为了避免这2种错误，可以在行首加分号：;(function() { ... })()
</code></pre><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><pre><code>function Test() { ... }
1. prototype：显式原型(属性)
    1. 定义函数时自动添加一个prototype属性，默认指向一个Object空对象，即原型对象；
    Test.prototype instanceof Object --&gt; true
    Function.prototype instanceof Object --&gt; true
    Object.prototype instanceof Object --&gt; false，Object除外
    2. 原型对象中又有一个属性constructor，指向函数自身；
    Test.prototype.constructor === Test ---&gt; true
    3. 给原型对象添加属性/方法，函数的所有实例对象自动拥有原型对象中的属性/方法。
2. __proto__：隐式原型(属性)，ES6之前不能直接操作该属性
    1. 创建实例对象时自动添加一个__proto__属性，默认值为构造函数的prototype属性值；
    即：实例对象的隐式原型和构造函数的显式原型指向同一个原型对象；
    var tes = new Test();
    tes.__proto__ === Test.prototype ---&gt; true
    2. 函数也有隐式原型，而且所有函数(包括Object和Function)都是Function的实例；
    Test/Object/Function.__proto__ === Function.prototype ---&gt; true
3. 原型链：__proto__链
    1. 原型对象中也有隐式原型__proto__，指向当前构造函数的父构造函数的原型对象；
    tes.show() --&gt; 自身 --&gt; 沿着__proto__查找：tes.__proto__ 即Test.prototype 
    --&gt; Test.prototype.__proto__ 即Object.prototype --&gt; show()不存在，报错；
    2. 所有对象/构造函数，包括Function，都直接/间接派生自Object，它是JS的顶层父类，
    其原型对象就是原型链的尽头，因为Object.prototype.__proto__ === null
4. 访问对象属性/方法时，会自动到原型链上查找；而设置对象的属性值时，则不会涉及原型链，
   如果对象中没有该属性/方法，则添加，否则就修改；
5. 一般情况下，方法定义在原型中，属性直接定义在通过构造函数；
6. A instanceof B 的判断的标准：如果B的显示原型在A的原型链上，则返回true.
</code></pre><h3 id="函数高级"><a href="#函数高级" class="headerlink" title="函数高级"></a>函数高级</h3><pre><code>1. 全局执行上下文
    1. 在执行全局代码前，将window确定为全局执行上下文；
    2. 对全局数据进行预处理：var定义的全局变量会被提前声明(值为undefined)，全局函数
    会被提前定义，并把全局变量/函数添加为window的属性/方法；
    3. this指向window；
    4. 在执行代码时，才会对变量重新赋值，而定义函数的代码会直接跳过，因为在执行全局
    代码之前，函数已经被提前定义了。
    var test = 1;
    function test() { ... }
    test(); ---&gt; 报错：test is not a function
    5. 真正的执行过程：
    var test; --&gt; function test() { ... } --&gt; test = 1; --&gt; test();
2. 函数执行上下文
    1. 调用函数、准备执行函数之前，创建对应的函数执行上下文；
    2. 对局部数据做预处理：变量的提前声明，函数的提前定义，this的指向，形参的赋值等；
3. 闭包：内部函数引用外部函数的局部变量，外部函数执行完后，其局部变量仍存活于内存中；
    function out() {
        var a = 2;
        function inner() {
            console.log(++a);
        }
        return inner;
    }
    1. var f = out(); --&gt; 变量f持有内函数inner()的引用，所以局部变量a仍在内存中；
    2. out(); --&gt; 没有任何引用内函数指向inner()，那么inner将成为垃圾对象，并被GC；
    也即，局部变量a也不存在了；
    3. 闭包的生命周期：在函数内部定义时就已经产生了，在内部函数成为垃圾对象时死亡；
    var f = out(); --&gt; f(); --&gt; f = null; --&gt; 死亡，释放内存；
    4. 闭包容易造成内存泄露，应该及时释放。
4. 利用闭包自定义JS模块-1：myModule.js
    function myModule() {
        var msg = 1;
        function showMsg() { ... }
        return showMsg; --&gt; 向外暴露
    }
    在html中引用：&lt;script src=&quot;myModule.js&quot; type=&quot;text/javascript&quot;&gt;        
    var fn = myModule(); --&gt; fn指向内部函数showMsg() --&gt; 执行showMsg()：fn();
    如果暴露多个函数，则返回一个对象：return { showMsg: showMsg, }
    var module = myModule(); --&gt; 执行showMsg()：module.showMsg();
5. 利用闭包自定义JS模块-2：myModule.js
    (function(w) {  --&gt; 自执行函数
        var msg = 1;
        function showMsg() { ... }
        w.myModule = { showMsg: showMsg, } --&gt; 向外暴露
    })(window) --&gt; 为全局上下文window添加属性myModule
    在html中引用：&lt;script src=&quot;myModule.js&quot; type=&quot;text/javascript&quot;&gt;        
    myModule.showMsg(); --&gt; myModule是window的属性，可以直接使用；
</code></pre><h3 id="对象高级"><a href="#对象高级" class="headerlink" title="对象高级"></a>对象高级</h3><pre><code>1. 创建对象：
    1. Object构造函数模式：var obj = new Object(); --&gt; 然后为对象添加属性/方法；
    2. 对象字面量模式：var obj = { ...(属性/方法) }
    3. 工厂模式：动态返回一个对象的函数；
    4. 自定义构造函数模式：var obj = new Person(&apos;Mack&apos;)
    function Person(name) {
        this.name = name;
        this.show = function() { ... }
    }
    5. 构造函数+原型的组合模式：
    function Person(name) { this.name=name; }
    Person.prototype.show = function() { ... } --&gt; 公共的方法定义在原型对象中
2. 原型链继承：子类的原型是父类的一个原型对象；
    1. 定义父类构造函数，并在原型中添加方法；
    function Supper() { this.supProp = &apos;Supper property&apos;; }
    Supper.prototype.showSupper = function() { ... }
    2. 定义子类构造函数，让子类的原型指向父类对象，修正子类原型对象中的constructor，
    让其指向子类构造函数，然后为子类的原型添加方法；
    function Sub() { this.subProp = &apos;Sub property&apos;; }
    Sub.prototype = new Supper(); --&gt; 更改显示原型的指向
    Sub.prototype.constructor = Sub; --&gt; 修正constructor的指向
    //Sub.prototype.__proto__即new Supper().__proto__，指向Supper.prototype
    Sub.prototype.showSub = function() { ... }
    3. 创建子类的对象，可以调用父类的方法：var sub = new Sub();
    sub.showSubProp(); sub.showSupperProp();
</code></pre><h3 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h3><pre><code>cookie，H5新增的localStorage、sessionStorage
</code></pre><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><pre><code>1. 存储在浏览器的一段文本信息，最大容量4k，在同源的http请求时携带传递，损耗带宽；
2. cookie是在服务器端设置的，浏览器接收到cookie信息，便以键-值的形式存储在本地；
3. 出于安全考虑，跨域名请求不会携带cookie，这是由浏览器技术实现的安全策略；
4. 可设置访问路径和过期时间，只有此路径及其子路径才能访问此cookie。
</code></pre><h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><pre><code>1. 容量最小5M，不会在http请求时携带传递，不需要服务器环境；
2. 在所有同源窗口中共享，数据始终有效，除非人为删除，可作为长期数据；
3. 设置：localStorage.setItem(&apos;key&apos;, &apos;value&apos;);    localStorage.key = value;
4. 获取：localStorage.getItem(&apos;key&apos;);    localStorage.key;
5. 删除：localStorage.removeItem(&apos;key&apos;);
</code></pre><h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><pre><code>1. 容量最小5M，不会在http请求时携带传递，在同源的当前窗口关闭前有效；
2. 与localStorage合称为Web Storage，支持事件通知机制，可以将数据更新通知监听者；
3. iPhone的无痕浏览不支持Web Storage，只能用cookie.
</code></pre><h2 id="JS与后台通信"><a href="#JS与后台通信" class="headerlink" title="JS与后台通信"></a>JS与后台通信</h2><h3 id="AJAX：同源策略"><a href="#AJAX：同源策略" class="headerlink" title="AJAX：同源策略"></a>AJAX：同源策略</h3><pre><code>1. JS原生支持AJAX，目的是让JS发送HTTP请求，且AJAX通信的过程是异步的；
2. 同源策略：基于安全考虑，AJAX只能请求同一域名下的资源，通常是JSON数据；
报错特征：No &apos;Access-Control-Allow-Origin&apos; header is present 
on the requested resource. Origin &apos;null&apos; is therefore not allowed access.
3. AJAX执行的是同源策略，所以请求的url不需要域名，比如 url: &apos;js/user.json&apos;;
</code></pre><h3 id="JSONP：跨域请求"><a href="#JSONP：跨域请求" class="headerlink" title="JSONP：跨域请求"></a>JSONP：跨域请求</h3><pre><code>1. 原理：&lt;script src=&quot;...&quot;&gt; src链接的地址不受限制；
2. 在页面上定义的JS函数，script-src链接的外部JS文件也可以调用，那么，外部JS就可以
   把数据以回调参数的形式传递回当前页面。
</code></pre><h2 id="移动端JS事件"><a href="#移动端JS事件" class="headerlink" title="移动端JS事件"></a>移动端JS事件</h2><pre><code>1. 移动端主要用手指操作，在JS中对应Touch事件：
    1. touchstart/touchend/touchmove：手指放到屏幕上/离开屏幕/滑动时触发；
    2. touchcancel：系统取消Touch事件时触发；
    3. 移动端一般操作：点击、滑动、拖动，这三种操作一般组合使用Touch事件完成。
2. zeptojs：最初是为移动端提供一个精简的、类似jQuery的JS库，现在发展成一个轻量级的、
   针对现代高级浏览器的JS库；
    1. API类也似于jQuery，比如$(function(){ ... })、$(this)、$(&apos;#div&apos;) ...
    2. 其touch模块封装了移动端常用的Touch事件，针对开发移动端的特定效果。
3. swiper.js：一个成熟稳定的、应用于PC端和移动端的滑动效果插件；
    1. 一般用来触屏焦点图、触屏整屏滚动、幻灯片等效果；
    2. 2.x版本支持低版本浏览器IE7，3.x放弃低版本浏览器，适用于移动端。
</code></pre><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><pre><code>1. 作为浏览器脚本语言，JS主要与用户交互及操作DOM，这决定了JS是单线程的，效率高；
2. H5中的Web Workers可以多线程运行；
3. 浏览器是多线程运行的，Firefox、老版IE是单进程，新版IE、Chrome是多进程；
4. 浏览器内核：支撑浏览器运行的核心程序，由很多模块组成；
    1. Chrome/Safari：webkit   Firefox：Gecko   IE：Trident
    2. 360、搜狗等国内浏览器的内核：Trident+webkit
    3. 内核模块-主线程：JS引擎模块(JS的编译与运行)，HTML文档解析模块，DOM/CSS模块
    (DOM/CSS在内存中的相关处理)，布局和渲染模块(负责页面的布局和效果的绘制)...
    4. 内核模块-子线程：定时器模块(管理定时器)，事件响应模块(管理事件)，网络请求模块
    (AJAX请求)...
</code></pre><h3 id="JS是单线程"><a href="#JS是单线程" class="headerlink" title="JS是单线程"></a>JS是单线程</h3><pre><code>1. 定时器机制：
    1. 定时器并不能保证真正的定时执行，一般会延迟一点点，但也有可能延迟很长时间；
    2. 定时器其实是在主线程中执行的，因为JS是单线程的，如果定时器执行前做耗时/阻塞的
    操作，那么就可能造成定时器延迟很长时间。
2. JS代码分为初始化代码、回调代码，JS引擎执行代码的基本流程：
    1. 先执行初始化代码：包括设置定时器、绑定监听、发送AJAX请求
    2. 在后面的某个时刻才会执行回调代码；
    3. 弹出alert，JS代码是阻塞的，计时也会被暂停，定时器随之被延迟，直到关闭alert后
    才会恢复计时，执行定时器。
3. 事件驱动模型
</code></pre><p><img src="https://i.imgur.com/6RlAIZh.jpg" alt></p>
<pre><code>1. event loop：事件轮询，事件包括定时器、DOM事件、AJAX
2. callback queue：事件的回调队列，存放待处理的回调函数；
3. 当事件发生时，管理模块会将回调函数及其数据添加到回调队列中，等待主线程执行。
</code></pre><h3 id="Web-Workers"><a href="#Web-Workers" class="headerlink" title="Web Workers"></a>Web Workers</h3><pre><code>1. JS是单线程的，在做耗时的操作时，如大量计算，Web界面就会卡死；
2. Web Workers是H5提供的一个JS多线程解决方案，子线程完全受主线程控制，由子线程去执行
耗时的计算，避免冻结主线程，但H5不允许子线程操作DOM，所以并没有改变JS单线程的本质；
3. 使用Web Workers：
    1. 创建子线程执行的JS文件：worker.js
    var onmessage = function(event) {  --&gt; 接收主线程发来的消息，var可省略
        var data = event.data
        postMessage(&apos;Hello Main&apos;) --&gt; 向主线程发消息
    }
    2. 在主线程中的JS中发消息，并设置回调：
    var worker = new Worker(&apos;worker.js&apos;)
    worker.onmessage = function(event) { --&gt; 监听子线程发来的消息
        var data = event.data --&gt; 获取子线程发来的数据
    }
    worker.postMessage(&apos;Hello Worker&apos;); --&gt; 向子线程发送消息
4. 主线程的全局上下文是window，而子线程的全局上下文DedicatedWorkerGlobalScope
    1. DedicatedWorkerGlobalScope的属性/方法：
    onmessage: null，postMessage: function，close: function ...
    2. 子线程的全局上下文对象中没有alert()、document等，所以子线程中不能更新界面。
5. Web Workers的缺点：慢，不能跨域加载JS，不能操作DOM，有些浏览器不支持。
</code></pre><h2 id="自动化与优化"><a href="#自动化与优化" class="headerlink" title="自动化与优化"></a>自动化与优化</h2><pre><code>1. less、sass、stylus：三种样式动态语言，属于CSS预处理语言，便于CSS的编写和维护；
    1. 有类似于CSS的语法，赋予CSS动态语言的特性，如变量、继承、函数等；
    2. 文件后缀分别是：x.less、x.scss、x.styl，并不能直接使用，需要编译成CSS文件；
    3. 编译方式：软件编译如koala，或者用nodejs程序编译，如grunt、gulp
2. gulp比grunt更简洁、性能更高，gulp的常用插件：
    1. 压缩JS代码gulp-uglify、less的编译gulp-less、CSS的压缩gulp-minify-css.
    2. 自动添加CSS3前缀gulp-autoprefixer、文件重命名gulp-rename.
</code></pre><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><pre><code>1. 代码部署
    1. 代码的压缩与合并：去除空格、换行等，可利用gulp工具的插件完成；
    2. 图片、JS、CSS等静态资源存储在与主站不同的域名地址，避免在传输时携带cookie；
    3. 权衡DNS查找次数，使用不同域名会增加DNS查找；与上述相违背，权衡处理；
    4. 使用内容分发网络 CDN；使用GZIP压缩传输，压缩效率高；
    5. 为文件设置Last-Modified、Expires和Etag，即本地缓存数据；
    6. 避免不必要的重定向，在链接末尾手动加&quot;/&quot;，如https://www.baidu.com/
2. HTML：避免空的src和href，不要在HTML中缩放图片。
3. CSS
    1. 精简CSS选择器的层级，并把CSS放到顶部，避免@import的方式引入样式；
    2. 使用Base64编码的图片数据取代图片文件，减少请求次数；
    3. 使用CSS动画来取代JS动画，CSS动画是虚拟完成的，并不会改变页面结构；
    4. 使用字体图标：https://fontawesome.com/icons
    5. 使用CSS Sprite雪碧图，SVG图像；避免使用CSS表达式和滤镜。
4. JavaScript
    1. 减少引用库的个数，使用模块化概念的requerejs/seajs异步加载JS；
    2. JS在加载时会阻塞页面继续向下解析，理论上JS应该放在页面底部引用；
    3. 避免全局查找，约束范围去查找；减少属性查找；尽可能使用原生方法；
    4. 用switch代替复杂的if-else；减少语句数，比如多个变量声明可以合成一句；
    5. 使用字面量表达式来初始化数组/对象，比如arr=[1,2,3]取代new Array(1,2,3);
    6. 使用DocumentFragments/innerHTML取代复杂的元素注入；
    7. 使用事件代理/委托；高频触发的事件设置函数节流；
    8. 避免多次dom选择集，使用变量存储，var d = $(&apos;#div&apos;);
    9. 使用Web Storage缓存数据；使用Array的join()取代字符串的&quot;+&quot;连接。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/03/JS-事件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/03/JS-事件/" itemprop="url">JS-事件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-03T00:00:00+08:00">
                2018-06-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><h3 id="DOM查询"><a href="#DOM查询" class="headerlink" title="DOM查询"></a>DOM查询</h3><pre><code>1. 通过domcument对象获取元素节点：
    1. getElementById(&quot;id&quot;)：通过id属性获取一个元素节点对象；
    2. getElementsByTagName(&quot;tag&quot;)：通过标签名获取一组元素节点对象；
    2. getElementsByTagName(&quot;*&quot;)：支持通配符，获取所有节点对象；
    3. getElementsByName(&quot;name&quot;)：通过name属性获取一组元素节点对象。
    4. 获取元素节点的属性值：节点对象.属性名，但对于class属性，节点对象.className
1. 通过具体的元素节点对象获取其子节点：
    1. childNodes：获取其所有的子节点，包括文本节点、换行、标签间的空白等，但IE8不会；
    2. children：获取所有的子元素，只获取标签元素，且是直接子元素；
    3. firstChild/lastChild：获取第一个/最后一个子节点，也包括文本节点、换行，空白等；
    4. firstElementChild：获取第一个标签元素，不兼容&lt;=IE8；
2. 获取父节点和兄弟节点：
    1. parentNode：获取当前节点的父节点；
    2. previousSibling/nextSibling：获取前/后一个兄弟节点；
    3. previousElementSibling：获取前一个兄弟标签元素，也不兼容&lt;=IE8；
    4. innerText/innerHTML/textContent：都可以获取一个标签的内容，innerHTML的内容包含
    子标签，而innerText和textContent只获取标签内的字符串文本；
    5. 只获取标签内自己的字符串：firstChild.nodeValue，没有字符串文本，则返回空字符串；
    对于不能做父元素的标签，如&lt;img/&gt;, 其firstChild为null
3. 每个节点(包括文本节点)都具有的3个属性：nodeName、nodeType、nodeValse
    1. 文档节点：nodeName =&gt;#document、nodeType =&gt;9、nodeValse =&gt;null
    2. 元素节点：标签名、1、null
    3. 属性节点：属性名、2、属性值
    4. 文本节点：#text、3、文本内容
4. document.documentElement/body：获取&lt;html&gt;/&lt;body&gt;的元素对象；
5. document.all/document.getElementsByTagName(&quot;*&quot;)：获取所有节点的标签元素；
6. getElementsByClassName(&apos;选择器名称&apos;)：根据class属性值获取一组元素，兼容到&gt;=IE8
7. querySelector(&apos;CSS选择器&apos;)：根据CSS选择器获取标签元素，只返回第一个，兼容到&gt;=IE8；
8. querySelectorAll(&apos;CSS选择器&apos;)：返回一组标签元素；
9. HTML是自顶向下解析的，不能提前获取document节点
    1. 在&lt;body&gt;标签之后使用&lt;script&gt;，可以获取节点对象；
    2. window.onload = function(){ ... }：等待HTML文档加载并渲染完成再执行；
</code></pre><h3 id="DOM增删改"><a href="#DOM增删改" class="headerlink" title="DOM增删改"></a>DOM增删改</h3><pre><code>1. appendChild()/removeChild()/replaceChild()：添加/删除/替换子节点；
2. insertBefore(newNode, oldNode)：在指定的子节点前插入新的子节点；
3. createElement()/createAttribute()/createTextNode()：创建元素/属性/文本节点；
    var li = document.createElement(&quot;li&quot;); --&gt; 创建一个&lt;li&gt;
    var text = document.createTextNode(&quot;Mark&quot;); --&gt; 创建文本节点
    li.appendChild(text); --&gt; 把文本节点添加到&lt;li&gt;中
4. innerHTML也可以完成DOM的增删改：li.innerHTML=&quot;&lt;span&gt;Smith&lt;/span&gt;&quot;;
    var li = document.createElement(&quot;li&quot;);
    li.innerHTML = &quot;Mark&quot;; --&gt; create与innerHTML结合使用
5. setAttribute()/getAttribute()：设置/获取指定的属性；
6. confirm(str)：确认/取消提示框，带有确认和取消按钮，返回true/false；
    &lt;button&gt;Button-1&lt;/button&gt; &lt;button&gt;Button-2&lt;/button&gt;
window.onload=function(){
    var btns = document.getElementsByTagName(&quot;button&quot;)
    for (var i=0; i&lt;btns.length; i++) {
        btn[i].onclick=function(){
            confirm(this.innerHTML); --&gt; this指向当前button对象
            confirm(btns[i].innerHTML); --&gt;报异常undefined，此时的i=btns.length
        }; --&gt; 页面加载完成，首先执行的是for循环，而不会执行函数；
    } --&gt; 在点击按钮时，此时的i=btns.length，所以报异常；
}; --&gt; 而函数内的this始终指向调用者，所以可以正常执行。
</code></pre><h3 id="DOM操作CSS"><a href="#DOM操作CSS" class="headerlink" title="DOM操作CSS"></a>DOM操作CSS</h3><h4 id="JS修改元素样式"><a href="#JS修改元素样式" class="headerlink" title="JS修改元素样式"></a>JS修改元素样式</h4><pre><code>1. 选择器中的样式是无法获取，也无法修改的，但可以操作元素的内联样式，其优先级高于选择器；
2. 元素对象.style.样式名 = &quot;样式值&quot;，通用写法：元素对象.style[&quot;样式名&quot;] = &quot;样式值&quot;
3. 对于&quot;-&quot;连接的属性，则去掉&quot;-&quot;，并把后面的首字母大写：btn.style.fontSize=&quot;20px&quot;;
4. 通用形式则不需要去掉属性名中的连接符：btn.style[&quot;font-size&quot;]=&quot;20px&quot;;
5. &lt;style&gt;中的选择器应避免使用&quot;!important&quot;，它表示样式的最高优先级，内联样式也无法覆盖；
6. element.setAttribute(&apos;style&apos;, &apos;width:20px;height:30px;&apos;)：设置元素的style属性；
7. element.setAttribute(&apos;style&apos;)：移除元素的style属性，也即删除style样式；
8. 如果要修改多个样式，可以在&lt;style&gt;中预定义CSS样式选择器，再赋值给元素的className属性，
   这种方式的性能比较高，也使得JS和CSS更好的分离。
</code></pre><h4 id="JS获取元素样式"><a href="#JS获取元素样式" class="headerlink" title="JS获取元素样式"></a>JS获取元素样式</h4><pre><code>1. element.style：获取的是当前元素上的所有内联样式，包括默认存在的内联样式；
2. element.style.样式名、element.style[&quot;样式名&quot;]：根据属性名获取内联样式的属性；
    1. 获取的只是内联样式上的属性，如果内联样式上没有手动设置该属性，则获取的属性值为&apos;&apos;；
    2. element.style.cssText：只获取标签上手动设置的CSS样式，是一个字符串；
    element.style.cssText = &quot;width:100%;font-size:16px;&quot; --&gt;修改/添加内联样式
3. element.getAttribute(&apos;style&apos;)：获取标签上的style属性值，同element.style.cssText
4. element.currentStyle.样式名：IE独有的，获取元素当前正在使用的所有样式信息；
    1. 如果没有手动设置样式的默认值，则返回auto；
5. getComputedStyle(element, null)：window的方法，获取元素当前正在使用的的所有样式；
    let sty = getComputedStyle(btn, null)
    1. sty[&quot;background-color&quot;]返回的是rgb值，btn.style[&quot;background-color&quot;]返回的是
    当前样式中设置的background-color属性值；
    2. 不兼容&lt;=IE8
6. currentStyle和getComputedStyle()获取的属性都是只读的，不能修改；
7. 获取CSS样式属性的兼容方式：
    function getStyle(element, styleName) {
        if(window.getComputedStyle) {
            return getComputedStyle(element, null)[styleName];
        } else { --&gt; IE8的window中没有getComputedStyle，则返回undefined，即false
            return element.currentStyle[styleName];
        } --&gt; 属性styleName要显示设置一个默认值，否则浏览器可能返回auto
    }
</code></pre><h3 id="DOM属性事件"><a href="#DOM属性事件" class="headerlink" title="DOM属性事件"></a>DOM属性事件</h3><pre><code>1. clientWidth/clientHeight：获取元素的可见宽高，不带单位px，返回的是数值；
    1. clientWidth = width + paddingLeft + paddingRight
    2. clientWidth和clientHeight都是只读属性；
    3. 浏览器窗口的宽度/高度：document.documentElement.clientWidth/clientHeight
2. scrollWidth/scrollHeight：获取元素的滚动区域宽高；
    1. 如果元素区域带有滚动条，clientWidth/clientHeight只能获取滚动窗口内可见的宽高，
    而scrollWidth/scrollHeight获取的宽高，包含滚动窗口外的宽高；
    2. clientWidth/clientHeight获取的宽高包含滚动条的宽度/高度；
    3. scrollLeft/scrollTop：水平/垂直滚动的距离；
    4. 当垂直滚动条滚到底部时，clientHeight == scrollHeight-scrollTop
    5. element.onscroll = function(){}; --&gt; 绑定滚动条滚动事件
3. offsetWidth/offsetHeight：获取元素的整个宽度和高度，width+padding+border
4. offsetParent：获取距离最近的、使用了定位的父元素对象，如果都没有定位，则返回body；
5. offsetLeft/offsetTop：当前元素相对于其定位父元素的水平/垂直偏移量，都是只读的属性；
1. 上传图片
    &lt;input type=&quot;file&quot; accept=&quot;image/*&quot; onchange=&quot;uploadImg(this)&quot; /&gt;
    1. accept：指定上传文件的类型，打开资源管理器展示的文件类型；
    2. onchange：&lt;input/&gt;中的内容发生变化时的事件；
    3. 预览图片，FileReader是H5提供的，用于读取文件
    uploadImg(ev) {
        let file = ev.files[0]
        let reader = new FileReader() --&gt;创建FileReader对象
        reader.onloadstart = function (e) { //开始读取 }
        reader.onprogress = function (e) { //正在读取中 }
        reader.onabort = function (e) { //中断读取 }
        reader.onerror = function (e) { //读取异常 }
        reader.onload = function (e) { ---&gt;读取成功的回调
            let img = document.querySelector(&quot;input[type=file]&quot;)
            img.src = e.target.result
        }
        reader.readAsDataURL(file) ---&gt;开始读取本地选择的文件
    }
1. element.onmousemove = function(event){}：鼠标在元素中移动时被触发；
    1. 回调的参数event中封装了所有信息，如鼠标的水平/垂直坐标：clientX/clientY
    2. 但在IE8中不会回调event，而是将事件对象保存在window的属性中：window.event
    3. clientX/clientY只针对当前浏览器的可见窗口，窗口左上角的坐标始终是(0, 0)；
    4. pageX/pageY：鼠标相对于当前页面的坐标，页面左上角的坐标才是(0, 0)，不兼容IE8；
2. 页面垂直滚动时，scrollTop的兼容性：获取页面滚动的距离；
    1. document.body.scrollTop：只适用于Chrome浏览器，其他浏览器返回0；
    2. document.documentElement.scrollTop：适用于Foxfire、IE，但Chrome仍返回0；
    3. 水平方向滚动时，scrollLeft同理。
3. 事件冒泡：如果父节点和子节点绑定了相同的事件，那么触发子节点事件时，父节点也会触发；
    1. 事件只会向上传递父节点的相同事件，不会向下传递；
    2. 阻止事件冒泡：event.stopPropagation(); --&gt; 不兼容IE
    3. IE浏览器特有的阻止事件冒泡：window.event.cancelBubble = true;
4. 事件委托：多个子元素需要注册同一种事件时，给其共同的父元素注册该事件，事件响应时，通过
   回调参数event获取每个子元素，根据不同的子元素，执行不同的代码；
    &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;超链接一&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;javascript:;&quot;&gt;超链接二&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;
    var uls = document.getElementsByTagName(&quot;ul&quot;)[0];
    uls.onclick = function(event) {
        event = event || window.event; --&gt; 兼容IE
        var node = event.target; --&gt; 获取当前点击的子元素节点对象
    };
    1. event.currentTarget 与 event.target：
    2. click事件实际注册到&lt;ul&gt;标签上，event.target获取的是实际点击标签的元素对象；
    点击&lt;li&gt;，则event.target就是&lt;li&gt;对象，点击&lt;a&gt;，则event.target就是&lt;a&gt;对象；
    3. event.currentTarget获取的是实际注册click事件的元素对象，点击&lt;a&gt;、&lt;li&gt;、&lt;ul&gt;，
    event.currentTarget都是&lt;ul&gt;对象。
5. 函数节流：
    1. JS中有些事件的触发频率特别高，比如：onresize，onmousemove
    2. 对于短时间内高频率触发的函数，可以在函数内使用定时器减少触发次数，实现函数节流；
    3. 在触发定时器之前，先清除一次定时器，只保留最后一次定时器任务；
    clearTimeout(timer); timer = setTimeout(function{ ... }, 200);
4. addEventListener(&quot;事件名&quot;, function, false)：事件绑定，事件名不带&quot;on&quot;；
    1. element.onclick=function(event){}; -&gt;属性的方式绑定事件，多次绑定同一事件时，
    最后一次绑定会覆盖之前的事件；
    2. addEventListener()可以重复绑定同一事件，响应事件时，从第一次绑定时开始响应；
    uls.addEventListener(&apos;click&apos;, function(){}, false); --&gt; 绑定click事件
    3. removeEventListener(&apos;事件名&apos;, callback)：移除绑定的事件，callback并不是移除
    事件的回调，而是addEventListener()的回调函数名，因为它可以对同一事件绑定多次；
    4. addEventListener()只兼容到IE9，而在IE8中，绑定事件使用attachEvent()
    5. attachEvent(&quot;事件名&quot;, function)：事件名中带&quot;on&quot;，也可以多次绑定同一个事件，
    但事件的响应顺序与addEventListener()相反；
    6. addEventListener()中的this指向绑定事件的对象，而attachEvent()中指向window；
    7. 兼容性：
    function bind(obj, event, callback) {
        if(obj.addEventListener) {
            obj.addEventListener(event, callback, false);
        } else {
            obj.attachEvent(&quot;on&quot;+event, function() {
                callback.call(obj);  --&gt; 让回调函数中的this指向绑定的对象
            });
        }
    }
5. 事件的传播：
    1. 微软公司认为事件应该从内向外，即事件冒泡的形式；而网景公司认为恰恰相反；
    2. W3C综合两种方案，将事件传播分为3个阶段：捕获阶段、目标阶段、冒泡阶段
    3. 捕获阶段：事件从最外层的父元素，向目标子元素进行事件的捕获，但默认此时不会触发事件；
    4. 目标阶段：事件捕获到目标元素，捕获结束，开始在目标元素上触发事件；
    5. 冒泡阶段：事件从目标元素向父元素传递，并依次触发父元素上的事件；
    6. 在捕获阶段也触发事件：addEventListener(&quot;事件名&quot;, function, true)
    7. IE&lt;=8没有事件捕获阶段。
6. 鼠标按下/移动/松开：onmousedown、onmousemove、onmouseup
    1. 拖拽网页中的内容时，浏览器默认会执行搜索内容，导致拖拽功能异常；
    2. return false; --&gt; 禁止默认行为，但不兼容IE8
    3. element.setCapture(); --&gt; 捕获element绑定的相关事件，优先响应；
    4. element.releaseCapture(); --&gt; 释放捕获；
    5. 但是，setCapture()只有IE支持，Firefox不会报错，Chrome会报错；
    element.setCapture &amp;&amp; element.setCapture(); --&gt; 有setCapture()方法，则执行
6. 鼠标拖拽标签：
    element.onmousedown = function(e){ --&gt; 给被拖拽的标签注册鼠标的按下事件
        if (event.button != 0) return; --&gt; 只有鼠标左键按下才有效
        element.setCapture&amp;&amp;element.setCapture() --&gt; 兼容IE
        document.onmousemove = function(e){ --&gt;把移动事件注册到document上，防止卡顿
            ...... ----------------&gt; 更改标签的left/top，达到移动效果
            e.preventDefault(); ---&gt; 阻止浏览器的默认行为
        }
        document.onmouseup = function(e){ --&gt;抬起事件也必须注册到document上，任何地方
            document.onmousemove = null; ----&gt; 都可以取消事件
            document.onmouseup = null;
            document.releaseCapture&amp;&amp;document.releaseCapture(); --&gt; 兼容IE
        }
        //屏蔽第二次拖拽时的鬼影，return false 无效
        event.preventDefault();
        event.stopPropagation();
    }
7. 鼠标滚轮：onmousewheel，但Firefox不支持，而是使用DOMMouseScroll，而且火狐必须通过
   addEventListener()绑定滚轮事件；
    1. event.wheelDelta：鼠标滚轮滚动的方向，只看正负，不管大小，负值表示向下滚动；
    2. FireFox也不支持event.wheelDelta，而是使用event.detail，正数表示向下滚；
    3. 如果浏览器有滚动条，滚动鼠标滚轮将执行浏览器的默认行为，而不会执行元素的滚轮事件；
    element.onmousewheel=function(event){
        return false; --&gt; 阻止浏览器的默认行为，执行元素的滚轮事件；
    };
    element.addEventListener(&quot;DOMMouseScroll&quot;, function(event){
        event.preventDefault &amp;&amp; event.preventDefault(); --&gt; 阻止浏览器的默认行为
    }, false);
    4. &quot;return false;&quot;在addEventListener()注册的事件中，无法阻止浏览器的默认行为，必须
    使用tevent.preventDefault();
8. 鼠标右击事件：oncontextmenu
9. 键盘事件：onkeydown(按下)、onkeyup(松开)、onkeypress(按下并松开)
    1. 键盘事件一般绑定给可以获取焦点的元素对象，或者document，比如&lt;input /&gt;输入框；
    2. 对于onkeydown，如果长时间按下一个按键，那么事件将一直触发，而且第一次和第二次
    触发的时间间隔会比第二次之后的时间间隔长一些，为了避免误操作；
    3. event.KeyCode：获取按键的编码，从而判断按键的类型，如y=89
    4. altKey、ctrlKey、shiftKey：判断Alt、Ctrl、Shift键是否被按下；
    event.keyCode===89 &amp;&amp; event.ctrlKey --&gt; Ctrl+y
    5. &lt;input /&gt;的onkeydown事件默认行为就是输入内容，&quot;return false;&quot;可以阻止输入。
9. 阻止默认行为：return false; 与 event.preventDefault();
    1. 在jQuery中，return false;相当于同时调用preventDefault()和stopPropagation()；
    2. IE不支持preventDefault()，需要使用：window.event.returnValue = false;
    3. 在原生JS中，addEventListener()/attachEvent()绑定的事件中，不支持return false
    阻止默认行为，必须使用preventDefault()、window.event.returnValue=false
    4. H5规范指出，在mouseover等几种特殊事件中，return false; 并不一定能终止事件，所以
    H5建议尽量不要使用return false来阻止事件的默认行为。
</code></pre><h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><pre><code>BOM：浏览器对象模型，可以让我们通过JS来操作浏览器；
1. BOM对象：Window、Navigator、Location、History、Screen
    1. Window：代表整个浏览器窗口，同时，window也是网页中的全局对象；
    2. Navigator：表示当前浏览器的信息，可以用来识别不同的浏览器；
    3. Location：浏览器的地址栏，可以获取地址栏信息，操作浏览器跳转页面；
    4. History：表示浏览器的历史纪录，但由于隐私原因，不能获取到具体的历史纪录，只能操作
    浏览器向前/后退，而且只在当次访问时有效，关闭之后再打开则无效；
    5. Screen：表示拥护的屏幕信息，可以获取显示器的相关信息，常用于移动端；
    6. 这些BOM对象在浏览器中都是作为window对象的属性保存的，又因为window是全局的对象，
    可以直接使用这些对象，而不用通过window.navigator调用；
2. Navigator
    1. 由于历史原因，navigator对象中的大部分属性都已经不能识别浏览器了；
    2. 一般只会使用userAgent来判断浏览器的信息：navigator.userAgent
    3. IE11中的userAgent已经去除了微软和IE的相关标识，不能通过userAgent来准确识别IE；
    4. window.ActiveXObject：IE特有的函数，根据这些特有的信息获取浏览器的类型；
    if(window.ActiveXObject) --&gt; 微软发现了这种判断方式，所以在IE11返回的是false
    但并不意味着IE11中没有该对象：if(&quot;ActiveXObject&quot; in window) --&gt; true
3. History
    1. length：浏览器历史列表中的URL数量；
    2. back()/forward()：加载前/下一个，回退/前进一个页面；
    3. go()：加载某个具体页面，go(1)相当于forward()，go(-1)相当于back()；
4. Location
    1. location可以获取地址栏的完成信息，也可以直接操作地址栏，同window.location
    2. 属性：hash、host、hostname、href、pathname、port、protocol、search
    5. location.href = &quot;https://www.baidu.com/&quot;：重定向到一个新的网站，会生成历史纪录
    6. location = &quot;/login/login.html&quot;：重定向到新的页面，当前域名/login/login.html
    1. window.location.search：获取地址的参数部分，?...
    2. window.location.hash：获取页面的锚点，#...
    1. assign()：加载新的文档，assign(&quot;https://www.baidu.com/&quot;)
    2. reload()：刷新，默认刷新带有缓存，reload(true)：强制清空缓存刷新
    3. replace()：用新的文档替换当前文档，不会生成历史纪录，即不能回退。
5. window.open()：开启一个新的窗口，加载文档
</code></pre><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><pre><code>setTimeout()、setInterval()、clearTimeout()、clearInterval()
1. 延迟任务：
    1. setTimeout(function, time)：time毫秒之后执行function，返回Number型的数据；
    2. clearTimeout(timer)：即使timer是undefined，也不会报错，什么也不做；
2. 定时任务
    1. setInterval(function, time)：每隔time毫秒执行一次function；
    2. clearInterval(timer)：清除定时器；
</code></pre><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><pre><code>1. JSON：JavaScript Object Notation，JS对象表示法
    1. JSON和JS对象的格式一样，只不过JSON字符串中的属性名必须加双引号；
    var str = &apos;{&quot;name&quot;: &quot;Mack&quot;, &quot;age&quot;: 18}&apos;;
    3. JSON类型：对象{}，数组[]
    4. JSON中允许的属性值：字符串、数值、布尔值、null、对象、数组
2. JSON字符串与JS对象相互转换：JSON
    1. JSON.parse(str)：JSON字符串转JS对象；
    2. JSON.stringify(obj)：JS对象转JSON字符串；
    3. IE7不支持JSON，可以使用eval(str)函数，将一个字符串转为有效的表达式；
    var obj = eval(&quot;(&quot; + str +&quot;)&quot;); --&gt;对字符串加&quot;()&quot;，告诉浏览器{}不是一个代码块；
    ==&gt; obj = {&quot;name&quot;: &quot;Mack&quot;, &quot;age&quot;: 18}
    4. 但是，eval()的性能比较低，而且存在安全隐患，转换的字符串可能是一段有害的JS代码.
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/01/JS-基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/01/JS-基础/" itemprop="url">JS-基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-01T00:00:00+08:00">
                2018-06-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JS基础"><a href="#JS基础" class="headerlink" title="JS基础"></a>JS基础</h2><pre><code>1. JS的特点：解释型语言、类似于C和Java的语法结构、动态语言、基于原型的面向对象；
2. document.write(str)：向body中写字符串文本；
3. console.log()：适用于所有浏览器；
4. 三种引入方式：
    1. 行间事件：&lt;input type=&quot;button&quot; name=&quot;&quot; onclick=&quot;alert(&apos;ok!&apos;);&quot; /&gt;
    2. 嵌入式：&lt;script type=&quot;text/javascript&quot;&gt; JS语句 &lt;script /&gt;
    3. 外链式：&lt;script src=&quot;js/set_root.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
    4. 外链式的标签内不能再写JS代码，是无效的，需要再添加一个&lt;script&gt;
5. JS代码可以编写在标签的onclick属性中，也可以写在&lt;a&gt;的href属性中；
    1. &lt;button onclick=&quot;alert(&apos;点击button&apos;);&quot;&gt;
    2. &lt;a href=&quot;javascript:alert(&apos;点击a&apos;);&quot;&gt;
    3. &lt;a href=&quot;javascript:;&quot;&gt; --&gt; 让超链接失效
6. JS一共有6种数据类型：
    1. 基本数据类型：string、number、boolean、null、undefined
    2. 引用数据类型：object
    3. typeof(var)：检查变量的类型，typeof(null) --&gt;object
    在JS的最初版本中，使用的是32位系统，出于性能考虑，使用低位存储变量的类型信息，000开头
    表示对象，而null表示为全0，所以会将null错误地判断为object，虽然现在内部类型判断的代码
    已经改变了，但这个JS的历史BUG却流传了下来。
    4. 数字的最大值：Number.MAX_VALUE，如果超过了最大值，则返回正无穷：Infinity
    5. NaN：not a number，一个特殊的Number类型；
    6. 数字的最小值：Number.MIN_VALUE
    7. 当声明一个变量，但并没有赋值时，该变量值就是undefined
    8. JS的浮点数运算可能得到一个不精确的结果，比如0.1+0.2=0.300···04
8. 类型转换：string、number、boolean
    1. var b = a.toString()：将a转为string，但不会影响a的数据类型，返回一个转换后的值，
    且null和undefined并没有toString()方法；
    2. b = String(a)：可以把任意类型的数据转为string，但也不会影响a的数据类型；
    3. 对于number和boolean，String()的底层仍然时调用toString()，而null和undefined直接
    转为&quot;null&quot;和&quot;undefined&quot;；
    4. Number(x)：将x转为number，如果x不是纯数字的字符串，则返回NaN；对于空字符串和纯空格
    的字符串，则返回0；
    5. Number(true/false/null)：true转为1，false和null转为0，undefined转为NaN；
    6. parseInt(s)/parseFloat(s)：把字符串转为整数/浮点数，都是针对字符串的函数，如果接收
    的不是字符串，则会先转为字符串，再尝试转为number
    7. parseInt(&quot;12ab&quot;) --&gt; 12，parseInt(&quot;ab12&quot;) --&gt; NaN，
    8. parseFloat(&quot;12.45.78ab&quot;)：12.45，只取有效的浮点数；
    9. Boolean(x)：0、NaN、空字符串、null、undefined都转为false，其它都转为true。
9. 十六/八/二进制数字以&quot;0x&quot;/&quot;0&quot;/&quot;0b&quot;开头，但在输出时仍以十进制输出；
    1. 不是所有浏览器都支持二进制数字，比如低版本的IE会报错；
    2. 八进制数的字符串在转为数字时，有些浏览器会当成十进制解析：parseInt(&quot;070&quot;)-&gt;70，
    3. parseInt()可以在第二个参数指定解析的基数，parseInt(&quot;070&quot;, 8)-&gt;56
</code></pre><h2 id="JS运算"><a href="#JS运算" class="headerlink" title="JS运算"></a>JS运算</h2><pre><code>1. 对于非number做运算时，都会先转为number，再做运算；
    1. true+false=1，2+null=2，但任何值和NaN做运算，结果都为NaN，2*undefined=NaN；
    2. 任何值和字符串做加法运算，都是在拼接字符串，而其他运算则会把字符串转为number；
    3. 任何值和空字符串做加法运算时，其底层其实是调用String(x)；
    4. &quot;12&quot;-0，&quot;12&quot;*1，&quot;12&quot;/1，其底层其实是调用Number(x)；
    5. 负号/正号的运算：+&quot;18&quot; =&gt; 18，-true =&gt; -1，1+ +&quot;2&quot;+3 =&gt; 1+2+3=6
2. 自增/自减：d=20
    1. d++ + ++d + d ==&gt; 20+22+22
    2. d = d++ ==&gt; var e=d++; d=e; ==&gt; d=20
3. 逻辑运算：&amp;&amp;、||、!
    1. !!x：如果x不是boolean，两次对x取反，其原理与Boolean(x)一样；
    2. &amp;&amp;/||都是短路的，一旦左边是成立的，则不会检查右边；
    3. 对非boolean参与的逻辑运算，会先转为boolean，但返回的结果仍是原值；
    4. 2&amp;&amp;3=&gt;3，true&amp;&amp;2=&gt;2，2&amp;&amp;true=&gt;true，0&amp;&amp;3=&gt;0，false&amp;&amp;0=&gt;false
    5. 单独使用&quot;&amp;&amp;&quot;时，如果左边是true，则返回右边的值；反之，则返回左边的值；
    6. 单独使用&quot;||&quot;时，如果左边是true，则返回左边的值；反之，则返回右边的值。
4. 比较运算：任何值和NaN做比较运算，结果都为false；
    1. 对于非number的比较，会将其转为number，然后比较：true&gt;false =&gt; 1&gt;0 =&gt; true
    2. 1&gt;&quot;0&quot; ==&gt; 1&gt;0 ==&gt; true，1&gt;&quot;hello&quot; ==&gt; 1&gt;NaN ==&gt; false
    3. 如果两边都是字符串，则比较Unicode编码，一位一位地比较，一旦两位不同，则停止比较，
    得出结果；如果前面的每一位都相同，但其中一方没有下一位，则位数更多的一方更大；
    4. 如果两边都是number型的字符串，会得到不可预期的结果，所以一定要转型为number比较；
    5. 对于&quot;==&quot;，大部分情况下会将两边的类型都转为number，然后再去比较；
    true==&quot;1&quot; --&gt; 1==1 --&gt; true，true==&quot;hello&quot; --&gt; 1==NaN --&gt; false
    6. 但是，null==0 --&gt; false，null并没有转为0；
    7. 而undefined衍生自null，undefined==null --&gt; true
    8. NaN不和任何值相等，包括它自己，判断一个值是不是NaN，使用函数：isNaN(x)
    9. ===/!==：不会做类型转换，&quot;123&quot;===123 -&gt; false，null===undefined -&gt; false
5. &quot;\u0000&quot;：&quot;\u&quot;和4位编码组合，表示Unicode编码输出，这4位编码是十六进制；
    1. 在标签中使用Unicode编码：&amp;#编码; ==&gt; 该编码是十进制，由Unicode的编码转换而来；
    2. &quot;\u2620&quot;等效于&amp;#9760; ==&gt; &lt;h1&gt;&amp;#9760;&lt;/h1&gt;
</code></pre><h2 id="JS代码块"><a href="#JS代码块" class="headerlink" title="JS代码块"></a>JS代码块</h2><pre><code>1. prompt(str)：弹出一个带有输入框的提示框，返回值也就是输入的内容；
2. switch(true)：JS的switch语句可以接收boolean，case是比较运算的表达式；
3. 计算一段代码执行的时间，性能测试：
    1. console.time(&quot;计时器的名字&quot;)：开启一个计时器；
    2. console.timeEnd(&quot;计时器的名字&quot;)：结束计时器，打印执行代码消耗的时间；
4.  JS函数
    1. var fun = new Function(); --&gt; 创建一个空的函数对象，函数语句则以字符串的形式传递
    给构造函数：var fun = new Function(&quot;console.log(&apos;Hello JS&apos;);&quot;)
    2. 函数声明的方式创建一个函数：function 函数名() { ... }
    3. 没有显式return的函数，默认返回undefined，即return undefined;
    4. 匿名函数：var fun = function() { ... }
    function() {...} --&gt;直接定义匿名函数会抛出异常，编译器会认为{...}是一个独立的代码块，
    与function()是两部分；
    (function() { ... }) --&gt; 告诉编译器这是一个整体，但无法调用这个匿名函数
    (function() { ... })(); -- &gt; 直接调用匿名函数，并立即执行；
5. 全局作用域：页面打开时创建，页面关闭时销毁；
    1. &lt;script&gt; ... &lt;/script&gt;：标签内的JS代码，都在全局作用域中；
    2. 全局作用域中有一个全局对象window，代表一个浏览器窗口，由浏览器创建，可以直接使用；
    3. 在全局作用域中，创建的变量都会作为window对象的属性保存，创建的函数都会作为window
    对象的方法保存：var n=10; window.n --&gt; 通过window也可以调用；
    4. 变量的声明提前：var声明的变量，会在代码执行之前被声明，如果没有用var，则不会提前；
    console.log(a); var a = 10; --&gt; 打印&quot;undefined&quot;，因为只是声明提前，赋值并没有；
    5. 函数定义的提前：function fun() {} 会在代码执行之前提前被创建；
    6. var fun = function(){}; --&gt; 这是一个函数表达式，fun被认为是一个变量。
6. 函数作用域：调用函数时创建函数作用域，函数执行完毕后，函数作用域自动销毁；
    1. 函数作用域可以视为一个小的全局作用域，var声明的变量也会被提前声明，函数中定义的函数
    也会被提前创建；
    2. 函数中没有使用var声明的变量，会被声明为全局变量；
    3. 形参就相当于在函数中声明了变量，默认值为undefined
7. Array：数组也是一个对象，它是通过角标操作元素；
1. 创建数组：var arr=new Array();  var arr=[]; --&gt; 数组元素的类型没有限制
    1. arr[0]=10; --&gt; 添加元素
    2. arr[8]=30; --&gt; arr[1]到arr[7]只是占位作用，默认为undefined
    3. arr.length：获取数组长度，直接为arr.length赋值，则会修改数组的长度；
    4. new Array(1,3)：创建一个包含2个元素的数组，new Array(5)：创建一个长度为5的数组。
2. 数组的常用方法：
    1. push/unshift(arg1, arg2, ...)：向数组的末尾/开头添加元素，并返回新的数组长度；
    2. pop/shift()：删除数组的最后一个/第一个元素，并返回该元素；
    3. slice(start, end)：截取数组的一部分并返回，原数组不变；
    4. splice(start, count, ...)：从start的位置开始，删除数组的一部分，返回删除的元素；
    count表示删除的个数，count后的参数表示在start位置添加的元素，count为0表示不删除元素
    5. concat()：连接数组，concat()可以接收数组，也可以直接接收元素，返回一个新的数组；
    6. join(str)：将数组元素转为一个字符串并返回，var arr=[1, 2, 3]
    arr.join() =&gt;&quot;1,2,3&quot;=&gt;默认使用&quot;,&quot;连接，arr.join(&quot;&quot;) --&gt; &quot;123&quot;
    7. reverse()：反转数组元素的位置，直接影响原数组；
    8. sort()：默认按照Unicode编码排序，包括数字；sort()可以接收一个函数，指定排序方式；
    该函数回调两个参数，表示数组的两个元素，返回大于0的值，则交换两个元素的位置，反之不变，
    返回0表示两个值相等，位置也不变。
    9. 反转字符串：str.split(&apos;&apos;).reverse().join(&apos;&apos;);
3. forEach：ES6新特性，用于遍历数组
    1. arr.forEach(function(item, index) { ... })：item表示数组元素，index表示角标
    2. Array.prototype.forEach.call(arr, function(item, index) { ... })
    3. 相比于for循环，forEach中不能使用break、continue、return，且forEach不兼容&lt;=IE8
4. 字符串操作
    1. 在底层存储时，字符串仍是数组的形式，每个字符作为一个元素；
    2. str.length：字符串长度，同时，字符串也可以使用角标获取字符；
    3. str.charAt(i)/charCodeAt(i)：根据角标获取字符，后者返回字符的Unicode编码；
    4. str.indexOf(c, i)：根据字符获取角标，参数2表示起始位置，默认为0；
    5. substring(start, end)/slice()：slice()的end可以接收负值，-1表示最后一个字符；
    而substring()的end为负值时，默认仍是0，且如果start小于end，会自动交换位置；
    6. substr(start, count)：也可以截取字符串，count表示截取的数量，但不属于ES标准；
    7. str.split(s)：根据指定的字串，拆分字符串，返回一个数组，split(&apos;&apos;)会拆分所有字符；
</code></pre><h2 id="JS对象"><a href="#JS对象" class="headerlink" title="JS对象"></a>JS对象</h2><pre><code>JS对象：内建对象、宿主对象、自定义对象
1. 内建对象由ES标准定义，如String、Number、Boolean、Math、Date、Function、Object
2. 宿主对象是由JS运行环境提供的对象，比如浏览器提供的对象有BOM、DOM
3. console、document都是浏览器提供的对象；
4. 使用new调用的函数，是构造函数constructor，构造函数是专门用来创建对象的函数；
    var obj = new Object(); --&gt; 创建对象
    1. 添加属性/方法：obj.name = &quot;Jack&quot;; obj.show = function(){ ... }
    2. 访问对象属性的方式：obj.name，obj[&quot;name&quot;] --&gt; 后者才更通用；
    3. 方法也可以视为属性，也可以使用&quot;[]&quot;访问：obj[&quot;show&quot;]() --&gt; 调用方法
    4. 删除对象的属性：deltele obj.name/obj[&quot;name&quot;];
1. 对象属性名不强制遵守变量标识符的规范，但对于特殊的属性名，必须使用&quot;[]&quot;去操作；
    obj[&quot;123&quot;] = 678 --&gt; 而且，[]可以接收变量，var n=&quot;123&quot;，obj[n] -&gt; 678
2. 对象的属性值可以是任意的数据类型，包括对象object；
3. var obj = { 属性名: 属性值, ... }; =&gt; 创建一个对象，一般属性名可以不显式使用字符串，
   但对于特殊的属性名，必须显示使用字符串，如&quot;123&quot;: 45
4. this：函数被调用时，会向函数内部传递一个隐含的参数this，它指向函数执行的上下文对象；
    1. 以函数的形式调用函数时，this始终指向window对象；
    function test(){ console.log(this) }
    test(); --&gt; Window
    2. 以方法的形式调用时，this指向调用的对象：obj.show() --&gt; this指向Object obj
5. 构造函数
    1. 构造函数与普通函数的定义方式一样，不同的时，构造函数需要使用new关键字来调用；
    function Persion() {} --&gt; 构造函数名的首字母通常大写，称为类
    var p = new Persion(); --&gt; 创建一个新的对象/实例，并执行函数中的代码
    2. new 函数的执行：创建一个新的对象 --&gt; 将新建的对象设置为函数中的this，在函数中
    可以使用this来引用新建的对象 --&gt; 逐行执行函数中的代码 --&gt; 将新建的对象作为返回值
    3. 使用this为构造函数添加成员：function Persion(){ this.name=&quot;Huck&quot;; }
    4. instanceof：检查一个对象是否属于一个类的实例：p instanceof Persion --&gt; true
    5. Object是JS的顶层父类，任何类都是派生自Object
    6. p.toString = function() { ... }; --&gt; 重写对象的toString()方法
6. 包装类：String、Number、Boolean
    1. String()：可以将基本数据类型字符串转为String对象；
    2. 同理，Number()将数字转为Number对象，Boolean将布尔值转为Boolean对象；
    var n=123;
    n.name=&quot;Mac&quot;; --&gt;临时把n转为对象，但执行完后会立即销毁，n仍是基本数据类型；
    console.log(n.name); =&gt;undefined，再一次把n转为对象，但该对象并没有name属性
7. for-in 与 for-of
    1. for-in 是ES5新特性，本用于遍历对象，但不适合遍历数组，因为数组的key就是角标；
    2. for-of 属于ES6，用于弥补 for-in 的缺陷，只能遍历可迭代对象，如数组、字符串、Set、
    Map、arguments... 但不能遍历普通对象，因为普通对象不具备Iterator接口；
    3. Object.keys(obj)可以获取对象的所有key，间接遍历普通对象
    for(let key of Object.keys(obj)) { var value = obj[key] }
1. call()、apply()：由函数对象调用的方法，用于修改函数内的this指向；
    1. 参数1都是this指向的上下文对象，不同的是，如果函数对象需要传递参数，call()是在第一个
    参数后依次传递，而apply()则会把参数封装成数组，作为第二个参数进行传递；
    2. function test(a, b) {} =&gt; test.call(obj1, a, b)，test.apply(obj2, [a, b])
2. arguments：也是浏览器在调用函数时传递的隐含参数，用于封装传递的所有实参；
    1. arguments是一个类数组对象，并不是真的数组，Array.isArray(arguments) =&gt; false
    2. arguments.length =&gt;长度； arguments[0] =&gt;角标操作； 
    3. arguments.callee：当前正在执行的函数对象；
</code></pre><h3 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h3><pre><code>1. 创建的每一个函数，解析器都会向函数中添加一个属性prototype
2. prototype属性对应一个对象，这个对象就是所谓的原型对象；
3. 如果函数作为普通函数调用prototype，不会有任何作用；如果以构造函数的形式调用函数，它所
   创建的对象中都会有一个隐含的属性__proto__，指向该构造函数的原型对象；
    function Persion() { ... }
    var p = new Persion();
    p.__proto__ == Persion.prototype --&gt; true
4. 原型对象就相当于一个公共的区域，同一个类的所有实例都可以访问到这个原型对象，所以，可以将
   对象中的共有内容，统一设置到原型对象中，节约开销，提高性能，不会污染全局作用域；
    1. 当访问对象的属性/方法时，会先在对象自身查找，如果没有，则会去原型对象中查找；
    Persion.prototype.name=&quot;Mark&quot;;  p.name; --&gt;&quot;Mark&quot;
    2. 在创建构造函数时，可以将对象共有的属性/方法，统一添加到函数的原型对象中。
5. prop in obj：检查对象obj是否有属性prop，如果对象中没有、而原型对象中有，也会返回true；
6. obj.hasOwnProperty(prop)：只检查对象自身中是否有某个属性；
7. 原型对象中也有原型属性__proto__，但Object的原型对象中没有原型；
8. 原型链：p.__proto__.__proto__
    1. 访问对象的属性/方法时，如果当前对象中没有，则查找该对象指向的原型对象；
    2. 如果原型对象仍没有，则继续查找该原型对象指向的原型对象，一直查找到Object指向的原型
    对象，如果仍没有，则返回undefined
</code></pre><h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><pre><code>当一个对象没有被任何变量/属性所引用，GC将自动从内存中回收该对象；
var obj=new Object(); obj=null; --&gt; GC将回收该对象
</code></pre><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><pre><code>1. var reg=new RegExp(&quot;pattern&quot;, &quot;mode&quot;);  var reg=/pattern/mode;
    1. pattern：正则表达式； mode：匹配模式，i=&gt;忽略大小写，g=&gt;全文匹配；
    2. 模式m：多行搜索，更改^和$的含义，分别在任意一行都匹配行首和行尾，而不仅只在整个
    字符串的开头和结尾才匹配；
    3. reg.test(str)：匹配成功，则返回true
2. String对象中支持正则表达式的方法：
    1. match(reg)：默认只匹配第一个，match(/[a-z]/g)：全文匹配；
    2. search(reg)：返回第一次匹配的索引，设置全局匹配也无效，如果不存在，则返回-1；
    3. replace(reg, newStr)：默认也只替换第一个，需要设置全局匹配；
    4. split(reg)：默认时全局匹配；
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/19/移动端开发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/19/移动端开发/" itemprop="url">移动端开发</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-19T00:00:00+08:00">
                2018-05-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML/" itemprop="url" rel="index">
                    <span itemprop="name">HTML</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h2><pre><code>视口是移动设备用于显示网页的区域，一般会比移动设备的可视区域大，宽度可能是980px或1024px；
目的是为了显示整个为PC端设计的网页，这样在移动端会出现横向滚动条；为了避免滚动条，移动端会
将视口缩放到移动端窗口的大小。
缩放后的网页在移动设备上不易观看，使用&lt;meta/&gt;标签，让视口兼容移动设备可视区的大小。
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no,
    initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot; /&gt;
1. viewport：视口；
2. width=device-width：设置视口的宽度等于设备的宽度；
3. user-scalable=no：不允许用户缩放；
4. initial-scale=1.0：设置初始缩放；
5. maximum-scale=1.0, minimum-scale=1.0：兼容浏览器。
6. 在&lt;head&gt;中生成的快捷键：meta:vp + tab键
</code></pre><h2 id="屏幕适配"><a href="#屏幕适配" class="headerlink" title="屏幕适配"></a>屏幕适配</h2><pre><code>视网膜屏幕：物理像素密度更高的屏幕，常见有2倍和3倍的视网膜屏幕，其物理像素点更小；
图像在视网膜屏和一般屏幕上显示的大小一样时，由于视网膜屏的物理像素点比一般屏幕小，图像就会
变得模糊；
解决方式：使用大一倍的图像，再用CSS强制设置图像的尺寸；
1. background-size：设置背景图像的大小；
    1. background-size: 500px 500px; --&gt; 设置背景图的宽高px；
    2. background-size: 100% 100%; --&gt; 百分比设置背景图的宽高，100%表示完全填充容器；
    3. auto：使用背景图的真实大小；
    4. cover：等比缩放到完全覆盖容器，背景图的宽度/高度可能超出容器；
    5. contain：等比缩放到与容器的宽度/高度相等，保证背景图始终被包含在容器内。
2. 标签的宽高不会影响到背景图的大小，通常会把使用标签的宽高设置的大一些，避免裁剪到背景图。
</code></pre><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><pre><code>1. 全适配：流体布局+响应式布局，适配PC端、平板、手机；
2. 移动端适配：流体布局+少量响应式，基于rem的布局，弹性盒模型；
3. 屏幕适配必须设置 &lt;meta name=&quot;viewport&quot; ... /&gt; 才有效；
4. 对于iPhone的设计图的尺寸，如果是2倍图，所有尺寸应该先除以2才是真实的px尺寸。
</code></pre><h3 id="流体布局"><a href="#流体布局" class="headerlink" title="流体布局"></a>流体布局</h3><pre><code>原理：用百分比设置标签的宽度width，比如 width:25%; 而height仍使用实际高度的固定值。
1. 盒子的边线无法用百分比
    1. 使用计算函数 calc() 设置宽度width，比如 2px的border：width:calc(25% - 4px);
    1. calc()中的运算符两边必须保证有一个空格，否则无效；
    2. 使用属性 box-sizing 将盒子设置为从边线计算盒子尺寸。
2. box-sizing
    1. content-box：默认的盒子尺寸计算方式；
    2. border-box：设置盒子的尺寸计算方式为从边框开始，width+border+padding
</code></pre><h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3><pre><code>原理：使用媒体查询的方式，通过查询浏览器窗口的宽度，对不同的宽度应用不同的样式块，
    每个样式块对应的是该宽度下的布局方式，从而实现响应式布局。
1. 实际上就是根据宽度/高度的改变，动态修改CSS样式的属性，以达到适配多种终端屏幕；
2. @media only screen and (max-width: 500px) { .box li{ width:50%; } }
    1. 当屏幕宽度width&lt;=500px时，&lt;li&gt;盒子的宽度设置为父标签宽度的50%；
    2. @media only screen and (min-width: 100px) and (max-width: 640px) { ... }
</code></pre><h3 id="rem布局"><a href="#rem布局" class="headerlink" title="rem布局"></a>rem布局</h3><pre><code>1. em：以标签自身的文字大小font-size为参考，设置该标签的尺寸；
    1. 比如 font-size:20px; 时，width:200px; --&gt; width:10em;
    2. em 单位只对当前的标签有效，对其他标签是无效的。
2. rem：以根节点&lt;html&gt;的文字大小font-size为参照，设置标签的尺寸；
    1. &lt;html style=&quot;font-size: 20px;&quot;&gt;
    2. div{ width:400px; height:200px } --&gt; div{ width:20rem; height:10rem }
    3. rem 单位对整个HTML都有效，在浏览器窗口大小变化时，就可以通过JS获取窗口的大小，
       并重新设置&lt;html&gt;的font-size，从而动态改变每个标签的 width、height、margin、
       padding... 达到适配不同屏幕的效果。
    4. 为了避免影响阅读效果，字体大小font-size仍使用px，部分字体使用响应式布局。
3. 监听页面宽度width的变化，动态修改&lt;html&gt;上的style.font-size属性值：
</code></pre><p><img src="https://i.imgur.com/nmV4fIB.jpg" alt></p>
<pre><code>4. innerWidth、clientWidth：前者是window对象的属性，后者是DOM对象的属性；
    1. innerWidth：窗口的文档显示区(body)的宽度，不支持IE9以下的IE浏览器；
    2. document.documentElement/document.body的clientWidth取代了innerWidth.
</code></pre><h3 id="弹性盒模型布局"><a href="#弹性盒模型布局" class="headerlink" title="弹性盒模型布局"></a>弹性盒模型布局</h3><pre><code>1. 容器属性，比如&lt;ul&gt;&lt;/ul&gt;
    1. display: flex; --&gt; 声明使用弹性盒布局；
    2. flex-direction：子元素的排列方向；
        1. row/row-reverse：子元素水平靠左排列/靠右倒序排列，row是默认属性值；
        2. column/column-reverse：垂直方向排列。
    3. flex-wrap：子元素超过父容器尺寸时是否换行；
        1. nowrap：默认值，不换行，对子元素进行缩放；
        2. wrap/wrap-reverse：换行/换行反向排列；
    4. flex-flow: flex-direction的属性值 | flex-wrap的属性值 --&gt; 同时设置；
    5. justify-content：多个子元素在水平方向上的分布方式；
        1. flex-start/flex-end：子元素整体靠左/右；
        2. center：水平居中；
        3. space-between：第一个/最后一个子元素分别靠左/右顶格，中间的子元素等分间距；
        4. space-around：第一个子元素靠左的间距和最后一个子元素靠右的间距，是中间子元素
        间距的一半，中间的子元素等分间距。
    6. align-items：多个子元素在垂直方向上的分布方式；
        1. flex-start/flex-end：子元素整体靠上/靠下；
        2. center：垂直居中；
        3. baseline：子元素内的文字底部对齐，如果文字大小不一致，子元素底部会对不齐；
        4. stretch：如果子元素不设置高度，其高度会被拉伸到与父容器的高度一致。
    7. align-content：设置多行子元素在行方向上的对其方式；
        1. flex-start/flex-end：每一行的子元素整体靠上/靠下；
        2. center：多行子元素整体居中；
        3. space-between：第一行/最后一行子元素分别靠上/下顶格，中间行元素等分间距；
        4. space-around：第一行子元素到上面的距离和最后一行子元素到下面的距离，是中间
        行元素间距的一半，中间行元素等分间距。
2. 条目属性，比如&lt;li /&gt;
    1. flex-grow：表示当父容器有多余空间时，这些空间在每个子标签之间的分配比例；
        1. 类似于权重，比如flex-grow: 1; --&gt; 如果&lt;li /&gt;是水平排列、且&lt;ul&gt;仍有多余空间，
        则每个&lt;li /&gt;会增大相同比例的宽度，平分&lt;ul&gt;的空间；
        2. 如果某个&lt;li /&gt;的flex-grow: 2; --&gt; 该&lt;li /&gt;的宽度会增长更多；
        3. 只有使用了flex-grow属性的标签才会被分配增长空间。
    2. flex-shrink：表示当父容器的空间不足、且不换行时，各个子标签的尺寸缩小比例；
    3. 父容器的空间不足时，flex-shrink设置缩小比例，此时设置flex-grow是无效的；
    4. flex-basis：设置弹性条目标签的初始尺寸，弹性布局的基数；
        1. flex-grow在平分父容器的多余空间时，增长基数默认是相同的；
        2. flex-basis:20px; --&gt; 设置该标签的增长基数为20px。
    5. align-self：复写父容器设置的对齐方式，即复写父容器的align-items属性；
    6. order：重置标签在父容器中的排列位置，类似于修改数组的角标。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">大麦田怪圈</p>
              <p class="site-description motion-element" itemprop="description">敢做就能赢！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">55</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大麦田怪圈</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
