<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="敢做就能赢！">
<meta property="og:type" content="website">
<meta property="og:title" content="大麦田程序猿">
<meta property="og:url" content="http://hellomyshadow.github.io/page/3/index.html">
<meta property="og:site_name" content="大麦田程序猿">
<meta property="og:description" content="敢做就能赢！">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="大麦田程序猿">
<meta name="twitter:description" content="敢做就能赢！">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hellomyshadow.github.io/page/3/">





  <title>大麦田程序猿</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大麦田程序猿</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2017/07/31/python多任务之线程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/31/python多任务之线程/" itemprop="url">python多任务之线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-31T00:00:00+08:00">
                2017-07-31
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h2><pre><code>1. 程序代码运行起来之后，系统会为其分配内存，占用系统资源，整个环境就是一个进程；
   在一个进程中，代码执行的过程，其实就是一个指针跟着代码的逻辑不断移动，这就是一个线程；
2. 在同一个进程中，程序开始执行时的第一个指针称为主线程，由主线程创建的其他线程称为子线程；
3. 进程是系统进行资源分配和调度的一个独立单位，线程是进程的一个实体，是CPU调度和分派的单位；
4. 一个程序至少有一个进程，一个进程至少有一个线程；
5. 线程的划分尺度小于进程(资源比进程少)，使得多线程程序的并发性高；
6. 进程拥有独立的内存单元，而多线程共享同一块内存，运行效率更高；
7. 线程执行的开销更小，但却不利于资源的管理和保护，而进程则恰恰相反。
</code></pre><h2 id="创建多线程"><a href="#创建多线程" class="headerlink" title="创建多线程"></a>创建多线程</h2><pre><code>Python的 thread 模块是比较底层的、创建多线程的模块，不能兼容不同的操作系统；
threading 模块对 thread 做了封装，兼容性更好；
</code></pre><h3 id="Thread-子线程"><a href="#Thread-子线程" class="headerlink" title="Thread 子线程"></a>Thread 子线程</h3><pre><code>Thread 是threading 模块提供的类，用于创建多线程：from threading import Thread
1. start()：开启线程；
2. Thread(target=None, name=None, args=(), kwargs={})
    target：子线程执行的任务代码；
    name：设置线程的名字；
    args：target 接收的参数，是一个元组；
    kwargs：target 接收的参数，是一个字典。
3. threading.current_thread()：获取当前线程的对象；
4. threading.current_thread().name：获取当前线程的名字；
5. threading.enumerate()：查看当前的线程数量，返回一个列表，元素是线程的对象；
    def test(a):
        print &apos;%s--%s&apos; % (threading.current_thread().name, a)
    t = Thread(target=test, args=(3,))
    t.start()
1. Thread 创建的子线程，主线程会主动等待所有的子线程执行结束，它才会结束；因为子线程也会
   占有一些资源(如程序计数器，一组寄存器和栈)，主线程负责回收子线程结束之后的资源；
2. 虽然主线程会等待子线程，但线程的执行顺序是不确定的，由系统的调度算法决定。
</code></pre><h3 id="继承Thread，创建子线程"><a href="#继承Thread，创建子线程" class="headerlink" title="继承Thread，创建子线程"></a>继承Thread，创建子线程</h3><pre><code>如果没有指定Thread 的形参target，调用start() 开启线程时，就将执行Thread的 run()；
所以，继承Thread、重写 run() 方法，创建对象时不指定target，也能创建一个线程。
    class MyThread(threading.Thread):
        def run(self):
            print &apos;---%s---&apos; % self.name
            time.sleep(1)
    t = MyThread()
    t.start()
1. join()：让主线程主动等待子线程执行结束，或者子线程执行超时之后，再继续执行主线程；
</code></pre><p><img src="https://i.imgur.com/owkUZnq.jpg" alt></p>
<pre><code>2. setDaemon(True/False)：在start()之前设置，默认为False，表示前台线程；
    1. setDaemon(True)：设置为后台线程，在主线程执行过程中，后台线程也执行，一旦主线程
    执行完毕，后台线程不论是否执行结束，主线程和后台线程均停止，程序执行结束；
    2. setDaemon(False)：主线程执行完毕后，会等待前台线程也执行完毕。
</code></pre><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><pre><code>1. 进程的内存资源都是独立的，所以进程之间不共享数据；
2. 多线程是在同一个进程中，共享内存资源，但线程的执行顺序是不确定的，访问同一个数据时，
   可能对数据造成破坏，这种现象称为线程不安全。
</code></pre><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><pre><code>mutex = threading.Lock()：创建锁；
mutex.acquire([blocking=True, timeout=-1])：锁定；上锁失败返回False；
    blocking：默认为True，如果已经有其他线程上锁，当前线程会阻塞，直到获取到锁为止；
        如果设置为False，则当前线程不会阻塞，若没有第一时间获取锁，acquire() 返回False；
    timeout：设置当前线程阻塞的超时时间，等待了timeout秒，仍然没有机会上锁，则返回False。
mutex.release()：释放锁；
</code></pre><p><img src="http://i.imgur.com/fRnPk4m.jpg" alt></p>
<pre><code>互斥锁只能约束使用了锁的线程，没有使用lock.acquire()上锁的线程抢到执行权时，仍然会继续执行。
</code></pre><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><pre><code>嵌套锁可能造成死锁；
</code></pre><p><img src="http://i.imgur.com/TMCosYX.png" alt></p>
<pre><code>线程t1 先上锁A，等待锁A 被释放；线程t2 先上锁B，等待锁A 被释放，从而造成死锁；
解决死锁的方式：
    1. 银行家算法，避免死锁；
    2. 设置acquire() 的超时时间timeout。
</code></pre><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><pre><code>线程之间的执行顺序是不确定的；
同一个线程不能重复上同一把锁，必须等锁被释放之后，才能重新上锁，否则就会阻塞。
依此原理，可以实现线程同步：
</code></pre><p><img src="http://i.imgur.com/rORO8zV.jpg" alt></p>
<pre><code>通过锁的锁定和解锁，实现线程同步:Task1 --&gt; Task2 --&gt; Task3 --&gt; Task1 --...
</code></pre><h2 id="生产者与消费者模式"><a href="#生产者与消费者模式" class="headerlink" title="生产者与消费者模式"></a>生产者与消费者模式</h2><pre><code>进程和线程的执行顺序都是不确定的，造成数据生产方与数据处理方的速度也往往是不匹配的；
此时需要使用数据缓冲，以匹配生产者和消费者的速度；
列表作为数据缓冲池并不安全，队列是阻塞的，可以作为数据缓冲池，实现线程同步；
Queue：队列，FIFO，first in first out，先进先出；
Stack：栈，FILO，first in last out，先进后出。
</code></pre><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><pre><code>python2的导入队列方式：from Queue import Queue
puthon3的导入队列方式：from queue import Queue
队列是阻塞的，恰好为生产者和消费者解耦。
线程中的队列与进程中的队列，所属模块不同，但在使用方法上是一样的；
</code></pre><p><img src="http://i.imgur.com/hCS5uaV.jpg" alt></p>
<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><pre><code>ThreadLocal 是一个对象，用于记录不同的线程所执行的操作；
threading.local()：创建ThreadLocal对象；
</code></pre><p><img src="http://i.imgur.com/CWPl5gJ.jpg" alt></p>
<pre><code>  ThreadLocal虽然是一个全局变量，但它可以记录每个线程所设置的属性值，线程之间互不干扰，
每个线程都有自己的独立副本，不会被其他线程修改；
  ThreadLocal解决了参数在每个线程中各个函数之间互相传递的问题。
</code></pre><h2 id="GIL"><a href="#GIL" class="headerlink" title="GIL"></a>GIL</h2><pre><code>GIL：全局解释器锁；
Python的多线程其实是伪多线程；
    假设有两个线程，双核CPU，理论上应该是两个CPU同时执行两个线程，但python并不是；
在同一时刻，只有一个线程被执行，由GIL控制线程的切换；当一个线程被CPU执行时，GIL会对线
程加锁，阻止另一个CPU执行其他线程；也即，Python中的多线程是伪多线程。
在Python中处理多任务，对于多核CPU，多进程的效率要远远大于多线程。
解决伪多线程的方式：
1. 尽量用多进程取代多线程；
2. 关键代码用C语言实现：
    from ctypes import * ：导入能执行C语言代码的模块；
    cdll.LoadLibrary()：加载C语言写的动态库，返回一个对象，通过该对象调用库中的功能；
</code></pre><p><img src="http://i.imgur.com/oY7EClN.jpg" alt></p>
<pre><code>在使用C语言代码的文件(.c后缀)之前，通常都需要先编译，生成库文件(.os后缀)；
对于编译方式，在提供C代码文件时，还会提供一个readme文件，其中会说明编译的环境和方式；
</code></pre><p><img src="http://i.imgur.com/gQVO772.jpg" alt></p>
<pre><code>Python多线程虽然不能实现多核任务，但多进程可以实现，每个进程有各自独立的GIL锁，互不影响。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2017/07/30/python多任务之进程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/30/python多任务之进程/" itemprop="url">python多任务之进程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-30T00:00:00+08:00">
                2017-07-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="子进程"><a href="#子进程" class="headerlink" title="子进程"></a>子进程</h2><pre><code>程序运行起来之后，就是一个进程，称为主(父)进程；
在主进程中新创建的进程，称为子进程；
操作系统根据调度算法决定要运行的进程，父子进程的先后顺序是不确定的。
</code></pre><h3 id="fork-创建子进程"><a href="#fork-创建子进程" class="headerlink" title="fork 创建子进程"></a>fork 创建子进程</h3><pre><code>import os
os.getpid()：获取当前进程的PID；PID是进程ID号，类似于身份证号；
os.getppid()：获取父进程的PID；
os.fork()：创建一个子进程；子进程的返回值为 0，主进程的返回值是大于 0 的；
        主进程的返回值其实就是子进程的PID，形成父子进程的映射关系；
</code></pre><p><img src="http://i.imgur.com/PGTUiNO.jpg" alt></p>
<pre><code>fork的子进程是独立执行的，并不会随着主进程的结束而结束；
子进程运行起来之后，其实是两块内存中执行两份代码，全局变量是不能共享的，也即进程之间不能直接
共享数据。
</code></pre><h4 id="fork-多个子进程"><a href="#fork-多个子进程" class="headerlink" title="fork 多个子进程"></a>fork 多个子进程</h4><pre><code>主进程创建子进程A，进程A 创建子进程B，那么对于进程B，进程A就是父进制；
也即，对于创建进程B 的fork()，进程B 返回值是 0，进程A 的返回值大于 0；
</code></pre><p><img src="http://i.imgur.com/CrxmdyQ.jpg" alt></p>
<pre><code>fork炸弹：
        while True: os.fork()
</code></pre><h3 id="Process-创建子进程"><a href="#Process-创建子进程" class="headerlink" title="Process 创建子进程"></a>Process 创建子进程</h3><pre><code>Python 是跨平台的语言，但 fork() 适用于ubuntu、Mac等，在windows上却没有 fock() 的调用；
为此，Python提供了一个跨平台的多进程支持模块：multiprocessing；
from multiprocessing import Process:导入 Process 类；
start()：开启进程；
</code></pre><p><img src="http://i.imgur.com/4eJzfOE.jpg" alt></p>
<pre><code>与fork()不同，Process的所有子进程执行结束之后，主进程才会结束；

1. Process()的常见参数：
    Process(target=None, name=None, args=(), kwargs={})
            target：指定进程执行的代码任务；
            name：为当前进程设置别名；
            args：所调用对象需要的参数，是一个元组；
            kwargs：所调用对象需要的参数，是一个字典。
</code></pre><p><img src="http://i.imgur.com/7pdzK0I.jpg" alt></p>
<pre><code>2. Process 的常用属性和方法：
    1. name：获取当前进程的名字；
    2. pid：同 os.getpid()；
    3. is_alive()：判断进程是否还在执行；
    4. join()：等待进程执行结束，再继续向下执行；    join(seconds)：等待一段时间(秒)；
    5. terminate()：杀死进程。
</code></pre><h4 id="僵尸进程与孤儿进程"><a href="#僵尸进程与孤儿进程" class="headerlink" title="僵尸进程与孤儿进程"></a>僵尸进程与孤儿进程</h4><pre><code>Process创建的子进程时，主进程会等待子进程执行结束，主进程再结束，是为了子进程结束之后，
让主进程回收子进程的资源；
如果子进程结束了，但主进程没有回收子进程的资源，这样的主进程称为僵尸进程；
如果子进程结束之前，主进程先结束了，这样的子进程称为孤儿进程；
在Linux运行起来时，会有一个PID为1的进程，系统中所有的子进程都是1号进程直接或间接创建的，
孤儿进程结束之后的资源回收，也是由1号进程完成的。
</code></pre><h4 id="继承Process，创建子进程"><a href="#继承Process，创建子进程" class="headerlink" title="继承Process，创建子进程"></a>继承Process，创建子进程</h4><pre><code>如果没有指定Process 的形参target，调用start() 开启进程时，就将执行 run()；
所以，继承Process、重写 run() 方法，创建对象时不指定target，也能创建一个进程。
</code></pre><p><img src="http://i.imgur.com/DwJCh0V.jpg" alt></p>
<pre><code>如果重写了Process 的 __init__() 方法，必须在子类的 init 方法中先执行 Process.__init__()
完成Process 的初始化，否则Process的一些功能无法正常使用。
</code></pre><h3 id="进程池Pool"><a href="#进程池Pool" class="headerlink" title="进程池Pool"></a>进程池Pool</h3><pre><code>进程池：先创建一定数量的子进程等待使用，使用完之后再重新归还进程池，增加重复使用；
Pool 也是属于 multiprocessing 的类，可以跨平台使用。
import multiprocessing import Pool：导入进程池类 Pool；
p = Pool(max)：创建一个进程池，包含max个进程；如果请求的任务个数大于max，进程池会分批完成；
Pool 的常用方法：
    apply_async(func, [args, kwargs, callback=None, error_callback=None])：
                非阻塞的方式执行进程任务func，即max个进程并行执行；
                func：进程执行的任务，args：参数元组，kwargs：参数字典；
                callback：异步回掉；
                error_callback：进程挂掉的回调。
    apply(func, [args, kwargs])：阻塞的方式执行，即每次只能执行一个进程；
    close()：关闭Pool，不再接受新的任务；
    join()：等待进程池中的进程完成任务，必须在 close()/terminate() 之后使用；
    terminate()：立即终止进程，不管任务是否完成。
</code></pre><p><img src="http://i.imgur.com/1kjwDsy.jpg" alt></p>
<pre><code>主进程不会等待Pool中的进程完成任务，主进程一旦执行结束，Pool也就随之结束；
1. 使用 join()，让主进程等待Pool 中的进程完成任务；
2. 在主进程中使用循环语句，不让主进程结束。
</code></pre><h4 id="异步回掉"><a href="#异步回掉" class="headerlink" title="异步回掉"></a>异步回掉</h4><pre><code>apply_async() 的可选参数 callback 用于异步回掉，回掉的代码是由主进程执行的；
callback 会接收子进程执行结束之后，即 func执行结束之后的返回值，没有return，表示返回None；
</code></pre><p><img src="http://i.imgur.com/hHS1aDu.jpg" alt></p>
<h2 id="进程间的通信"><a href="#进程间的通信" class="headerlink" title="进程间的通信"></a>进程间的通信</h2><pre><code>进程之间是没有任何关联的，不能直接共享数据，
</code></pre><h3 id="Process-进程间的通信"><a href="#Process-进程间的通信" class="headerlink" title="Process 进程间的通信"></a>Process 进程间的通信</h3><pre><code>Queue：队列，先进先出；multiprocessing 模块提供的类，用于支持进程间的通信；
Queue本身是一个消息队列程序；
import multiprocessing import Queue：导入队列；
q = Queue(max)：创建一个队列，可以接收max条消息，也可以指定max；
1. 向队列中写入消息
    put(msg, [block, timeout])：将消息存入队列，msg 可以是任意类型，包括对象；
                block，time：可选参数，block默认为true，表示队列没有空间时，程序会被阻塞，
                            停在写入状态，直到队列腾出空间为止；
                            如果设置了超时时间timeout，则会等待timeout秒，若还没有空间，
                            则抛出异常；
                            block设置为false时，消息队列一旦没有空间，则会立刻抛出异常。
    put_nowait(msg)：相当于 put(msg, False)。
2. 从队列中读取消息
    get([block, timeout])：从队列中取出一条消息，该消息将从队列中移除，先进先出的原则；
            block，timeout：可选参数，block默认为true，表示队列没有空间时，程序会被阻塞，
                            停在读取状态，直到读到消息为止；
                            如果设置了超时时间timeout，则会等待timeout秒，若队列中还没有
                            消息可读取，则抛出异常；
                            block设置为false时，消息队列一旦为空，则会立刻抛出异常。
    get_nowait()：相当于 get(False)。
3. full()：判断消息队列是否已经满了；
4. empty()：判断消息队列是否为空；
5. qsize()：获取当前队列的消息数量；
</code></pre><p><img src="http://i.imgur.com/p2CZx34.jpg" alt></p>
<h3 id="Pool-进程间的通信"><a href="#Pool-进程间的通信" class="headerlink" title="Pool 进程间的通信"></a>Pool 进程间的通信</h3><pre><code>Pool进程间通信，使用的是 multiprocessing 模块提供的 Manager 类，Manager类 中提供了 Queue；
import multiprocessing import Manager：导入 Manager；
q = Manager().Queue(max)：创建消息队列；操作队列的方法与Process使用的 Queue 相同。

拷贝一个目录(目录中不包括文件夹)：
</code></pre><p><img src="http://i.imgur.com/lllkukn.jpg" alt></p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2017/07/29/python高级2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/29/python高级2/" itemprop="url">python高级2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-29T00:00:00+08:00">
                2017-07-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="生成器：generator"><a href="#生成器：generator" class="headerlink" title="生成器：generator"></a>生成器：generator</h2><pre><code>生成器：保存一种算法，它并不会立刻创建所有的元素，而是在需要某个元素时再生成，节约内存；
1. 创建生成器的方式1：
    创建一个偶数生成器generator：g = (x*2 for x in range(10))
    next(g)：每次生成一个元素，所有元素生成之后再调用next(g)，会报StopIteration；
2. 创建生成器的方式2：yield
    带有 yield 关键字的函数，就是生成器，返回一个对象g，next(g)生成元素；
    1. next(g)执行一次，程序执行到 yield 会终止，并返回 yield 的值；
    2. 下次执行 next(g)，会从上次终止的地方开始执行，遇到 yield 终止；
</code></pre><p><img src="http://i.imgur.com/GjADhWZ.png" alt></p>
<pre><code>for temp in generator：可以直接迭代一个生成器，temp是每次 yield 返回的值；
next(g) 等价于 g.__next__()；
3. send()：也是用于生成元素；
    yield 语句赋值给一个变量，该变量并不能获得 yield 返回的值，变量值仍为 None；
    与next()不同，send(data)的参数值可以直接赋值给 yield 所赋值的变量；
</code></pre><p><img src="http://i.imgur.com/gqV0AYt.png" alt></p>
<pre><code>在执行 send() 之前，必须先执行一次next()；
如果强制第一次就执行 send()，必须设置参数为 None：send(None)，temp的值为None；
4. 生成器完成多任务：协程，多任务的一种
</code></pre><p><img src="http://i.imgur.com/Bh2H8AJ.png" alt></p>
<pre><code>因为CPU运行很快，看起来任务1和任务2在同时执行。
5. 集合数据类型(list、tuple、dict、set、str)和生成器generator，都可以作用于for循环，
    这些对象统称为可迭代对象：Iterable
    1. 判断一个对象是否是Iterable：from collections import Iterable
    2. isinstance(x, Iterable)：True/False
</code></pre><h2 id="迭代器：iterator"><a href="#迭代器：iterator" class="headerlink" title="迭代器：iterator"></a>迭代器：iterator</h2><pre><code>字符串、列表、字典、元组、集合、生成器都是可迭代的对象，但只有生成器才是迭代器；
1. 可以被next()函数调用并不断返回下一个值的对象，统称为迭代器；
    1. 判断是不是迭代器：from collections import Iterator
    2. isinstance(g, Iterator)：True/False
2. iter(iterable)：可以把字符串、列表等Iterable转为Iterator
3. Python的Iterator是一个数据流，可以理解为一个有序序列，但并不能提前获取序列长度，
只能通过next()实现按需计算下一个数据，也即Iterator的计算是惰性的；Iterator甚至可以
表示一个无限大的数据流，如全体自然数，而list是不可能存储所有自然数的。
</code></pre><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><pre><code>变量名是对数据的引用，同理，函数名(变量)是对函数体的引用；
定义函数，其实是在内存中创建函数体，再让函数名(变量)指向函数体；
Python中定义同名的函数，其实是改变函数名(变量)的指向，并不会报错；
lambda 表达式定义的小型匿名函数，test = lambda x, y:x+y，相当于 test(x, y) 函数；
</code></pre><p><img src="http://i.imgur.com/WonhjIG.png" alt></p>
<pre><code>闭包：在函数内再定义一个函数，并且该函数用到了外函数的变量；
一个完整的闭包是，外函数的返回值是内函数的函数名；
模拟 y = ax + b
</code></pre><p><img src="http://i.imgur.com/UIQfW0G.png" alt></p>
<pre><code>1. line = test(1, 1)：虽然外函数执行完毕，但因为 line 指向内函数，而内函数又使用了
   外函数的变量，所以外函数并没有被销毁；
2. 如果再创建一条直线 line2 = test(10, 4)，python会在内存中再创建一份外函数和内函数，
   而不会销毁上次创建的函数；
3. 闭包最大的作用：保存局部变量，避免被全局变量污染。
</code></pre><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><pre><code>装饰器可以提高开发的效率；
写代码遵循 开放-封闭 的原则，规定已经实现的功能代码不允许被修改，但可以扩展开发；
</code></pre><h3 id="装饰器的原理"><a href="#装饰器的原理" class="headerlink" title="装饰器的原理"></a>装饰器的原理</h3><pre><code>场景1：部门A负责功能代码的实现，部门B调用部门A提供的接口(函数)；
    现需要对原有函数加验证，否则不允许调用，但是又不能影响部门B的调用方式；
</code></pre><p><img src="http://i.imgur.com/Zib2HKJ.png" alt></p>
<h3 id="装饰器的实现"><a href="#装饰器的实现" class="headerlink" title="装饰器的实现"></a>装饰器的实现</h3><pre><code>@...：装饰标识，在函数的上面声明；
</code></pre><p><img src="http://i.imgur.com/p5AIWZ4.png" alt></p>
<h3 id="装饰器的执行时间"><a href="#装饰器的执行时间" class="headerlink" title="装饰器的执行时间"></a>装饰器的执行时间</h3><pre><code>python编译器只要执行了@...，就已经开始执行装饰了，而不是在调用时才开始装饰；
</code></pre><p><img src="http://i.imgur.com/oVeDKhZ.png" alt></p>
<h3 id="多个装饰器"><a href="#多个装饰器" class="headerlink" title="多个装饰器"></a>多个装饰器</h3><p><img src="http://i.imgur.com/5n0b2xJ.png" alt></p>
<pre><code>1. python编译器执行到 @makeBold 时，并没有加载装饰器makeBold，因为它下面是一个装饰器，
    而不是被装饰的函数，所以python会优先加载内装饰器makeItalic，然后再加载外装饰器;
    加载过程：
        --&gt; 加载内装饰器makeItalic --&gt; makeItalic(fn) 的fn 接收被装饰的函数test, 
    即 fn 与 test 指向同一个函数体 --&gt; return 内函数 ，返回值是用被装饰的函数test
    接收的，即 test 的指向被改变 --&gt; test 指向 makeItalic 的内函数wrapped ------
    --&gt; 再加载外装饰器makeBold --&gt; makeBold(fn) 的fn 接收被装饰的函数test，此时的
    test 的指向已经改变了,即 fn 与 test 指向内装饰器makeItalic 的内函数wrapped ---
    --&gt; return 内函数，返回值也是用 test 接收的，即test 的指向再次被改变 ----------
    --&gt; test 指向 makeBold 的内函数wrapped --&gt; 加载完成；
2. 最后调用 test() 时，test 指向外装饰器makeBold 的内函数 --&gt; 执行 makeBold-wrapped
    --&gt; makeBold-wrapped 内部调用的 fn 又指向内装饰器makeItalic 的内函数 --&gt; 执行
    makeItalic-wrapped --&gt; makeItalic-wrapped 内部调用的 fn 又指向原test 的函数体
    --&gt; 执行原test 函数 --&gt; 执行完毕。
3. 装饰器的加载是由外而内，但数据的装饰是由内而外的。
</code></pre><h3 id="有参数函数的装饰"><a href="#有参数函数的装饰" class="headerlink" title="有参数函数的装饰"></a>有参数函数的装饰</h3><pre><code>1. 固定参数
    被装饰函数的指向链上的每一个函数，都保持与被装饰函数的参数一致；
</code></pre><p><img src="http://i.imgur.com/F1Fs3U3.jpg" alt></p>
<pre><code>    被装饰函数test(a, b) 的指向链：test --&gt; wrapBold(fn) --&gt; wrapItalic(fn)
2. 不定长参数
    不定长参数使用 *args和 **kwargs，args 将参数保存为元组，kwargs 将参数保存为字典，
    所以，在指向链上的参数传递过程中，必须要拆包传递；
</code></pre><p><img src="http://i.imgur.com/53vv2WC.jpg" alt></p>
<h3 id="有返回值函数的装饰"><a href="#有返回值函数的装饰" class="headerlink" title="有返回值函数的装饰"></a>有返回值函数的装饰</h3><pre><code>在执行被装饰函数时，其函数名的指向已经发生了改变，所以在指向链上的每个函数，必须返回
被装饰后的结果；
</code></pre><p><img src="http://i.imgur.com/LIwWQqX.jpg" alt></p>
<h3 id="通用装饰器"><a href="#通用装饰器" class="headerlink" title="通用装饰器"></a>通用装饰器</h3><pre><code>通用的装饰器，也即是使用不定长参数、并带有 return 的装饰器；
</code></pre><p><img src="http://i.imgur.com/bzn18Mf.jpg" alt></p>
<h3 id="带有参数的装饰器"><a href="#带有参数的装饰器" class="headerlink" title="带有参数的装饰器"></a>带有参数的装饰器</h3><pre><code>如果装饰器需要参数，就要在原装饰器的外面再定义一个函数，组成一个新的装饰器；
最外层的函数用于接收参数，其返回值是原装饰器的函数名；
</code></pre><p><img src="http://i.imgur.com/o6jJfrI.jpg" alt></p>
<pre><code>1. python编译器执行到 @makeBold_arg(&quot;Hello&quot;)，时，会执行函数 makeBold_arg(arg)，
并返回原装饰器makeBold 的函数名，也即是 @makeBold，然后加载原装饰器，装饰test 函数。
2. 带参数的作用
    内函数可以使用外函数的变量，所以，原装饰器可以根据外部传入的参数，执行不同的操作。
</code></pre><h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><pre><code>类装饰器，是用一个类装饰函数；
__call__(self)：重写了该方法，可以像调用函数的方式调用对象，执行的就是该方法；
</code></pre><p><img src="http://i.imgur.com/kx07k5r.jpg" alt></p>
<pre><code>@类名：类装饰器装饰函数的形式
</code></pre><p><img src="http://i.imgur.com/P3mW6ta.jpg" alt></p>
<pre><code>形参func.__name__：获取传入实参的函数名；
加载过程：
    ---&gt;执行 @Decorator 时，开始加载装饰器 --&gt; 初始化对象，被装饰函数test 作为实参，
--&gt; func 与 test 指向同一个函数体 --&gt; self.__func = func，即 self.func 与 func
指向同一个函数体 --&gt; 初始化完成，返回值是对象的引用，被装饰函数test 接收，即 test 的
指向被改变 --&gt; test = Decorator(test)；
最后执行 test() 时，test 指向类对象，因为类对象重写了 __call__()，所以其实执行的是
__call__ 方法 --&gt; self.__func 指向原test 的函数体，self.__func() 执行的是被装饰
函数 --&gt; 执行完毕。
</code></pre><h2 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h2><pre><code>1. 类也是对象
  如果类中有执行语句，python解释器加载类的过程，也是执行类的过程，类中的执行语句会被执行
</code></pre><p><img src="http://i.imgur.com/5noUzSI.jpg" alt></p>
<pre><code>2. 类可以动态创建
  可以用函数动态创建类，返回值是类名，也即在调用函数的过程中，动态创建类，甚至根据不同的
条件，创建不同的类。
</code></pre><p><img src="http://i.imgur.com/OC4QU9x.jpg" alt></p>
<pre><code>  但是，类在开发中属于一等公民，通常不会放在其他作用域中去创建。
3. 创建类的另一种方式：type()
  type() 可以查看一个数据的类型，也可以动态创建一个类；
类型实际上也是一个类，比如，100 是 int 类型，100 其实是 int 创建的对象。
type() 之所以会根据传入参数的不同、实现两种完全不同的功能，python 是为了兼容其他的版本。
type(className, tuple, dict)：
    className：创建的类名，是一个字符串；
    tuple：由父类名组成的元组，如果没有继承，元组为空；
    dict：包含属性的字典，key 必须是字符串；
实例对象是由类创建的，类也是对象，类是由 type() 创建的，type() 就是元类；
    1. 创建一个空类Test：Test = type(&quot;Test&quot;, (), {})；
    2. 创建一个带有属性的类：Test = type(&quot;Test&quot;, (), {&quot;num&quot;:20})； num 是类属性；
    3. 创建一个带有实例方法、类方法、静态方法的类：
</code></pre><p><img src="http://i.imgur.com/oU9WiQq.jpg" alt></p>
<pre><code>type(x) 与 x.__class__ 都可以查看数据的类型
    p.__class__： __main__.Person
        表示对象p 是当前模块中的类Person 创建的，__main__表示当前模块中；
    Person.__class__：type，表示类Person 是元类type 创建的。
</code></pre><h3 id="metaclass-属性"><a href="#metaclass-属性" class="headerlink" title="__metaclass__ 属性"></a>__metaclass__ 属性</h3><pre><code>__metaclass__ 属性用于决定在class 定义一个类时，谁创建这个类；也即，其属性值就是元类；
class 定义一个类时，python解释器 __metaclass__ 属性的过程：
    当前类中 --&gt; 父类中 --&gt; 内建模块中 --&gt; 使用python系统默认的 __metaclass__；
__metaclass__ 属性的使用：
</code></pre><p><img src="http://i.imgur.com/YptTQqH.jpg" alt></p>
<h2 id="gc：垃圾回收"><a href="#gc：垃圾回收" class="headerlink" title="gc：垃圾回收"></a>gc：垃圾回收</h2><pre><code>python 的 gc 采用引用计数机制为主、隔(分)代回收机制为辅的策略；
Python及时清理内存，保证了程序运行的效率。
</code></pre><h3 id="小整数对象池-常量池"><a href="#小整数对象池-常量池" class="headerlink" title="小整数对象池(常量池)"></a>小整数对象池(常量池)</h3><pre><code>Python定义的小整数：[-5, 256]，这些整数对象是提前创建好的，不会被gc，常驻内存；
重复创建小整数，使用的都是小整数对象池的整数：a=10，b=10，a和b的地址相同，a is b：True；
同理，字母也是这样的：a=&apos;a&apos;，b=&apos;a&apos;，a和b的地址也是相同的；

疑惑部分：
    在.py文件中，只要是数值，不管整数和浮点数，地址都是相同的；字符串的地址也是相同；
数值和字符串都是不可变类型，但不可变类型中的元组却不一样。
</code></pre><h3 id="intern-机制"><a href="#intern-机制" class="headerlink" title="intern 机制"></a>intern 机制</h3><pre><code>字符串是不可变类型，对于纯字母组成的字符串，Python会开启 intern 机制，共享的该字符串；
a=&quot;helloworld&quot;，b=&quot;helloworld&quot;，a和b的地址是一样的；
当 &quot;helloworld&quot; 的引用计数为 0 时，就会触发gc。
</code></pre><h3 id="引用计数机制"><a href="#引用计数机制" class="headerlink" title="引用计数机制"></a>引用计数机制</h3><pre><code>python的底层是C语言，CPython是C语言编写的Python解释器；
gc 的引用计数机制的核心就是一个结构体：pyObject
</code></pre><p><img src="http://i.imgur.com/Lm945XP.jpg" alt></p>
<pre><code>引用计数为 0 时，就会触发 gc；
查看一个对象的引用个数：import sys --&gt; sys.getrefcount(x)
因为sys.getrefcount(x) 用形参接收对象的引用，所以返回的引用计数会比实际的引用计数多1个。
</code></pre><h4 id="引用计数-1"><a href="#引用计数-1" class="headerlink" title="引用计数 +1"></a>引用计数 +1</h4><pre><code>1. 对象被创建：a = 10，引用计数+1
2. 对象被引用：b = a，引用计数+1
3. 对象被作为函数的参数：func(a)，引用计数+1
4. 对象作为一个元素存入容器：list = [10, a]，引用计数+1
</code></pre><h4 id="引用计数-1-1"><a href="#引用计数-1-1" class="headerlink" title="引用计数 -1"></a>引用计数 -1</h4><pre><code>1. del a
2. 改变引用的指向：a = 20，a = None
3. 离开其作用域，比如函数func执行结束，形参会被释放，引用计数-1
4. 所在容器被销毁，或容器主动删除该对象元素，引用计数-1
</code></pre><h3 id="隔-分-代回收"><a href="#隔-分-代回收" class="headerlink" title="隔(分)代回收"></a>隔(分)代回收</h3><pre><code>引用计数机制只能解决大部分垃圾回收，对于循环引用，引用计数始终不为0，也就无法触发gc；
隔代回收机制可以解决循环引用的问题：
    创建一个类对象或其他数据之后，python会使用一种不同的链表进行持续追踪，python内部的
C代码将其称为零代Zero；
    当达到某种程度时，零代链表会检测循环引用，对于存在循环引用的对象，Python会将其引用计
数减1，并清理引用计数为0的对象，而没有被清理的对象会用另一条链表进行追踪，称为一代One；
    当达到某种程度时，一代链表也会检测循环引用，对存在循环引用的对象，将其引用计数减1，
并清理引用计数为0的对象，引用计数不为0的对象会再用一条链表进行追踪，称为二代Two；
这就是Python的隔代回收机制。
</code></pre><h3 id="gc-模块"><a href="#gc-模块" class="headerlink" title="gc 模块"></a>gc 模块</h3><pre><code>gc 是Python提供的一个模块，import gc 导入模块；
Python 的 gc 默认是开启的；
gc.isenable()：判断gc 是否开启，返回值为True 时，表示gc 是开启状态；
gc.disable()：关闭gc；
gc.enable()：开启gc；
gc.collect()：手动立即执行垃圾回收；
gc.garbage：获取清理的详细信息；
gc.get_threshold()：返回一个元组(700, 10, 10)，元组的元素值表示隔代回收触发的条件；
    700：表示已创建的对象减去已回收的对象，差值大于700时，就会触发清理零代链表；
    10：表示每清理10次零代链表，就触发清理1次一代链表，同时再清理1次零代链表；
    10：表示每清理10次一代链表，就触发清理1次而代链表，同时再清理1次一代和零代链表；
gc.set_threshold(x1, x2, x3)：可以设置触发的频率；
gc.get_count()：返回一个元组，包含3个元素，获取当前自动执行gc 的计数器；
    元素1：已创建对象与已回收对象的差值，每次触发清理零代链表，其差值就会锐减；
    元素2：清理一代链表的次数；
    元素3：清理二代链表的次数。
另外，类的 __del__(self) 方法，其实是用于清理这个类及其对象占用的内存，如果重写了 del
方法，但是没有调用其父类的 del 方法清理内存，__del__ 方法就失去了清理类及其对象的功能，
即使手动执行gc，也是无效的；
所以，如果重写了 __del__(self) 方法，就必须调用父类的 __del__ 方法，完成内存的释放。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2017/07/28/python高级1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/28/python高级1/" itemprop="url">python高级1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-28T00:00:00+08:00">
                2017-07-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><h3 id="pdb-调试"><a href="#pdb-调试" class="headerlink" title="pdb 调试"></a>pdb 调试</h3><pre><code>pdb 是基于命令行的调试工具，有三种启动方式；
</code></pre><h4 id="执行时调试"><a href="#执行时调试" class="headerlink" title="执行时调试"></a>执行时调试</h4><pre><code>python/python3 -m pdb x.py
进入pdb调试：
    l：查看当前程序执行到了哪一步；
    n：单步执行，控制程序向下执行一步；
    c：一次性执行完毕，重新回到第一步；
    b 行号：加断点，l 会显示行号，c 会一次性执行到断点处；
    b：显示所有断点，会显示断点的序号；
    cl/clear 序号：删除某个断点；
    s：如果当前行执行的是函数，会跳转到函数内部执行；
    p 形参：查看当前传递的实参值，p 也可以查看当前变量的值；
    a：查看当前函数所有的形参值；
    r：快速执行完函数；
    q：退出调试。
</code></pre><h4 id="交互调试"><a href="#交互调试" class="headerlink" title="交互调试"></a>交互调试</h4><pre><code>在交互模式下进行调试，先导入pdb模块：import pdb
调试函数test(args)：pdb.run(&quot;test(实参)&quot;)，进入pdb调试，s 命令进入函数内部开始执行。
</code></pre><h4 id="程序里埋点"><a href="#程序里埋点" class="headerlink" title="程序里埋点"></a>程序里埋点</h4><pre><code>在代码中，导入pdb模块：import pdb
当执行到 pdb.set_trace() 时，进入pdb调试模式。
</code></pre><h3 id="日志调试"><a href="#日志调试" class="headerlink" title="日志调试"></a>日志调试</h3><pre><code>print() 打印日志；
不允许服务器停止，通过分析日志查找Bug，使用热修复(程序未停止的前提下打补丁)的方式解决。
</code></pre><h2 id="进制的转换"><a href="#进制的转换" class="headerlink" title="进制的转换"></a>进制的转换</h2><pre><code>字节的最高位是符号位，0表示正数，1表示负数。
</code></pre><h3 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h3><pre><code>正数：原码 = 反码 = 补码
负数：反码 = 符号位不变，其他位取反；补码 = 反码+1；负数在内存中按补码存储。
负数参与的运算，用的是补码；如果运算的结果是负数，也是补码形式。
</code></pre><h3 id="十进制与二-八-十六进制间的转换"><a href="#十进制与二-八-十六进制间的转换" class="headerlink" title="十进制与二/八/十六进制间的转换"></a>十进制与二/八/十六进制间的转换</h3><pre><code>bin(x)：将x转为二进制，二进制数的开头是 0b；
oct(x)：将x转为八进制，八进制数的开头是 0o；
hex(x)：将x转为十六进制，十六进制数的开头是0x；
int(x, 2/8/16)：二/八/十六进制数(字符串形式)转十进制；
</code></pre><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><pre><code>1. 位运算：一个数值按照比特位进行的运算；位运算的效率最高，而且节约内存。
    比如，十进制5，对应的二进制为0000 0101，5&lt;&lt;1：5左移1位为00001010，
    对应十进制为10，是5的两倍，比直接使用乘法5*2的效率要高，
    因为计算机底层的乘除运算，其实就是按位左移/右移，再做加减运算。
2. 低4位对应的十进制是8-4-2-1：1000--&gt;8，0100--&gt;4，0010--&gt;2，0001--&gt;1；
3. &amp;：按位与； |：按位或； ^：按位异或，不同为1，相同为0； ~：按位取反；
    比如 ~9，二进制00001001，取反：11110110，负数在内存中以补码形式存储的，
    所以取反后的11110110是补码形式，反码：11110101，原码：10001010，
    二进制10001010，对应十进制-10，即~9的值为-10。
4. &lt;&lt;：按位左移； &gt;&gt;：按位右移。
</code></pre><h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><pre><code>只复制变量指向的地址，而没有在内存中重新创建数据；
a=[2, 3, 4]，b=a --&gt; 浅拷贝
b 和 a指向同一个地址，“[2, 3, 4]” 在内存中只有一份。
</code></pre><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><pre><code>import copy
b=copy.deepcopy(a) --&gt; 深拷贝
b 和 a 指向不同的地址，a 修改列表数据，b 列表不会受到影响。

注意：深拷贝只对可变类型有效；对数值、字符串、元组都无效。
</code></pre><h4 id="deepcopy-与-copy"><a href="#deepcopy-与-copy" class="headerlink" title="deepcopy 与 copy"></a>deepcopy 与 copy</h4><pre><code>1. deepcopy
    a=[1, 2, 3]，b=[5, 6, 7]
    c=[a, b] --&gt; [[1, 2, 3], [4, 5, 6]]； m=(a, b) --&gt; ([1, 2, 3], [4, 5, 6])
        修改列表a/b的数据，列表c 和元组m 中的元素都会变化；
    d=copy.deepcopy(c)； n=copy.deepcopy(m)
        深拷贝会递归拷贝，不仅拷贝列表c/元组m的数据，也会拷贝列表a和b的数据。
2. copy
    与deepcopy不同的是，copy() 是单层拷贝，不会递归拷贝；
    但是，如果拷贝的是元组m=(a, b)，copy() 不会拷贝； t=copy.copy(m) 等效于 t=m；
    也即，copy() 会判断拷贝的数据是可变类型，还是不可变类型；copy() 不会拷贝不可变类型。
</code></pre><h2 id="模块进阶"><a href="#模块进阶" class="headerlink" title="模块进阶"></a>模块进阶</h2><h3 id="模块导入问题"><a href="#模块导入问题" class="headerlink" title="模块导入问题"></a>模块导入问题</h3><h4 id="模块的重新导入"><a href="#模块的重新导入" class="headerlink" title="模块的重新导入"></a>模块的重新导入</h4><pre><code>1. 模块名.path：查看系统搜索模块的优先顺序；
</code></pre><p><img src="http://i.imgur.com/uMPoRAt.png" alt></p>
<pre><code>   sys.path 返回的是一个列表，列表是可以修改的，比如增加一条搜索路径，
   sys.path.append(&quot;/home&quot;)；
2. 导入一个模块后，在程序没有结束的情况下，又对该模块做了修改，程序检测不到模块被修改的，
    使用的仍然是模块原来的功能，“ import 模块名 ” 重新导入的方式是无效的；
需要借助 imp 模块实现重新导入：import imp --&gt; imp.reload(模块名) 函数实现重新导入。
</code></pre><h4 id="模块的循环导入"><a href="#模块的循环导入" class="headerlink" title="模块的循环导入"></a>模块的循环导入</h4><pre><code>模块A导入模块B，模块B又需要导入模块A，会陷入循环、导致程序崩溃；
在设计模块的过程中，必须避免循环导入。
</code></pre><h3 id="functools-模块"><a href="#functools-模块" class="headerlink" title="functools 模块"></a>functools 模块</h3><pre><code>python2.5引入的一个模块，存放一些常用的工具函数；
1. partial()：偏函数，加工一个函数，传递默认值；
</code></pre><p><img src="http://i.imgur.com/kCWBLZc.jpg" alt></p>
<pre><code>2. wraps()
    一个函数被装饰之后，其函数名的指向已经发生了改变，所以，再查看该函数的doc信息时，
所查看的是其实际指向的函数体的文档信息；
wraps() 装饰到函数实际指向的函数上，就可以恢复原始的doc；
</code></pre><p><img src="http://i.imgur.com/jG77WUh.jpg" alt></p>
<h3 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a>常用模块</h3><h4 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h4><pre><code>Python常用的标准库有 os，sys，functools ...
1. builtins：内建函数是默认加载的；
2. os：操作系统接口；        sys：Python自身运行环境相关；
4. functools：常用工具库；    random：生成随机数；        copy：拷贝相关；
5. time：时间相关；        datetime：日期和时间；    calendar：日历相关；
6. multiprocessing：多进程相关；        threading：多线程相关；
7. json：编码和解码 JSON 对象；
8. logging：记录日志，调试相关；
9. re：字符串正则匹配；
10. hashlib：加密算法；
11. socket：标准的 BSD Sockets API；
12. shutil：文件和目录管理；
13. glob：基于文件通配符搜索。
</code></pre><h4 id="扩展库"><a href="#扩展库" class="headerlink" title="扩展库"></a>扩展库</h4><pre><code>Python常用的扩展库有 requests，urllib，scrapy，beautifulsoup4 ...
1. urllib：基于http的高层库；
2. requests：使用的是urllib3，继承了urllib2的所有特性；
3. scrapy：爬虫相关；
4. beautifulsoup4：HTML/XML的解析器；        xmltodict：xml转dict；
5. redis：缓存相关；
6. celery：分布式任务调度模块；
7. pymysql：数据库连接相关；
8. matplotlib：画图相关；        Pillow：图像处理(PIL)；
9. xlsxwriter/xlwt/xlrd：excel相关；
10. diango/tornado/flask：Web框架；
11. SimpleHTTPServer：一个不使用Web框架、简单的HttpServer；
12. gevent：基于协程的Python网络库；
</code></pre><h2 id="内建模块"><a href="#内建模块" class="headerlink" title="内建模块"></a>内建模块</h2><pre><code>内建模块是Python系统默认提供的功能，不需要导入模块，可以直接使用。
</code></pre><h3 id="内建属性"><a href="#内建属性" class="headerlink" title="内建属性"></a>内建属性</h3><pre><code>常用的内建(专有)属性：__new__，__init__，__str__，__del__，__class__，__repr__，
__dict__，__doc__，__getattribute__，__bases__；
__repr__：没有重写__str__的情况下，直接打印一个类对象，就是__repr__返回的结果；
__dict__：dir(对象)可以查看所有的属性，对象.__dict__ 只返回对象自己的属性；
__doc__：查看类文档；
__bases__：类名调用，查看所有父类；
</code></pre><h4 id="getattribute"><a href="#getattribute" class="headerlink" title="__getattribute__"></a>__getattribute__</h4><pre><code>__getattribute__：属性访问拦截器，用于高级定制属性；
    1. 方法名也是属性，只不过它指向的是函数体；
    2. 对象.访问属性/方法时，不管是否存在，都会先执行__getattribute__()；
</code></pre><p><img src="http://i.imgur.com/mQY97LQ.jpg" alt></p>
<pre><code>1. 属性/方法名会先被转为字符串，再传递给__getattribute__()；
2. __getattribute__()必须要有return返回值，否则默认返回None，返回值决定属性值；
3. 不需要自定义属性的内容时，必须要返回object.__getattribute__()，执行默认的操作；
4. 方法名也是属性，object.__getattribute__()会检测到show 是绑定到具体哪个对象的方法，
   返回的检测的信息：bound method ... ，然后才会进一步执行show()，完成方法的调用。
5. __getattribute__ 的bug：
</code></pre><p><img src="http://i.imgur.com/Q1ijMNt.jpg" alt></p>
<pre><code>1. p.a：不管属性a 是否存在，都会先调用__getattribute__()，将 a 作为字符串传递给
    形参obj，符合设置的拦截条件，则返回自定义信息；
2. p.b：属性b 不是以 &quot;a&quot; 开头的，则执行 &quot;return self.test&quot;，self.test也是在访问
    属性，又会调用__getattribute__()，&quot;test&quot; 也不是以&quot;a&quot;开头的字符串，所以又
    会执行 &quot;return self.test&quot;，如此循环，造成程序崩溃；
所以，在__getattribute__()中定制属性的内容时，禁止再使用self.调用属性/方法。
</code></pre><h4 id="getattr"><a href="#getattr" class="headerlink" title="__getattr__"></a>__getattr__</h4><pre><code>在对象.访问一个不存在的属性时，只要__getattribute__() 执行的是默认操作，python解释器在
抛出异常前，会先调用__getattr__() 函数；
反之，如果__getattribute__() 执行的不是默认操作，就不会再调用__getattr__()
1. __getattr__() 的参数与__getattribute__() 的参数一致；
2. __getattr__() 的返回值就是属性值，如果没有return，默认返回None；
</code></pre><p><img src="http://i.imgur.com/W7ZXtfx.jpg" alt></p>
<h3 id="内建方法"><a href="#内建方法" class="headerlink" title="内建方法"></a>内建方法</h3><pre><code>input、print ... 都是内建函数；
1. range(start, stop, step)
    1. python2中的 range() 可能造成内存溢出，xrange() 则可以避免；
    2. xrange() 与python3中的 range() 功能相同；
2. map(function, sequence...)
    function：接收一个函数；
    sequence：接收一个或多个可迭代序列，序列的个数取决于function需要几个参数；
    迭代每个序列，把每个序列的元素依次传给function的形参，并返回一个新序列，新序列的每
    个元素值取决于function的返回值；
    1. map(lambda x:x*x, [1, 2, 3])
        lambda 表达式需要1个参数，则传入1个序列：[1, 4, 9]
    2. map(lambda x, y:x+y, [1, 2, 3], [4, 5, 6])
        lambda 表达式需要2个参数，则传入2个序列：[1+4, 2+5, 3+6] --&gt; [5, 7, 9]
    3. 与range()类似，python2中的map()会直接返回新序列，python3中则返回一个生成器。
3. filter(function, sequence)：用于过滤可迭代对象的元素
    迭代sequence，依次将每个元素传递给function，如果function返回True，则保留该元素，
    如果function返回False，则舍弃该元素；
    1. filter(lambda x:x%2, [1, 2, 3, 4])
        只保留奇数：[1, 3]，因为0表示False，非0表示True；
    2. fliter(None, &quot;Hello&quot;)
        function接收的是None，表示不过滤，返回结果：Hello；
    3. python2中的filter()会直接返回新序列，python3中则返回一个生成器。
4. reduce(function, sequence, initial)
    initial：固定初始值；
    依次取出sequence 的元素，和上次function返回的结果作为参数，再次调用function；
    1. reduce(lambda x, y:x+y, [1, 2, 3, 4])
        迭代列表元素，第一个元素传递给x，第二个元素传递给y，返回的结果3 再传递给x，
        第三个元素再传递给y，依次类推：1+2+3+4 --&gt; 10
    2. reduce(lambda x, y:x+y, [1, 2, 3, 4], 5)
        先把初始值5 传递给x，再迭代列表元素，把第一个元素传递给y：5+1+2+3+4 --&gt;15；
    3. python3中的reduce()被放在模块functools中，需要导入才能使用。
5. sorted(iterable)：与列表的sort() 函数相似，从小到大排序。
</code></pre><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><pre><code>1. globals()
    查看当前可用的所有全局变量，返回一个字典；
2. locals()
    查看当前的局部变量，返回一个字典。
</code></pre><h3 id="LEGB规则"><a href="#LEGB规则" class="headerlink" title="LEGB规则"></a>LEGB规则</h3><pre><code>LEGB规则：变量重名时，python解释器的查找规则；
    Local --&gt; Enclosing function(闭包的内函数) --&gt; globals --&gt; builtins；
    1. Local：当前代码块；
    2. builtins：内建模块，包含python系统默认提供的变量、函数、类等；
    3. dir(__builtin__)：查看所有的builtins；
</code></pre><h2 id="python-动态添加属性、方法"><a href="#python-动态添加属性、方法" class="headerlink" title="python 动态添加属性、方法"></a>python 动态添加属性、方法</h2><h3 id="动态添加属性"><a href="#动态添加属性" class="headerlink" title="动态添加属性"></a>动态添加属性</h3><pre><code>1. 给对象动态添加属性
    对象名.属性名：其实是给对象动态添加属性，其他对象不能使用。
2. 给类动态添加属性
    类名.属性名：动态添加类属性，所有对象共享。
</code></pre><h4 id="slots"><a href="#slots" class="headerlink" title="__slots__"></a>__slots__</h4><pre><code>__slots__ 用于限制对象可以动态添加的属性；
</code></pre><p><img src="http://i.imgur.com/R3iUc9f.jpg" alt></p>
<h3 id="动态添加方法"><a href="#动态添加方法" class="headerlink" title="动态添加方法"></a>动态添加方法</h3><h4 id="给对象动态添加方法"><a href="#给对象动态添加方法" class="headerlink" title="给对象动态添加方法"></a>给对象动态添加方法</h4><pre><code>import types --&gt; types.MethodType(函数名, 对象名)：将函数绑定到指定的对象；
绑定完成后，返回方法体的地址，需要有变量接收；
</code></pre><p><img src="http://i.imgur.com/F5xadW1.jpg" alt></p>
<pre><code>1. 为对象p1 动态添加属性 eat，指向绑定到对象的函数，属性eat 也就转化了为一个方法；
2. 每次绑定都返回一个新的方法体地址，也即，p1.eat 和 x 的地址是不同的；
3. 函数是绑定对象的，其他对象不能共享。
</code></pre><h4 id="动态添加静态方法、类方法"><a href="#动态添加静态方法、类方法" class="headerlink" title="动态添加静态方法、类方法"></a>动态添加静态方法、类方法</h4><pre><code>给类动态添加静态方法、类方法，用类属性接收即可；
</code></pre><p><img src="http://i.imgur.com/0FYMbUZ.jpg" alt></p>
<h2 id="私有化"><a href="#私有化" class="headerlink" title="私有化"></a>私有化</h2><pre><code>__xx：属性名和方法名前加两个下划线，表示私有；
__xxx__：前后两个下划线的属性和方法，通常是Python自带的、具有特殊功能的属性和方法，
    比如__file__、__init__()；
xx_：关键字不能用于定义变量和函数，如果强制使用，通常在关键字后面加一个下划线；
_xx：前面加一个或两个下划线，禁止 “ from 模块名 import * ” 的方式导入到其他模块。
</code></pre><h3 id="名字重整"><a href="#名字重整" class="headerlink" title="名字重整"></a>名字重整</h3><pre><code>私有属性和私有方法不能直接访问与继承，是因为python系统对它们进行了名字重整；
dir(对象名)：查看类中的被重整之后的私有属性名和方法名、以及其他所有的属性和方法名；
</code></pre><p><img src="http://i.imgur.com/WfbF39u.png" alt></p>
<pre><code>也即，私有属性和方法也可以直接访问，P._Person__age，P._Person__writeFile()
</code></pre><h3 id="property"><a href="#property" class="headerlink" title="property"></a>property</h3><pre><code>property 可以简化 set、get 方法的调用，
方式一：property(get, set)，用属性的调用掩盖方法的调用；
</code></pre><p><img src="http://i.imgur.com/m78fjj9.jpg" alt></p>
<pre><code>方式二：装饰器
</code></pre><p><img src="http://i.imgur.com/sx7TtQ2.jpg" alt></p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2017/07/27/python基础2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/27/python基础2/" itemprop="url">python基础2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-27T00:00:00+08:00">
                2017-07-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><pre><code>1. 定义：def 函数名()
2. return：
    1. 连续执行多个return，并没有语法错误，但只会执行第一个return；
    2. return a, b, c：abc会被封装成元组后再返回，相当于 return (a, b, c)；
    3. 将没有返回值的函数赋值给一个变量，变量值为None。
</code></pre><h3 id="全局变量与局部变量"><a href="#全局变量与局部变量" class="headerlink" title="全局变量与局部变量"></a>全局变量与局部变量</h3><pre><code>1. 全局变量定义在函数外部；局部变量定义在函数内部，作用域只限于该函数；
2. global：
    1. 在函数内部修改全局变量，必须先用 global 声明，否则只不过是在定义一个与全局变量同名
    的局部变量，修改变量值，对全局变量无效；
    2. 列表、字典：可以不用 global 声明，在函数中可以直接修改，作为实参传递的方式也可以修改，
    但是也只限于修改，不能重新定义(赋值)，否则，如果不用 global 声明，仍然是局部变量；
    3. 全局变量定义的位置：如果函数中使用了全局变量，则该全局变量必须在函数调用之前定义；
    4. 为了区分全局变量和局部变量，通常全局变量名的前几个字符使用统一风格
    比如 g_name，g_age，g_height；
    5. Python检索局部变量的速度比检索全局变量快，也即尽量少用 global 关键字。
</code></pre><h3 id="复合赋值运算符的特性"><a href="#复合赋值运算符的特性" class="headerlink" title="复合赋值运算符的特性"></a>复合赋值运算符的特性</h3><p><img src="http://i.imgur.com/KmEQG11.jpg" alt></p>
<pre><code>在接收到一个实参时，系统会检查该参数是不是可变类型；
如果是不可变类型，“ x += x ” 其实是定义局部变量x，如果是可变类型，则会修改参数本身；
而 “ x = x + x ” 其实是在定义局部变量，并不会改变实参的值。
</code></pre><h3 id="函数的文档说明"><a href="#函数的文档说明" class="headerlink" title="函数的文档说明"></a>函数的文档说明</h3><pre><code>1. 在函数体内，第一行使用多行注释对函数的功能进行说明，就可以定义函数的文档；
2. 在交互模式下，help(函数名)，可以查看函数的文档说明。
</code></pre><h3 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h3><pre><code>1. 定义函数时，被赋值的形参：def test(a, b = 20)，又称为默认参数；
2. 缺省参数必须放在形参的最后位置，形参a称为位置参数；
3. 调用函数时，如果缺省参数没有传递实参，则使用缺省参数的默认值；
4. 多个缺省参数时，给指定的缺省参数传递实参，要指定缺省参数名
    1. 定义：def test(a, b = 20, c = 30)
    2. 调用：test(5, c = 100) ---&gt; a：5，b：20，c：100，此时，参数c 称为命名参数；
    3. 一般参数也可以使用命名参数：test(a = 50, c = 100)
5. 默认参数必须指向不可变对象，而不能是列表等可变对象，否则在使用时会有bug。
</code></pre><h3 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h3><pre><code>1. 定义1：def test(a, b, *args)，args：接收多余的、没有命名的实参，并返回一个元组；
2. 定义2：def test(a, b=10, *args, **kwargs)
    1. kwargs：称为关键字参数，接收多余的、带名字的实参，并返回一个字典；
    2. test(3, 4, 5, 6, task=99, done=89) ---&gt; a：3，b：4
    --&gt; args：(5, 6)，kwargs：{ &quot;task&quot;: 99, &quot;done&quot;: 89 }
3. 定义3：def test(a, b, *, name, age)，def test(a, b, *args, name, age)
    1. *和*args后的参数称为命名关键字参数，用于限制可传递的关键字参数；
    2. 调用时也必须指定命名关键字参数名：test(1, 2, name=&apos;Jack&apos;, age=20)
    3. 命名关键字参数也可以使用缺省值：def test(a, b, *, name=&apos;Mack&apos;, age=20)
</code></pre><h3 id="拆包"><a href="#拆包" class="headerlink" title="拆包"></a>拆包</h3><pre><code>A = (12, 13, 15)，B = {&apos;name&apos;:&apos;Mack&apos;, &apos;age&apos;:20}
在传递实参时，在元组名前加&quot;*&quot;，在字典名前加&quot;**&quot;，就会传递给对应的args和kwargs，
即拆包：test(3, 4, *A, **B)，如果不拆包，A和B会作为整体被传递给args。
1. 拆包之后，参数的实际形式为：test(3, 4, 12, 13, 15, name=&quot;Make&quot;, age=20)，
    这样才会把12、13、15存入args，把name、age存入kwargs。
2. kwargs实际是拷贝了一份B，在函数内更改kwargs的元素，并不会影响B。
</code></pre><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><pre><code>1. lambda表达式可以定义小型匿名函数
</code></pre><p><img src="http://i.imgur.com/m216UHZ.jpg" alt></p>
<pre><code>冒号前的参数是函数的形参，冒号后面其实是函数 return 的返回值；
在ASCII表中，每个字母对应的都有数值，按照 name 排序，其实就是按照字母的大小排序。
2. 函数可以接收函数作为参数：
</code></pre><p><img src="http://i.imgur.com/oIv1rIZ.jpg" alt></p>
<pre><code>3. python是动态语言，可以在程序的运行中，再输入传递的实参
</code></pre><p><img src="http://i.imgur.com/THg5fmv.png" alt></p>
<pre><code>eval(str)：将字符串转化为有效的表达式。
</code></pre><h2 id="eval-str"><a href="#eval-str" class="headerlink" title="eval(str)"></a>eval(str)</h2><pre><code>eval(str)：作用是把字符串的标识(双引号)去掉，恢复数据本身的含义；
1. eval(&quot;1+2&quot;) --&gt; 1+2 --&gt; 3；
2. eval(&quot;lambda x,y:x+y&quot;) --&gt; 返回一个lambda表达式；
3. l = [1, 2, 3] --&gt; sl = str(list) --&gt; 恢复为列表：eval(sl)
</code></pre><h2 id="不可变类型"><a href="#不可变类型" class="headerlink" title="不可变类型"></a>不可变类型</h2><pre><code>1. 数值本身；
2. 字符串：name = &quot;Hello&quot;，name[0] = &quot;w&quot; 会报异常；
3. 元组：tuple = (10, 20)，tuple[0] = &quot;30&quot; 会报异常。
</code></pre><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><pre><code>1. a = 10，b = a ：在Python中，“ a=10 ”并不是在赋值，而是让a指向“10”所在的内存地址，
   “ b=a ” 使 a 和 b 指向同一个内存地址，变量a 和变量b 都是引用；
2. 没有任何引用指向的内存地址，Python会自动清理；
3. id(变量)：查询变量所指向的地址；
4. del a：删除变量a，并解除变量a 对数据“ 10 ”的引用；当没有任何变量指向数据“ 10 ” 时，
   python就会清理“ 10 ”所占用的内存。
</code></pre><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><pre><code>1. open(文件名, 模式)：打开文件
    1. open() 返回一个文件对象，不显式声明模式，默认只读；
    2. Linux中并不强调文件的扩展名，有些文件为了避免直接被编辑器打开，通常自定义后缀名；
    3. 文件名支持相对路径和绝对路径：open(&quot;../a.txt&quot;, &quot;w&quot;)，在上一层路径下创建文件a.txt；
    4. 模式说明：
</code></pre><p><img src="http://i.imgur.com/GM7Iheu.jpg" alt></p>
<pre><code>    5. r 与 w 配合使用，rb 与 wb 配合使用；
    6. r、w 只适合读写文本文件，rb、wb 是二进制读写文件，适合文本、图片、音频等各式文件。
2. close()：通过open()返回的文件对象调用，关闭读取流。
3. 读取文件
    1. read()：一次性读取出文件的所有内容；
        1. r、w 模式，返回值是字符串；rb、wb 模式，返回值是bytes类型；
        2. 读取文件时，由读取指针不断移动、实现读取，read()之后，读取指针处于内容末尾，
        文件读取完毕，再次执行read()，将返回空字符串；
    2. read(1)：r、w 模式，每次读取一个字符；rb、wb 模式，每次读取一个字节；
    3. readline()：每次读取一行；
    4. readlines()：返回一个列表，列表的元素是每一行的内容。
4. write(content)：写入content，如果是复制文件，content 是 read() 的返回值。
</code></pre><h3 id="大文件操作"><a href="#大文件操作" class="headerlink" title="大文件操作"></a>大文件操作</h3><pre><code>1. read() 是把文件内容一次性读取到内存中，文件过大可能报内存溢出，所以，大文件操作禁止使用；
2. read(1024)：按照1024或1024的倍数循环读取，用 len() 判断返回值的长度是否为0，
如果长度为 0，则表示读取完毕，结束循环。
</code></pre><h3 id="定位读写"><a href="#定位读写" class="headerlink" title="定位读写"></a>定位读写</h3><pre><code>1. seek(offset, from)：控制读取指针的位置；
    offset：偏移量，单位是字节；正数向右移动，负数向左移动，但python3不支持负数；
    from：方向，0：文件开头，1：当前位置，2：文件末尾；
    seek(0, 0)：控制读取指针回到文件开头位置。
2. tell()：获取当前读取指针的位置。
</code></pre><h3 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h3><pre><code>import os：
重命名/删除文件：os.rename(oldName, newName)/os.remove(filename)；
创建/删除文件夹：os.mkdir(dirname)/os.rmdir(dirname)；
os.getcwd()：返回当前正在操作的绝对路径；
os.chdir(&quot;../&quot;)：切换到上一层路径，此后的操作都是在上一层路径中；
os.listdir(&quot;./&quot;)：返回一个当前路径下的所有文件和文件夹名的列表。
</code></pre><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><pre><code>python既支持面向过程，又支持面向对象；
</code></pre><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><pre><code>1. 定义：class 类名 ==&gt; 成员：属性，方法；class Cat:
2. 对象：tom = Cat()
3. 对象可以为自身创建属性：tom.name = &quot;Tom&quot;，为tom对象创建属性name，属性值为&quot;Tom&quot;；
4. self：用于保持对象的引用，类似于Java中的this；
</code></pre><p><img src="http://i.imgur.com/54PV3Wp.png" alt></p>
<pre><code>5. __init__(self, ...)：类似于Java中的构造方法，用于初始化对象；
</code></pre><p><img src="http://i.imgur.com/mbmQrS6.png" alt></p>
<pre><code>6. __str__(self)：自定义对象的描述信息；默认打印对象，得到是内存地址等信息；
</code></pre><p><img src="http://i.imgur.com/Ryy0m6J.png" alt></p>
<pre><code>7. __del__(self)：当没有任何引用指向一个对象时，Python就会销毁该对象，此时会调用 del()；
    当程序执行结束，对于没有释放的对象，Python会统一释放掉，此时也会调用 del()。
</code></pre><h4 id="查看一个对象的引用个数"><a href="#查看一个对象的引用个数" class="headerlink" title="查看一个对象的引用个数"></a>查看一个对象的引用个数</h4><pre><code>import sys
sys.getrefcount(引用)：结果会比实际引用多1个，因为形参接收到实参之后，也指向了对象。
</code></pre><h4 id="私有属性、方法"><a href="#私有属性、方法" class="headerlink" title="私有属性、方法"></a>私有属性、方法</h4><pre><code>在类中定义属性/方法时，在属性名/方法名前加两个下划线，比如self.__name，此时不能再通过
&quot;对象.属性&quot;直接访问了，但Python中没有真正的私有属性，加双下划线更像是一种规范；
1. 为私有属性定义set、get 方法，间接设置/获取私有属性；
2. 对象.__name = &apos;Python&apos;：只是为该对象定义了一个与私有属性__name同名的属性。
</code></pre><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><pre><code>1. 定义：class 类名(父类名)
   1. 定义一个类时，默认都会继承顶层父类 object；
   2. 显式写出继承的 object 类，python3中称为新式类，隐式的称为经典类；
2. 重写：在子类中定义一个和父类方法同名的方法；
3. 调用被重写的父类方法：父类名调用、super()调用，super()只适用于python3；
    class Cat:
        def eat(self):
            pass
    class BosiCat(Cat):
        def eat(self):
            Cat.eat(self) --&gt; 调用父类被重写的方法
            super().eat() --&gt; 调用父类被重写的方法，只适用于python3
4. 如果子类重写了__init__()，那么必须在第一行调用父类的初始化方法：
    1. 父类名.__init__(self)
    2. super(子类名, self).__init__()
5. 私有方法、私有属性不能被继承；
6. 多继承：class D(A, B, C)
7. 类名.__mro__：查看调用属性/方法时的遍历顺序：C3算法
</code></pre><p><img src="http://i.imgur.com/WkDaqdW.jpg" alt></p>
<pre><code>尽量避免同名的属性/方法。
8. python2和python3环境下，尽量使用新式类，新式类与经典类的区别
    1. 多继承时，新式类查找属性/方法的顺序是广度优先级：
    D--&gt;A--&gt;B--&gt;C--&gt;A的父类--&gt;B的父类--&gt;C的父类--&gt;...--&gt;object
    2. 经典类的查找顺序是深度优先级：
    D--&gt;A--&gt;A的父类--&gt;...--&gt;object--&gt;B--&gt;B的父类--&gt;...--&gt;object--&gt;C--&gt;...
</code></pre><h3 id="类属性与实例属性"><a href="#类属性与实例属性" class="headerlink" title="类属性与实例属性"></a>类属性与实例属性</h3><pre><code>1. 类属性：在类中直接定义的变量，所有对象共享，类似于Java中的静态属性；
   调用：类名调用和对象调用；但是，类名调用可以修改，而对象调用只能获取值，不能修改；
    对象直接修改类属性，相当于为该对象添加一个同名的实例属性；
2. 实例属性：类的方法中定义的变量，以及“ 对象.属性名 ”所添加的变量，只属于对象，不能共享。
</code></pre><h3 id="实例方法、类方法、静态方法"><a href="#实例方法、类方法、静态方法" class="headerlink" title="实例方法、类方法、静态方法"></a>实例方法、类方法、静态方法</h3><pre><code>1. 实例方法：在类中直接定义的方法，如果要使用或修改类属性，必须使用类名调用类属性；
2. 类方法：在定义方法时，在方法的上面加上“ @classmethod ”，
    第一个形参是 cls，用于保存类的引用；类名和对象都可以直接调用。
3. 静态方法：python同时支持面向过程和面向对象，可以在类外定义函数，但是不符合面向对象
    的规范，所以需要把函数定义在类内部，但是该函数又不能受这个类的限制；
    1. 定义：在方法上面加上 “ @staticmethod ” ，函数的参数不受类限制；
    2. 调用：类名调用和对象调用；
</code></pre><p><img src="http://i.imgur.com/vvetpC4.png" alt></p>
<h3 id="new-cls"><a href="#new-cls" class="headerlink" title="__new__(cls)"></a>__new__(cls)</h3><pre><code>__new__(cls, ...)：用于创建对象；
1. Java中的构造方法负责对象的创建和初始化，在Python中，对象的创建和初始化是分开的；
2. 重写 new()，但是重写后的 new() 不能创建对象，必须通过 object 的 new() 创建对象；
3. 类其实也是对象，类名和 cls 都是该对象的引用，指向同一地址；
</code></pre><p><img src="http://i.imgur.com/dqC7CD1.png" alt></p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><pre><code>单例对象、单例初始化：__new__()和__init__()分别用于对象的创建和初始化，它们的第一个参数
表示不同的意义，其他参数必须保持一致；
</code></pre><p><img src="http://i.imgur.com/7naQEBy.png" alt></p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><pre><code>1. 基本形式：try - except
2. except 可以有多个，捕获不同的异常；可以把多个异常组成一个元组，使用一个except；
3. Exception 是所有异常的父类；try ... except Exception 可以捕获所有的异常；
    Python2中，except 后不指定任何异常，表示捕获所有异常；
4. except Exception as ret：变量ret 中保存有出现异常的具体信息；
5. try - except - else - finally
    1. else 的内容只有在没有异常时才会执行；
    2. finally 的语句不管有没有异常，都会被执行。
6. try 语句中还可以嵌套 try - except；
7. 在程序执行过程中，Ctrl+C 强制结束程序也是一个异常：KeyboardInterrupt。
8. 异常的传递：一个函数抛出异常，但没有try-except，异常就会向上传递给调用者，
    如果调用者仍没有处理，直至传递给Python编译器。
</code></pre><h3 id="抛出自定义异常"><a href="#抛出自定义异常" class="headerlink" title="抛出自定义异常"></a>抛出自定义异常</h3><pre><code>1. raise 异常对象：抛出异常；
2. 自定义异常必须继承 Exception；
3. except 语句中仍可以使用 raise 抛出异常；
4. exit()：结束程序。
</code></pre><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><pre><code>模块其实就是.py文件，通常，主模块命名为 main.py，主函数命名为 main()；
1. __file__：查看模块的路径，import os --&gt; os.__file__：os.py的路径。
2. 编译器查找模块时的顺序
    当前目录 --&gt; python系统默认目录/usr/lib/python --&gt; 找不到，报错；
    定义模块时，避免与系统自带的模块同名。
3. 安装第三方模块
    pip/pip3是python管理模块的工具；
    sudo pip/pip3 install 模块名：pip表示安装到python2中，pip3表示安装到python3中；
    sudo pip install pygame：pygame是第三方开发小游戏的模块。
</code></pre><h3 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h3><pre><code>1. import 模块名
    使用模块时，必须用模块名调用模块中的函数，变量和类；
    import 模块名 as 别名：为模块名自定义一个别名，应用于模块名比较复杂的模块。
2. __import__(&quot;模块名&quot;)
    m = __import__(&quot;sys&quot;)：动态导入模块，类似于：import sys as m
3. from 模块名 import 函数名1, 函数名2, 函数名3 ...
    1. 可以直接使用被导入的函数；
    2. 缺点：如果从不同模块中导入同名的函数，后面导入的函数会覆盖掉前面导入的；
    3. from 模块名 import *：导入模块中的所有内容。
4. __name__
    1. 导入模块时，其实会把模块的语句执行一遍，如果模块中有测试语句，也会被执行；
    2. __name__ 是一个系统属性，用于判断一个模块是自身单独执行的，还是被导入执行的；
    3. 自身单独执行时，值为 &quot;__main__&quot;；被导入执行时，值为模块名；
</code></pre><p><img src="http://i.imgur.com/FghXJJs.png" alt></p>
<pre><code>5. __all__
    用于限制“ from 模块名 import * ”导入的功能，只有添加进 all 列表中的功能，才能被导入；
</code></pre><p><img src="http://i.imgur.com/GgGmLgx.png" alt></p>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><pre><code>1. 存放.py文件的目录，并在该目录下创建 __init__.py 文件，称为包；
2. __init__.py：该文件用于声明可以使用的模块；导入一个包时，实际上会先执行 init 文件；
    1. 声明方式1：__all__ = [&quot;模块名1&quot;, &quot;模块名2&quot;]
    影响“ from 包名 import * ”导入的模块，可以直接使用模块；
    2. 声明方式2：import 模块名
    影响“ import 包名 ”导入的模块，通过包名调用模块：包名.模块名.功能；
    但是，这两种声明方式只适用于 python2，对 python3 无效；
    3. 通用声明方式：from . import 模块名，. 表示当前目录。
</code></pre><h3 id="模块的发布与安装"><a href="#模块的发布与安装" class="headerlink" title="模块的发布与安装"></a>模块的发布与安装</h3><pre><code>1. 制作
    1. 创建 setup.py 文件，setup.py 的内容格式：
</code></pre><p><img src="http://i.imgur.com/jDKSxnV.png" alt></p>
<pre><code>    2. 构建模块：python/python3 setup.py build，生成build目录；
        python 命令表示制作 python2 的模块，python3 命令表示制作 python3 的模块；
    3. 生成发布的压缩包：python/python3 setup.py sdist，生成sdist目录；
       在sdist目录下生成的压缩包，模块制作完成。
2. 发布：将压缩包上传到github上。
3. 安装到python系统默认目录下
    1. 对压缩包解压；
    2. 进入解压的目录中，执行：sudo python/python3 setup.py install；
    3. 安装完成，在任何目录下都能使用。
</code></pre><h3 id="给程序传参数"><a href="#给程序传参数" class="headerlink" title="给程序传参数"></a>给程序传参数</h3><pre><code>import sys
sys.argv：返回一个列表，保存运行.py文件时，python/python3 后面的参数；
    列表的第一个元素是运行的.py文件名；
</code></pre><p><img src="http://i.imgur.com/4sGLX2O.png" alt></p>
<h3 id="time-模块"><a href="#time-模块" class="headerlink" title="time 模块"></a>time 模块</h3><pre><code>import time
time.sleep(seconds)：单位是秒，seconds 可以是整型，也可以是浮点型；
time.time()：获取当前时间的毫秒值(时间戳)，浮点型小数，更加精确；
time.ctime()：获取当前格式化后的日期和时间，字符串类型。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2017/07/26/python基础1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/26/python基础1/" itemprop="url">python基础1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-26T00:00:00+08:00">
                2017-07-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><pre><code>1. py为扩展名的文件编写python代码；
2. python/python3：分别进入python2与python3环境的交互模式，测试python的语法；
3. ipython、ipython3：进入交互模式，不仅支持python语法，而且支持Linux命令。
4. 注释
    1. #... ：单行注释，Python解释器会忽略单行注释的内容；
    2. &apos;&apos;&apos; ... &apos;&apos;&apos; / &quot;&quot;&quot; ... &quot;&quot;&quot; ：（三个单引号/双引号）多行注释；
    3. 多行注释其实是一种特殊的字符串，Python解释器会加载到内存中，如果多行注释
    的内容特别大，可能会造成内存崩溃。
5. python2的中文报错，在文件第一行声明：#coding=utf-8 或 #-*- coding:utf-8 -*-
6. 字符编码
    1. python3的字符串使用Unicode，直接支持多语言；
    2. b&apos;ABC&apos;与&apos;ABC&apos;：前者是bytes类型，每个字符占1个字节，用于网络传输/保存在磁盘；
    后者是一个Unicode编码的字符串；
    3. python源代码包含中文时，必须指定保存为UTF-8编码，为了让python解释器按UTF-8
    读取源代码，通常在文件开头指定：
    1. #!/usr/bin/env python3 ==&gt; 告诉Linux/OS X系统，这是一个python可执行程序；
    2. # -*- coding: utf-8 -*- ==&gt; 以utf-8保存/读取。
</code></pre><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><pre><code>Python是动态语言，定义变量不需要声明类型；但是，Python仍然区分数据类型。
</code></pre><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><pre><code>输入语句：raw_input()、input()
1. input()
    name = input(&quot;请输入名字：&quot;)，在python3中，返回输入的内容，赋值给name；
    而在python2中执行，只是作为一个语句执行；
2. raw_input()：python2中的输入函数，python3没有，其功能与python3中input()相同；
3. 输入函数的返回值都是字符串类型；
4. python2中的input()
    1. 输入 “ 1+2 ”，相当于 name = 1+2；
    2. 输入 “ abc ”，相当于 name = abc，abc 被当作变量，但是又没有定义该变量，
    所以会报no defined；
    3. 输入 lambda 表达式，相当于定义函数，name指向 lambda 表达式的函数体。
</code></pre><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><pre><code>输出语句：print()
1. %d：整数，age = 20，print(&quot;年龄：%d&quot; % age) ==&gt; 年龄：20；
2. %s：字符串，如果不清楚输出的数据类型，%s永远有效；
3. %f：浮点数，height = 1.75，print(&quot;身高：%0.2f&quot;%height)
    0.2：0表示1.75前面没有占位符，2表示小数点后保留2位，Python默认保留6位。
4. 输出多个参数：print(&quot;名字：%s，年龄：%d，身高：%0.2f&quot; % (name, age, height))
</code></pre><p><img src="http://i.imgur.com/G7bMLwW.png" alt></p>
<pre><code>5. print(&quot;abcd&quot;, end=&quot;&quot;)：执行输出之后不换行；
    1. end 是print() 的缺省参数，用于控制执行输出后的操作，默认值为换行符&quot;\n&quot;；
    2. end=&quot;&quot; ： 表示执行输出后，不再执行任何操作；
    3. end=&quot;,&quot; ： 表示执行输出后，加一个逗号&quot;,&quot;。
6. print(&quot;百分比:%d%%&quot;%age)：20%
    当输出语句中有%d、%f 等定向输出时，必须使用两个% 才能输出一个%，避免影响定向输出。
6. \n：换行，字符串中包含\n，\n后面的内容会换行显示；
7. \t：制表符；
8. \r：输出时，其后面的内容会从左边顶行输出；
</code></pre><p><img src="http://i.imgur.com/Yr5Dm3j.jpg" alt></p>
<pre><code>1. &quot;abcd\r12&quot;：\r后面的&quot;12&quot;会从左边顶行输出，覆盖前面的&quot;ab&quot;；
2. end=&quot;&quot;：表示每次输出不换行；\r：因为每次输出都不换行，\r后面的内容左起顶行输出，
所以每次输出的内容只有计算的rate在变化，可用于实时显示传输数据的进度。
</code></pre><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><img src="http://i.imgur.com/dCJxhSO.png" alt></p>
<pre><code>1. type(x)：查看x的数据类型；
2. int(x)/float(x)/str(x)：将x转换为一个整数/浮点数/字符串；
3. isinstance()：类型检查，返回值是boolean型；
    isinstance(x, (int, float))：x是int/float型，则返回True
</code></pre><h3 id="特有的运算符"><a href="#特有的运算符" class="headerlink" title="特有的运算符"></a>特有的运算符</h3><pre><code>1. a//b：取商；    a%b：取余数；
2. a**b：a 的 b 次方；
3. &quot;abc&quot; *3：&quot;abcabcabc&quot;；
4. &lt;&gt;：phthon2中的运算符，等效于 !=；
5. or/and：或/与运算；    not x：非运算；
6. is 与 ==
    1. ==：判断值是否相等；
    2. is：判断两个引用指向的地址是否相同。
7. 复合赋值运算符：+=、%=、**=、//= 等；
8. a, b = 3, 4：python中特有的赋值方式
    1. 交换两个变量的值：a, b = b, a
    2. 这种方式交换两个变量的值，比使用第三方变量的方式更高效。
9. 空字符串，None，0，空列表，空字典，空元组，都表示False；其他都表示True。
</code></pre><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><pre><code>1. while 循环
    1. while - else：
    while循环结束后会执行else，如果while循环中执行了break，则不会执行else；
    2. 死循环 while 1 比 while True 更高效
    python底层是C语言编写的，C语言中并没有boolean类型，False和True其实是按照 0 和 1
    存储的，每次循环判断时，True都需要在底层转换，而 1 不会，所以 while 1 的效率更高。
2. for循环：for...in
    1. 用于遍历可迭代对象的元素，比如 name = &quot;abcdef&quot;
    2. for temp in name：每个循环的字符存入temp；
    3. for...in - else：for结束后会执行else语句，如果for中有break，则不会执行else。
3. break/continue：跳出循环/结束本次循环。
</code></pre><h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><pre><code>import random：random.randint(0, 9)：随机生成一个0~9之间的整数。
</code></pre><h2 id="字符串：str"><a href="#字符串：str" class="headerlink" title="字符串：str"></a>字符串：str</h2><pre><code>1. 单引号和双引号都表示字符串；
2. 在内存中的存储方式
    1. 一个字节存储的最大数值是255，比如，数值100是用一个字节存储的；
    2. 字符串存储时，会把字符串拆分成一组字符，每个字符占一个字节；在底层C语言存储字符串时，
    会在字符串的末尾加一个&apos;\0&apos;。
3. str(x)：将x转换成一个字符串，列表、元组、字典、集合等都可以转为字符串；
4. len(str)：获取字符串的长度；
5. 拼接字符串
    1. + 号连接两个字符串，拼接的必须是字符串类型，否则会报异常；
    2. % 拼接字符串：a = &quot;abc&quot;，b = &quot;OK&quot;，c = &quot;==%s==&quot;%(a+b)，c：&quot;==abcOK==&quot;。
6. 下标：name = &quot;abc&quot;
    1. 正向：name[0]--&gt;&apos;a&apos;，name[len(name)-1]--&gt;&apos;c&apos;；
    2. 反向：name[-1]--&gt;&apos;c&apos;，name[-len(name)]--&gt;&apos;a&apos;；
    3. 下标的方式只能获取对应的字符，但不能通过下标修改字符； name[0]=&quot;w&quot; 会报异常。
7. b&apos;AB&apos; --&gt; 二进制数据，r&apos;AB\tAB&apos; --&gt; 不允许对字符串转义，u&apos;AB&apos; --&gt; Unicode字符串
</code></pre><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><pre><code>切片：name = &quot;abcdefABCDEF&quot;
1. name[开始角标:结束角标]：取字符串的一部分，左开右闭的原则；name[2:5]--&gt;&quot;cde&quot;；
2. name[2:-1]，等效于 name[2:len(name)-1] --&gt; &quot;cdefABCDE&quot;
3. 省略开始角标，默认为 0；name[:5]，等效于name[0:5]--&gt;&quot;abcde&quot;；
4. 省略结束角标，默认为len[name]；name[6:]--&gt;&quot;ABCDEF&quot;；
5. name[开始角标:结束角标:步长]：步长是取元素时跳过的个数，name[2:9:2]--&gt;&quot;ceAC&quot;，
   步长为1时，等效于name[2:9]，步长默认为1，但步长不能为0；
6. 逆序1：name[-1::-1] --&gt; &quot;FEDCBAfedcba&quot;，结束角标取决于步长；
    1. 如果步长是负数，则取到第一个字符，name[-1::-2] --&gt;FDBfdb；
    2. 如果步长为正数，则取到最后一个，即取到的字符串始终为&quot;F&quot;。
7. 逆序2：name[:]--&gt;&quot;abcdefABCDEF&quot;，相当于复制字符串；
    name[::-1]--&gt;&quot;FEDCBAfedcba&quot;，逆序。
</code></pre><h3 id="字符串的常见操作"><a href="#字符串的常见操作" class="headerlink" title="字符串的常见操作"></a>字符串的常见操作</h3><pre><code>1. 查找
    find(子串)/rfind(子串)：正向/反向查找指定的子串，返回子串首字母的下标，-1表示不存在；
    index()、rindex()：与find()的区别是，如果查找失败，则抛出异常；
2. count(子串)：返回指定子串的出现次数。
3. 替换
    replace(子串A，子串B)：用B替换字符串中所有的A，返回一个新的字符串，不会改变原字符串；
    replace(子串A，子串B，num)：num表示要替换的个数。
4. split(子串)：切割字符串，返回一个列表；
    split()：不加参数时，默认会按照空格、&apos;\t&apos;、&apos;\n&apos;进行切割；
</code></pre><p><img src="http://i.imgur.com/MTdw3qn.png" alt></p>
<pre><code>    splitlines()：按照行切割，即字符串中的&apos;\n&apos;。
5. 字母大小写
    capitalize()：把字符串的首字母大写；
    title()：把每个单词的首字母大写；
    lower()/upper()：所有大/小写字母都变成小/大写。
6. startswith(子串)/endswith(子串)：是否以指定子串开头/结束，返回True/false；
7. 指定位置
     center(num)：居中，num表示宽度，小于字符串长度时无效；
     ljust(num)/rjust(num)：左/右对齐。
8. 去除字符串的空格
     strip()：同时去除左右空格；
     lstrip()/rstrip()：去除左/右边的空格；
9. partition(子串)：以字符串中的第一个子串为中心，将字符串拆分成3部分，返回一个元组；
    rpartition()：反向查找出匹配子串，拆分字符串；
10. 判断字符串类型
     isalpha()：字符串是纯字母（a~z和A~Z），返回True；
     isdigit()：字符串是纯数字时，返回True；
     isalnum()：字符串是纯字母、纯数字，或者字母和数字的组合时，返回True；
     isspace()：字符串是纯空格，则返回True。
11. join(iterable)：以调用者为中间字符，连接iterable中的元素，组成一个新的字符串。
    iterable是指可迭代对象，如字符串，元组，列表，字典，集合 ...
    1. 元组，列表和集合的元素，以及字典的键，必须是字符串类型才能连接；
    2. 对于字符串，连接的是每个字符；对于字典，连接的是每个键；
    3. join() 连接字符串的效率要比 “ + ” 更高。
</code></pre><h2 id="列表：list"><a href="#列表：list" class="headerlink" title="列表：list"></a>列表：list</h2><pre><code>1. 定义：list = [ 元素1，元素2，元素3 ]，可以是不同数据类型的元素；
2. 交互模式下，help(list)，可以查看列表的文档；
3. len(list)：返回列表的长度，即元素个数；
4. list(iterable)：把iterable型的数据转为列表；
    1. 如果是字符串，会把字符串拆开，每个字符当作列表元素；
    2. 如果是字典，则把键当作列表元素。
5. 列表支持负角标，也支持切片。
</code></pre><h3 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h3><pre><code>1. append(x)：添加一个新元素，添加在列表最后；
    如果添加的元素是一个列表，则该列表会被看作是一个元素，而不会被拆开。
2. insert(index，x)：在指定位置index插入元素；
    python 的列表其实是一个数组，查找快，insert()插入的效率比append()低。
3. extend()：将两个列表合并成一个列表；两个列表相加，也可以合并成一个新的列表；
4. pop()：删除最后一个元素；    pop(index)：按照角标删除元素；
5. remove(x)：删除指定的元素，只删第一个；
6. del list[index]：根据下标删除；
7. list[index] = y：修改指定元素；
8. 查询：in、 not in
    if x in list：x 在列表 list 中；
    if x not in list：x 不在列表 list 中。
9. index(x)：获取元素的角标，如果该元素不存在，会抛出异常；
10. 排序
    1. sort()、sort(reverse=True)：从小到大排序、从大到小排序，对纯数值元素的列表有效；
    2. reverse()：反向列表，对纯数值元素的列表有效。
11. for...in：遍历列表的元素；
    迭代过程中不能删除列表的元素，因为删除后，列表的元素会发生移动，但迭代指针不会随之移动，
从而造成元素遗漏；
</code></pre><p><img src="http://i.imgur.com/eDBYpOn.jpg" alt></p>
<pre><code>解决的一种方式：创建一个列表Flag，保存要删除的元素；然后再迭代Flag，删除lists的元素。
</code></pre><h3 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h3><pre><code>1. range(start, stop, step)
   生成一个int型的列表，start 列表的第一个元素，stop-1 最后一个元素，step 表示步长；
2. range(5) 等效于 range(0, 5) --&gt; [0, 1, 2, 3, 4]；
3. python2：如果 stop 的值足够大，会内存溢出；所以，python2中的range()是有风险的；
4. python3：range() 并不会立刻生成一个列表，而是作为一个生成器，需要某个元素时再生成；
   所以，range()不会内存溢出；
5. python3下，list(range(5)) 会将生成器转化为列表：[0, 1, 2, 3, 4]
6. xrange() 在python2和python3环境下都是一个生成器，不会造成内存溢出；
7. [i for i in range(5)] --&gt; [0, 1, 2, 3, 4]
    for 语句只用于控制循环的次数，每次循环都会改变i的值，for前面的参数表示每次循环之后、
    存入列表的元素；
8. for - if：筛选生成的元素
      [i for i in range(10) if i%2==0]：只生成偶数的元素，[0, 2, 4, 6, 8]。
9. 多层for循环
    1. [i for i in range(3) for j in range(2)]：
    外层for循环一次，内层for会循环2次(0，1)，生成列表：[0, 0, 1, 1, 2, 2]；
    2. [(i, j) for i in range(3) for j in range(2)]：用元组存储一次生成的多个子元素，
    生成列表：[(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)]。
</code></pre><h2 id="字典：dict"><a href="#字典：dict" class="headerlink" title="字典：dict"></a>字典：dict</h2><pre><code>1. 定义：dict = {键:值，键:值，键:值}，以键值对形式存储数据；
2. 键的类型可以是字符串，数值，元组，但不能是列表；
   因为字典元素的存储地址，是对键进行哈希算法计算的，所以键一定要是不可变的类型，
   而列表是可变类型，计算的值会根据列表的变化而改变；
3. len(dict)：返回字典的长度，即元素个数；
</code></pre><h3 id="常见操作-1"><a href="#常见操作-1" class="headerlink" title="常见操作"></a>常见操作</h3><pre><code>1. 添加/修改： dict[&quot;name&quot;] = &quot;Make&quot;；
2. 指定键进行删除：del dict[键]，pop(key)
3. 查询
     dict[键]：获取值，但是如果该键不存在，将报出异常；
     get(键[, defaultValue])：获取值，如果键不存在，默认返回None，也可以设置默认值。
4. keys()：python2返回键的列表，python3返回一个生成器：dict_keys([键1, 键2])；
5. values()：python2返回值的列表，python3返回一个生成器：dict_values([值1, 值2])；
6. items()：dict = {&quot;name&quot;:&quot;DD&quot;, &quot;age&quot;:20}
    python2中：[(&apos;age&apos;, 20), (&apos;name&apos;, &apos;DD&apos;)]，是一个列表；
    python3中：dict_items([(&apos;name&apos;, &apos;DD&apos;), (&apos;age&apos;, 20)])，是一个生成器对象。
</code></pre><p><img src="http://i.imgur.com/xPbLLEo.jpg" alt></p>
<pre><code>7. for temp in dict：遍历的是字典的键。
</code></pre><h2 id="元组：tuple"><a href="#元组：tuple" class="headerlink" title="元组：tuple"></a>元组：tuple</h2><pre><code>1. 定义：tuple = (元素1，元素2，元素3)
2. 与列表的区别：元组的元素是不可变的，只能查看，不能修改；
3. 如果元组只有一个元素，必须在元素后加逗号：(20, )
4. tuple(iterable)：把iterable型的数据转为元组；
5. len(tuple)：获取元组的长度，即元素的个数；
6. 元组支持负角标，也支持切片；
7. 获取元组的值：a = (10, 12)
    1. 下标的方式：tuple[0]--&gt;10
    2. 拆包：b, c = a --&gt; b：10，c：12
8.  index(x)：返回元素x第一次出现的角标，如果元素不存在，会抛出异常；
9.  count(x)：计算元素x在元组中出现的个数。
10.  zip(list1, list2)：
    1.  zip([1, 2], [&apos;A&apos;, &apos;B&apos;]) --&gt; [(1, &apos;A&apos;), (2, &apos;B&apos;)]
    2.  zip([1, 2, 3, 4], [&apos;A&apos;, &apos;B&apos;]) --&gt; [(1, &apos;A&apos;), (2, &apos;B&apos;)]，多余元素被忽略
</code></pre><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><pre><code>1. 定义：set = { 元素1, 元素2, 元素3 }
2. set与dict类似，也是一组key的集合，但不存储value；同理，key不能重复、不能是可变的；
3. False和True是按照 0 和 1 存储的，所以，False和0、True和1，也被视为重复元素；
4. len(set)：获取集合的长度，即元素的个数；
5. set(iterable)：把iterable型的数据转为集合，并去除重复元素；
6. 常见操作：add(x) 添加一个元素；pop() 删除第一个元素；remove(x) 删除元素x。
7. for...in 的方式遍历，字典和集合的效率比列表要高；
8. 集合A，集合B
     A &amp; B：交集；A | B：并集
     A - B：A 的差集，A 中有，B 中没有的元素；同理，B-A：B的差集；
     A ^ B：对称差集，等效于 A-B 与 B-A 的并集；
9. 应用场景：集合A 表示上个月浏览的用户，集合B 表示这个月浏览的用户
A &amp; B 过滤出老用户；A | B 统计出所有用户；A - B 统计丢失的用户；B - A 统计新用户
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2017/07/25/linux命令入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/25/linux命令入门/" itemprop="url">linux命令入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-25T00:00:00+08:00">
                2017-07-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Linux-的目录结构"><a href="#Linux-的目录结构" class="headerlink" title="Linux 的目录结构"></a>Linux 的目录结构</h2><pre><code>不同于windows，Linux没有分盘，只有一个根目录 /：
</code></pre><p><img src="http://i.imgur.com/eNoIkyr.jpg" alt></p>
<pre><code>/bin：和程序相关；  /boot：和系统启动相关；  /cdrom：和光盘相关；  /dev：和设备相关；
/etc：程序和服务器配置相关；  /lib：存放库；  /home：存放家目录，即打开终端默认所在路径；
</code></pre><h2 id="linux常用命令"><a href="#linux常用命令" class="headerlink" title="linux常用命令"></a>linux常用命令</h2><pre><code>pwd：查看当前所在路径；
ls：列出当前目录下的文件和文件夹； ls /：列出根目录下的文件和文件夹；  
ls的常用参数：
    1. ls -a：显示隐藏文件及目录；
    2. ls -l：以列表形式显示详细信息；
    3. ls -lh：显示文件及目录的大小时，转换为合适的单位； 
touch 文件名：创建文件；
mkdir 目录名：创建文件夹；  mkdir a/b/c -p：如果c之前有不存在的目录，则创建；
tree：显示当前目录的内容结构；
rmdir：删除空目录；
rm：删除文件；  rm -r：可以删除非空的目录，-r，递归；  -f，强制删除；
命令名 --help：查询命令的文档；
man 命令名：分屏的方式查询命令，会进入一个新的界面显示查询结果，每次只显示一屏，支持上下键
    翻动，f:向下翻一屏，b：向上翻一屏，q：退出；
Tab：自动补全；
cat 文件名：查看文件的内容；    cat a.txt b.txt：同时查看文件a和b。
more 文件名：分屏的方式查看文件内容；
ls -alh /bin | more：以分屏的方式显示根目录下bin文件夹的内容；    |：管道，ls输出的内容
    先存入管道，more再从管道中取出，以分屏的方式显示；
history：查看输入过的命令；  !行号：执行行号对应的命令；
&gt;、&gt;&gt;：重定向
    ls &gt; a.txt，将ls命令显示的内容写入a.txt中，会先清空文件的内容；
    ls &gt;&gt; a.txt，追加内容，不会清空文件原内容；如果文件不存在，则会先创建文件；
    cat a.txt b.txt &gt; c.txt：合并文件a和文件b。
cd ./a：.代表当前目录，等效于 cd a；
cd ..：回到上一层目录；  cd ../..：回到上一层目录的上一层目录；
cd -：回到上一次所在的目录，不一定是上一层目录；
cd ~：回到家目录；
软连接、硬链接
    ln -s 文件名 自定义的软连接文件名：创建一个软连接，相当于快捷方式，如果删除了原文件，
        软连接文件无效；
    ln 文件名 自定义的硬链接文件名：创建一个硬链接，相当于为文件创建一个别名，删除原文件，
        硬链接仍有效；
    创建一个文件时，文件内容和文件名是分开存储的，文件名其实就是一个硬链接，当一个文件的硬
    链接数为 0 时，系统就会删除文件内容。
</code></pre><p><img src="http://i.imgur.com/2UC6GMc.jpg" alt></p>
<pre><code>mv：重命名、移动；如果目录不允许移动，则加 -r；
cp：复制并粘贴；如果目录不允许操作，则加 -r；
文本搜索：grep
    grep &quot;内容&quot; 文件名：-n，显示匹配的内容在文件中对应的行号；    -v，求反，搜索内容之外
        的其他内容；    -i，忽略大小写；
    grep &quot;^abc&quot; 文件名：以abc开头的内容；
    grep &quot;abc$&quot; 文件名：以abc结尾的内容。
搜索文件：find
</code></pre><p><img src="http://i.imgur.com/Hugd8Vp.jpg" alt></p>
<pre><code>    find ./ -name &quot;*name*&quot;：查找文件名中包含&quot;name&quot;的文件；
执行命令时，如果没有权限，可以在命令的开头使用 sudo；
归档管理：tar
    1. tar命令很特殊，其参数前可以不使用 &quot;-&quot;；
    2. tar -cvf abc.tar *.py：将所有.py后缀的文件打包成abc.tar；  
       tar -xvf abc.tar：解压缩；
    3. tar -zcvf abc.tar.gz *.py：压缩并打包成abc.tar.gz，占用空间比abc.tar小很多；  
       tar -zxvf abc.tar：解压缩；
       tar -zxvf abc.tar.gz -C workspace：解压到指定目录；
    4. tar -jcvf abc.tar.bz2 *.py：压缩并打包，占用空间比gz稍微大一点；  
       tar -jxvf abc.tar.bz2：解压缩；
    5. zip ab.zip *.py：打包成ab.zip，占用空间较大；
       unzip ab.zip：解压缩
       unzip -d ./test ab.zip：解压到指定目录。
    6. 常用 gz，bz2
which 命令名：查看命令所在目录；
cal：查看日历；
date：查看当前时间，自定义格式：date &quot;+%Y年%m月%d日&quot;；
查看进程信息
    ps -aux：查看所有进程的详细信息（windows的任务管理器）
    top、htop：在一个独立的界面显示进程的信息，q：退出。
kill PID：杀死指定PID的进程，kill -9 PID：强制杀死；
关机重启
    reboot：重启系统，等效于 init 6；
    shutdown -r now：重启系统，会提示给别的用户；
    shutdown -h now：立即关机，等效于 init 0；
    shutdown -h 20:25：定时今天20:25关机；
    shutdown -h +10：10分钟后关机；
df -h：查看当前内存的使用情况；
du -h：查看当前路径下的目录和文件的占用空间大小；
ifconfig -a：查看所有网卡的信息，主要用于查看IP地址信息；
    sudo ifconfig 网卡名(ens33) 新IP：修改指定网卡的IP；
    sudo dhclient：重新动态获取Ip；
ping IP地址：检测是否能与某个IP通信（连通性）；
对于虚拟机上的ubuntu系统，其网卡Ip必须和本机Ip设置在同一个网段，才能实现通信。
用户相关
    linux是多用户多任务的操作系统；
    useradd 用户名 -m：添加一个新的用户，在/etc/passwd文件中可以查看，在/home中会同时
        创建该账户的家目录；
    passwd 用户名：设置（修改）账户密码，新创建的账户默认没有密码；
    userdel -r 用户名：删除用户，并删除home下的家目录；
    whoami：查看当前用户；
    exit：退出当前用户；
    ssh 用户名@IP：远程登陆另一台电脑；
    who：查看登陆当前用户的电脑，显示IP的表示远程登陆的用户，没有IP的表示当前的终端登录；
    su 账户名：切换用户，需要输入该账户的密码；但是，并不会切换当前目录；
        su - 账户名：切换用户，并切换到该账户的家目录；
        su、 su root：切换到超级管理员root；
        su - 、 su - root：切换到root，同时切换到/root目录；
    sudo -s：切换到root权限，并不通用，只在ubuntu的Linux中；
    但是，普通用户会切换root失败，并且会报告给管理员。
用户组
    groupadd 组名：创建一个用户组，在/etc/group文件中可以查看；
    groupdel 组名：删除一个组；
    groupmod +多个Tab：查看当前所有用户组
    为创建的普通用户添加 root 权限
        能切换到 root 权限的组是 adm 和 sudo；
        普通用户不在 adm 和 sudo 组，也就不能通过 sudo -s 切换到root权限；
        cat /etc/group | grep sudo：查看在group文件中搜索出的、属于 sudo 组的用户；
        sudo usermod a -G adm 用户名：加入到 adm 组；
        sudo usermod -a -G sudo 用户名：加入到 sudo 组；
chown 用户名 文件：修改所有者；
chgrp 用户组 文件：修改用户组。
文件的权限
</code></pre><p><img src="http://i.imgur.com/MUFG2iL.jpg" alt></p>
<pre><code>r：读，w：写，x：可执行；
字母法修改文件的权限
    chmod u=rwx 文件名：修改所有者权限为可读、可写、可执行；
    chmod u=r 文件名：修改所有者权限为可读；
    chmod g=rx 文件名：修改所有组权限为可读、可执行；
    chmod o=x 文件名：修改其他人的权限为可执行；
    chmod u=w,g=r,o=x 文件名：同时修改三者的权限；
    chmod u=,g=,o= 文件名：三者都没有任何权限；
数字法修改文件的权限
    r --&gt; 4，w --&gt; 2，x --&gt; 1；
    rw --&gt; 6，rx -- &gt; 5，wx --&gt; 3，rwx --&gt; 7；
    chmod 777 文件名：三者可读、可写、可执行；
    chmod 000 文件名：三者没有任何权限。
</code></pre><h2 id="vi、vim"><a href="#vi、vim" class="headerlink" title="vi、vim"></a>vi、vim</h2><pre><code>vi、vim：进入命令模式，vim 是 vi 的升级版；
vi 文件名 +15：打开文件时，光标定位到15行；
i、I、A、a、O、o：命令模式进入编辑(插入)模式；
    编辑的位置：i，光标前； I，行首； a，光标后； A，行末； o，下一行； O，上一行；
在命令模式下，：--&gt; 进入末行模式；
Esc：退出编辑模式或末行模式；
命令模式下常用命令：
    yy：复制光标所在的行；  4yy：复制光标所在行开始向下的4行；  p：粘贴；
    dd：剪切(删除)光标所在的行；  3dd：剪切光标所在行开始向下的3行；
    D：从光标的位置开始剪切，一直到行末；  d0：从光标位置开始剪切，一直到行首；
    x：向后删除一个；  X：向前删除一个；
    h：控制光标向左；  j：向下；  k：向上；  l：向右；
    H：控制光标定位到当前屏幕的最上面一行；  M：当前屏幕的中间一行；
    L：当前屏幕的最下面一行；  G：整个文件的最后一行，  gg：整个文件的第一行，
    20G：光标定位到第20行；
    w：光标跳到下一个单词的开始处；  b：光标调到上一个单词的开始处；  dw：剪切整个单词；
    u：撤销回上一步操作；  Ctrl+r：反撤销；
    v、V：选中一片代码；v：选中光标经过的位置；  V：选中光标经过的行；
        选中之后， y：复制；  d：剪切；  &gt;：整体向右移动；  &lt;：整体向左移动；
        .：重复执行上一次的命令。
    Ctrl+d：向下翻半屏； Ctrl+u：向上翻半屏； Ctrl+f：向下翻一屏； Ctrl+b：向上翻一屏；
    {：光标向上移动到一块代码的开始；  }：向下移动到一块代码的结尾；
    r、R：替换；  r：替换光标所在的单个字符；  R：替换光标以及后面的字符；
    /：搜索；  /Hello + Enter：搜索“Hello”；
        n：光标移动到下一个搜索的内容；  N：移动到上一个；
    Shift+zz：保存并退出。
末行模式下常用的命令：
    %s/world/hello/g：将文件中的所有 “ world ” 替换为 “ Hello ”；
    %5,20s/world/hello/g：只替换5-20行的 “ world ”；
    w：保存；
    q：退出；  q!：强制退出；  wq：保存并退出；  wq!：保存并强制退出；
    x：保存并退出。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/04/15/Redis高级/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/15/Redis高级/" itemprop="url">Redis高级</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-15T00:00:00+08:00">
                2016-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><pre><code>1. Redis是一种基于C语言开发的NoSQL数据库，代码量只有3万多行，内存级别的读写，而且提供了持久化功能；
2. Redis与Memcache
    1. 它们都是非常流行的两种NoSQL数据库，都能用于服务器端的数据缓存；
    2. 实现方式：Redis是单线程，Memcache是多线程；
    3. 存储方式：Redis支持数据持久化和主从备份，数据更安全；Memcache的数据只存储在内存中，没有持久化功能；
    4. Redis除了基本的 k-v 结构，还支持多种其他复杂结构、事务等高级功能，它已经不仅仅是一个缓存服务；
    5. Memcache只支持基本的 k-v 结构，功能相对单一；
    6. 可用性：Redis支持主从复制、数据分片、哨兵监控；Memcache没有分片功能，需要从客户端支持。
3. 安装
    cd /usr/local/
    wget http://download.redis.io/releases/redis-5.0.4.tar.gz
    tar -zxvf /redis-5.0.4.tar.gz
    cd redis-5.0.4
    make &amp;&amp; make install
</code></pre><h2 id="redis-conf"><a href="#redis-conf" class="headerlink" title="redis.conf"></a>redis.conf</h2><pre><code>1. Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程
    daemonize no
2. 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件
    pidfile /var/run/redis.pid
3. Redis监听端口，默认为6379
    port 6379
4. 绑定的主机地址
    bind 127.0.0.1
5. 当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能
    timeout 300
6. 指定日志记录级别，Redis共支持四个级别：debug、verbose、notice、warning，默认为verbose
    loglevel verbose
7. 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，
   则日志将会发送给/dev/null
    logfile stdout
8. 设置数据库的数量，默认为16，编号0-15，默认操作是 0 号数据库
    databases 16
9. RDB方式的持久化，默认方式
    save 900 1
    save 300 10
    save 60 10000
10. 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩;
    rdbcompression yes
    1. 如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大.
11. 指定本地数据库文件名，默认值为dump.rdb
    dbfilename dump.rdb
12. 指定本地数据库存放目录，默认就是当前目录
    dir ./
13. 当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步
    slaveof &lt;masterip&gt; &lt;masterport&gt;
14. 当master服务设置了密码保护时，slav服务连接master的密码
    masterauth &lt;master-password&gt;
15. 设置Redis连接密码，如果配置了密码，客户端在连接Redis时需要通过AUTH &lt;password&gt;命令提供密码，默认关闭
    requirepass foobared
16. 设置同一时间最大客户端连接数，默认无限制;
    maxclients 128
    1. Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数;
    2. 如果设置 maxclients 0，表示不作限制;
    3. 当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息.
17. 指定Redis最大内存限制
    maxmemory &lt;bytes&gt;
    1. Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key;
    2. 如果这种方式处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作;
    3. Redis新的 vm 机制会把 Key 存放内存，Value 存放在 swap 区.
18. AOF方式的持久化，默认关闭
    appendonly no
    appendfilename appendonly.aof
    appendfsync everysec  # no  always  everysec
19. 指定包含的其它配置文件
    include /path/to/local.conf
    1. 在同一主机上，多个Redis实例可以使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件.
</code></pre><h3 id="远程访问"><a href="#远程访问" class="headerlink" title="远程访问"></a>远程访问</h3><pre><code>1. Redis默认不允许远程访问，修改配置文件：
    1. bind 127.0.0.1 # 注释掉 或者 改为本机的IP地址
    2. protected-mode no  # 如果不设置密码，则关闭保护模式
    3. deamonize yes  # 后台启动运行Redis
2. Redis数据库由一个整数索引标识，而不是一个具体的数据库名称，默认操作的数据库是0号;
    1. select 数据库索引：切换数据库;
    2. move key 数据库索引：移动key到指定数据库;
    3. flushdb：清空当前数据库的key;
    4. flushall：清空所有数据库的key.
</code></pre><h3 id="数据淘汰策略"><a href="#数据淘汰策略" class="headerlink" title="数据淘汰策略"></a>数据淘汰策略</h3><pre><code>1. Redis脚本：Redis使用 Lua 解释器来执行脚本，Redis2.6通过内嵌支持 Lua 环境，执行脚本的常用命令为 EVAL
2. Redis数据淘汰策略
    1. Redis官方的警告：当内存不足时，Redis会根据配置的缓存策略淘汰部分Key，以保证写入成功;
    2. 当无淘汰策略 或者没有找到合适的key时，Redis直接返回 Out of Memory 错误;
    3. 在配置文件 redis.conf 中，允许设置的最大缓存大小：maxmemory 512G
3. Redis提供的数据淘汰策略
    1. volatile-lru：从已设置过期时间的数据集中，挑选最近最少使用的数据淘汰;
    2. volatile-lfu：从已设置过期的key中，淘汰一段时间内使用次数最少的;
    3. volatile-ttl：从已设置过期时间的数据集中，淘汰最近将要过期的数据;
    4. volatile-random：从已设置过期时间的数据集中，随机选择淘汰的数据;
    5. allkeys-lru：从数据集中，淘汰最近最少使用的数据;
    6. allkeys-lfu：从所有key中，淘汰一段时间内使用次数最少的;
    7. allkeys-random：从数据集中，随机选择淘汰的数据;
    8. no-enviction：不采用任何淘汰策略，默认配置.
4. 在平时使用时，应尽量主动设置/更新key的过期时间，主动剔除不活跃的旧数据，有助于提升查询性能.
</code></pre><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><pre><code>1. RDB：默认持久化方案，当满足一定条件时，Redis会自动将内存中的数据全部持久到硬盘文件中;
    1. 在配置文件redis.conf中配置RDB的条件：save (time) (count)
    2. 当满足在time(秒)时间内，至少进行了count次修改后，触发持久化条件，进行RDB快照
2. 默认配置(三者是或的关系)
    save 900 1  # 15分钟内，有至少1个键被更改，则触发RDB快照
    save 300 10  # 5分钟内，有至少10个键被更改
    save 60 10000  # 1分钟内，至少有10000个键被更改
3. 以快照的方式写入到二进制文件中，默认文件名：dump.rdb
    dbfilename dump.rdb  #本地数据库文件
    dir  ./  #本地数据库的存放路径，./ 表示当前目录
4. 快照：保存数据、还原数据极快，适用于灾难性备份;
5. 触发快照的条件，除了配置文件中配置的RDB快照，在服务器正常关闭时，shutdown，也会触发快照;
2. RDB的流程：
    1. Redis使用fork函数来复制一份当前进程(父进程)的副本(子进程);
    2. 父进程继续接收并处理请求，子进程开始把内存中的数据写入硬盘中的临时文件;
    3. 子进程写完后，会使用临时文件替代旧的RDB文件;
</code></pre><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><pre><code>1. AOF：把每一条服务端接收到的写命令都记录下来，每隔一定时间，写入硬盘的AOF文件中;
    1. 当服务器重启后，重新执行这些命令，恢复数据;
    appendonly yes  # 开启AOF
    2. 每收到写命令时，都会记录到文件中，默认文件名：appendonly.aof
2. 这种方式没有RDB快照的限制，适用于Redis意外宕机的数据恢复;
3. AOF的缺点也很明显，占用较大的内存，所以Redis的默认持久化策略是RDB
4. AOF写入的频率：同步策略三选一
    appendfsync always  # 每次都同步(最安全但最慢)
    appendfsync everysec  # 每秒同步(默认)
    appendfsync no  # 不主动同步，由操作系统来决定(最快但不安全)
    1. 默认情况下，文件会先写入到系统的缓存中，系统每30s同步一次，才会真正写入到硬盘;
    2. 如果在这30s内，服务器宕机，那么数据也会丢失;
  5. AOF文件重写
      1. 当记录命令过多时，必然会出现对同一个key的多次写操作，此时只需要记录最后一条即可，前面的记录都毫无意义;
      2. 因此，当满足一定条件时，Redis会对AOF文件进行重写，移除对同一个key的多次操作命令，只保留最后一条;
auto-aof-rewrite-percentage 100
    1. 当前的AOF文件大小超过上一次重写时的AOF文件大小的百分之多少时，会再次进行重写;
    2. 如果之前没有重写过，则以启动时的AOF文件大小为依据;
auto-aof-rewrite-min-size 64mb
    1. 限制允许重写的最小AOF文件大小，通常在AOF文件很小的时候、即使其中有些冗余的命令，也是可以忽略的;
</code></pre><h2 id="订阅发布"><a href="#订阅发布" class="headerlink" title="订阅发布"></a>订阅发布</h2><pre><code>1. Redis的发布订阅是一种消息通信模式：发送者发送消息，订阅者接收消息，客户端可以订阅任意数量的频道;
2. 订阅频道
    1. subscribe 频道1 频道2 ... : 订阅指定的一个或多个频道;
    2. psubscribe 模式1 模式2... : 订阅一个或多个符合指定模式的频道;
3. 发布频道
    publish 频道1 消息
4. 退订频道
    1. unsubscribe 频道1 频道2 ...
    2. punsubscribe 模式1 模式2 ...
5. 比如：客户端1、2 订阅频道cctv5，客户端3 向频道cctv5 发布消息，客户端1、2 就会受到订阅的消息;
6. 应用：构建实时消息系统，如普通的即时聊天、群聊等功能；
    1. 在一个博客网站，有100个粉丝订阅了AA，当AA发布新文章时，就可以推送消息给这100个粉丝;
    2. 微信公众号模式;
</code></pre><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><pre><code>1. Redis事务可以一次执行多个命令，按顺序串行化执行，且执行过程中不许加塞;
    1. 批量操作在发送 EXEC 命令前被放入队列缓存;
    2. 收到 EXEC 命令后，进入事务执行，事务中任何命令执行失败，其余命令依然被执行;
    3. 在事务执行过程中，其他客户端提交的命令请求不会插入到事务执行序列中;
    4. 总的来说，Redis会将一个事务中的所有命令序列化，然后按顺序执行，且不允许出现加塞行为.
2. 事务经历的三个阶段：开启事务 --&gt; 命令入列 --&gt; 执行事务;
3. A向B转账
    multi  #开启事务，以后的命令会依次进入到序列中
    get account:a
    get account:b
    decrby account:a 50  #A减50
    incrby account:b 50  #B加50
    exec  #执行事务
4. discard：取消事务，放弃队列中的所有命令；开启了事务，但不想执行 exec 命令时，可执行 discard 命令取消事务;
5. 错误处理：
    1. 如果队列中的某个命令出现错误，比如操作的key不存在，属于逻辑业务的错误，那么这条命令不再执行，
    而其他命令仍照常执行，而且不会回滚;
    2. 但如果某个命令出现报告错误(语法错误)，比如输入的命令不存在，Redis会立即报错，那么Redis会取消事务，
    所有命令都不会执行;
6. watch/unwatch
    1. 当两个事务同时操作同一个key时，可能会导致数据的不一致;
    2. watch key key ... : 监视key，在开启事务之后、执行事务之前，这个key被其他命令改动了，
    那么当前事务将会被打断，并回滚;
    3. unwatch：取消对所有key的监视;
    4. 如果在执行 watch 命令之后，只要执行了 exec 或 discard 命令，watch会自动取消，无需再执行 unwatch 命令.
7. 应用场景：
    1. 一组命令必须同时执行，或者都不执行;
    2. 保证一组命令在执行过程中不被其他命令插入;
    3. 商品秒杀活动、转账;
</code></pre><h2 id="缓存的数据一致性"><a href="#缓存的数据一致性" class="headerlink" title="缓存的数据一致性"></a>缓存的数据一致性</h2><pre><code>1. Redis缓存与MySQL中的数据要保证一致性;
2. 实时同步：适用于对一致性要求比较高的业务;
    1. 缓存中不存在，则去数据库查询，并保存到缓存中;
    2. 如果数据库中的数据修改了，缓存也要修改;
3. 在SpringBoot中，采用注解的方式来完成 if-else 的工作
    1. @Cacheable：查询时使用，Long类型需要转为String类型，否则会抛出异常;
    2. @CachePut：更新时使用，此注解一定会从数据库中查询数据;
    3. @CacheEvict：删除时使用;
    4. @Caching：组合用法;
4. 异步队列：对于并发程度较高的情况，则采用异步消息队列的方式同步;
5. 阿里的同步工具canal：模拟MySQL slave和master(主从)的同步机制，监控DB bitlog的日志更新来触发缓存的更新;
6. 采用UDF自定义函数的方式：面向MySQL的API进行编程，利用触发器进行缓存同步，UDF主要由C/C++实现;
</code></pre><h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h2><h3 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h3><pre><code>1. 缓存穿透
    1. 查询一个不存在数据时，缓存中没有，就需要从数据库中查询，查不到数据就不写入缓存中，导致每次请求
    这个不存在的数据时，都要到数据库中去查询，造成缓存穿透;
    2. 解决方式：持久层查询不到数据时，就缓存一个空结果(空字符串)，每次查询时先判断缓存中是否存在key，
    如果有，则直接返回空值，表示此数据不存在，否则就去查询数据库;
    3. 另外，持久层 insert 此数据时，及时清除查询的key，或者设置空结果的缓存时间;
2. 缓存雪崩
    1. 如果缓存集中在一段时间内失效，发生大量的缓存穿透，所有的查询都落在数据库上，造成缓存雪崩;
    2. 缓存雪崩没有完美的解决方案，应分析用户行为，尽量将缓存失效时间均匀分布;
    3. 大多数系统设计者会考虑加锁/分布式锁，或者队列的方式来保证单线程/进程去写缓存，从而避免失效时
    大量的并发请求落在数据库上;
3. 热点key
    1. 某个key访问非常频繁，当key失效时，将会有大量线程来构建缓存，导致负载增加，系统崩溃;
    2. 解决方案：
        1. 使用锁，单机使用synchronized、lock等，分布式使用分布式锁;
        2. 不设置缓存过期时间，而是在对应的value里设置一个时间，如果检测到超过了这个时间，则异步更新缓存;
        3. 在value里设置一个比过期时间t0小的过期时间t1，当t1过期时，延长t1，并更新缓存;
        4. 设置标签缓存，并设置过期时间，标签缓存过期后，异步更新实际缓存;
4. 缓存预热：在项目即将发布上线之前，清空Redis数据库，然后由开发者把所有的功能调试一遍，
   这样Redis中就有了一些缓存数据，然后再发布项目，这样做也是为了避免大量用户同时去查询MySQL数据库了;
</code></pre><h3 id="高并发思路"><a href="#高并发思路" class="headerlink" title="高并发思路"></a>高并发思路</h3><pre><code>1. 在实际项目中，一般不会只是用一台Redis
    1. 从结构上来说，单个Redis服务器会发生单点故障，并且一台服务器处理所有的请求负载，压力较大;
    2. 从容量上来说，单个Redis服务器的内存容量有限，就算容量为256G，也不能都用作Redis存储内存，
    单台Redis最大使用内存不应超过20G;
2. 高并发的指标：响应时间、吞吐量、每秒查询率QPS、并发用户...
3. 在方法论中，提高系统并发能力的方式主要有两种：垂直扩展、水平扩展
    1. 垂直扩展：提升单机的处理能力，包括增强单机硬件性能、提升单机架构性能;
    2. 水平扩展：增加服务器数量，线性扩充系统性能;
</code></pre><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><pre><code>1. 一个Redis服务有多个复制品，这个服务称为Master，其他复制品称为Slaves
2. 在Redis主从模式中，一台主库可以有多个从库，但一个从库只能有一个主库;
3. Redis默认支持主从复制，配置极其简单::自行百度
4. 单机主从复制(一台机器，多个Redis服务)，集群主从复制
</code></pre><h2 id="集群：Redis-Cluster"><a href="#集群：Redis-Cluster" class="headerlink" title="集群：Redis-Cluster"></a>集群：Redis-Cluster</h2><pre><code>1. Redis搭建集群的方案有多种，Redis3.0之前大多采用哨兵模式、主从复制;
2. 从Redis3.0开始支持 redis-cluster 集群，至少需要 3(Master)+3(Slave) 才能搭建集群;
</code></pre><h3 id="去中心化"><a href="#去中心化" class="headerlink" title="去中心化"></a>去中心化</h3><pre><code>1. Redis-Cluster采用去中心化结构，每个节点都保存数据和整个集群状态，每个节点都和其他所有节点连接;
2. 所有节点彼此互联(PING-PONG机制)，内部使用二进制协议优化传输速度和带宽;
3. 节点的fail是通过集群中超过半数的节点检测失效时才生效;
4. 客户端与Redis节点直连，不需要中间Proxy层，客户端只需要连接集群中的任意一个节点即可;
5. Redis-Cluster把所有的物理节点映射到 0-16383 slot上，Cluster负责维护;
6. Redis集群预分配 16384 个哈希槽，在Redis集群中放置一个 key-value 时，Redis先对key使用 crc16 算法
   计算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，
   Redis会根据节点数量大致均等地将哈希槽映射到不同的节点上;
</code></pre><h3 id="容错性"><a href="#容错性" class="headerlink" title="容错性"></a>容错性</h3><pre><code>1. 投票机制：由集群中所有的Master参与，如果半数以上的Master节点与当前Master节点通信超时，则认为当前Master节点挂掉;
2. 如果集群中的某个Master挂掉，且它没有Slave，则集群进入fail状态，也可以认为集群的Slot映射 0-16383 不完整时进入fail状态;
3. 如果集群超过半数以上的Master挂掉，无论是否有Slave，集群都进入fail状态.
</code></pre><h3 id="节点分配"><a href="#节点分配" class="headerlink" title="节点分配"></a>节点分配</h3><pre><code>1. 三个主节点分别是A、B、C，它们可以是一台机器上的三个端口，也可以是三台不同的服务器;
2. 采用哈希槽的方式来分配 16384 个Slot时，三个节点分别承担的Slot区间：A[0-5460]，B[5461-10922]，C[10923-16383]
3. 新增一个主节点D，Cluster会从各个主节点的前面各取一部分Slot到 D 上;
    1. A 覆盖 [1365-5460]，B 覆盖 [6827-10922]，C 覆盖 [12288-16383]
    2. D 覆盖 [0-1364，5461-6826，10923-12287]
4. Redis-Cluster的节点分配体现了去中心化思想，不会去优待任何节点;
</code></pre><h3 id="搭建集群"><a href="#搭建集群" class="headerlink" title="搭建集群"></a>搭建集群</h3><pre><code>1. 集群中至少应该有奇数个节点，同时每个节点至少有1个备份节点，主节点、备份节点由 Redis-Cluster 确定;
2. 真集群 - 至少6台机器，假集群 - 一台机器中存在6个Redis服务;
[- 使用一台机器模拟：ubuntu、redis-v5.0.4、一台机器模拟 -]
1. 创建Redis节点安装目录(集群目录)
    mkdir /usr/local/redis_cluster
2. 在 redis_cluster 目录下，创建6个文件夹：7001-7006，分别代表6个节点
    mkdir 7001 7002 ... 7006
3. 把 redis.conf 分别拷贝到这6个目录下，修改这些目录下的redis.conf，以7001为例
    bind 192.168.103.30  # 直接注释掉(必配)
    port  7001  # 绑定端口号，分别对应7001-7006，以区分Redis服务(必配)
    protected-mode no  #如果不设置密码，则关闭保护模式(必配)
    daemonize  yes  # redis后台运行(守护进程的方式)
    pidfile  /var/run/redis_7001.pid  # 修改PID进程文件名(必配)
    logfile  /usr/local/redis_cluster/7001/redis.log  #日志文件名

    cluster-enabled  yes  # 开启集群(必配)
    cluster-config-file  nodes_7001.conf  # 集群节点的配置文件(必配)
    cluster-node-timeout  15000  #集群节点的超时时间
4. 启动各个节点
    1. 在编译安装Redis的目录中，有一个src目录，分别拷贝到 7001-7006 目录中;
    2. 分别进入 7001-7006 目录下，使用 sudo src/redis-server ./redis.conf 命令启动当前的Redis服务;  
    3. 当然，也可以不拷贝src目录，使用同一个 redis-server 命令，指定不同的配置文件，启动6个Redis服务;
    4. 切记：启动时一定要有权限，因为设置后台运行之后，如果没有权限，它不会提示！
    5. 查看启动的服务：ps -ef | grep -i redis
5. 客户端连接/断开节点，测试单个Redis服务
    1. 连接：src/redis-cli -p 7001
    2. 停止：src/redis-cli -p 7001 shutdown  //正常关闭，数据会自动保存
    3. kill -9 PID  //非正常关闭，断电，数据容易丢失
6. 创建集群：Redis5.0以下
    1. src目录下命令 redis-trib.rb
        redis-trib.rb create --replicas 1 127.0.0.1:7001 ... 127.0.0.1:7006
    2. --replicas  1  表示自动为每一个master节点分配一个slave节点，按照一定规则生成 3个master 3个slave
    3. redis-trib.rb 依赖 Ruby 环境
        yum -y install ruby ruby-devel rubygems rpm-build   #安装Ruby
        gem install redis  # gem是ruby的一个工具包，可能会报错，要求Ruby版本为2.2.2以上
    4. 执行 redis-trib.rb create ... 命令，创建集群;
7. 创建集群：Redis5.0+
    1. 从 Redis5.0 开始，不再使用 redis-trib.rb，而是使用C语言实现的 redis-cli 来创建集群;
        redis-cli --cluster create 127.0.0.1:7001 ... 127.0.0.1:7006 --cluster-replicas 1
        ===&gt; Can I set the above configuration?   yes
        [OK] All 16384 slots covered.  ===&gt;集群创建成功
    2. 常见报错：Node 127.0.0.1:7001 is not empty. Either the node already knows other nodes
    3. 解决方式：逐个连接Redis服务，清空数据库：flushall
    4. Redis服务的重启，不需要再执行创建集群的命令，启动所有Redis服务，集群自动开启;
[- 访问集群 -]
    redis-cli -h IP -c -p PORT -a Password  # -c表示连接redis集群
1. 访问redis集群中的任意一个节点
    redis-cli -h 127.0.0.1 -c -p 7001  ==&gt; 没有设置密码，不需要使用 -a
2. 登录之后的命令
    1. info：查看所有信息;
    2. info replication：只查看replication，当前节点的身份、状态等信息;
    3. cluster nodes：查看当前集群中的所有节点，及其主从关系;
        7ffc63c7283a05b799d553002bf1d14ef413a655 127.0.0.1:7004@17004 slave 9e191422······
        9e1914220a6300e63fe1532ebdfe50c0d7f28e0b 127.0.0.1:7002@17002 master - 0 155······
        ······
        1. 第一列表示Redis节点的ID值，且此ID将被Redis实例永久使用，以便于在集群中唯一标识一个Redis节点;
        2. 每个节点都会记录其他节点的ID，而不是通过IP或端口号，因为IP/端口号可能变化，而ID在整个生命周期内是不会变的;
    4. set/get数据时，可能会提示 Redirected to slot [xxxx] located at 127.0.0.1:700x，表示集群搭建成功.
3. Redis Cluster采用去中心化、去中间件的设计，即集群中的每个节点都是平等的，都保存各自的数据和整个集群的状态;
    1. 每个节点都和其他节点连接，而且这些连接保持活跃，保证了只需要连接集群中的任意节点，就可以获取到其他节点的数据;
    2. get的数据被存储在哪个slot下，就重定向到该slot所分配的节点去获取数据，整个数据查找过程由 Redis Cluster 完成.
4. 如果是外部访问，需要开放 7001-7006 端口，并重启防火墙;
5. Java使用 Jedis 访问Redis集群
    //在nodes中指定每个节点的地址
    Set&lt;HostAndPort&gt; nodes = new HashSet&lt;&gt;();
    nodes.add(new HostAndPort(&quot;127.0.0.1&quot;, 7001));
    nodes.add(new HostAndPort(&quot;127.0.0.1&quot;, 7002));
    nodes.add(new HostAndPort(&quot;127.0.0.1&quot;, 7003));
    nodes.add(new HostAndPort(&quot;127.0.0.1&quot;, 7004));
    nodes.add(new HostAndPort(&quot;127.0.0.1&quot;, 7005));
    nodes.add(new HostAndPort(&quot;127.0.0.1&quot;, 7006));
    //创建一个JedisCluster对象，jedisCluster在系统中是单例的
    JedisCluster cluster = new JedisCluster(nodes);
    cluster.set(&quot;name&quot;, &quot;Hello World&quot;);
    cluster.set(&quot;value&quot;, &quot;100&quot;);
    String name = cluster.get(&quot;name&quot;);
    String value = cluster.get(&quot;value&quot;);
    //系统关闭时关闭JedisCluster
    cluster.close();
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/04/12/RabbitMQ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/12/RabbitMQ/" itemprop="url">RabbitMQ</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-12T00:00:00+08:00">
                2016-04-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><pre><code>1. 消息队列是典型的 生产者、消费者 模型，简称MQ;
2. MQ是消息通信的模型，并发的具体实现，目前实现MQ的两种主流方式是：AMQP、JMS
3. AMQP：高级消息队列协议，一个进程间传递异步消息的应用层协议，为面向消息的中间件设计；
4. JMS：由Sun公司早期提出的消息标准，为Java应用提供统一的消息操作，与JDBC担任类似的角色；
5. AMQP与JMS
    1. JMS定义了统一的接口，规范消息操作；AMQP是通过协议来统一数据交互的格式；
    2. JMS限定了必须使用Java语言；AMQP只是一种协议，实现方式是跨语言的；
    3. JMS规定了两种消息模型，而AMQP的消息模型更加丰富。
6. 常见的MQ
    1. ActiveMQ：Apache，基于JMS；
    2. RabbitMQ：采用Erlang语言开发，基于AMQP，可靠性、稳定性好；
    3. RocketMQ：阿里巴巴，基于JMS，目前交给Apache；
    4. Kafka：分布式消息系统，高吞吐量。
</code></pre><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><pre><code>1. RabbitMQ最初起源于金融系统，用于在分布式系统中存储、转发消息；
    1. 可靠性：RabbitMQ使用诸如持久化、传输确认、发布确认等机制来保证可靠性；
    2. 灵活的路由：在消息进入队列之前，通过 Exchange 来路由消息；
    3. 消息集群：多个 RabbitMQ 服务器可以组成一个集群，形成一个逻辑 Broker；
    4. 高可用：队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下仍然可用；
    5. 多种协议：RabbitMQ支持多种消息队列协议，比如 STOMP、MQTT...
    6. 多语言客户端：RabbitMQ几乎支持所有常用语言，比如Java、.NET、Ruby...
    7. 管理界面：RabbitMQ提供了一个易用的用户界面，可以监控和管理消息Broker；
    8. 追踪机制：如果消息异常，RabbitMQ提供了消息跟踪机制，从而查找出原因；
    9. 插件机制：RabbitMQ提供了许多插件，可以从多方面进行扩展，也可以自定义插件。
2. 安装RabbitMQ，启动服务，配置环境和用户、权限...
3. Web管理平台的默认端口号是15672，使用配置的用户去登录管理平台：http://localhost:15672
    1. 创建虚拟主机
        Admin --&gt; Virtual Hosts --&gt; Add virtual host --&gt; 输入Name，如/test
        Admin --&gt; Users --&gt; 选择一个用户 --&gt; Permissions
    2. Current permissions：当前拥有的虚拟主机；
    3. Set permission：为用户添加虚拟主机。
4. RabbitMQ是一个消息的代理者(Message Broker)，负责接收消息并传递消息，传递二进制数据。
</code></pre><h2 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h2><pre><code>1. RabbitMQ提供了6种消息模型，但第6种其实属于RPC(远程服务调用)，并不算是MQ；
    https://www.rabbitmq.com/getstarted.html
2. 搭建环境(两种方式)
    1. 创建SpringBoot项目进行测试，引入启动器：spring-boot-starter-amqp
    2. 创建普通的Maven Java项目，引入依赖：spring-rabbit、slf4j-nop
</code></pre><h3 id="模型一：Hello-World"><a href="#模型一：Hello-World" class="headerlink" title="模型一：Hello World"></a>模型一：Hello World</h3><pre><code>1. 模型：Producer --&gt; MQ --&gt; Consumer，单个生产者和单个消费者
2. 创建连接的工具类
    public class ConnectionUtil {
        public static Connection getConnection() throws IOException, TimeoutException {
            //定义连接工厂
            ConnectionFactory factory = new ConnectionFactory();
            //设置服务地址和端口
            factory.setHost(&quot;192.168.103.30&quot;);
            //Web管理端的默认端口号是15672，访问服务的默认端口号是5672
            factory.setPort(5672);
            //设置账号信息：虚拟主机及其对应的用户名、密码
            factory.setVirtualHost(&quot;/techsel&quot;); //虚拟主机
            factory.setUsername(&quot;java&quot;);  //用户名
            factory.setPassword(&quot;123456&quot;);  //密码
            //通过工厂获取连接
            return factory.newConnection();
        }
    }
3. 生产者
    public class Send {
        //队列名称
        private static final String QUEUE_NAME = &quot;simple_queue&quot;;

        public static void main(String[] args) throws IOException, TimeoutException {
            //创建连接，在Web管理平台：Connections 上会多一条连接信息
            Connection conn = ConnectionUtil.getConnection();
            //创建通道，在Web管理平台：Channels 上会多一条通道信息
            Channel channel = conn.createChannel();
            //声明队列: 设置队列名称, ...
            channel.queueDeclare(QUEUE_NAME, false, false, false, null);
            //消息内容
            String message = &quot;Hello RabbitMQ&quot;;
            //向指定的队列中发送消息，在Web管理平台：Queues 上可以查看消息通道及其详细信息
            channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());
            //关闭通道和连接
            channel.close();
            conn.close();
        }
    }
4. 消费者
    public class Recv {
        //队列名称：与生产者声明的队列名称一致
        private static final String QUEUE_NAME = &quot;simple_queue&quot;;

        public static void main(String[] args) throws IOException, TimeoutException {
            Connection conn = ConnectionUtil.getConnection();
            Channel channel = conn.createChannel();
            //声明队列
            channel.queueDeclare(QUEUE_NAME, false, false, false, null);
            //定义队列的消费者
            DefaultConsumer consumer = new DefaultConsumer(channel){
                //消费的回调方法：消费者会一致阻塞，只要MQ中一有消息，就回调此方法，进行消费
                public void handleDelivery(String consumerTag, Envelope envelope, 
                    AMQP.BasicProperties properties, byte[] body) throws IOException {
                    //消费消息: body
                    String message = new String(body);
                    System.out.println(&quot;消费者：&quot; + message);
                }
            };
            //监听队列：绑定消息队列和消费者，参数2表示：是否自动进行消息确认(手动/自动ACK)
            channel.basicConsume(QUEUE_NAME, true, consumer);
        }
    }
5. 启动消费者，监听队列，等待消费消息；再启动生产者，生产消息；在Web管理平台上跟踪连接、通道、消息;
</code></pre><h3 id="消费者的消息确认机制"><a href="#消费者的消息确认机制" class="headerlink" title="消费者的消息确认机制"></a>消费者的消息确认机制</h3><pre><code>1. 消息确认机制：Acknowlege，当消费者获取消息之后，会向RabbitMQ发送回执ACK，告知消息已经被接收;
2. RabbitMQ收到回执的ACK后，就会立即删除消息;
3. 回执ACK有两种情况：自动ACK、手动ACK
    1. 自动ACK：消息一旦被接收，消费者自动发送ACK;
        channel.basicConsume(QUEUE_NAME, true, consumer);
    2. 手动ACK：消息接收后，不发送ACK，去手动调用;
        channel.basicConsume(QUEUE_NAME, false, consumer);
4. 在自动回执ACK时，回调方法 handleDelivery() 尚未开始执行，但消息已经从MQ中删除了，一旦回调方法中
   发生了异常，消息就找不回来了，所以就需要 手动ACK 的方案，确保一些重要的消息不会丢失；
5. 手动ACK：等待处理逻辑执行完成，再手动回执ACK，从而避免消息的丢失；
    public void handleDelivery(...) {
        String message = new String(body);
        int i = 1/0;  //发生逻辑错误
        //手动回执ACK
        channel.basicAck(envelope.getDeliveryTag(), false);
    }
    1. 因为发生了逻辑错误，没有手动回执ACK，消息会回滚MQ中，然后再分发给其他消费者，保证消息不会被删除;
    2. 但是，因为当前消费者没有ACK，在没有断开重连之前，MQ不会再把消息分发给它，所以如果没有其他消费者，
    就可能造成消息堆积，从而影响MQ的速度.
</code></pre><h3 id="模型二：Work-queues"><a href="#模型二：Work-queues" class="headerlink" title="模型二：Work queues"></a>模型二：Work queues</h3><pre><code>1. 如果消息处理比较耗时，生产消息的速度远远大于消费消息的速度，那么就可能造成消息堆积;
2. 模型：Producer --&gt; MQ --&gt; Consumer1、Consumer2，让多个消费者绑定到一个队列上，共同消费队列的消息;
3. 生产者发送消息
    for (int i=0; i&lt;100; i++) {
        String message = &quot;Hello RabbitMQ : &quot; + i;
        channel.basicPublish(&quot;&quot;, QUEUE_NAME, null, message.getBytes());
        Thread.sleep(i * 2);  //休眠一段时间，让消费者去消费消息
    }
4. 消费者消费消息：创建两个消费者，绑定同一个队列
    1. 消费者性能相同，则消费能力相同
        public void handleDelivery(...) {  ---&gt;消费者-1的回调方法
            String message = new String(body);
            System.out.println(&quot;消费者111：&quot; + message);
            //使用手动ACK
            channel.basicAck(envelope.getDeliveryTag(), false);
        }
        public void handleDelivery(...) {  ---&gt;消费者-2的回调方法
            String message = new String(body);
            System.out.println(&quot;消费者222：&quot; + message);
            //使用手动ACK
            channel.basicAck(envelope.getDeliveryTag(), false);
        }
    2. 消费者性能不同，消费者-1的机器配置较差
        public void handleDelivery(...) {  ---&gt;消费者-2的回调方法
            String message = new String(body);
            Thread.sleep(500);  ---&gt; 模拟消费者-2的性能较差，处理消息速度慢
            System.out.println(&quot;消费者222：&quot; + message);
        }
5. 对比结果可知：无论消费者的性能是否相同，它们处理消息的数量总是相同的；
6. 也就是说，不管消费者是否已经消费完消息(发送回执ACK)，MQ总是平均分配消息给每个消费者；
7. 让MQ不要平分消息给消费者，让性能好的消费者多消费，性能差的消费者少消费;
    1. 在每个消息者中，设置 Channel 每次同时只能处理1条消息，在没有回执ACK时，不要再分配消息
        channel.basicQos(1);
</code></pre><h3 id="模型三：Publish-Subscribe"><a href="#模型三：Publish-Subscribe" class="headerlink" title="模型三：Publish/Subscribe"></a>模型三：Publish/Subscribe</h3><pre><code>1. 模型3、4、5其实是类似的，都是订阅模型，在生产者和MQ之间增加了一层交换器exchange;
2. 生产者永远不会把消息直接发给MQ，实际上，生产者也不关心消息是否会被发送给MQ;
3. 生产者只负责把消息发给交换器，由交换器去决定是把消息传递给所有MQ，还是特定的MQ，亦或者是丢弃消息;
4. 交换器处理消息的方式，取决于不同的交换类型：direct、topic、headers、fanout，其中headers不常用;
5. 模型三称为订阅/发布模型，也称为广播，属于交换类型fanout
    Producer --&gt; X --&gt; MQ1-&gt;Consumer1、MQ2-&gt;Consumer2
6. 生产者
    1. 不再直接声明队列，而是声明交换器，并指定交换类型为fanout
    private static final String EXCHANGE_NAME = &quot;fanout_exchange&quot;;
    //声明交换器
    channel.exchangeDeclare(EXCHANGE_NAME, ExchangeTypes.FANOUT);
    2. 发布消息到交换器
    String message = &quot;Hello RabbitMQ&quot;;
    channel.basicPublish(EXCHANGE_NAME, &quot;&quot;, null, message.getBytes());
    3. 在Web管理平台的 Exchanges 上，可以查看创建的交换器.
7. 消费者
    private static final String EXCHANGE_NAME = &quot;fanout_exchange&quot;;
    1. 消费者1、2 使用不同的队列：
        QUEUE_NAME = &quot;fanout_queue_1&quot;;
        QUEUE_NAME = &quot;fanout_queue_2&quot;;
    2. 声明队列之后，把队列绑定到交换器上，其实就是订阅消息
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);
        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;&quot;);
8. 启动消费者1、2，再启动生产者，两个消费者都会收到消息.
</code></pre><h3 id="模型四：Routing"><a href="#模型四：Routing" class="headerlink" title="模型四：Routing"></a>模型四：Routing</h3><pre><code>1. 设置交换类型为direct，与模型三不同的是：它可以订阅不同的消息类型(Routingkey)，实现定向发布;
2. 生产者
    1. 声明交换器
    channel.exchangeDeclare(EXCHANGE_NAME, ExchangeTypes.DIRECT);
    2. 在发送消息时，指定消息的类型
    channel.basicPublish(EXCHANGE_NAME, &quot;delete&quot;, null, message.getBytes());
3. 消费者：在绑定队列到交换器时，指定监听的消息类型；
    1. 消费者-1：监听2种消息类型
    channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;insert&quot;);
    channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;delete&quot;);
    2. 消费者-2：只关心1种消息类型
    channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;delete&quot;);
4. 生产者发送消息类型delete时，消费者-1、2都会收到消息；发送消息类型insert时，只有消费者-1能收到.
</code></pre><h3 id="模型五：Topics"><a href="#模型五：Topics" class="headerlink" title="模型五：Topics"></a>模型五：Topics</h3><pre><code>1. 设置交换类型为topic，与模型四不同的是，它可以使用通配符;
2. 消息类型通常都是一个或多个单词组成，单词之间以 . 分割，如item.insert
3. 通配符的类型和规则
    1. #：匹配一个或多个词，如audit.# 可以匹配 audit.irs.corp、audit.del
    2. *：只能匹配一个词，如audit.* 只能匹配 audit.del、audit.ins
4. 生产者
    channel.exchangeDeclare(EXCHANGE_NAME, ExchangeTypes.TOPIC);
    channel.basicPublish(EXCHANGE_NAME, &quot;intem.delete&quot;, null, message.getBytes());
5. 消费者
    channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;item.*&quot;);
</code></pre><h3 id="消息丢失"><a href="#消息丢失" class="headerlink" title="消息丢失"></a>消息丢失</h3><pre><code>1. 手动回执ACK的方式并不能完全解决消息丢失的问题，比如MQ服务器宕机了;
2. 虽然集群MQ全部宕机的几率很小，但宕机总会导致消息的丢失，这就需要消息的持久化;
3. RabbitMQ默认不会持久化消息，重启RabbitMQ服务，会发现交换器、队列、消息统统丢失了;
    1. 交换器的持久化：生产者声明交换器时，设置第三个参数为true
    channel.exchangeDeclare(EXCHANGE_NAME, ExchangeTypes.TOPIC, true);
    2. 队列的持久化：消费者声明队列时，设置第二个参数为true
    channel.queueDeclare(QUEUE_NAME, true, false, false, null);
4. 消息持久化：生产者发送消息时，设置消息参数BasicProperties
    1. BasicProperties的构造方法特别多，所以它提供了枚举类型MessageProperties，封装了常用设置;
    2. 是否持久化的区别在于：BasicProperties构造方法上的参数deliveryMode，2表示启用持久化;
    3. 默认枚举值BASIC，持久化的枚举值：PERSISTENT_TEXT_PLAIN(文本类型)、PERSISTENT_BASIC(二进制数据流)
    //发送的是字符串，则可以使用文本类型
    channel.basicPublish(EXCHANGE_NAME, &quot;item.delete&quot;, MessageProperties.PERSISTENT_TEXT_PLAIN,
        message.getBytes());
5. 生产者确认机制
    1. 手动回执解决了消费者丢失消息，持久化解决了RabbitMQ丢失消息，但生产者在发送消息到MQ时，也可能发送失败;
    2. 消费者确认机制：消费者收到消息，向MQ发送回执ACK;
    3. 生产者确认机制：MQ收到消息，向生产者发送确认回执;
    4. 在生产者中，开启生产者确认;
        Channel channel = conn.createChannel();
        channel.confirmSelect();
    5. 通过生产者确认的相关API，处理消息回执;
        channel.addConfirmListener(...);  //监听器
        channel.waitForConfirms([long]);  //等待机制
        channel.waitForConfirmsOrDie([long]);  //等待机制
6. 解决消息丢失
    1. 消费者确认机制(ACK)
    2. 持久化
    3. 可靠消息服务：在发送消息前，将消息持久化到数据库，并记录状态
    4. 生产者确认机制
7. 消息发送失败的重试问题：可能导致消息的重复性
    1. 因为网络等原因，导致消息发送时间特别长，但仍发送成功，由于发送时间超时，生产者又发送了一次，导致消息重复;
    2. 在金融方面，消息的重复性可能导致灾难性问题，此时就需要保证消息处理方的幂等性;
    3. 幂等性：同一个接口被重复执行时，其结果应该是一致的;
    4. 有些接口天生就是幂等的，如查询接口；有些接口就不是幂等的，如新增、删除、修改;
    5. 要保证幂等性，就应该在接口中加入一些特殊的标识，以判断重复性操作，通常是在一定时间内去判断.
</code></pre><h2 id="SpringBoot整合RabbitMQ"><a href="#SpringBoot整合RabbitMQ" class="headerlink" title="SpringBoot整合RabbitMQ"></a>SpringBoot整合RabbitMQ</h2><pre><code>1. 创建SpringBoot的项目，引入AMQP的启动器：spring-boot-starter-amqp
2. spring-rabbit 与 spring-amqp
    1. spring-amqp 是对AMQP协议的抽象实现;
    2. spring-rabbit 是对协议的具体实现，也是目前的唯一实现，底层使用的就是RabbitMQ.
3. 在配置文件 application.yml 中，配置RabbitMQ的连接信息
    spring:
        rabbitmq:
            host: 192.168.103.30
            username: java
            password: 123456
            virtual-host: /techsel
4. Spring也为AMQP提供了Template：AmqpTemplate
    1. 向交换器发送消息
        @RunWith(SpringRunner.class)
        @SpringBootTest
        public class StartApplicationTests {
            @Autowired
            private AmqpTemplate amqp;

            @Test
            public void contextLoads() {
                String msg = &quot;Hello SpringBoot&quot;;
                amqp.convertAndSend(&quot;boot_exchange&quot;, &quot;item.insert&quot;, msg);
            }
        }
    2. 向MQ中直接发送消息
        amqp.convertAndSend(&quot;boot_queue&quot;, msg);
    3. 底层借助JDK自动对消息进行序列化和反序列化.
5. 从MQ中消费消息
    @Component
    public class Listener {
        @RabbitListener(queues = &quot;boot_queue&quot;)
        public void listen(String msg) {
            System.out.println(&quot;消费者：&quot; + msg);
        }
    }
    1. 一旦监听器中发生异常，消息默认回滚到MQ中;
    2. 对于不希望消息回滚的操作，如发送验证码短信，则使用try-catch捕获异常.
6. 如果监听的队列不存在，就会报错，那么就应该自动创建不存在的队列和交换器，并把队列绑定到交换器;
    @RabbitListener(bindings = @QueueBinding(
        value = @Queue(value = &quot;spring_queue&quot;, durable = &quot;true&quot;), --&gt;声明队列，并持久化
        exchange = @Exchange(
            value = &quot;spring_exchange&quot;,
            ignoreDeclarationExceptions = &quot;true&quot;, --&gt;忽略声明的错误
            type = ExchangeTypes.TOPIC), --&gt;声明交换器，默认就是持久化
        key = {&quot;#.#&quot;}))  --&gt;绑定队列到交换器，&quot;#.#&quot;表示监听一切消息
    public void listen(String msg) {
        System.out.println(&quot;消费者：&quot; + msg);
    }
7. 在实际开发中，可能还会配置更多参数
    spring:
        rabbitmq:
            host: 192.168.103.30
            username: java
            password: 123456
            virtual-host: /techsel
            template:  # 设置AmqpTemplate
                retry: # 发送失败的重试机制
                    enabled: true  # 开启
                    initial-interval: 10000ms  # 重试周期10s(第一次等待10s后再重新发送)
                    max-interval: 30000ms  # 最大重试周期，超过30s，则不再重试
                    multiplier: 2  # 每次重试的基数
                exchange: ly.item.change # 设置默认交换机
            publisher-confirms: true  #开启生产者确认机制
    1. 第一次重试等待10s，第二次重试等待2*10s，第三次等待2*2*10s，已经超过了最大重试周期30s，则不再重试;
    2. 在发送消息时，如果不指定交换机，则使用默认交换机ly.item.change，而不是队列
        amqp.convertAndSend(&quot;item.insert&quot;, msg); //item.insert是消息类型，而不再是队列名称
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/04/03/SpringBoot整合/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/03/SpringBoot整合/" itemprop="url">SpringBoot整合</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-03T00:00:00+08:00">
                2016-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="整合MyBatis"><a href="#整合MyBatis" class="headerlink" title="整合MyBatis"></a>整合MyBatis</h2><pre><code>1. mybatis的启动器，第三方框架的启动器通常不是以 spring- 开头;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
        &lt;version&gt;2.0.1&lt;/version&gt;
    &lt;/dependency&gt;
2. MySQL的连接驱动
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;8.0.16&lt;/version&gt;
    &lt;/dependency&gt;
3. 创建配置文件 resources/application.properties，配置数据库连接信息(覆盖默认配置)
    spring.datasource.driverClassName=com.mysql.cj.jdbc.Driver
    spring.datasource.url=jdbc:mysql://host:port/database?serverTimezone=Asia/Shanghai
    spring.datasource.username=root
    spring.datasource.password=123456
4. 实体类(POJO)：cn.boot.pojo.User
    public class User {
        private Integer id;  //尽量使用包装类型
        private String username;
        private String password;
        ... //getter、setter
    }
5. Dao层：cn.boot.mapper.IUserMapper，Mybatis的两个注解 @Mapper、@MapperScan
    @Mapper
    @Repository
    public interface IUserMapper {
        List&lt;User&gt; findAll();
    }
    1. @Mapper：修饰在Dao层接口上，为其生成实现类;
    2. @MapperScan：修饰在引导类上，指定Mapper接口所在的包，为包下的所有接口生成实现类;
        @SpringBootApplication
        @MapperScan(basePackages={&quot;cn.boot.mapper&quot;})
        public class BootdemoApplication {
             ...
        }
    3. 在使用 @Autowired 注入Dao时，IDE会报错，但能运行，在Dao层接口上注解 @Repository 可以消除错误.
6. 建立POJO与Dao的映射关系
    1. 映射配置文件的方式：resources/mapper/IUserMapper.xml
        &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
        &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
                &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
        &lt;mapper namespace=&quot;cn.boot.mapper.IUserMapper&quot;&gt;
            &lt;select id=&quot;findAll&quot; resultType=&quot;user&quot;&gt;
                select * from user
            &lt;/select&gt;
        &lt;/mapper&gt;
    2. 注解的方式
        @Mapper
        public interface IUserMapper {
            @Select(&quot;select * from user&quot;)
            List&lt;User&gt; findAll();
        }
7. 在 application.properties 中配置Mybatis的信息
    # 开启驼峰扫描
    mybatis.configuration.map-underscore-to-camel-case: true
    # 配置POJO别名的扫描包
    mybatis.type-aliases-package=cn.boot.pojo
    #加载Mybatis的映射文件(如果使用映射配置文件的方式)
    mybatis.mapper-locations=classpath:mapper/*Mapper.xml
8. 在Controller中，使用 @Autowired 注入Dao(Mapper)对象
    @Controller
    public class QuickController {
        @Autowired
        private IUserMapper userMapper;

        @RequestMapping(&quot;/test&quot;)
        @ResponseBody
        public String test() {
            List&lt;User&gt; users = userMapper.findAll();
            return &quot;Hello SpringBoot&quot;;
        }
    }
</code></pre><h2 id="集成Spring-Data-JPA"><a href="#集成Spring-Data-JPA" class="headerlink" title="集成Spring Data JPA"></a>集成Spring Data JPA</h2><pre><code>1. 引入起步依赖：spring-boot-starter-data-jpa
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
    &lt;/dependency&gt;
2. 引入MySQL连接驱动：
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;8.0.16&lt;/version&gt;
    &lt;/dependency&gt;
3. application.properties
    # MySQL连接信息
    spring.datasource.driverClassName=com.mysql.cj.jdbc.Driver
    spring.datasource.url=jdbc:mysql:...
    spring.datasource.username=root
    spring.datasource.password=123456
    # JPA的配置信息
    spring.jpa.database=MySQL
    spring.jpa.show-sql=true
    spring.jpa.generate-ddl=true
    spring.jpa.hibernate.ddl-auto=update
    spring.jpa.hibernate.naming_strategy=org.hibernate.cfg.ImprovedNamingStrategy
4. 创建POJO
    @Entity  --&gt;javax.persistence.Entity
    public class User {
        @Id
        @GeneratedValue(strategy=GenerationType.IDENTITY)
        private Long id;  //使用包装类型
        private String username;
        private String password;
        ... //getter、setter
    }
5. Dao层接口：cn.boot.repository.UserRepository
    public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
        List&lt;User&gt; findAll();
    }
6. 使用junit测试：测试失败，等学了JPA再说吧
    @RunWith(SpringRunner.class)
    @SpringBootTest(classes=引导类.class)
    public class TestIbatis {
        @Autowired
        private UserRepository userRepository;  //注入Repository对象

        @Test
        public void test() {
            List&lt;User&gt; users = userRepository.findAll();
        }
    }
7. JDK9环境可能报异常：JAXBException，是因为缺少依赖;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;
        &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;
        &lt;version&gt;2.3.1&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><pre><code>1. Redis官方推荐的Java客户端有很多，常用的有Jedis、Redisson...
2. 其中，Redisson基于Redis实现了很多常用的结构，甚至还有分布式锁和同步器;
3. Spring对Redis做了集成，SpringDataRedis，最初是基于Jedis，Spring5.0开始转向响应式编程，
   所以 SpringDataRedis 重新采用一套响应式编程实现，性能比Jedis更高;
4. SpringDataRedis属于Spring Data的一部分，也为Redis提供了一个Template对象：RedisTemplate
</code></pre><h3 id="整合Redis"><a href="#整合Redis" class="headerlink" title="整合Redis"></a>整合Redis</h3><pre><code>1. Redis的启动器：spring-boot-starter-data-redis
2. 在 application.yml 中，配置Redis的连接信息
    spring:
        redis:
            host: 192.168.103.30
            port: 6379  # 默认6379
            database: 0  #配置Redis的数据库编号，默认就是0
3. 在测试类中，注入 RedisTemplate 对象，操作Redis数据库
    @Autowired
    private RedisTemplate redis;

    @Test
    public void contest() {

    }
4. redis.opsForValue()、opsForList()、opsForSet()、opsForZSet()、opsForHash() 对应Redis中的5种数据结构，
   封装到不同的 Operations 对象中;
    1. 字符串操作对象：ValueOperations ops = redis.opsForValue();
    2. opsForXXX() 在获取Operations对象时做了单例优化，可以不创建Operations对象的变量;
5. redis.boundXXXOps(key)：以绑定key的方式创建 Operations 对象，后续操作不需要再指定key
</code></pre><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><pre><code>1. RedisTemplate 其实是带有泛型的：RedisTemplate&lt;K, V&gt;，分别代表Key、Value的类型;
2. 虽然Redis的key和value通常都是字符串类型：RedisTemplate&lt;String, String&gt;，但底层存储时仍是二进制字节;
3. 泛型的 K、V 可以指定任意类型，RedisTemplate自动把这些类型转为字节进行存储，因为默认使用JDK的序列化工具;
4. 在命令行上查看时，Redis不会转换JDK序列化的结果，可读性很差，所以通常把对象转为JSON字符串，然后存储到Redis中;
5. 考虑到这种转换会很频繁，所以Spring提供了RedisTemplate的子类：SpringRedisTemplate，它的序列化工具不再是JDK，
   而是string.getBytes()，在命令行上查看时，Redis能够自动再转为字符串;
6. 当然RedisTemplate也允许自定义序列化工具。
7. 短信验证码的发送
    1. 把发送事件推送到RabbitMQ中，由消费者调用短信的API;
    2. 短信发送成功后，使用Redis记录下当前手机号，key=sms:phone:手机号，value=当前时间戳，并设置过期时间;
    3. 每次收到发送短信的消息时，先从Redis中获取手机号，如果没有或者时间已经超过了1分钟，则发送，否则不发送，
    避免短信服务的限流;
</code></pre><h2 id="通用Mapper"><a href="#通用Mapper" class="headerlink" title="通用Mapper"></a>通用Mapper</h2><pre><code>1. 通用Mapper：一款中国人自己开发的框架，只支持单表的CRUD;
    1. 在单表的CURD中，其SQL语句的性能通常是固定的，不像多表的SQL语句那样、有很大的优化余地;
    2. 所以在单表操作时，完全可以为Dao层的方法自动生成SQL语句，这就是通用Mapper的作用.
2. 通用Mapper的启动器：mapper-spring-boot-starter
    1. 启动器中已经引入了 spring-boot-starter、spring-boot-starter-jdbc、mybatis、mybatis-spring
    2. 所以不能再引入 mybatis-spring-boot-starter、spring-boot-starter-jdbc
    3. 而且，通用Mapper 默认开启驼峰匹配，无需在 application.yaml 中手动开启;
    4. 在 application.yaml 中，选择使用Spring的默认连接池，配置数据库连接的4大参数.
    spring:
        datasource:
            ...... # driver-class-name、url、username、password
    mybatis:
        type-aliases-package: cn.boot.pojo
3. Dao层接口需要继承 Mapper 接口，泛型为实体类
    public interface UserMapper extends Mapper&lt;User&gt; {
        //Mapper中已经提供了常用的CRUD方法
    }
    1. 通用Mapper底层利用Mybatis的拦截器，动态生成SQL语句，并做了SQL缓存，所以性能很好;
    2. @MapperScan、@Mapper 要使用通用Mapper包下的注解，不能再使用Mybatis包下的了.
4. 在启动类上注解通用Mapper的 @MapperScan , 声明扫描Mapper/Dao层接口所在的包
    @SpringBootApplication
    @MapperScan(&quot;cn.boot.mapper&quot;)
    public class StartQuickBoot {
        ...
    }
5. 实体类相关
    1. 通用Mapper默认会使用实体类名作为数据库表名，@Table(name=&quot;表名&quot;) 用于指定数据库表名;
    2. @Id 注解在属性上，指定主键;
    3. 对于自增长的主键，还需要使用 @KeySql(userGeneratedKeys=true) 注解;
    4. 如果实体类的某个属性不作为数据库的字段，则使用 @Transient 注解;
    @Data
    @Table(name=&quot;tl_user&quot;)
    public class User {
        @Id
        @KeySql(userGeneratedKeys=true)
        private Integer id;  //自增长的主键
        private String username;
        @Transient
        private String remark;  //额外的属性
    }
6. 测试
    @RunWith(SpringRunner.class)
    @SpringBootTest
    public class UserMapperTest {
        @Autowired
        private UserMapper mapper;

        @Test
        public void test() {
            User u = mapper.selectByPrimaryKey(8);  //按主键查询：where id=8
        }
    }
7. Service层：使用 @Transactional 注解引入事务;
    @Service
    public class UserService {
        @Autowired
        private UserMapper mapper;

        public User findById(Integer id) {
            return mapper.selectByPrimaryKey(id);
        }
        @Transactional
        public void insertUser(User user) {  //插入数据时使用事务
            mapper.insert(user);
        }
    }
8. 使用Controller测试
    @Slf4j
    @RestController
    @RequestMapping(&quot;/user&quot;)
    public class UserMapperTest {
        @Autowired
        private UserService service;  //注入Service对象

        @GetMapping(&quot;/{id}&quot;)
        public User test(@PathVariable(&quot;id&quot;) Integer id) {
            log.debug(&quot;test service&quot;);
            return service.findById(id);
        }
    }
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">大麦田怪圈</p>
              <p class="site-description motion-element" itemprop="description">敢做就能赢！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">53</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大麦田怪圈</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
