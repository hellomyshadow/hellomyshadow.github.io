<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="敢做就能赢！">
<meta property="og:type" content="website">
<meta property="og:title" content="大麦田程序猿">
<meta property="og:url" content="http://hellomyshadow.github.io/page/3/index.html">
<meta property="og:site_name" content="大麦田程序猿">
<meta property="og:description" content="敢做就能赢！">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="大麦田程序猿">
<meta name="twitter:description" content="敢做就能赢！">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hellomyshadow.github.io/page/3/">





  <title>大麦田程序猿</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大麦田程序猿</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/05/19/移动端开发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/19/移动端开发/" itemprop="url">移动端开发</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-19T00:00:00+08:00">
                2018-05-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML/" itemprop="url" rel="index">
                    <span itemprop="name">HTML</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h2><pre><code>视口是移动设备用于显示网页的区域，一般会比移动设备的可视区域大，宽度可能是980px或1024px；
目的是为了显示整个为PC端设计的网页，这样在移动端会出现横向滚动条；为了避免滚动条，移动端会
将视口缩放到移动端窗口的大小。
缩放后的网页在移动设备上不易观看，使用&lt;meta/&gt;标签，让视口兼容移动设备可视区的大小。
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no,
    initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot; /&gt;
1. viewport：视口；
2. width=device-width：设置视口的宽度等于设备的宽度；
3. user-scalable=no：不允许用户缩放；
4. initial-scale=1.0：设置初始缩放；
5. maximum-scale=1.0, minimum-scale=1.0：兼容浏览器。
6. 在&lt;head&gt;中生成的快捷键：meta:vp + tab键
</code></pre><h2 id="屏幕适配"><a href="#屏幕适配" class="headerlink" title="屏幕适配"></a>屏幕适配</h2><pre><code>视网膜屏幕：物理像素密度更高的屏幕，常见有2倍和3倍的视网膜屏幕，其物理像素点更小；
图像在视网膜屏和一般屏幕上显示的大小一样时，由于视网膜屏的物理像素点比一般屏幕小，图像就会
变得模糊；
解决方式：使用大一倍的图像，再用CSS强制设置图像的尺寸；
1. background-size：设置背景图像的大小；
    1. background-size: 500px 500px; --&gt; 设置背景图的宽高px；
    2. background-size: 100% 100%; --&gt; 百分比设置背景图的宽高，100%表示完全填充容器；
    3. auto：使用背景图的真实大小；
    4. cover：等比缩放到完全覆盖容器，背景图的宽度/高度可能超出容器；
    5. contain：等比缩放到与容器的宽度/高度相等，保证背景图始终被包含在容器内。
2. 标签的宽高不会影响到背景图的大小，通常会把使用标签的宽高设置的大一些，避免裁剪到背景图。
</code></pre><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><pre><code>1. 全适配：流体布局+响应式布局，适配PC端、平板、手机；
2. 移动端适配：流体布局+少量响应式，基于rem的布局，弹性盒模型；
3. 屏幕适配必须设置 &lt;meta name=&quot;viewport&quot; ... /&gt; 才有效；
4. 对于iPhone的设计图的尺寸，如果是2倍图，所有尺寸应该先除以2才是真实的px尺寸。
</code></pre><h3 id="流体布局"><a href="#流体布局" class="headerlink" title="流体布局"></a>流体布局</h3><pre><code>原理：用百分比设置标签的宽度width，比如 width:25%; 而height仍使用实际高度的固定值。
1. 盒子的边线无法用百分比
    1. 使用计算函数 calc() 设置宽度width，比如 2px的border：width:calc(25% - 4px);
    1. calc()中的运算符两边必须保证有一个空格，否则无效；
    2. 使用属性 box-sizing 将盒子设置为从边线计算盒子尺寸。
2. box-sizing
    1. content-box：默认的盒子尺寸计算方式；
    2. border-box：设置盒子的尺寸计算方式为从边框开始，width+border+padding
</code></pre><h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3><pre><code>原理：使用媒体查询的方式，通过查询浏览器窗口的宽度，对不同的宽度应用不同的样式块，
    每个样式块对应的是该宽度下的布局方式，从而实现响应式布局。
1. 实际上就是根据宽度/高度的改变，动态修改CSS样式的属性，以达到适配多种终端屏幕；
2. @media only screen and (max-width: 500px) { .box li{ width:50%; } }
    1. 当屏幕宽度width&lt;=500px时，&lt;li&gt;盒子的宽度设置为父标签宽度的50%；
    2. @media only screen and (min-width: 100px) and (max-width: 640px) { ... }
</code></pre><h3 id="rem布局"><a href="#rem布局" class="headerlink" title="rem布局"></a>rem布局</h3><pre><code>1. em：以标签自身的文字大小font-size为参考，设置该标签的尺寸；
    1. 比如 font-size:20px; 时，width:200px; --&gt; width:10em;
    2. em 单位只对当前的标签有效，对其他标签是无效的。
2. rem：以根节点&lt;html&gt;的文字大小font-size为参照，设置标签的尺寸；
    1. &lt;html style=&quot;font-size: 20px;&quot;&gt;
    2. div{ width:400px; height:200px } --&gt; div{ width:20rem; height:10rem }
    3. rem 单位对整个HTML都有效，在浏览器窗口大小变化时，就可以通过JS获取窗口的大小，
       并重新设置&lt;html&gt;的font-size，从而动态改变每个标签的 width、height、margin、
       padding... 达到适配不同屏幕的效果。
    4. 为了避免影响阅读效果，字体大小font-size仍使用px，部分字体使用响应式布局。
3. 监听页面宽度width的变化，动态修改&lt;html&gt;上的style.font-size属性值：
</code></pre><p><img src="https://i.imgur.com/nmV4fIB.jpg" alt></p>
<pre><code>4. innerWidth、clientWidth：前者是window对象的属性，后者是DOM对象的属性；
    1. innerWidth：窗口的文档显示区(body)的宽度，不支持IE9以下的IE浏览器；
    2. document.documentElement/document.body的clientWidth取代了innerWidth.
</code></pre><h3 id="弹性盒模型布局"><a href="#弹性盒模型布局" class="headerlink" title="弹性盒模型布局"></a>弹性盒模型布局</h3><pre><code>1. 容器属性，比如&lt;ul&gt;&lt;/ul&gt;
    1. display: flex; --&gt; 声明使用弹性盒布局；
    2. flex-direction：子元素的排列方向；
        1. row/row-reverse：子元素水平靠左排列/靠右倒序排列，row是默认属性值；
        2. column/column-reverse：垂直方向排列。
    3. flex-wrap：子元素超过父容器尺寸时是否换行；
        1. nowrap：默认值，不换行，对子元素进行缩放；
        2. wrap/wrap-reverse：换行/换行反向排列；
    4. flex-flow: flex-direction的属性值 | flex-wrap的属性值 --&gt; 同时设置；
    5. justify-content：多个子元素在水平方向上的分布方式；
        1. flex-start/flex-end：子元素整体靠左/右；
        2. center：水平居中；
        3. space-between：第一个/最后一个子元素分别靠左/右顶格，中间的子元素等分间距；
        4. space-around：第一个子元素靠左的间距和最后一个子元素靠右的间距，是中间子元素
        间距的一半，中间的子元素等分间距。
    6. align-items：多个子元素在垂直方向上的分布方式；
        1. flex-start/flex-end：子元素整体靠上/靠下；
        2. center：垂直居中；
        3. baseline：子元素内的文字底部对齐，如果文字大小不一致，子元素底部会对不齐；
        4. stretch：如果子元素不设置高度，其高度会被拉伸到与父容器的高度一致。
    7. align-content：设置多行子元素在行方向上的对其方式；
        1. flex-start/flex-end：每一行的子元素整体靠上/靠下；
        2. center：多行子元素整体居中；
        3. space-between：第一行/最后一行子元素分别靠上/下顶格，中间行元素等分间距；
        4. space-around：第一行子元素到上面的距离和最后一行子元素到下面的距离，是中间
        行元素间距的一半，中间行元素等分间距。
2. 条目属性，比如&lt;li /&gt;
    1. flex-grow：表示当父容器有多余空间时，这些空间在每个子标签之间的分配比例；
        1. 类似于权重，比如flex-grow: 1; --&gt; 如果&lt;li /&gt;是水平排列、且&lt;ul&gt;仍有多余空间，
        则每个&lt;li /&gt;会增大相同比例的宽度，平分&lt;ul&gt;的空间；
        2. 如果某个&lt;li /&gt;的flex-grow: 2; --&gt; 该&lt;li /&gt;的宽度会增长更多；
        3. 只有使用了flex-grow属性的标签才会被分配增长空间。
    2. flex-shrink：表示当父容器的空间不足、且不换行时，各个子标签的尺寸缩小比例；
    3. 父容器的空间不足时，flex-shrink设置缩小比例，此时设置flex-grow是无效的；
    4. flex-basis：设置弹性条目标签的初始尺寸，弹性布局的基数；
        1. flex-grow在平分父容器的多余空间时，增长基数默认是相同的；
        2. flex-basis:20px; --&gt; 设置该标签的增长基数为20px。
    5. align-self：复写父容器设置的对齐方式，即复写父容器的align-items属性；
    6. order：重置标签在父容器中的排列位置，类似于修改数组的角标。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/05/15/图片格式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/15/图片格式/" itemprop="url">图片格式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-15T00:00:00+08:00">
                2018-05-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML/" itemprop="url" rel="index">
                    <span itemprop="name">HTML</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="psd"><a href="#psd" class="headerlink" title="psd"></a>psd</h2><pre><code>1. photoshop的专用格式，用作效果图，不压缩，保留了图层、透明、半透明等图片信息；
2. 保存了图片的原始数据，方便对图片的修改，相对地，psd图片的容量也很大；
3. 前端工程师使用psd格式的效果图进行切图，制作网页，而不是在网页中直接使用psd图片。
</code></pre><h2 id="jpg"><a href="#jpg" class="headerlink" title="jpg"></a>jpg</h2><pre><code>1. 一种有损压缩格式，压缩效率高，容量小，网络传输速度快；
2. 不能保存为透明背景，在网页中应用广泛。
</code></pre><h2 id="gif"><a href="#gif" class="headerlink" title="gif"></a>gif</h2><pre><code>1. 一种无损压缩格式，最多只有256种颜色，对于颜色丰富的图片转化为gif格式会失真；
2. 背景可以透明，但不能是半透明；
3. 对于透明背景中的图像，如果边缘轮廓使曲线，会产生锯齿；
4. 还可以保存为动画格式。
</code></pre><h2 id="png"><a href="#png" class="headerlink" title="png"></a>png</h2><pre><code>1. 无损压缩格式，用于替代gif；
2. 背景可以是透明或半透明，且透明背景中的图像边缘光滑，没有锯齿；
3. png也是firework的专用格式，可以包含图层信息，firework也是一款图像处理软件。
</code></pre><h2 id="webp"><a href="#webp" class="headerlink" title="webp"></a>webp</h2><pre><code>1. 谷歌于2010年推出的新一代图片格式；
2. 在压缩方面比jpg格式更优越，在质量相同的情况下，webp图像的体积比jpg的小40%；
3. 尚未得到浏览器的广泛支持，只在Chrome和Opera上有效。
</code></pre><h2 id="位图和矢量图"><a href="#位图和矢量图" class="headerlink" title="位图和矢量图"></a>位图和矢量图</h2><pre><code>1. 位图：也称为点阵图，由一个个的方形像素点排列拼接而成，放大时会失真；
2. psd、jpg、gif、png、webp都是位图；
3. 矢量图：与位图的原理不同，其图像轮廓是由函数曲线生成的；
4. 放大矢量图时，其原理就是将曲线乘以一个倍数，不会出现锯齿。
</code></pre><h2 id="svg"><a href="#svg" class="headerlink" title="svg"></a>svg</h2><pre><code>1. 一种矢量二维图片格式，基于xml标记语言描述的，可以通过任何文本编辑器创建；
2. 文件容量小，放大不会失真，背景可以是透明的，很适合做高质量、单色调的图标；
3. 目前，网页图标/地图大量使用svg格式，这种矢量图在不同终端屏幕上的显示效果都很好。
</code></pre><h2 id="flash"><a href="#flash" class="headerlink" title="flash"></a>flash</h2><pre><code>1. 一种适量动画文件格式，很多优秀特性都可以用HTML5取代，如今已逐渐退出历史的舞台；
2. 既可以是静态图片，也可以是多媒体动画，还可以加入用户交互和数据；
3. 格式名为swf，flash是对它的统称，swf文件中衍生出一种流媒体视频格式flv；
4. flv格式的容量小，可以边下载、边观看，广泛应用于视频网站。
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><pre><code>1. 网页制作中，不透明背景的图片就使用jpg，透明或者半透明背景的图片就使用png；
2. 制作网页图标
    1. 多颜色的图标使用gif/png格式；
    2. 单色且对显示效果要求高的图标使用svg格式；
    3. 动画图标使用gif格式。
3. 雪碧图/精灵图：HTML网页中的图片需要网络请求，为了减少网络请求的次数，将装饰性图片
   按照一定的距离，排列在一张透明背景的图片上，这样只需要做一次网络请求即可；
   HTML在使用时，通过CSS的定位取出对应图片的位置。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/05/13/HTML5-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/13/HTML5-2/" itemprop="url">HTML5-2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-13T00:00:00+08:00">
                2018-05-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML/" itemprop="url" rel="index">
                    <span itemprop="name">HTML</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><h2 id="音视频标签"><a href="#音视频标签" class="headerlink" title="音视频标签"></a>音视频标签</h2><pre><code>1. H5之前对音视频没有一个标准，在网页中的音视频都是通过第三方插件的方式嵌入的；
2. 视频：&lt;video src=&quot;video/test.mp4&quot; controls width=&quot;500&quot; height=&quot;500&quot;&gt;
    1. controls：布尔值属性，显示/隐藏控制播放的控件，但不同浏览器上渲染的样式不同；
    2. src还可以加载网络视频资源：src=&quot;http://······&quot;
    3. poster：一个海报帧(图片)的地址，用于在用户播放或跳帧之前的展示；
    4. autoplay/loop/muted：是否自动播放/循环/静音；
    5. preload：none(告诉浏览器不要预加载该视频，点击播放时再加载)，metada(只抓取该视频的
    元数据，如长度、海报帧等，并显示给用户，但不会预加载该视频)，auto(预加载该视频)
    6. preload: &quot;&quot;; --&gt; 等效于 preload: auto;
    7. 这些都是attribute属性
    8. property属性：
3. 音频：&lt;audio src=&quot;res/test.mp3&quot; controls&gt;
    1. attribute属性：src、controls、autoplay、loop、muted、preload
    2. 对音视频标签支持最好的是FireFox；
    3. property属性：
4. 容器
    1. 实际上，.avi、.mp4并不是视频文件本身，而是容器的格式，它只是决定了视频存储的方式，
    而不关心存储的内容，类似于.zip
    2. 视频容器包含音频轨道、视频轨道和其他一些元数据，视频播放时，音频轨道和视频轨道是绑定
    在一起的，元数据包含了视频的封面、标题、子标题、字幕等相关信息；
    3. 主流容器格式(视频文件格式)：MPEG-4(以.mp4为扩展名)，Flash视频(.flv)，Ogg(.ogv)，
    WebM(.webm)，音频视频交错(.avi)
    4. 主流音频文件格式：MPEG-3(.mp3)，Acc音频(.acc)，Ogg音频(.ogg)
5. 编解码器
    1. 音频和视频的编码/解码是一组算法，用来对一段特定音频/视频进行解码和编码，使音频和视频
    能够播放；
    2. 原始的媒体文件体积非常巨大，如果不编码，数据量很大，在互联网上传输也会消耗大量时间；
    如果不解码，也无法将编码后的数据重组为原始的媒体数据；
    3. 视频编解码器：H.264(又称为MPEG-4的第十部份)、VP8、Ogg Theora
    4. 音频编解码器：ACC、MPEG-3、Ogg Vorbis
    5. 编解码器的配置分为基本配置、主配置、高级配置，手机上支持基本配置，电视机上支持基本配置
    和主配置，电脑上支持三种配置；
    6. 目前还没有一种编解码器和容器的组合能够适配所有浏览器，因此要对视频做格式转化；
    7. 音视频的格式转化工具：FFmpeg
6. 音视频的兼容模式
    1. &lt;video&gt;可以包裹&lt;source&gt;，提供不同格式的视频，不支持视频标签，则提供视频的下载链接；
    &lt;video width=&quot;800&quot; height=&quot;800&quot; controls&gt;
        &lt;source src=&quot;res/test.mp4&quot; type=&quot;video/mp4&quot;&gt;&lt;/source&gt;
        &lt;source src=&quot;res/test.ogv&quot; type=&quot;video/ogg&quot;&gt;&lt;/source&gt;
        &lt;source src=&quot;res/test.webm&quot; type=&quot;video/webm&quot;&gt;&lt;/source&gt;
        当前浏览器不支持video直接播放，点击下载：&lt;a href=&quot;res/test.mp4&quot;&gt;下载视频&lt;/a&gt;
    &lt;/video&gt;
    2. 浏览器通过检查&lt;source&gt;的type属性，查找所支持的视频格式，达到浏览器的兼容效果；
    3. 同理，&lt;audio&gt;也可以包裹&lt;source&gt;，提供不同格式的音频。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/05/12/HTML5-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/12/HTML5-1/" itemprop="url">HTML5-1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-12T00:00:00+08:00">
                2018-05-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML/" itemprop="url" rel="index">
                    <span itemprop="name">HTML</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><pre><code>1. HTML5：HTML标准的的最新版本，是一个更大的技术集，具有新的元素、属性、行为；
2. 跨平台：H5本身并不能跨平台，但浏览器是跨平台的，如Java语言不跨平台，但JVM是跨平台的；
3. HTML运行在浏览器上，是唯一可以通吃PC、MAC、iPhone、Android、Linux等主流平台的语言。
</code></pre><h3 id="H5与H4"><a href="#H5与H4" class="headerlink" title="H5与H4"></a>H5与H4</h3><pre><code>1. &lt;meta charset=&quot;UTF-8&quot;&gt;：告诉浏览器以utf-8渲染当前的html文档；
2. DOCTYPE
    1. DOCTYPE：Document Type Declaration，文档类型声明，简称DTD
    2. 通常情况下，DOCTYPE在HTML文档的首行位置，因为浏览器在解析HTML正文之前，必须确定
    当前文档的类型，再决定需要采用的渲染模式；
    3. 不同的渲染模式会影响浏览器对于CSS、JS的解析。
3. 浏览器的渲染模式
    1. 目前为止，浏览器主要包括三种渲染模式，在H5草案中规定了模式的定义；
    2. 现代主流浏览器，包括IE9以上的浏览器，三种模式在渲染方面几乎没有区别；
    3. IE7/8/9理论上存在怪异模式，但实际上只有标准模式；
    4. 在IE6中，标准模式和怪异模式的差别最大，而IE6以下的浏览器只有怪异模式。
4. document.compatMode：查看当前的渲染模式，返回两个值CSS1Compat、BackCompat
    1. 标准兼容模式：CSS1Compat，怪异模式：BackCompat
    2. H5文件的首行声明：&lt;!DOCTYPE html&gt; ==&gt;&gt;表示开启标准模式，必须放在首行才有效
    3. 如果不声明&lt;!DOCTYPE html&gt;，或者&lt;!DOCTYPE html&gt;的位置不正确，则开启怪异模式。
5. H4的声明、根标签、META
    &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; ······&gt;
    &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;&quot; charset=&quot;UTF-8&quot; /&gt;
    1. xmlns：XHTML1.0的概念，声明命名空间，而H5中的每个元素都具有此空间，不需要声明；
    2. H5中已经简化了根标签的声明：&lt;html&gt;&lt;/html&gt;
    3. META类型：Content-Type:text/html; 在网络传输声明当前数据类型为html；
    4. 在H5中，Content-Type的声明已经被移植到HTTP中，不需要在&lt;meta /&gt;上声明。
</code></pre><h3 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h3><pre><code>1. 常用的H5语义化标签：&lt;hgroup&gt;、&lt;header&gt;、&lt;nav&gt;、&lt;section&gt;、&lt;footer&gt;、&lt;article&gt;...
    1. 各大浏览器厂商在分析了大量的页面之后，发现&lt;div&gt;的id名称大量重复，如id=&quot;footer&quot;
    标记页脚内容，所以引入了语义化标签；
    2. 这些语义化标签其实也是&lt;div&gt;，它们也没有任何默认样式，除了会让文本另起一行之外；
    3. HTML5通过这些语义化、结构化的代码标签，代替无意义的&lt;div&gt;，提升了网页的质量和语义，
    对搜索引擎也更加友好。
2. 测试H5文档的语义化站点：https://gsnedders.html5.org/outliner/
3. &lt;hgroup&gt;：多个h1-h6的容器，比如文章的主标题和副标题
    1. 如果有连续多个h1-h6标签，就用&lt;hgroup&gt;包裹，如果只有一个h1-h6标签，则不需要；
    2. 如果有连续多个标题和其他数据，则标题放入&lt;hgroup&gt;，并和其他数据一起放入&lt;header&gt;
4. &lt;header&gt;：网页或&lt;section&gt;的页眉，没有个数限制，通常会包含h1-h6或者&lt;hgroup&gt;
5. &lt;nav&gt;：页面的导航区域，用于定义整个页面的主要导航部分
6. &lt;section&gt;：h5文档中的片段，节
7. &lt;article&gt;：表示一个文档，在页面中自成一体的内容
8. &lt;aside&gt;：可用于侧边栏、副导航、附属信息如名词解释
</code></pre><h2 id="prop与attribute"><a href="#prop与attribute" class="headerlink" title="prop与attribute"></a>prop与attribute</h2><pre><code>1. 以复选框为例，checked表示勾选，其属性值并没有类型之分，都是字符串，只要使用了此属性，
   复选框都会被勾选；
    &lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; /&gt;
    &lt;input type=&quot;checkbox&quot; checked=&quot;true&quot; /&gt;
    &lt;input type=&quot;checkbox&quot; checked=&quot;234&quot; /&gt; &lt;input type=&quot;checkbox&quot; checked /&gt;
2. 标签上固有的属性，称为html预定义属性，如type、check，除此之外，还有html自定义属性；
    &lt;input type=&quot;checkbox&quot; checked=&quot;true&quot; abc=&quot;abc&quot; /&gt; --&gt;abc就是自定义属性
    1. 预定义属性和自定义属性统称为attribute，在元素对象的attributes属性中管理；
    2. JS原生对象的直接属性，被称为property，如attributes
    3. 每一个预定义的attribute都会有一个property与之对应，即attributes中管理的预定义
    属性，在对象的直接属性上也会有一份，但自定义属性不会有；
    元素对象==&gt; {
        attributes: { type:&quot;checkbox&quot;, check:&quot;true&quot;, abc:&quot;abc&quot; },
        type:&quot;checkbox&quot;,
        check:&quot;true&quot;
    }
    4. attributes中管理的属性，是以对象的形式管理的，这些属性对象被称为属性节点，它们都
    具有3个通用的属性，分别是：nodeName、nodeType、nodeValue
    5. 属性节点的nodeType都是2，以type属性为例：&quot;type&quot;, 2, &quot;checkbox&quot;
    6. 操作attributes中的属性：setAttribute()、getAttribute()、removeAttribute()
3. 调试的关键字：debugger
4. attribute与property的关系
    &lt;input type=&quot;checkbox&quot; checked=&quot;true&quot; name=&quot;user&quot; /&gt;
    let pt = document.querySelector(&apos;input[type=checkbox]&apos;)
    1. pt.setAttribute(&apos;checked&apos;, false); --&gt; 操作的是attribute
    2. pt.checked=false; pt[&apos;name&apos;]=&apos;psd&apos;; ---&gt; 操作的是property
    3. 布尔值属性：property是布尔值类型，如checked
    pt.checked=&apos;123&apos;; --&gt;&apos;123&apos;会转为布尔型 --&gt;console.log(pt.checked)--&gt;true
    4. 非布尔值属性：property是非布尔值类型，如name、type
</code></pre><h3 id="attribute与property的同步"><a href="#attribute与property的同步" class="headerlink" title="attribute与property的同步"></a>attribute与property的同步</h3><pre><code>1. 非布尔值属性：attribute与property会立刻实时同步，修改任意一方，另一方也会随之改变；
2. 布尔值属性
    1. 改变property，不会同步修改attribute
    2. 在没有修改过property时，修改attribute，会同步修改property
    3. 一旦修改过property，则不会再同步给attribute
    4. property保存的始终是布尔值，而attribute中保存的则是当前设置的值
    pt.setAttribute(&apos;checked&apos;, &apos;abc&apos;) --&gt;attribute：checked:&apos;abc&apos;
3. 浏览器界面上的操作，影响的是property，还是attributes
    1. 对于非布尔值属性，property和attributes是相互同步的，相对来说，操作attribute的
    成本更低，因为操作property会有一个转换过程；
    2. 鼠标选中/取消复选框，即操作布尔值属性，改变的也是property，不会影响attribute
    3. 即：只有property变化了，浏览器界面上的属性效果才会随之变化，所以操作布尔值属性时，
    务必使用property
</code></pre><h2 id="新增功能"><a href="#新增功能" class="headerlink" title="新增功能"></a>新增功能</h2><pre><code>    &lt;div id=&quot;box&quot; data-test=&quot;123&quot; data-user-name=&quot;Mack&quot;&gt;&lt;/div&gt;
    let node = document.querySelector(&quot;#box&quot;)
1. classList：标签上的CSS选择器的集合
    1. node.classList.add(&quot;test&quot;); --&gt; 添加一个新的选择器test
    2. node.classList.remove(&quot;test&quot;); --&gt; 移出选择器test
    3. node.classList.toggle(&quot;test&quot;); --&gt; 如果有，则移出，反之则添加
2. dataset：标签上的自定义属性的集合
    1. 对于以 data- 开头的自定义属性，都会保存在元素的 dataset 中；
    2. node.dataset.test：获取自定义属性test的属性值，同时可以直接修改此属性值；
    3. 对于 - 连接的自定义属性，必须使用驼峰式操作：node.dataset.userName
    node.dataset[&apos;userName&apos;]，不能使用node.dataset[&apos;user-name&apos;]
    4. node.dataset.password=&apos;abcde&apos;; --&gt;在dataset中新增/修改自定义属性
    5. delete node.dataset[&apos;userName&apos;]; --&gt;删除dataset中的自定义属性
    6. for-in 可以遍历dataset，但for-of不能。
3. attribute操作dataset
    1. node.attributes：获取当前标签显式使用的属性，包括自定义属性；
    2. node.attributes中管理的标签属性，就是标签上的名称，即使是自定义属性，也不会改变
        node.attributes：NamedNodeMap{ id, data-test, data-user-name }
    3. attributes必须使用 for-of 遍历，不能用 for-in
    4. setAttribute()、getAttribute()：也可以操作自定义属性
        node.setAttribute(&apos;data-user-name&apos;, &apos;abc&apos;); --&gt;修改自定义属性
    5. setAttribute(&apos;data-evty&apos;, &apos;12&apos;)：添加自定义属性，因为是以&quot;data-&quot;开头的属性，
    所以该属性也会被 dataset 管理。
4. 让标签内的字符串文本可编辑：contenteditable=&quot;true&quot;
    &lt;div id=&quot;box&quot; contenteditable=&quot;true&quot;&gt;新增标签属性&lt;/div&gt;
</code></pre><h2 id="其他新增标签"><a href="#其他新增标签" class="headerlink" title="其他新增标签"></a>其他新增标签</h2><pre><code>1. &lt;meter&gt;：用于显示已知范围的标量值/分数值，默认样式类似于进度条
    1. value：当前数值
    2. min/max：最小/最大边界值，如果没有设置，默认为0/1
    3. low/high：定义了低值/高值区间的上限值/下限值，value处在低值与高值区间的样式不同
    4. optimum：用于指示最优/最佳的取值。
&lt;meter value=&quot;80&quot; min=&quot;0&quot; max=&quot;100&quot; low=&quot;40&quot; high=&quot;60&quot; optimum=&quot;50&quot;&gt;&lt;/meter&gt;
2. &lt;progress&gt;：用于显示一项任务的完成进度，默认样式为带有单元格的进度条
    1. max：总进度
    2. value：当前完成的进度，如果不设置，进度条不会显示任何进度。
3. 列表标签：datalist、detail、summary
    1. datalist：让input输入框具备可选列表，类似于&lt;select&gt;的列表
    &lt;input type=&quot;text&quot; list=&quot;zdy&quot; /&gt;
    &lt;datalist id=&quot;zdy&quot;&gt; -------------------&gt;通过id属性绑定input
        &lt;option value=&quot;1&quot;&gt;列表标签&lt;/option&gt;
    &lt;/datalist&gt;
    2. detail、summary：展开/折叠
    &lt;detail&gt;
        &lt;summary&gt;用于展开折叠的文本&lt;/summary&gt;
        &lt;p&gt;被折叠的内容&lt;/p&gt;
        &lt;p&gt;被折叠的内容&lt;/p&gt;
    &lt;/detail&gt;
4. 注释标签：ruby、rt，展示文字注音或字符注释
    &lt;span&gt;&lt;ruby&gt;注&lt;rt&gt;zhu&lt;/rt&gt;释单词&lt;/ruby&gt;&lt;/span&gt;  --&gt;&quot;注&quot;的上面会有注音&quot;zhu&quot;
5. 标记标签：&lt;mark&gt;着重内容&lt;/mark&gt;
</code></pre><h3 id="新增表单属性"><a href="#新增表单属性" class="headerlink" title="新增表单属性"></a>新增表单属性</h3><pre><code>1. placeholder：输入框的提示信息，&lt;input type=&quot;text&quot; placeholder=&quot;请输入账号&quot; /&gt;
2. autofocus：指定表单获取输入焦点，布尔值属性，&lt;input type=&quot;text&quot; autofocus /&gt;
3. required：必填项、必选项，不能为空；如果没有内容/选项，在提交表单时会弹框提示；
4. pattern：自定义正则校验，如果不符合正则，提交时会弹框提示；
    &lt;input type=&quot;text&quot; pattern=&quot;\d{1,5}&quot; /&gt;
5. formaction：自定义submit的提交地址；
&lt;form action=&quot;http://www.sina.com&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交1&quot; /&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交2&quot; formaction=&quot;http://www.baidu.com&quot; /&gt;
&lt;/form&gt;
6. list属性与&lt;datalist&gt;：为输入框构造一个选择列表。
</code></pre><h3 id="新增表单type类型"><a href="#新增表单type类型" class="headerlink" title="新增表单type类型"></a>新增表单type类型</h3><pre><code>1. type=&quot;email&quot;：email地址类型，type=&quot;tel&quot;：电话类型，type=&quot;url&quot;：URL地址类型
    1. 它们并不会限制输入内容，只是在输入的内容不符合指定的类型格式时，提交不会成功；
    2. 但是在移动端，它们获得焦点时会弹出对应类型的键盘。
2. type=&quot;range&quot;：可拖动的进度条
    1. min(最小值)、max(最大值)、value(当前值)
    2. step：一步跳动的值，如取值范围0-100，step=&quot;20&quot;，相当于分了5步，每一步跳动20
    &lt;input type=&quot;range&quot; min=&quot;0&quot; max=&quot;100&quot; value=&quot;20&quot; step=&quot;20&quot; /&gt;
3. type=&quot;search&quot;：输入框的内右侧会有一个&quot;x&quot;，用于便捷式清空输入的内容；
4. type=&quot;number&quot;：只允许输入数字，输入框获取焦点时，内右侧会有增大(+1)和减小(-1)的按钮；
5. type=&quot;color&quot;：颜色选择器，可以调出颜色选择的面板；
6. 日期时间：type=&quot;datetime&quot;、&quot;datetime-local&quot;、&quot;date&quot;、&quot;time&quot;、&quot;week&quot;、&quot;month&quot;
</code></pre><h3 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h3><pre><code>1. validity对象：通过注册 invalid 事件，查看验证是否通过；
    input.addEventListener(&quot;invalid&quot;, function(){ this.validity }, false)
    1. 提交表单时，如果验证失败，则会触发此事件；
    2. 在回调函数中，通过 this.validity 获取验证对象。
2. validity.valueMissing：输入内容为空时返回true
    &lt;input type=&quot;text&quot; required /&gt; --&gt;没有输入内容时，valueMissing为true
3. validity.typeMismatch：输入的内容与预期类型不匹配时返回true
    &lt;input type=&quot;email&quot; /&gt; --&gt;输入内容不是Email类型时，typeMismatch为true
4. validity.patternMismatch：输入内容不匹配pattern正则时返回true
5. 鸡肋的属性
    1. tooLong：maxLenght属性已经限制了输入内容的长度，所以不会触发此验证属性
    2. rangeUnderflow、rangeOverflow、stepMismatch：&lt;input type=&quot;range&quot; /&gt;相关
6. validity.customError：不符合自定义验证时，则返回true
    1. setCustomValidity()：用于设置自定义验证的提示内容；
    2. setCustomValidity(&quot;&quot;)：设置为空字符串，表示放行，验证通过；
    &lt;form&gt; &lt;input type=&quot;text&quot; name=&quot;user&quot; id=&quot;user&quot; /&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;/form&gt;
    let name = document.querySelector(&quot;#user&quot;)
    let submit = document.querySelector(&quot;input[type=submit]&quot;)
    submit.onclick = function() {
        if(name.value === &apos;123&apos;) { ---&gt; 当输入框中的内容为&quot;123&quot;时，会弹框提示
            name.setCustomValidity(&apos;请不要输入敏感词&apos;) ---&gt; 设置提示框的内容
            console.log(name.validity) --&gt; validity.customError返回true
        } else {
            name.setCustomValidity(&apos;&apos;)
        }
    }
    3. 验证失败时，会阻止表单继续提交。
7. 关闭验证：formnovalidate属性
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/05/09/CSS3-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/09/CSS3-3/" itemprop="url">CSS3-3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-09T00:00:00+08:00">
                2018-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML/" itemprop="url" rel="index">
                    <span itemprop="name">HTML</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="新增布局"><a href="#新增布局" class="headerlink" title="新增布局"></a>新增布局</h2><pre><code>1. table布局是CSS2中唯一为布局为生的，专门为做布局而生的一套属性；
    1. display:table; 可以将一个元素转为table
    2. 但是，table布局并不是流式的，而div布局是流式的；
    3. 网络数据是以流的形式进行传输，对于流式布局，浏览器接收到一段数据，就可以开始渲染；
    4. table布局则不然，必须等到接受完所有数据，浏览器才能开始渲染，性能极其低下；
    4. 而且，更改table布局中的任何一部分数据，整个table都要重新开始渲染。
2. CSS3为布局而生的扩展：flex布局，响应式布局，多列布局(分栏布局)
</code></pre><h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h2><pre><code>1. 弹性盒子/布局：使页面布局适应不同的屏幕尺寸和不同的显示设备，所以常用于移动端布局；
    1. 弹性盒子模型提供了对块盒子模型的改进，因为它不使用浮动；
    2. flex容器的边缘也不会与其内容的边缘发生折叠。
2. flex布局经历了2个版本：老版本display:box; 新版本display:flex;
    1. Android4.4之前只支持老版本，4.4开始支持新版flex；
    2. Less、Sass和Stylus是CSS预处理器，使CSS可以工程化开发；
    3. PostCSS是CSS后处理器，但它像是一种插件系统，用于处理CSS的兼容性问题；
    4. Autoprefixer就是PostCSS的一个非常受欢迎的插件。
3. flex布局在容器上声明，作用于容器中的子元素，且新版与老版的布局效果是不同的；
    &lt;div id=&quot;box&quot;&gt; ---&gt; 容器
        &lt;div class=&quot;item&quot;&gt;1&lt;/div&gt; ---&gt; 项目
        &lt;div class=&quot;item&quot;&gt;2&lt;/div&gt;
        ......
    &lt;/div&gt;
    #box {
        display: -webkit-box;  --&gt; 老版
        display: flex; --&gt; 新版
    }
    1. 容器内管理的子元素称为项目，容器与项目上分别使用不同的flex属性；
    2. flex布局中存在两条坐标轴：主轴、侧轴，由flex-direction/-webkit-box-orient控制
    3. 当指定X轴为主轴时，Y轴为侧轴，反之亦然！项目永远排列在主轴的正方向上！
4. 富裕空间：容器box的宽高为(400px,400px)，每个项目的宽高为(50px,50px)，共用4个项目；
    1. 假设项目的margin都是0px，X轴为主轴，那么主轴的富裕空间为(400-50*4=200px, 50px)
    2. 侧轴的富裕空间为(width:400px, height:400-50=350px)
</code></pre><h3 id="了解老版本的容器"><a href="#了解老版本的容器" class="headerlink" title="了解老版本的容器"></a>了解老版本的容器</h3><pre><code>1. 尽管PostCSS的插件系统可以处理大部分CSS3的兼容性问题，但仍需要了解以下老版flex布局；
2. 容器中的布局方向：-webkit-box-orient
    1. -webkit-box-orient的本质是确定X轴和Y轴中的哪一根为主轴，默认是X轴；
    2. -webkit-box-orient: horizontal(X轴)/vertical(Y轴);
    3. 项目排列在主轴上，主轴改变了，项目的排列位置也随之改变！
3. 容器中的排列方向：-webkit-box-direction，用于控制主轴的正方向
    1. -webkit-box-direction: normal/reverse(反向);
    2. 项目沿着主轴的正方向排列，主轴的正方向改变了，项目的排列方式也随之改变。
4. 富裕空间管理：-webkit-box-pack(主轴)，-webkit-box-align(侧轴)
    1. 它们不会给项目去分配任何空间，只是用于确定富裕空间的位置；
    2. 老版本管理富裕空间的位置与主轴/侧轴的正方向无关，造成新老版本的项目排列位置不同。
5. -webkit-box-pack: start/end/center/justify; --&gt; 管理主轴的富裕空间
    1. X轴是主轴：在主轴的右边(start)/左边(end)/两边(center)/项目之间(justify)
    2. Y轴是主轴：在主轴的下面(start)/上面(end)/两边(center)/项目之间(justify)
6. -webkit-box-align: start/end/center; --&gt; 管理侧轴的富裕空间
    1. X轴是侧轴：在侧轴的右边(start)/左边(end)/两边(center)
    2. Y轴是侧轴：在侧轴的下面(start)/上面(end)/两边(center)
</code></pre><h3 id="新版本的容器"><a href="#新版本的容器" class="headerlink" title="新版本的容器"></a>新版本的容器</h3><pre><code>1. 容器中的布局方向和排列方向：flex-direction
    1. flex-direction: row/column/row-reverse/column-reverse;
    2. row、row-reverse：主轴为x轴，正方向分别是从左往右、从右往左
    3. column、column-reverse：主轴为y轴，正方向分别是从上往下、从下往上
2. 富裕空间管理：justify-content，align-items
    1. justify-content、align-items分别管理主轴、侧轴的富裕空间；
    2. 富裕空间的位置与主轴/侧轴的正方向有关。
3. justify-content：管理主轴的富裕空间
    1. flex-start/flex-end：富裕空间在主轴的正方向上/反方向上；
    2. center：在主轴的两边，即项目会在主轴上居中显示；
    4. space-between：在项目之间，第一个和最后一个分别只有一边有富裕空间；
    5. space-around：富裕空间在项目两边，每个项目的两边都有富裕空间；
4. align-items：管理单行/列项目时侧轴的富裕空间
    1. flex-start/flex-end/center：富裕空间在侧轴的正方向/反方向/两边；
    2. baseline：按基线对齐，基线是line-height的相关概念；
    3. stretch：默认值，等高布局，如果项目没有设置高度，则把它们拉伸到相同的高度。
5. flex-wrap：当容器的主轴空间不足时，控制项目是否换行；
    1. nowrap：默认值，不换行，压缩项目的宽度/高度，不让它们超出容器；
    2. wrap/wrap-reverse：换行，以行为单位、沿着侧轴的正/反方向排列；
    3. 换行时，默认会等分侧轴的富裕空间，此时由align-content属性管理侧轴的富裕空间。
6. align-content：管理多行/列项目时的侧轴富裕空间，只有一行/列则无效；
    1. 属性值：flex-start/flex-end/center/space-between/space-around/stretch
    2. 只有在设置了flex-wrap:wrap/wrap-reverse; 设置的align-content才有效。
7. flex-flow：flex-direction和flex-wrap的简写形式，默认值row nowrap
</code></pre><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><pre><code>1. order：默认值为0，数值越大，项目越靠后排列，精确控制每个项目的排列顺序，如order:5;
2. align-self：管理单个项目的侧轴富裕空间
    1. 属性值：auto/flex-start/flex-end/center/baseline/stretch
    2. auto：默认使用容器上的align-items属性值，如果容器上没有设置，则使用stretch
    3. 多行项目时，align-self相对于当前行的侧轴富裕空间，且优先级小于align-content
    4. 单行时，align-self的优先级大于align-items
</code></pre><h4 id="弹性空间管理"><a href="#弹性空间管理" class="headerlink" title="弹性空间管理"></a>弹性空间管理</h4><pre><code>1. flex-grow、flex-shrink、flex-basis
2. flex-grow：定义弹性盒子(项目)的拉伸因子，默认值为0
    flex-grow: 1; --&gt;对应的老版本：-webkit-box-flex: 1;
    1. 把主轴上的富裕空间按比例分配到每个项目的width(X轴)/height(Y轴)上；
    2. 属性值为弹性因子，也就是分配富裕空间时所占的权重、比例，弹性因子越大，分配越多。
3. flex-shrink：收缩因子，容器空间不足时，指定项目被压缩的比例(项目不能换行)，默认值为1
4. flex-basis：项目在主轴的方向的初始大小，也就是伸缩的基准值
    1. 默认值是auto，但在flex简写属性中，默认值为0
    2. X轴为主轴时，如果没有设置项目的flex-basis，那么flex-basis的值为项目的width
5. flex-grow的拉伸规则(X轴为主轴)
    1. 可用空间 = 容器大小 - 所有相邻项目flex-basis的总和
    2. 可扩展空间 = 可用空间 / 所有相邻项目flex-grow的总和
    3. 每个项目伸缩后的真实大小 = flex-basis + 可扩展空间 x flex-grow
    &lt;div id=&quot;box&quot;&gt; ---------&gt; #box{ width:400px; height:300px; display:flex; }
        &lt;div&gt;11&lt;/div&gt; &lt;div&gt;22&lt;/div&gt; &lt;div&gt;33&lt;/div&gt; &lt;div&gt;44&lt;/div&gt; &lt;div&gt;55&lt;/div&gt;
    &lt;/div&gt; --------------&gt; #box &gt; div{ width:50px; height:50px; flex-grow:1; }
    #box &gt; div:nth-child(1){ flex-grow:4; }
    1. 可用空间 = 400 - 5*50 = 150px
    2. 可扩展空间 = 150/(1*4+4) = 18.75px
    3. 第1项伸缩后的width：50 + 18.75 * 4 = 125px
    4. 第2/3/4/5项伸缩后的width：50 + 18.75 * 1 = 68.75px
6. flex-shrink的收缩规则(X轴为主轴)
    1. 计算收缩因子与基准值乘的总和 = 所有项目的(flex-basis x flex-shrink)之和
    2. 计算收缩因数 = 项目的收缩因子 x 项目flex-basis / 收缩因子与基准值乘的总和
    3. 每个项目需要减去的大小 = 收缩因数 x 项目溢出容器的大小
    #box{ width:100px; height:300px; display:flex; }
    #box &gt; div{ width:50px; height:50px; flex-shrink:1; }
    #box &gt; div:nth-child(1){ width:200px; }
    1. 收缩因子与基准值乘的总和 = 200*1 + 50*1*4 = 400
    2. 第1项的收缩因数 = 1*200/400 = 1/2，第2/3/4/5项的收缩因数 = 1*50/400 = 1/8
    3. 第1项需要减去的大小 = 1/2 * (200 + 50*4 - 100) = 150px
    4. 第2/3/4/5项需要减去的大小 = 1/8 * (200 + 50*4 - 100) = 37.5px
    5. 第1项收缩后的width = 200 - 150 = 50px
    6. 第2/3/4/5项收缩后的width = 50 - 37.5 = 12.5px
7. flex-shrink收缩规则的前提(X轴为主轴)
    1. flex-shrink不会把项目的width缩减为0，flex布局会考虑项目的内容；
    2. 如果项目中的内容宽度大于最终收缩后的项目宽度，那么项目的实际宽度就是内容所占的宽度，
    至于多占用的宽度，会让其他项目一起承担；
    3. 所以，在设计flex布局时，需要精确考虑项目中的内容，不能太多；
    4. 老版本并没有这些专用控制伸缩的属性，在老版本上有可能把项目收缩为0
8. flex的简写属性
    1. flex: 1; --&gt; flex-grow:1; flex-shrink:1; flex-basis:0%;
    2. flex: 1; 实现等分布局，每个项目在主轴上的width/height是相同的；
    2. flex实现有规律的布局极其简单，如等比例、等分、居中... ，所以在移动端大行其道。
</code></pre><h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><pre><code>1. CSS3的媒体查询是响应式布局方案的核心技术，媒体查询选择器以 @media 开头；
2. 媒体查询选择器不会对CSS的特殊性有任何贡献，即不会影响选择器的优先级。
</code></pre><h3 id="媒体类型"><a href="#媒体类型" class="headerlink" title="媒体类型"></a>媒体类型</h3><pre><code>1. all(所有媒体，默认)，screen(彩色屏幕)，print(打印预览)
2. projection(手持设备)，tv(电视)，braille，embossed，speech，tty...
3. PC端、移动端都是彩色屏幕，属于screen的范围
    @media screen { --&gt;定义彩色屏幕上的选择器样式，类似于if-else条件表达式
        #wrap{ background:red; } --&gt;在彩色屏幕上，id选择器wrap上的背景色为red
    }
</code></pre><h3 id="媒体属性"><a href="#媒体属性" class="headerlink" title="媒体属性"></a>媒体属性</h3><pre><code>1. width、height：浏览器窗口的宽度、高度，可以加max、min前缀，height很少使用
    @media screen and (min-width:800px) {
        #wrap{ background:red; } --&gt;彩色屏幕且浏览器窗口的宽度&gt;=800px时，样式生效
    }
2. device-width：设备宽度，屏幕分辨率，如1280X720，可以加max、min前缀
    @media screen and (min-device-width:1280px) { ... }
    1. 彩色屏幕且设备分辨率的宽度&gt;=1280px时，样式生效
3. device-pixel-ratio：像素比，DPR，必须加webkit前缀，也可以加max、min前缀
    @media screen and (-webkit-min-device-pixel-ratio:1) { ... }
    1. 彩色屏幕且DPR&gt;=1时，样式生效
4. orientation：portrait(竖屏width=&lt;height)，landscape(横屏width&gt;height)
    @media screen and (orientation:landscape) { ... }
    1. 彩色屏幕且浏览器窗口为横屏时，样式生效
</code></pre><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><pre><code>操作符/关键字：only，and，or，not
1. and、or、not：连接媒体类型与媒体属性，分别表示与、或、非；其中，or用&quot;,&quot;表示
    @media screen and (max-width:800px), (orientation:landscape) { ... }
    1. 彩色屏幕且浏览器窗口的宽度&lt;=800px时生效，亦或者屏幕为横屏时生效；
    2. or(,)后面只有媒体属性，没有声明媒体类型，则默认媒体类型为all
2. only：与浏览器的兼容性有关，老版本浏览器只支持媒体类型，不支持带有媒体属性的选择器
    @media screen and (min-width:800px){ ... }
    1. 老版本浏览器会解析为：@media screen { ... } --&gt;在老版本浏览器中，不管浏览器窗口
    的宽度是否&gt;=800px，样式始终生效
    2. 老版本浏览器只识别到 @media 后的第一个标识符，如果该标识符不属于媒体类型，则忽略
    @media only screen and (width:800px){ } --&gt;老版本浏览器解析为：@media only { }
    3. only不属于媒体类型，该媒体查询会被老版本浏览器忽略，该媒体查询选择器不会生效；
    4. 防止老旧浏览器不支持带媒体属性的查询，所以建议在媒体查询时都加上only
3. not
    @media not screen and (width:800px), (orientation:landscape) { ... }
    1. 生效条件：(不是彩色屏幕 || 浏览器尺寸!=800px) || (屏幕为横屏)
    2. 老版浏览器会解析成 @media not{ }，而not不属于媒体类型，所以该媒体查询选择器也不会
    生效，也就不需要再加only
</code></pre><h2 id="多列布局"><a href="#多列布局" class="headerlink" title="多列布局"></a>多列布局</h2><pre><code>&lt;div id=&quot;box&quot;&gt;多列布局······分栏布局······多列布局······分栏布局&lt;/div&gt;
#box{ width:600px; border:1px solid #000000; }
1. 栏目宽度：column-width，指定每一列的宽度
    1. column-width: 100px; --&gt;每一列的宽度为100px
    2. 尽管指定了每一列的宽度，但很难均分容器的width，最后分出来的列数可能只有5列
2. 栏目列数：column-count，指定需要分成多少列
    1. column-count:3; --&gt;把容器的内容分为3列
    2. 比column-width更友好、更强大，只需要指定列数，每一列的宽度会自动配分
3. 列与列的间距：column-gap，列与列之间的距离
4. 列与列的分割线：column-rule，列与列之间添加分割线，并设置分割线的样式
    column-rule: 1px solid red;
</code></pre><h2 id="CSS3的兼容性前缀"><a href="#CSS3的兼容性前缀" class="headerlink" title="CSS3的兼容性前缀"></a>CSS3的兼容性前缀</h2><pre><code>1. -ms-：兼容IE
2. -moz-：兼容firefox
3. -o-：兼容opera
4. -webkit-：兼容chrome和safari
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/05/08/CSS3-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/08/CSS3-2/" itemprop="url">CSS3-2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-08T00:00:00+08:00">
                2018-05-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML/" itemprop="url" rel="index">
                    <span itemprop="name">HTML</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h2><pre><code>1. transition：过渡动画
    1. CSS的效率极高，速度极快，为此，CSS transition提供了一种在更改CSS属性时，控制动画
    速度的方法，它让属性变化持续一段时间，而不是立即生效；
    2. 比如，改变一个元素的颜色时，可以用transition逐渐从原色变为目标色；
    3. 对于transition作用的属性，不管以哪种方式发生了变化，即使是JS操作，也会执行；
    4. 但是，并不是所有的属性变化都支持transition，比如display:none;
    5. transition只关心元素的初始状态和结束状态，无法定制过渡动画中的每一帧状态。
2. transition-property：指定使用过渡的属性，可指定多个，默认为all(所有变化的属性)
3. transition-duration：动画执行的时间，必须以秒(s)和毫秒(ms)为单位，默认值为0s
    &lt;div id=&quot;wrap&quot;&gt; &lt;div id=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt;
    #wrap { width:600px; height:600px; border:1px solid red; }
    #inner { width:200px; height:200px; background:red; }
    1. 鼠标悬浮在wrap上时，让inner的宽高变小
    #wrap:hover #inner{ width:100px; height:100px; background:green; }
    2. 让wrap的宽度变化有过渡动画，且动画时间为5s
    #inner{ transition-property:width; transition-duration:5s; }
    3. 动画会执行两次，分别是悬停在wrap上(hover事件)、移出wrap(恢复初始状态)
    4. -duration的复制原理：当指定的属性列表大于时间列表时，时间列表会拷贝一份
    transition-property: width,height,background;
    transition-duration: 5s,2s; --&gt; 5s,2s,5s,2s --&gt; 最后一个2s会被裁剪
    5. 时间列表中有任何一个值不加单位，整个动画机制都会失效。
4. transition-timing-function：变化的过程，变化速率的曲线，默认ease(加速然后减速)
    1. 如果速率列表小于属性列表，缺少的速率会被设置为默认值ease，反之会被裁剪；
    2. liear(匀速)、ease-in(加速)、ease-out(减速)、ease-in-out(加速然后减速)
    3. cubic-bezier(贝塞尔曲线)、step-start、step-end、steps(number, ...)
    4. step-start、step-end分别等同于steps(1,start)、steps(1,end)
    5. steps(start, end)：第一个参数必须是正整数，表示函数的步数，第二个值表示每一步发生
    变化的时间点，默认值end
5. transition-delay：动画执行的延迟时间，复制原理与-duration相同；
6. 过渡动画的完成事件
    1. 标准浏览器下的完成事件是transitionend，而webkit下是webkitTransitionEnd
    2. 每一个拥有过渡动画的属性，在完成动画时都会分别触发一次transitionend事件；
    3. 在过渡动画完成之前，设置display:none; 不会再触发transitionend事件。
7. transition的天然缺陷
    1. 缺陷一：动画是浏览器的渲染机制进行渲染的，其渲染速度要小于CSS、JS的解析速度
    #inner { transition-property:width; transition-duration:2s; }
    #wrap:hover #inner{ transition-property:height; --&gt;修改过渡动画作用的属性
        width:100px; height:100px; }
    2. hover事件迅速修改了transition作用的属性，等到浏览器的渲染机制执行动画时，发现使用
    过渡动画的属性是height，所以对height执行transition动画；
    3. 鼠标移出wrap时，transition作用的属性又恢复为width，所以渲染机制对width执行动画。
    2. 缺陷二：transition在元素首次渲染还没有结束的情况下，是不会被执行的；
    let inner = document.querySelector(&quot;#inner&quot;)
    inner.style[&apos;width&apos;] = &apos;100px&apos; --&gt;虽然放在&lt;body&gt;之后执行，但也不会触发动画
    3. JS要触发transition，必须在window.onload的回调函数中执行，等待页面渲染完成。
8. transition的简写：transition: property,duration,timing-function,delay
    1. 同时设置多个属性：transition: 2s 3s width, 3s height;
    2. 第一个时间被解析为动画执行的时间，第二个时间被解析为动画的延迟时间；
    3. width的动画时间为2s，延迟时间为3s，height的执行时间为3s，延迟时间为0s
</code></pre><h2 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h2><pre><code>1. transform：变形，2D变换，只对块级元素有效；
2. transform是静态效果，并不会有过渡动画，需要配合transition属性；
3. 旋转：transform: rotate(360deg);
4. 平移
    1. 水平移动：transform: translateX(200px); --&gt; 向右平移200px
    2. 垂直移动：transform: translateY(400px); --&gt; 向下平移400px
    3. 指定坐标点的移动：transform: translate(100px,100px); --&gt;坐标(100,100)
    4. 设置为负值表示反向移动，translate()只设置一个值时，表示Y轴为0px
    5. translate(x,y)使用百分比时，分别参照自身的width和height
5. 斜切：skewX(45deg)、skewY(45deg)、skew(45deg, 45deg)
    transform: skewX(45deg); --&gt;沿X轴斜切45°，支持负值
6. 缩放：scale()、scaleX()、scaleY()
    1. 缩小的范围为0-1，放大的范围则大于1，负值有旋转效果，不推荐使用；
    transform: scaleX(.5); --&gt; 0.5, 缩小一倍
    2. scale(x, y)：只设置一个值时，表示x与y相等。
7. 基点的变换：transform-origin，改变元素变形的基点
    1. 支持关键字：left、right、top、bottom、center
    #inner{ transition:2s; transform-origin:left top; } -&gt;以盒子左上角为基点
    2. 也支持px值和百分比，以盒子的左上角为原点(0, 0)
    #inner{ transition:2s; transform-origin:10px 10px; } -&gt;基点(10,10)
    3. 旋转、斜切、缩放的基点默认都是盒子的中心点(50%,50%)
8. transform不会影响文档流，盒子的位移、缩放等不会改变相邻盒子的位置，性能更高。
</code></pre><h3 id="变换组合"><a href="#变换组合" class="headerlink" title="变换组合"></a>变换组合</h3><pre><code>1. 所有2D变换的底层实现都是依靠矩阵：transform: matrix(a,b,c,d,e,f);
    1. 平移对应的矩阵：transform: matrix(1,0,0,1,X,Y);
    2. transform: matrix(1,0,0,1,300,0); --&gt;平移300px
2. 变换组合的底层渲染就是矩阵计算，且矩阵计算的方向是从右向左
    transform: translateX(100px) scale(0.5); --&gt;平移与缩放的组合
    1. 原理：先计算缩放的矩阵，再计算位移的矩阵，且矩阵的运算是不可逆的；
    2. 组合变换的位置不同，矩阵的计算结果也不同，展现的过程和结果也不相同。
3. 在切换组合变换的样式时，必须保证组合变换的个数、位置相同，否则可能不会执行过渡；
    if(flag) {
        box.style.transform = &apos;rotate(-720deg) scale(1)&apos;
    } else {
        box.style.transform = &apos;rotate(0deg) scale(1)&apos;
    }
4. 扇形导航：定位、transform、勾股定理、三角函数、角度与弧度的转化
5. 时钟：通过JS批量处理HTML节点与style样式，transform-origin改变元素变换的基点
</code></pre><h2 id="3D变换"><a href="#3D变换" class="headerlink" title="3D变换"></a>3D变换</h2><pre><code>1. 3D变换：3D缩放、3D旋转、3D平移
2. 3D旋转
    1. transform: rotate(360deg); 默认就是按照Z轴旋转，等同于rotateZ(360deg);
    2. rotateX(360deg); rotateY(360deg); 分别按照X轴、Y轴旋转
    3. rotate3d(x,y,z,deg)：(x,y,z)表示3D空间的一个点，坐标原点到(x,y,z)形成一条射线，
    元素按照这条射线旋转。
3. 3D平移
    1. transform: translateZ(100px); Z轴不支持百分比，只有X轴和Y轴支持；
    2. translate3d(x,y,z);
4. 3D缩放：transform: scaleZ(2);
</code></pre><h3 id="景深"><a href="#景深" class="headerlink" title="景深"></a>景深</h3><pre><code>1. 景深：激活3D空间，元素会有近大远小的效果，营造立体空间感
    1. 简单讲，景深就是肉眼距离显示器的距离，景深越大，元素离眼睛越远，反之越近；
    2. 景深是不可继承属性，但其所有的后代元素都会受影响，应用景深的元素称为舞台元素。
2. 两种使用方式：transform:perspective(depth);  perspective:depth;
    1. transform:perspective(depth); 直接作用的当前元素本身，且必须放在transform的
    第一个位置，否则会被忽略；
    2. perspective:depth; 作用在子元素上，使用该属性的元素只是作为一个包裹器；
    3. depth的默认值为none，可以设置一个px值，表示沿着Z轴到坐标原点的距离。
3. 原理：景深越大，灭点越远，元素变形越小，反之亦然；
    1. 灭点：元素变形后，一直向远处的方向，会有一个交叉点，称之为灭点
    2. 以火车铁轨为例，一直沿着铁轨向远处眺望，会发现两条铁轨逐渐靠近，最终交叉成一个点。
4. perspictive-origin：控制景深的基点，默认值是盒模型宽高的(50% 50%)
5. 景深叠加
    1. 如果当前元素已经使用了景深，其后代元素也应用了景深，效果会叠加，而不是覆盖；
    2. 每款浏览器的景深叠加是不同的，所以尽量避免景深叠加，后代元素不要再使用景深。
</code></pre><h3 id="3d舞台"><a href="#3d舞台" class="headerlink" title="3d舞台"></a>3d舞台</h3><pre><code>1. 3D舞台：只有近大远小的效果是不够的，需要营造具有层级的3d舞台；
2. transform-style：3D舞台，不可继承，作用于子元素，而不是元素自身；
    transform-style: preserve-3d;
3. backface-visibility：是否显示元素的背面，默认值visible(显示)，hidden(隐藏)
    1. 对于立体的元素，设置了透明度后，可以看到其他位面，此属性可以隐藏其他位面；
    2. 以立方体为例，隐藏其他位面之后，只保留正向的位面。
</code></pre><h4 id="transition旧版"><a href="#transition旧版" class="headerlink" title="transition旧版"></a>transition旧版</h4><pre><code>待整理
1. transition-property：设置过度的属性，比如width、height、background-color；
2. transition-duration：设置过度的时间，比如 1s，500ms；
3. transition-timing-function：设置过度的运动方式；
    1. linear 匀速；ease 开始和结束慢速；ease-in/ease-out 开始/结束是慢速；
    2. ease-in-out 开始和结束时慢速；cubic-bezier(n,n,n,n) 设置曲线；
4. transition-delay：设置动画的延迟；
5. 复合属性的设置：transition:property duration timing-function delay;
6. 动画播放：
    1. 为盒子添加hover事件，当鼠标悬停在盒子上时，开始播放动画；
    1. width、height、background-color、border-radius的播放顺序与排列顺序有关；
    2. 每种动画同时播放：transition:all 500ms ease;
    3. 曲线设置的网站：https://matthewlein.com/tools/ceaser
</code></pre><h4 id="transform旧版"><a href="#transform旧版" class="headerlink" title="transform旧版"></a>transform旧版</h4><pre><code>待整理
1. translate(x, y)：盒子位移到(x, y)的像素坐标点，单位是px；
    1. 三维移动：translateX(10px)、translateY(10px)、translateZ(10px)
2. scale(x, y)：盒子缩放，x=y=1，表示原始大小，x=y=0.5，表示盒子大小的一半；
3. rotate(x)：盒子旋转，x表示角度，单位是deg，支持正负值，默认是Z轴旋转；
    1. 三维旋转：rotateX(30deg)、rotateY(30deg)、rotateZ(30deg)
4. skew(x, y)：斜切，x、y表示X轴和Y轴斜切的角度，单位是deg；
5. perspective(x)：设置透视距离，单位是px；
    1. 三维操作需要配合透视距离才能显现效果，特征：近大远小；
    2. 通常设置为800px，更容易欺骗眼睛。
6. transform-style：盒子是否按3D空间显示，flat/perserve-3d；
8. backface-visibility：设置盒子背面是否可见，默认可见visible，hidden表示不可见；
    1. rotateY(180deg)：盒子沿Y轴旋转180度，若设置背面不可见，盒子会隐藏；
</code></pre><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><pre><code>1. animation：动画，作用的元素一旦加载就会执行动画，不会等待页面完全渲染；
    1. 人类具有视觉暂留的特性，人的眼睛在看到一幅画或一个物体后，在0.34s内不会消失；
    2. 动画的原理：把人物的表情、动作、变化等分解后，画成许多动作瞬间的画幅，利用视觉暂留的
    特性，在一幅画消失之前，播放下一幅画，就会给人造成一种流畅的视觉变化效果。
    3. CSS3动画：将元素从一个样式逐渐过渡到另一种样式的效果。
2. @keyfrmes 关键帧(动画的标识) { from{ //动画的初始状态 }  to{ //动画的结束状态 } }
</code></pre><h3 id="动画属性"><a href="#动画属性" class="headerlink" title="动画属性"></a>动画属性</h3><pre><code>1. animation-name：关键帧的名称，none表示无关键帧；
2. animation-duration：动画的时间，默认值为0s，表示无动画，单位为s、ms
    &lt;div id=&quot;box&quot;&gt;&lt;/div&gt; --&gt;div{ width:100px; height:100px; }
    #box{ animation-name:move; animation-duration:3s; }
    @keyframes move { ---&gt; 旋转360°的动画关键帧
        from{ transform: rotate(0deg); }
        to{ transform: rotate(360deg); }
    }
3. animation-timing-function：动画的执行函数，默认是由慢变快再变慢
    1. linear：线性过渡，等同于贝塞尔曲线(0, 0, 1, 1)
    2. ease：平滑过渡，等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0)
    3. ease-in：慢-&gt;快，等同于贝塞尔曲线(0.42, 0, 1, 1)
    4. ease-out：快-&gt;慢，等同于贝塞尔曲线(0, 0, 0.58, 1)
    5. ease-in-out：慢-&gt;快-&gt;慢，等同于贝塞尔曲线(0.42, 0, 0.58, 1)
    6. steps(n, start|end)：第一个参数表示把动画分成n等分，第二个参数默认为end
4. animation-delay：动画执行的延迟时间，属于动画外的范畴；
5. animation-iteration-count：动画的执行次数，重复执行的是关键帧，from-&gt;to
    1. 与name、duration、function都是属于表示动画内的范畴；
    2. 动画的执行时间为1s，执行次数为3，延迟时间为1s，那么动画只会在开始时延迟1次，重复时
    不会再延迟；
    3. infinite：无限循环。
6. animation-direction：动画执行的方向，默认值normal，reverse表示反向
    1. reverse反向的是关键帧和执行函数，关键帧：to-&gt;from，ease-in：快-&gt;慢
    2. alternate：执行次数大于1时，让动画连续执行，from-&gt;to-&gt;from-&gt;to-&gt;from-&gt;...
    3. alternate-reverse：to-&gt;from-&gt;to-&gt;from-&gt;to-&gt;...
7. animation-fill-mode：元素在动画外的状态，默认情况下，动画执行完还会回到元素的初始状态
    1. backwards：元素的初始状态与from中定义的状态保持一致；
    2. forwards：动画执行结束后，元素的状态与to中定义的状态保持一致；
    3. both：元素的初始状态和结束状态分别与from、to中定义的状态保持一致。
8. animation-play-state：动画的执行与暂停，paused(暂停)，running(执行)
    #box:hover { animation-play-state:parsed; } --&gt;鼠标悬停在box上时，动画暂停
9. 简写属性：animation: name duration function delay count direction mode state;
    1. 第一个time会分配给duration，第二个time会分配给delay
    2. animation: 2s 3s; --&gt; 动画执行时间为2s，延迟时间为3s
</code></pre><h3 id="关键帧"><a href="#关键帧" class="headerlink" title="关键帧"></a>关键帧</h3><pre><code>1. 关键帧：@keyframes
    @keyframes name {
        keyframes-selector { css声明; }
    }
    1. name：动画的名称，必选项；
    2. keyframes-selector：动画持续时间的百分比，from相当于0%，to相当于100%
    @keyframes move {
        0% { transform: translateY(-100px); } --&gt;动画的初始状态
        50% { transform: translateY(-50px); } --&gt;动画时间执行50%时的状态
        100% { transform: translateY(100px); } --&gt;动画时间执行结束时的状态
    }
    1. animation-timing-function作用于一个动画周期，而非整个动画周期；
    2. 0% -&gt; 50%，50% -&gt; 100% 表示两个动画周期
2. animation-timing-function: steps(n, start|end);
    @keyframes move {
        0%{ transform: translateY(-100px); }
        25%{ transform: translateY(-90px); }
        50%{ transform: translateY(0px); }
        75%{ transform: translateY(90px); }
        100%{ transform: translateY(100px); }
    }
    animation: move 4s both running 3 alternate steps(1, end);
    1. n：表示把一个动画周期分成n步执行，1 表示一步执行完，跳变执行，没有过渡动画；
    2. 执行时间为4s，执行次数为3，那么总的动画执行时间为3*4s=12s
1. steps(1, end)的执行过程：
    0% 等待1s -&gt; 25% 等待1s -&gt; 50% 等待1s -&gt; 75% 等待1s =&gt; 动画执行1次=&gt; 75% 等待1s
    -&gt; 50% 等待1s -&gt; 25% 等待1s -&gt; 0% 等待1s =&gt; 执行2次=&gt; 0% 等待1s -&gt; 25% 等待1s-
    -&gt; 50% 等待1s -&gt; 75% 等待1s =&gt; 执行3次=&gt; 100% =&gt; 动画结束
    1. 动画执行1次结束、开始执行第2次时，还会在75%的状态等待1s，相当于在75%等待了2s
    2. 同理，第2次执行结束、开始执行第3次时，也会在0%再等待1s
    3. 其实，第3次执行结束后，动画已经结束了，但因为animation-fill-mode:both; 所以元素
    最后的状态必须处在最后一帧，即100%的状态；
    4. 综上所述，end是看不到最后一帧的，也就是100%时的状态。
2. steps(1, start)的执行过程：
    25% 等待1s -&gt; 50% 等待1s -&gt; 75% 等待1s -&gt; 100% 等待1s =&gt; 执行1次 =&gt; 100% 等待1s
    -&gt; 75% 等待1s -&gt; 50% 等待1s -&gt; 25% 等待1s =&gt; 执行2次=&gt; 25% 等待1s -&gt; 50% 等待1s
    -&gt; 75% 等待1s -&gt; 100% 等待1s =&gt; 动画结束
    1. 动画开始执行时，已经从0%跳变到25%，所以在这个动画的执行过程中，都没有0%的状态；
    2. 所以，start是看不到第一帧的，也就是0%时的状态。
3.steps()的跳变动画，可用于实现连环画的效果，比如GIF表情包
    1. 以微信的兔斯基表情为例，一张连续动作的静态图片，假设一共12个动作，加上最后一张空白
    2. 把图片设置为background-image的属性值，再通过animation修改background-position
    @keyframes move { from{} to{}}
    3. steps(12, end)：把 from-&gt;to 的一个周期划分为12步，即12帧，再设置次数为infinite
    4. end看不到最后一帧，但动作表情是12个，第13个是空白，用于占位，所以刚好看不到第13帧
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/05/07/CSS3-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/07/CSS3-1/" itemprop="url">CSS3-1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-07T00:00:00+08:00">
                2018-05-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML/" itemprop="url" rel="index">
                    <span itemprop="name">HTML</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><pre><code>1. 基本选择器的扩展
    1. E &gt; F { ... }：直接后代选择器，匹配E的直接后代F，第一层级的子元素；
    2. E + F：相邻兄弟选择器，只匹配与E相邻的下一个兄弟F；
    3. E ~ F：通用兄弟选择，匹配E的所有兄弟F；
    4. 测试时不能使用可继承的属性，如color，必须使用不可继承的属性。
2. CSS没有版本之分，只有级别，CSS3指的是CSS的第三个级别；
3. 属性选择器
    1. E[attr]：使用了选择器E，且使用了属性attr，如#box[name]{ color: #0000ff; }
    2. E[attr=&quot;val&quot;]：属性名为attr，且属性值为val，如div[name=&quot;box&quot;]{ ... }
    3. E[attr~=&quot;val&quot;]：属性值是一个以空格作为分割的列表，其中至少一个值为val
    &lt;div name=&quot;box cnb cty&quot; class=&quot;test&quot;&gt;&lt;/div&gt; ===&gt; .test[name~=&quot;cnb&quot;]{...}
    4. E[attr|=&quot;val&quot;]：attr的属性值为val，或以&quot;val-&quot;开头；
    5. E[attr^=&quot;val&quot;]：属性值以&quot;val&quot;开头；
    6. E[attr$=&quot;val&quot;]：属性值以&quot;val&quot;结尾；
    7. E[attr*=&quot;val&quot;]：属性值的字符串中包含&quot;val&quot;
    8. E并不是属性选择器的构成部分，也是选择器，是为了限制属性选择器的作用范围。
</code></pre><h3 id="伪类与伪元素选择器"><a href="#伪类与伪元素选择器" class="headerlink" title="伪类与伪元素选择器"></a>伪类与伪元素选择器</h3><pre><code>1. 伪类：并存在于DOM树中，只是为了让CSS有能力获取DOM节点以外的元素状态；
2. 链接伪类：只能应用与&lt;a&gt;，:link、:visited、:target(选中锚点URI对应的id样式)
    a:link{ color: black; } --&gt;未访问过的样式
    a:visited{ color: red; } --&gt;访问过的样式，必须清除浏览器的历史纪录才能还原样式
    1. :visited与浏览器地址栏上的URL有关，如果&lt;a href=&quot;javascript:;&quot;&gt;，点击&lt;a&gt;，
    地址栏的URL是不变的，即浏览器不认为&lt;a&gt;被访问过，那么:visited也不会相应；
    2. 与href=&quot;javascript:;&quot;不同，href=&quot;#&quot;虽然也能阻止&lt;a&gt;的默认跳转，但地址栏的URL
    尾部会添加&quot;#&quot;，:visited也会响应；
    3. :visited中只有3个样式属性有效：color、background-color、border-color
    4. :target：href=&quot;#box&quot;时，地址栏URL后会添加&quot;#box&quot;，:target则匹配id=&quot;box&quot;的
    元素，同理，点击&lt;a href=&quot;box2&quot;&gt;，:target又会重新匹配id=&quot;box2&quot;的元素；
    :target{ color: green; }
    &lt;div id=&quot;box&quot;&gt;BOX&lt;/div&gt; &lt;a href=&quot;#box&quot;&gt;ToBox&lt;/a&gt;
    &lt;div id=&quot;box2&quot;&gt;BOX2&lt;/div&gt; &lt;a href=&quot;#box2&quot;&gt;ToBox2&lt;/a&gt;
3. 动态伪类：:hover(鼠标悬停在元素上的样式)、:active(鼠标点击/按下时的元素样式)
    1. :hover和:active可以作用在任意元素上，使用的CSS属性也不受限制；
    &lt;div id=&quot;box&quot;&gt; &lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt; &lt;/div&gt;
    #box ul { display: none; } ------&gt; 正常情况下，&lt;ul&gt;是隐藏的
    #box:hover ul { display: block; } ---&gt; 当鼠标悬停在box上时，让&lt;ul&gt;显示
    2. :link、:visited、:hover、:active同时使用时，必须遵循一定的顺序：l-v-h-a
4. 表单相关伪类：:enabled、:disable、:checked、:focus
    1. :enabled、:disable分别匹配可编辑和被禁用的表单；
    2. :checked、:focus分别匹配被选中和获得焦点的表单；
    3. 自定义单选框：只用CSS实现，不借助JS
    label { float:left; width:100px; height:100px; border 2px solid;
    border-radius:50%; overflow:hidden; position:relative; } --&gt;label做单选框
    label &gt; span { position:absolute; left:0; top:0; right:0; bottom:0; }
    input { position:absolute; left:-50px; top:-50px; } --&gt; 隐藏掉原单选框
    input:checked + span { blackground:red; } --&gt;选中input时，让span模拟选中样式
    &lt;label&gt;
        &lt;input type=&quot;radio&quot; name=&quot;hobby&quot; /&gt; &lt;span&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;label&gt;
        input type=&quot;radio&quot; name=&quot;hobby&quot; /&gt; &lt;span&gt;&lt;/span&gt;
    &lt;/label&gt;
    ---&gt; &lt;label&gt;是内联元素，使用浮动是为了让其转为内联块元素，支持宽高
    4. 原理：&lt;label&gt;与&lt;input type=&quot;radio&quot; /&gt;一起使用时，点击&lt;label&gt;可会选中单选框，
    再利用同name的单选框是互斥的，隐藏&lt;input&gt;，选中用&lt;span&gt;的样式代替。
</code></pre><h4 id="结构性伪类"><a href="#结构性伪类" class="headerlink" title="结构性伪类"></a>结构性伪类</h4><pre><code>1. 类型：:nth-child(index)系列、:nth-of-type(index)系列、:not、:empty
2. 索引index从1开始计数，且可以设置为变量n或n的表达式，n从0开始计数，如偶数2n、奇数2n+1
3. E:nth-child(1){ ... }：匹配使用了E选择器的元素、且是其父元素下的第一个子元素；
    1. 如果不指定E，则匹配整个文档的、符合条件的元素；
    &lt;ul id=&quot;warpper&quot;&gt;
        &lt;li&gt;Test1&lt;/li&gt; &lt;li&gt;Test2&lt;/li&gt; &lt;li&gt;Test3&lt;/li&gt;
    &lt;/ul&gt;
    #wrapper li:nth-child(1){ color:red; } ---&gt;匹配Test1
    2. :nth-child(index)系列的其他类型：:first-child、:last-child、:only-child、
    :nth-last-child(index)
    3. E:first-child{ ... }、E:last-child{ ... } 分别匹配第一个和最后一个；
    4. E:nth-last-child(index){ ... } 表示倒序匹配；
    5. E:only-child{ ... } 匹配父元素只有一个子元素、且子元素类型为E
4. E:nth-of-type(1){ ... }：查找父元素下的所有类型为E的子元素，再匹配其中的第一个；
    &lt;ul id=&quot;warpper&quot;&gt;
        &lt;li&gt;Test1&lt;/li&gt; &lt;li&gt;Test2&lt;/li&gt; &lt;p&gt;Test4&lt;/p&gt;
    &lt;/ul&gt;
    #wrapper p:nth-of-type(1){ color:red; } --&gt;匹配Test4
    1. :nth-of-type系列的其他类型：:first-of-type、:last-of-type、:only-of-type、
    :nth-last-type(index)
5. 两种系列的区别：
    1. E:nth-of-type(index)以元素为中心，E始终是标签名，即使把E指定为class选择器，
    解析时也会被替换为元素的标签名；而E:nth-child(index)则不会；
    &lt;div id=&quot;wrap&quot;&gt;
        &lt;div class=&quot;inner&quot;&gt;div&lt;/div&gt;
        &lt;p class=&quot;inner&quot;&gt;p&lt;/p&gt;
        &lt;span class=&quot;inner&quot;&gt;span&lt;/span&gt;
    &lt;/div&gt;
    #wrap .inner:nth-of-type(1) { ... } ---&gt;相当于：#wrap div:nth-of-type(1),
    #wrap p:nth-of-type(1), #wrap span:nth-of-type(1) { ... }，所以都会匹配
6. E:empty{ ... }：E不能包含任何子元素、文本、空格，如&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;
7. E:not(F){ ... }：E和F都可以是选择器，匹配所有E，除了F
    &lt;div id=&quot;box&quot;&gt;
        &lt;p&gt;container&lt;/p&gt; &lt;p&gt;container&lt;/p&gt; &lt;p&gt;container&lt;/p&gt;
    &lt;/div&gt;
    #box &gt; p:not(:last-child){ ... } --&gt;除了最后一个&lt;p&gt;，其他子元素都匹配
</code></pre><h4 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h4><pre><code>1. 伪元素：仍是元素，只是不在DOM树中，是为了让CSS操作DOM树以外的元素；
    #box::before{ display:block; content:&quot;&quot;; width:80px; height:80px;
        border:1px solid black; position:absolute; left:0; top:20px; }
    1. 伪元素仍是元素，像使用普通DOM元素一样，对其使用定位，默认参照的仍是初始包含块；
    2. 伪元素建议使用双冒号：E::after{ ... }、E::before{ ... }
    3. 伪元素中必须使用content属性，用于添加文本内容，如果不需要，则设置为空字符串。
2. E::after、E::before：可以向DOM文档中插入新的元素，但并不存在于DOM树中；
    1. E::after、E::before分别是向元素E的末尾/开始插入一个子元素。
3. E::first-letter、E::first-line：分别匹配E中的第一个文字、第一行文字；
4. E::selection{ color:#ff0; background:red; }：文本被鼠标选中时的样式；
</code></pre><h3 id="CSS声明的优先级"><a href="#CSS声明的优先级" class="headerlink" title="CSS声明的优先级"></a>CSS声明的优先级</h3><pre><code>1. 选择器的特殊性：由选择器本身的组件确定，特殊性的值表述为4个部分，如 0,0,0,0
    1. id选择器的特殊性为：0,1,0,0 --&gt; #box{ ... }
    2. 类属性选择器、属性选择器、或伪类选择器的特殊性为：0,0,1,0
    3. 元素和伪元素选择器的特殊性为：0,0,0,1 ---&gt; div{ ... }
    4. 通配符选择器的特殊性为：0,0,0,0 --&gt; *{ ... }
    5. 结合符对特殊性没有任何贡献，如body,ul,li{ ... }
    6. 内联声明的特殊性都是1,0,0,0
    7. 继承没有特殊性，比0,0,0,0的优先级还要低；
    8. 特殊性的值可以累加，但不会进位，比如12个0,1,0,0的累加值为0,12,0,0
    9. 选择器的特殊性最终都会授予其对应的声明，构成CSS的优先级。
    div[id=&quot;test&quot;]{ ... } --&gt;0,0,1,1   #test{ ... } --&gt;0,1,0,0
2. 重要声明：对于某个比较重要的声明，超过了其他所有声明，CSS2.1称为重要声明；
    1. 在重要声明的结尾、分号之前插入 !important 来标志，如color: red !important;
    2. 实际上，浏览器会把重要声明和普通声明分别划分成一组，在各自的分组内部解决冲突；
    3. 重要声明虽然没有特殊值，但重要声明与普通声明产生冲突时，重要声明总是胜出。
3. CSS的来源决定了CSS的权重
    1. CSS样式的来源大致有三种：创作人员(开发者)、读者(用户)、用户代理(浏览器)
    2. 来源的权重：读者的重要声明&gt;创作人员的重要声明&gt;创作人员的普通声明&gt;读者的普通声明&gt;
    用户代理的声明，用户代理不会加重要声明，所以用户代理没有重要声明；
    3. 在浏览器的开发者模式下，查看样式时，用户代理的样式标识：user agent stylesheet
    4. 开发者模式下直接手动修改样式，也是属于创作人员的声明；
    5. Chrome和Firefox并没有提供读者的样式接口，需要借助插件(Stylish)导入样式表；
    6. IE提供了读者的样式接口，可以导入外部的CSS文件，属于读者的样式声明。
4. 层叠样式表：CSS声明优先级的真正体现
    1. 找出所有的相关规则，这些规则都包含一个CSS选择器；
    2. 计算声明的优先级：先按来源排序，如果来源相同，再按选择器的特殊性排序，如果特殊性也
    相同，则按排列的顺序.
</code></pre><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><pre><code>1. CSS3的自定义字体：@font-face
    1. @font-face：允许为网页指定在线字体，通过这种方式可以消除对用户电脑字体的依赖；
    @font-face { font-family: &quot;Test&quot;; src: url(font/BAUHS93.TTF) }
    #box { font: 16px &quot;Test&quot;; } ---&gt; 使用自定义字体Test
    2. font-family：指定字体的名称，用于font/font-family属性；
    3. src：字体资源的地址；把字体保存在服务器上，就不再依赖用户电脑上的字体，保持统一。
2. 字体图标：只需要下载一次字体包，降低了网络的负担，使得操作更加友好，而且是矢量图；
    1. 与位图相比，矢量图放大后不会失真，但矢量图的色调通常比较单一；
    2. 字体图标也是一种字体，通过color和font-size可以控制图标的颜色和大小。
    3. 制作矢量图(Ai) --&gt; 把矢量图与字符绑定，生成字体图标(FontLab Studio) --&gt; 把生成
    的字体图标制作成自定义字体(网站工具) --&gt; 引入自定义字体，使用该字符时，就会自动转为所
    绑定的矢量图
    4. www.fontsquirrel.com/tools/webfont-generator：字体兼容性处理网站，可以把字体
    转为自定义字体，生成stylesheet.css
3. 批量生成自定义字体：https://icomoon.io/#home，把矢量图与字符绑定，制作字体图标
    1. 生成style.css，其内部是伪元素选择器:before{ content: &quot;字体图标的绑定字符&quot; }
    2. 在使用style.css中的字体图标时，只需要使用其中的选择器即可。
</code></pre><h2 id="CSS3新增UI方案"><a href="#CSS3新增UI方案" class="headerlink" title="CSS3新增UI方案"></a>CSS3新增UI方案</h2><h3 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h3><pre><code>1. opacity：设置盒子的透明度，属性值的范围是 0-1
    1. 虽然不可继承，但透明度也会同时作用在其子元素上；
    2. 为了兼容IE浏览器，还必须设置filter: alpha(opacity=30);
2. rgba：同时设置颜色及颜色的透明度，如rgba(0, 0, 0, .8)，透明度为0.8
3. text-shadow：文字阴影，可以添加多层，每层用&quot;,&quot;隔开，第一个阴影在最上面
    text-shadow: 阴影色 水平偏移量 垂直偏移量 模糊值, 阴影色 水平偏移量 ...
    1. 浮雕文字：h1 { color: white; text-shadow: black 1px 1px 10px; }
    2. 文字模糊：h1:hover{ color:rgba(0,0,0,0); text-shadow:black 0 0 100px; }
4. -webkit-text-stroke：文字描边，不算是CSS3，只有webkit内核才支持
5. direction：控制文字的方向，一定要与 unicode-bidi:bidi-override; 配合使用；
    .content { direction:rtl; unicode-bidi:bidi-override; } --&gt;文字从右向左排列
6. text-overflow：未显示内容的溢出信号，显示省略号，但不支持内联元素；
    1. 配合 white-space:nowrap; overflow:hidden; 实现溢出内容显示省略号；
    .wraper { white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
</code></pre><h3 id="盒模型样式"><a href="#盒模型样式" class="headerlink" title="盒模型样式"></a>盒模型样式</h3><pre><code>1. box-shadow：盒模型阴影
    box-shadow: inset 阴影色 水平偏移量 垂直偏移量 模糊值 阴影扩展大小, inset ...
    1. 阴影的真实大小=盒子大小+阴影扩展大小，默认的阴影大小就是盒子大小；
    2. box-shadow默认是外阴影，在盒子的右下角，偏移量可以设置为负值，改变阴影的位置；
    3. inset表示设置内阴影，阴影扩展大小也可以设置为负值，阴影也可以叠加，用&quot;,&quot;隔开。
2. -webkit-box-reflect：元素的倒影，只有webkit内核支持
    1. -webkit-box-reflect: 倒影的方向(above,below,right,left) 倒影的距离 渐变
    2. 移动端的浏览器(IOS、Android)都是webkit内核，所以倒影和文字描边常用于移动端。
3. box-sizing：更改计算元素真实宽高的默认CSS盒子模型，默认属性值为content-box
    1. 默认情况下，设置盒子的padding会增大盒子的真实大小；
    2. box-sizing:border-box; --&gt;盒子的真实大小始终为width/height，设置的padding会
    占用width/height的大小，类似于Android上的EditText
4. resize：允许控制一个元素的可调整大小，必须与 overflow:auto/hidden; 配合使用；
    1. 不可继承，默认值为none，元素不能被缩放；
    2. horizontal/vertical：只允许在水平/垂直方向上调整元素的大小。
    3. both：允许在水平和垂直方向上调整元素大小，原理是在盒子上动态添加style样式。
</code></pre><h3 id="新增UI样式"><a href="#新增UI样式" class="headerlink" title="新增UI样式"></a>新增UI样式</h3><pre><code>1. border-radius：圆角，设置为百分比时参照盒子的width和height
    1. border-radius: 10px(左上角) 20px(右上角) 30px(右下角) 40px(左下角)
    2. border-radius: 10px(左上角、右下角) 30px(右上角、左下角)
    3. border-radius: 10px(左上角) 20px(右上角、左下角) 30px(右下角)
    4. border-radius: 50%; --&gt; 同时设置4个角，不支持负数
    5. 第二种语法：border-radius:10px/20px; 10px/20px 30px; 10px/20px 30px 40px;
    border-radius: 10px/20px 30px 40px 50px;
2. border-radius使用百分比的兼容性
    1. 在旧版本的Chrome和Safari中不支持使用百分比值(fixed in 09/2010)
    2. Opera11.50之前的版本中也不支持百分比值；
    3. Gecko2.0(Firefox4)版本之前的实现不标准：水平/垂直半轴都相对于盒子的宽度；
    4. IOS5之前、Android webkit532之前都不支持百分比值，所以移动端开发尽量使用px值。
3. border-image：边框图片，允许CSS属性在元素的边框上绘制图像，会替换掉border-style
    1. border-image-source：设置边框上的图片，替换border-style，默认值为none
    border-image-source: url(img/border.png); --&gt; 如果不设置，仍使用border-style
    2. border-image-slice：可以设置4个值，来控制切片线的位置，默认值100%，相对于图片；
    3. border-image-repeat：填充边框的模式，默认值stretch(拉伸)，repeat/round(平铺)
    单个值表示设置所有边框，两个值表示分别设置水平与垂直的边框；
    4. border-image-width：默认值为1，如果不指定，图像边框的宽度使用border-width
    5. border-image-outset：边框图像可超出边框盒的大小，放大边框。
4. background：背景新增属性
    1. background-image支持设置多张背景图，且前者叠加在后者之上；
    background-image: url(img/a.png) url(img/b.png) url(img/c.png);
    2. 默认从padding box开始绘制，从border box开始剪裁，超出盒子边框的部分被裁剪；
    3. background-origin：设置背景渲染的起始位置，默认值padding-box，不填充边框
    background-origin:content-box; --&gt; 从内容区开始渲染，不填充边框和内边距
    background-origin:border-box; --&gt; 从border box开始渲染，填充边框和内边距
    4. background-clip：设置背景的裁剪位置，默认值border-box，即超出盒子的部分被裁剪
    background-clip: padding-box; --&gt; 从padding box开始裁剪，即超出内边距就裁剪
    background-clip: content-box; --&gt; 从内容区开始裁剪，即超出内容区就裁剪
    5. background-origin和background-clip不只是设置背景图，对背景颜色也有效；
    6. -webkit-background-clip: text; --&gt;只支持webkit内核，让背景只在文字区域渲染
    文字要设置为半透明才能看到背景的效果；
    7. background-size：设置背景图的大小，默认值auto auto; 分别表示图片的宽度和高度；
    8. 图片的特性就是高宽自适应，保持图片不变形，设置单个值，表示宽度，高度为auto
    9. background-size设置为百分比：背景图相对于背景区域的百分比，真实渲染的背景区域由
    background-origin设置，默认为盒模型的内容区+内边距；
    background-size: 100% 100%; --&gt; 让图片完全填充背景区域，图片可能变形。
</code></pre><h3 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h3><pre><code>1. 渐变是CSS3新增的图片类型(不是颜色)，加快页面的载入时间，页面的缩放效果也比图片更好；
2. 浏览器支持两种类型的渐变：线性渐变(linear-gradient)，径向渐变(radial-gradient)
3. 渐变的方向
    1. 默认从上到下的渐变：background-image:linear-gradient(red, blue); red-&gt;blue
    2. 多颜色的渐变：background-image:linear-gradient(red, yellow, green);
    3. 渐变的方向：top、bottom、left、right
    background-image: linear-gradient(to right, red, blue); --&gt;由左向右的渐变
4. 使用角度：
    1. 以盒子的中心点为圆心，水平方向为-90°~90°(从左到右)，垂直方向为0~180°(从上到下)
    2. 45度方向的多色渐变：linear-gradient(45deg, red, yellow, green);
    3. 控制颜色的分布：linear-gradient(red 长度px/百分比, blue 长度px/百分比, ...)
    background-image: linear-gradient(90deg, red 10%, blue, gray);
    4. 10%的含义并不是red占10%，而是纯色的red占10%，从10%处开始渐变。
5. 渐变区间的判定
    1. 如果每个颜色上都是用了长度px或百分比，它们之间必须存在差值，否则不会发生渐变；
    1. linear-gradient(90deg, red 10px, blue 10px)：两个颜色值的占比相同时，并不会
    发生渐变，而是red占盒子的10%，而blue占盒子的90%；
    2. linear-gradient(90deg, red 10px, blue 20px)：10px的差值，则red占盒子的10%，
    渐变色占10%，blue占80%，即在red和blue之间的渐变色只有10px的长度。
6. 透明色的渐变：linear-gradient(90deg, rgba(0,0,0,0) 10px, rgba(0,0,0,1) 50px)
7. 重复的渐变：repeating-linear-gradient(90deg, blue, red 100px);
    1. 对于重复的渐变色，通常只指定最后一个颜色的长度/百分比，渐变色块的分布会更均匀；
    2. 如果每种颜色的长度/百分比设置的都一样，最后一种颜色会占据整个盒子，没有渐变。
8. 发廊灯效果
    &lt;div id=&quot;box&quot;&gt; &lt;div id=&quot;hear&quot;&gt;&lt;/div&gt; &lt;/div&gt;
    #box{ width:50px; height:300px; border:1px solid black; overflow:hidden; }
    #hear{ height:600px; background: repeating-linear-gradient(135deg, 
        black 0px, black 10px, white 10px, white 20px); }
    let hear = document.querySelector(&apos;#hear&apos;)
    let flag = 0
    setInterval(()=&gt;{
        flag++
        if(flag &gt;= 300) flag = 0
        hear.style[&apos;margin-top&apos;] = -flag + &apos;px&apos;
    }, 1000/60)
    1. hear的高度比父元素box更大，动态改变hear的margin-top，让hear向上移动；
    2. 缺陷：hear向上移动到临界值时，margin-top重置为0px，会造成瞬间的卡断问题。
9. 光斑动画：文字的闪亮效果
    body { background: black; }
    h1 {
        color: rgba(255,255,255, .3);  font: bold 80px &quot;microsoft yahei&quot;;
        background: linear-gradient(120deg, rgba(255,255,255,0) 100px, 
            rgba(255,255,255,1) 180px, rgb(255,255,255,0) 260px);
        background-repeat: no-repeat;
        -webkit-background-clip: text; --&gt; 让背景只渲染文字所在的区域
    }
    let h1 = document.querySelector(&apos;h1&apos;)
    let flag = -160
    setInterval(() =&gt; {
        flag+=10
        if(flag &gt;= 600) flag = -160
        h1.style[&apos;background-position&apos;] = flag + &apos;px&apos;
    }, 30)
    1. 让背景图(渐变色)只渲染文字区域，且不能重复平铺，同时设置文字为半透明；
    2. 通过改变背景图的background-position，以动态改变背景图的位置，达到闪亮效果。
</code></pre><h3 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变"></a>径向渐变</h3><pre><code>1. radial-gradient()由渐变中心点向四周辐射的颜色渐变，默认均匀分布；
    background-image:radial-gradient(red, blue, green); ==&gt; red-&gt;blue-&gt;green
2. 不均匀分布：radial-gradient(red 50%, blue 70%); --&gt;渐变色只有20%，50%为纯红色
3. 径向渐变默认是椭圆ellipse，指定为圆形：radial-gradient(circle, red, blue);
4. 改变渐变形状的大小
    1. 默认是最近角：radial-gradient(closest-corner circle, red, blue);
    2. farthest-side(最远边)、 closest-side(最近边)、farthest-corner(最远角)
5. 改变圆心(渐变中心)
    radial-gradient(closest-corner circle at 10px 10px, red, blue);
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/05/05/CSS2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/05/CSS2/" itemprop="url">CSS2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-05T00:00:00+08:00">
                2018-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML/" itemprop="url" rel="index">
                    <span itemprop="name">HTML</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><pre><code>1. &lt;link /&gt;引入CSS的方式可以利用浏览器的缓存，提高访问速度；
2. &lt;a /&gt;可以包含任何元素，但&lt;p&gt;除了它自身，不可以包含任何块元素；
3. 复合/交集选择器：用于选中同时满足多个选择器的元素，选择器1选择器2 { ... }
    1. span.p3 { background-color: yellow; } --&gt;只对使用了类选择器p3的span有效
    2. id是标签的唯一标识，所以id选择器通常不会再使用复合的形式。
4. 伪类选择器
    1. a:link { color: black; } --&gt; 为没访问过的链接设置一个颜色；
    2. a:visited{ color: red; } -&gt;设置访问过的链接的颜色，浏览器根据历史纪录判断；
    3. a:active{ color: green; } --&gt; 设置超链接被点击时的颜色；
    4. input:focus {background-color: red;} -&gt;设置&lt;input /&gt;获得焦点后的背景色；
    5. p::selection{background-color: red;} -&gt; 设置鼠标选中时的背景色；
    6. 兼容Firefox：p::-moz-selection { ... }
    7. IE6不支持&lt;a /&gt;以外的元素设置:hover和:active，也不支持:focus和::selection；
    8. 针对段落&lt;p&gt;的伪元素：:first-letter(首字母)，:first-line(首行)
5. H5规定的一些语义标签：对于不需要着重的内容、而是单纯的加粗/斜体，就可以使用&lt;b&gt;和&lt;i&gt;
    1. &lt;small&gt;用于表示一些细则一类的内容，如合同中的小字、网站的版权声明；
    2. &lt;cite&gt;：网页中所有的加&quot;《》&quot;的内容，表示引用的参考，如书名、电影名、歌名
    3. &lt;q&gt;：行内引用的内容，为该内容加引号，&lt;p&gt;子曰：&lt;q&gt;温故而知新！&lt;/q&gt;&lt;/p&gt;
    4. &lt;sup&gt;：上标，&lt;p&gt;2&lt;sup&gt;3&lt;/sup&gt;&lt;p&gt; --&gt; 2的3次方的形式；
    5. &lt;sub&gt;：下标，&lt;p&gt;H&lt;sub&gt;2&lt;/sub&gt;O&lt;p&gt; --&gt; 水的化学方程式；
    6. &lt;del&gt;：加删除线，&lt;p&gt;&lt;del&gt;17.8&lt;/del&gt;&lt;p&gt;
    7. &lt;ins&gt;：表示一个插入的内容，自动添加下划线；
    8. &lt;pre&gt;：预格式标签，会保存内容的格式，不会忽略前后的空格；
    9. &lt;code&gt;：专用于表示代码，但不会保留格式，所以通常配合&lt;pre&gt;表示代码。
6. RGB表示颜色时，有两种方式：rgb(255,0,100)、rgb(100%,0%,100%)
1. text-transform：设置文本的大小写，默认值为none
    1. capitalize：每个单词的首字母大写，通过空格识别单词；
    2. uppercase/lowercase：所有字母都大写/小写。
2. text-decoration：设置文本的修饰，下划线、删除线、上划线，如&lt;a&gt;默认带下划线；
3. text-indent：设置文本的首行缩进，通常使用em作为单位；
    1. 如果设置一个足够大的负数，可以把文本隐藏，供搜索引擎查看，而不让用户看到。
4. user-select:none; --&gt;不允许鼠标以任何方式选中文本，包括按住鼠标拖动选中、双击选中
</code></pre><h2 id="CSS2-1"><a href="#CSS2-1" class="headerlink" title="CSS2.1"></a>CSS2.1</h2><pre><code>1. div+CSS布局的原因：&lt;div&gt;是块级元素，在所有浏览器的解析都是一样的，而且&lt;div&gt;的样式
   是很干净的，所以选择用&lt;div&gt;作为包含块(父级元素)；
2. 包含块：根元素(html)的包含块也称为初始包含块，有些浏览器会使用body作为根元素；
    1. 对于大多数浏览器，初始包含块就是一个视窗大小的矩形，但不等于视口；
    2. 对于浮动元素，其包含块为最近的块级父元素，定位元素则更为复杂；
    3. position为relative/static的非根元素，包含块由最近的块级框、表单元格或行内块
    祖先框的内容边界构成；
    4. position为absolute的非根元素，包含块设置为最近的、使用了定位的父元素，如果没有
    任何父元素使用定位，则以初始包含块为参照。
3. 默认值与百分比的参考值
    1. width和height都不可继承，默认值为auto，而不是100%！
    2. 没有设置width和height的情况下，内联元素和内联块元素的宽高由内容撑起，所以如果没有
    内容，其width和height的实际值都是0px，而块元素独占一行，如果没有内容，其width仍撑满
    父元素，即width的实际值与父元素的width相同，但其height的实际值也是0px
    &lt;div id=&quot;outter&quot;&gt; --&gt; #outter{ width: 100px; height: 100px; }
        &lt;div id=&quot;inner&quot;&gt;&lt;/div&gt; --&gt; #inner{ height: 50px; margin: 0 20px; }
    &lt;/div&gt; ---&gt;inner的width=100-20-20=60px
    3. width的默认值为auto，实际值为父级width-自身margin-自身padding-自身border
    4. margin和padding的默认值为0，使用百分比时都参照父级定位元素的width
    5. left和top的默认值是auto，而不是0，使用百分比时，分别参照包含块的width和height
    &lt;div id=&quot;outter&quot;&gt;&lt;/div&gt;
    &lt;div id=&quot;box&quot;&gt;&lt;/div&gt; --&gt; #box{ position: absolute; } --&gt; box位于outter下方
    6. 相对定位的包含块为父元素；对于绝对/固定定位，包含块为最近的、使用定位的父级元素。
4. 浮动：浮动只会提升半层层级，而定位提升1个层级；
    1. 文字绕图：浮动只提升半层层级的体现，只浮动下半层；
    2. 只有在浮动的时候才会考虑盒子的分层问题，上层为文字相关，下层为盒模型相关。
</code></pre><h3 id="固定定位的扩展理解"><a href="#固定定位的扩展理解" class="headerlink" title="固定定位的扩展理解"></a>固定定位的扩展理解</h3><pre><code>1. 绝对定位参照的是包含块，固定定位参照的是视口；
2. 视口、html、body的高度实现三合一，必须一层层继承，只设置body{ height:100%; }是无效的
    html, body { height: 100% } --&gt; 让body能够充当视口的大小
4. 滚动条：可分为系统滚动条和元素上的滚动条；
    1. 系统滚动条属于document，作用在整个HTML文档上，也就是浏览器窗口；
    2. 只设置&lt;html&gt;或&lt;body&gt;中的一个overflow，都会传递给document
    3. 禁用系统滚动条：html{ height: 100%; overflow: hidden }
5. 初始包含块是一个视口大小的矩形，但并不是视口，它也在文档的最外层，包裹整个文档；
    1. 拖动系统滚动条，视口不会移动，但初始包含块会随之移动，整个文档也随之移动；
    2. 拖动其他元素上的滚动条，影响的都只是该元素内的子元素，并不会影响初始包含块的位置；
    3. 如果没有任何父元素使用定位，绝对定位则参照初始包含块；
    4. 系统滚动条能影响初始包含块的位置，也就能间接影响绝对定位的元素位置。
6. 解决固定定位不兼容IE6
    1. 如果当前拖动的不是系统滚动条，那也就不影响初始包含块，绝对定位的元素也就不会移动；
    2. 因此，可以用绝对定位间接实现固定定位的效果；
    html{ height: 100%; overflow: hidden; } --&gt; 禁止系统滚动条
    body{ height: 100%; overflow: auto; } --&gt; 让&lt;body&gt;充当视口，使用&lt;body&gt;的滚动条
</code></pre><h3 id="经典布局"><a href="#经典布局" class="headerlink" title="经典布局"></a>经典布局</h3><pre><code>1. 三列布局：两边固定、中间自适应，中间列要完整显示，且中间列要优先加载
    1. 定位实现过于复杂，还会影响后续的布局，所以不建议用定位做框架布局；
    2. 浮动实现：中间列不能优先加载
    div{ height: 100px; }  body{ min-width: 600px; }--&gt;最小宽度：2*left+right
    &lt;div class=&quot;left&quot;&gt;LEFT&lt;/div&gt; --&gt; .left{ width: 200px; float: left; }
    &lt;div class=&quot;right&quot;&gt;RIGHT&lt;/div&gt; --&gt; .right{ width: 200px; float: right; }
    &lt;div class=&quot;middle&quot;&gt;MIDDLE&lt;/div&gt; --&gt; 只能排在最后面，导致中间列不能优先加载
2. 圣杯布局实现三列布局：浮动、margin为负值、相对定位
    1. margin：外边距，控制盒子边框之间的距离，把margin设置为负值是布局中的重要应用；
    2. margin改变的其实是盒子的边界位置，并不会主动改变盒子本身的大小和位置，盒子本身的
    位置只能由定位(left,top)进行改变，但margin会影响盒子的盒模型变化；
    3. 对于两个并列的盒子(内联元素)，后者的margin-left设置为负值，在表象上会覆盖前者；
    4. margin-left设置为负值，改变盒子的边界，就是圣杯布局实现的关键
    body { min-width: 600px; margin: 0; padding: 0; } --&gt;最小宽度2*left+right
    .content { padding: 0 200px; } --&gt;为父元素设置左右padding，显现middle
    #middle { width: 100%; float: left; } --&gt; 中间列也要左浮动，且手动设置宽度100%
    #left, #right { width: 200px; float: left; }
    #left { margin-left: -100%; position: relative; left: -200px; } --&gt;left的
    原位置在middle的下面，与middle同层级，左边界垂直在一条线上，middle的width为100%，
    则设置left的margin-left为-100%，left会自动覆盖前面的middle，且左边界合并，又因为
    父元素的左padding为200px，对left设置相对定位，使left向左移动200px
    #right { margin-left: -200px; position: relative; right: -200px; } --&gt;left
    移动了之后，right会自动占据left的位置，right的width为200px，则设置margin-left为
    -200px，right和middle的右边界自动垂直在一条线上，又因为父元素的右padding为200px，
    则对right设置相对定位(right:-200px)
    &lt;div class=&quot;content clearfix&quot;&gt; --&gt;.clearfix清除浮动
        &lt;div id=&quot;middle&quot;&gt;middle&lt;/div&gt; --&gt;中间列优先加载
        &lt;div id=&quot;left&quot;&gt;Left&lt;/div&gt;
        &lt;div id=&quot;right&quot;&gt;right&lt;/div&gt;
    &lt;/div&gt;
3. 等高布局：伪等高
    1. 原理：padding-bottom改变盒子本身的大小，margin-bottom设置负值改变盒子的边界，
    父元素设置为overflow:hidden，剪切掉盒子padding-bottom超出父元素的部分；
    &lt;div class=&quot;box clearfix&quot;&gt;
        &lt;div class=&quot;left&quot;&gt;盒子&lt;/div&gt;
        &lt;div class=&quot;right&quot;&gt;等高布局······等高布局&lt;/div&gt;
    &lt;/div&gt;
    .box { width: 700px; border: 2px solid gold; overflow: hidden; }
    .left { width: 200px; float:left; }  .right { width: 500px; float:left; }
    .right, .left {  padding-bottom: 10000px; margin-bottom: -10000px; }
    2. right中的内容多于left，所以right的高度更大，父元素的高度也就是right的高度；
    3. 对left和right设置一个足够大的padding-bottom:10000px，盒子的底部边界向下延申
    10000px，那么父元素的高度也被撑开10000px；
    4. 对left和right再设置margin-bottom:-10000px，将盒子的底部边界向上移动10000px，
    盒子本身的大小不会改变，但父元素的高度会随之向上回缩10000px，那么盒子会由10000px
    超出父元素，所以对父元素设置overflow:hidden，剪切掉超出的部分。
4. 双飞翼布局实现三列布局：避免使用定位，样式更干净
    1. 双飞翼与圣杯布局的不同之处：如何处理中间列的位置
    2. 圣杯布局：父元素设置padding:0 200px，再对left和right设置相对定位；
    3. 双飞翼布局：给中间列再添加一个父元素，再对中间列设置padding:0 200px;
    .left, .right { width: 200px; float: left; }  body { min-width: 600px; }
    &lt;div class=&quot;clearfix&quot;&gt; --&gt;只清除浮动
        &lt;div class=&quot;middle&quot;&gt; --&gt; .middle { width: 100%; float: left; }
            &lt;div class=&quot;inner&quot;&gt;middle&lt;/div&gt; --&gt; .inner{ padding:0 200px; }
        &lt;/div&gt;
        &lt;div class=&quot;left&quot;&gt;Left&lt;/div&gt; --&gt;.left { margin-left: -100%; }
        &lt;div class=&quot;right&quot;&gt;right&lt;/div&gt; --&gt;.right { margin-left: -200px; }
    &lt;/div&gt;
5. 粘连布局：stickyFooter，一般应用于移动端
    1. 当main中的内容不足以撑满屏幕的高度时，footer固定在屏幕底部；main中的内容高度
    超过屏幕高度时，footer跟随在main的底部；
    html, body { height: 100%; } --&gt;让body充当视口
    &lt;div id=&quot;wraper&quot;&gt; --&gt;#wraper { min-height: 100%; }，最小高度为屏幕的100%
        &lt;div id=&quot;main&quot;&gt;main······main&lt;/div&gt; --&gt;#main{ padding-bottom: 30px; }
    &lt;/div&gt;
    &lt;div id=&quot;footer&quot;&gt;footer&lt;/div&gt; --&gt;#footer{height: 30px; margin-top: -30px;}
    2. wraper设置最小高度为视口的100%，保证下面的兄弟节点footer至少位于底部；
    3. 对main设置padding-bottom，让main中的内容不会与footer交叉；
    4. footer只能布局在wraper之下，设置margin-top为负数，改变边界，让盒子向上移动。
</code></pre><h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><h3 id="Box-Formatting-Context"><a href="#Box-Formatting-Context" class="headerlink" title="Box Formatting Context"></a>Box Formatting Context</h3><pre><code>1. Box：盒子，CSS布局的基本单位，也即一个页面由多个Box组成；
    1. Box也有多种类型，元素的类型和display属性决定了一个Box的类型；
    2. 不同类型的Box，会参与不同的Formatting Context(一个决定如何渲染HTML文档的容器)，
    所以，Box内的元素会以不同的方式渲染。
2. Box的类型
    1. display属性值为block、list-item、table的元素，会生成block-level box，并参与
    block formatting context；
    2. display为inline、inline-block、inline-table的元素，会生成inline-level box，
    并参与inline formatting context；
3. Formatting Context：W3C CSS2.1规范的概念，页面中的一块渲染区域，并且有一套渲染规则；
    1. 它决定了其子元素将如何定位，以及和其他元素的关系、相互作用；
    2. 最常见的有Block Formatting Context(简称BFC)，Inline Formatting Context(IFC)
    3. 不同于BFC，每个浏览器对IFC维护的规则不同，所以常用的布局是div+CSS.
</code></pre><h3 id="Block-Formatting-Context"><a href="#Block-Formatting-Context" class="headerlink" title="Block Formatting Context"></a>Block Formatting Context</h3><pre><code>1. BFC：块级格式化上下文，它是一个独立的渲染区域，只有Block-level Box参与，它规定了内部
   的Block-level Box如何布局，且与区域外部无关；
2. BFC的布局规则
    1. 内部的Box会在垂直方向一个个地放置，也即块级元素独占一行；
    2. BFC的区域不会与浮动的Box重叠；
    3. 内部的Box在垂直方向的距离由margin决定，同一个BFC的两个相邻Box的margin会发生重叠；
    4. 计算BFC的高度时，浮动元素也参与计算(清除浮动、开启haslayout)
    5. BFC就是页面上的一个隔离的独立容器，容器里的子元素不会影响到外面的元素，反之亦然。
3. 会生成BFC的元素：开启BFC的条件
    1. 根元素，也即&lt;html&gt;就是一个BFC容器，所以其中的块元素能够遵循BFC的规则；
    2. float不为none，position为absolute/fixed，都会自动开启BFC，管理其中的块元素；
    3. overflow不为visible，也会开启BFC；
    4. display为inline-block、table-cell、table-caption、flex、inline-flex
4. BFC实现两列布局：利用&quot;BFC的区域不会与浮动的Box重叠&quot;的规则
    body { min-width: 600px; }  div{ height: 200px; }
    &lt;div id=&quot;left&quot;&gt;Left&lt;/div&gt; --&gt; #left{ width: 200px; float: left; }
    &lt;div id=&quot;right&quot;&gt;Right&lt;/div&gt;  --&gt; #right{ overflow: hidden; }
    1. right开启了BFC，将不会与浮动的left重叠，形成两个完全独立的布局；
    2. 使用场景：左边为商品图片，右边为商品的简介。
5. margin的合并：BFC的规则导致，两个Box满足&quot;处在同一个BFC、相邻、都是块元素&quot;
    1. 一旦打破其中一个条件，比如其中一个盒子为display:inline-block，则不会发生重叠；
    2. &quot;相邻&quot;的意义：两个盒子的margin相邻，也即在两个盒子之间加一个空&lt;div&gt;也是无效的，
    但是，如果这个&lt;div&gt;设置height:1px; 那么两个盒子的margin将不再相邻，也不会重叠；
    3. 为了使样式更干净，可以为第二个Box加一个父元素，并设置父元素overflow:hidden;
    4. 除了会导致兄弟元素的margin合并，此规则也会使父子元素之间发生margin的合并，也就是
    margin-top的塌陷，子元素的margin-top传递给了父元素，因为它们也符合BFC的规则。
</code></pre><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><pre><code>1. 暴力方式：直接给父元素设置高度；
2. 利用BFC的规则之一：&quot;计算BFC的高度时，浮动元素也参与计算&quot;：
    1. 开启BFC的父元素能感知浮动元素的高度，也就能被撑开；
    2. 如overflow:hidden;(常用于移动端)，但IE6/7不支持BFC。
3. 在浮动元素下面添加&lt;br clear=&quot;all&quot; /&gt;，也能清除浮动，但破坏了结构，也不兼容IE6；
4. 在最后一个子元素后面添加一个空标签：&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;
    1. 副作用：结构与样式未分离，且如果该标签中有内容，即使设置height:0; 在IE6也有19px
    的默认高度，再设置font-size:0; 还是会有2px的高度。
5. 伪元素的方式：.clearfix:after{ content:&quot;&quot;; display:block; clear:both; }
    1. 其实是第四种的变种，实现了结构与样式的分离，且基本没有副作用，但IE6/7不支持伪元素。
    2. 兼容IE6/7：.clearfix{ *zoom:1; } 开启IE特有的haslayout，*表示IE的hack
</code></pre><h2 id="兼容IE"><a href="#兼容IE" class="headerlink" title="兼容IE"></a>兼容IE</h2><pre><code>1. haslayout：IE6没有BFC的概念，layout是IE的一个私有概念；
    1. layout决定了元素如何对其内容定位、尺寸计算，以及与其他元素的关系、相互作用；
    2. 当一个元素拥有layout时，它会负责本身及其子元素的尺寸和定位，如果没有，则由最近的、
    拥有layout的父元素控制其尺寸和位置；
    3. IE8+使用了全新的引擎，已经不再支持haslayout了，所以haslayout只针对IE6/7
    4. haslayout出现的原因：理论上每个元素都应该控制自己的尺寸和定位，即每个元素都应该拥有
    layout；然而，对于早期的IE引擎来说，如果让所有元素都拥有layout的话，会导致性能很低；
    所以，IE团队决定使用布局的概念来减少浏览器的性能开销，即只将布局应用于实际需要的元素，
    所以出现&quot;拥有布局&quot;和&quot;没有拥有布局&quot;两种情况。
    5. 默认拥有布局的元素：html、body、table、tr、td、img、hr、input、select、button、
    textarea、iframe、embed、object、applet、marquee
    6. 开启haslayout：浮动、display:inline-block、绝对定位、width/height值非auto、
    zoom值非normal、writing-mode:tb-rl
    7. IE7增加开启haslayout的方式：min-height/min-width为任意值，position:fixed、
    max-heigth/max-width的值不为none，overflow值非visible，仅用于块元素。
2. 了解hack
    1. 不同厂商的浏览器或者同一浏览器的不同版本，如IE6和IE7，对CSS的解析不完全相同，
    CSS hack的目的就是使CSS兼容不同的浏览器，反之，利用hack为不同的浏览器定制CSS效果；
    2. hack使用最多的是IE浏览器，一般只关心IE的hack：*、+、-、_、#、\0、\9\0、!important
    3. -：IE6特有的hack，其他版本的IE都不支持；
    4. *：对于标准版的IE，只有IE6/7支持，所以使用{*zoom:1}开启IE6/7的haslayout，而其他
    版本的IE支持伪元素和BFC，则不需要开启haslayout，节省开销；
    5. 对于标准IE，\9在IE6/7/8/9/10都支持，\0只在IE8/9/10中生效，\9\0只对IE9/10有效；
    6. \0、\9\0、!important都是写在属性值后面，如background:red\9\0;
    7. 除了CSS hack，还有一种hack可以写在HTML中，称为条件注释表达式
    &lt;body&gt;
        &lt;!--[if IE]&gt;
            这段文字只在IE浏览器上显示
        &lt;![endif]--&gt;
        &lt;div&gt; ······ &lt;/div&gt; ---&gt; 页面的布局
    &lt;/body&gt;
    1. 这种hack只在IE10以下有效，因为IE6是一个版本，IE7/8/9又是一个版本，而IE10以上的
    浏览器已经接近于标准浏览器，取消了这种hack；
    2. &lt;!--[if IE 6]&gt;：只在IE6上生效； &lt;!--[if gte IE 6]&gt;：IE6+上有效；
2. 检测低版本IE
    function checkIE(version) {
        let b = document.createElement(&apos;b&apos;)
        b.innerHTML = &apos;&lt;!--[if IE &apos; + version + &apos;]&gt;&lt;i&gt;&lt;/i&gt;&lt;![endif]--&gt;&apos;
        return b.getElementsByTagName(&apos;i&apos;).length == 1
    } --&gt; console.log(checkIE(8)) --&gt; 当前浏览器为IE8时，返回true，否则返回false
</code></pre><h2 id="字体相关"><a href="#字体相关" class="headerlink" title="字体相关"></a>字体相关</h2><pre><code>1. font-size：可继承，Chrome的默认值为16px，最小值为12px，常用单位有px、em、百分比
    1. em：1em等于其父元素的字体大小；
    2. 百分比：参照父元素的字体大小；
    3. 字体大小设置为小于12px，Chrome仍按照12px渲染，但设置为0时，则按照0px渲染。
2. font-style：可继承，默认值normal，可选值italic(斜体字体)、oblique(让当前字体倾斜)
3. font-weight：可继承，指定字体的粗细程度，默认值normal(400)，加粗bold(700)
    1. 设计比较好的字体，粗细程度会划分为9个等级：100-900
    2. 回退机制：有些字体只提供两种粗细风格，100-500渲染为normal，600-900渲染为bold
4. font-family：指定字体，可以同时指定多种字体，优先使用靠前的字体；
    1. font-family: &apos;arial&apos;,&apos;微软雅黑&apos;; --&gt;如果都不支持，则使用浏览器的默认字体；
    2. 字体分为5大类：serif(衬线字体)，sans-serif(非衬线)，monospace(等宽字体)...
    3. 使用一个字体族时，浏览器会自动选择其小分类的字体，但不同浏览器选择的不一样。
5. 简写属性的默认值问题：font: style weight size/line-height family
    #box { line-height:20px; font:20px &apos;arial&apos;; } --&gt; line-height是无效的
    1. font是简写属性，如果没有显式设置，也会有默认值，会覆盖掉之前的line-height
    2. 正确写法：#box {  font:20px &apos;arial&apos;; line-height:20px; }
</code></pre><h2 id="文本相关"><a href="#文本相关" class="headerlink" title="文本相关"></a>文本相关</h2><pre><code>1. 文本属性：line-height、color、text-align、text-indent、text-decoration...
2. line-height：行高，CSS中没有直接设置行间距的属性，只能通过行高间接设置行间距；
    1. 行间距 = 行高 - 字体大小，文字默认垂直居中；
    2. 行高可以设置百分比/数值，相对于字体大小，一般行高大约是字体大小的1.4倍；
    3. line-height:1.5; 表示行高是字体的1.5倍，开发中通常设置为1.5倍，渲染效果更好；
    4. 行高不能小于字体大小，因为有的浏览器解析的会很怪异；
    5. 行高最常见的应用：单行文本的垂直居中。
3. 行高的继承性：
    1. line-height设置为像素值/百分比时，子元素继承的是父元素的行高；如果line-height
    设置为数值，子元素会直接继承，而不是父元素计算后的行高；
    &lt;div id=&quot;wrap&quot; style=&quot;font-size:30px;line-height:1;&quot;&gt;
        &lt;div id=&quot;inner&quot; style=&quot;font-size:20px;&quot;&gt;inner&lt;/div&gt;
    &lt;/div&gt;
    2. inner会直接继承line-height:1，那么inner的行高为20px；
    3. 所以，通常初始化设置行高为1，body { line-height: 1; }，在需要的地方再重新设置；
    4. 而对于大文本，如&lt;p&gt;、&lt;/span&gt;，则设置为1.5，p,span{ line-height: 1.5; }
4. text-align：只对内联元素有效，对浮动元素无效，浮动元素有自己的盒模型；
5. letter-spacing/word-space：前者设置每个字符之间的距离，后者设置单词之间的距离；
6. white-space：控制换行，nowrap表示强制不换行，常用于实现一行文本过多时显示省略号；
    1. .wrap { white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    2. 还包括一个隐含设置：display:block; 如果当前作用的盒子不是块元素，则无效。
7. vertical-align：指定内联块元素在垂直方向的位置，但对块元素/浮动/定位元素都是无效的；
    1. 应用场景：让图片&lt;img /&gt;或&lt;input /&gt;这种内联块元素在父元素内垂直水平居中
    &lt;div id=&quot;wrap&quot;&gt; &lt;img src=&quot;img/img2.jpg&quot; width=&quot;150px&quot; /&gt; &lt;/div&gt;
    #wrap { width:400px; height:400px; border:1px solid red; }
    #wrap:after { content:&quot;&quot;; display:inline-block; --&gt; 把伪元素转为内联块
    height:100%; width:0px; vertical-align:middle; } --&gt;垂直居中，作为参考基线
    #wrap img { vertical-align:middle; } --&gt;图片水平垂直居中
    2. &lt;img /&gt;会参考伪元素，实现水平居中，在使用vertical-align实现垂直居中；
    3. 图片和文字排列在一行时，默认它们的基线对齐，要让文字与图片的中间对齐：
    img { vertical-align: middle; }
    &lt;span&gt;文字文字文字&lt;/span&gt; &lt;img src=&quot;...&quot; /&gt; &lt;span&gt;文字文字文字&lt;/span&gt;
</code></pre><h2 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h2><pre><code>1. 水平居中：margin: auto; 浏览器渲染时仍解析为margin:0 auto; 浮动/定位时auto失效；
2. CSS2.1的标准没有直接垂直居中的属性，所以只能间接实现盒子的垂直居中；
    &lt;div id=&quot;wrap&quot;&gt; &lt;div id=&quot;inner&quot;&gt;Test&lt;/div&gt; &lt;/div&gt;
    #wrap { width:400px; height:600px; position:relative; }
1. 已知高度的盒子
    1. 绝对定位 + margin负值的实现方案：
    #inner { width:100px; height:100px; position:absolute; left:50%; top:50%; 
    margin-left:-50px; margin-top:-50px; }
    2. 绝对定位 + margin:auto的实现方案：
    #inner { width:100px; height:100px; position:absolute; left:0; top:0; 
    right:0; bottom:0; margin:auto; }
    3. 绝对定位的盒子特性：
    水平方向：left+right+width+padding+margin=包含块padding区域的尺寸
    垂直方向：top+bottom+height+padding+margin=包含块padding区域的尺寸
    4. 对于绝对定位的盒子模型，浏览器不会把margin:auto解析为margin:0 auto
2. 未知高度的盒子：涉及CSS3的属性，兼容性较差
    #inner { position:absolute; left:50%; top:50%; 
    transform:translate3d(-50%, -50%, 0) } --&gt;CSS3的新增属性，以自身为参照(x,y,z)
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/05/03/CSS基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/03/CSS基础/" itemprop="url">CSS基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-03T00:00:00+08:00">
                2018-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML/" itemprop="url" rel="index">
                    <span itemprop="name">HTML</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="CSS简介"><a href="#CSS简介" class="headerlink" title="CSS简介"></a>CSS简介</h2><pre><code>CSS：Cascading Style Sheets，层叠样式表，拆分网页的内容和样式，丰富网页元素的样式；
CSS的出现，使得HTML中有很多自带样式的标签被废弃了，也让HTML更专注于文档的结构和内容。
</code></pre><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><pre><code>1. CSS的定义：选择器{属性:值; 属性:值; 属性:值;}
    1. 选择器是将样式和HTML标签关联起来的名称；
    2. 属性是设置的每个样式属性有一个或多个值。
2. CSS并不属于HTML语言，有三种方式引入HTML页面中：
    1. 内联式：每个HTML标签都有style属性，通过style属性可以在标签上直接定义样式；
        1. 比如：&lt;div style=&quot;width:100px; height:100px; color:red&quot;&gt;...&lt;/div&gt;
        2. 但是，内联式并没有使标签和样式进行分离，不常用。
    1. 文本的常用CSS样式：
        1. color：设置文字的颜色，如 color:red;
        2. font-size：文字的大小，默认16px，如 font-size:12px; font-size:100%
        3. font-family：设置字体，如 font-family:&apos;微软雅黑&apos;;
        属性值为中文可能造成乱码，&apos;微软雅黑&apos;对应的英文是&apos;microsoft yahei&apos;；
        4. font-style：文字是否倾斜，normal 不倾斜，italic 倾斜；
        5. font-weight：是否加粗，bold 加粗，normal不加粗；
        6. line-height：文字的行高，有些字体带有默认的行高，布局时需要重置；
        6. font是复合属性：font:weight size/line-height family;
        7. text-decoration：设置文字的下划线；
        比如去除&lt;a&gt;标签超链接文本的下划线：a{ text-decoration: none; }
        8. text-indent：设置文字的首行缩进，比如 text-indent: 24px;
        9. text-align：设置文字水平对齐方式，水平居中text-align: center;
    2. 内嵌式：在&lt;head&gt;标签中，使用&lt;style&gt;标签定义样式；
        1. 定义：标签名{ ... }，比如 div{ color: &apos;red&apos;; ... }
        1. 定义了div的样式之后，在当前页面直接使用&lt;div&gt;标签，就会自带所定义的CSS样式；
        2. 网站的首页通常使用内嵌式，提高加载效率。
    3. 外联式：在&lt;head&gt;标签中，通过&lt;link href=&quot;xxx.css&quot; /&gt;引入CSS样式文件；
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;main.css&quot; /&gt;
        1. rel：定义当前文档与被链接文档之间的关系，stylesheet表示文档的外部样式表；
        2. href：被链接文档的路径；
        3. 外联式拆分了HTML网页和CSS样式，引入CSS文件之后，可以直接使用文件的样式标签。
3. CSS颜色表示法
    1. 颜色名表示：red 红色，gold 金色；
    2. rgb表示：rgb(255,0,0) 红色；
    3. 十六进制表示：#ff0000 红色，可以简写为#f00
</code></pre><h3 id="CSS的样式选择器"><a href="#CSS的样式选择器" class="headerlink" title="CSS的样式选择器"></a>CSS的样式选择器</h3><pre><code>1. 标签选择器：在定义CSS样式时，使用HTML的标签名作为选择器；
    1. 这种方式会作用于当前HTML页面的所有同名标签上，影响范围大，不灵活；
    2. *{属性:值; 属性:值;}：用通配符 * 作为选择器，会统一设置所有HTML标签的样式；
    3. 比如，&lt;body&gt;标签默认设置了margin值，造成在浏览器页面上，页面内容到边框也有一定的
    间距，去除默认间距的样式：body{ margin:0; padding:0; }
    4. 在IE下，&lt;img/&gt;加载的图片做链接时会产生边框，去除方式：img{ border:none; }
2. id选择器：以 # 为起始标识，自定义选择器的名称，HTML标签在使用时，通过id属性引用；
    1. 比如：#xuanze{color:red;}，&lt;div id=&quot;xuanze&quot;&gt;...&lt;/div&gt;
    2. 但是，id是标签的唯一标识，属性值不能重复，所以每个样式只能供一个标签使用；
    3. 而且，id一般供程序使用，所以也不推荐使用id作为选择器。
3. 类选择器：以 . 为起始标识，自定义选择器名称，HTML标签通过class属性引用；
    1. 比如：.xuanze{color:red;}，&lt;div class=&quot;xuanze&quot;&gt;...&lt;/div&gt;
    2. 一个标签上可以同时使用多个类选择器，用一个空格隔开：class=&quot;选择器1 选择器2&quot;
    3. 如果一个标签上同时使用id选择器和类选择器，id选择的权重更高，会覆盖类选择器。
4. 层级选择器：用标签的父子关系，制约样式的作用范围；
    .red{ color: red; }   .red em{ font-style: normal; }
    &lt;p class=&quot;red&quot;&gt;层级选择器&lt;em&gt;层级选择器&lt;/em&gt;&lt;/p&gt;
    &lt;p&gt;层级选择器&lt;em&gt;层级选择器&lt;/em&gt;&lt;/p&gt;
    1. 第一个&lt;p&gt;使用了类选择器red，第二个&lt;p&gt;没有使用，那么对于层级选择器red em{...}，
    第一个&lt;em&gt;中的字体受层级样式的影响，不会倾斜，而第二个&lt;em&gt;中的字体则不受影响；
    1. 浏览器是从右向左解析选择器的：em --&gt; .red，层级越多，解析越慢，不要超过4层；
    2. &lt;ul&gt;的&lt;li&gt;内容前默认带有图形样式，去除该样式：ul{ list-style: none; }
5. 组选择器：多个选择器，如果有相同的样式，可以使用组选择器；
    1. 设置方式：选择器1,选择器2,选择器3{属性:值; 属性:值;}
    2. 比如标签&lt;div&gt;和&lt;p&gt;的组选择器：div,p{font-size:20px;}
6. 伪类、伪元素选择器：hover、before、after
    1. hover：鼠标悬停在标签上时，标签内容显示的样式；常用在&lt;a&gt;标签上，当鼠标悬停时，
    超链接文本的样式发生变化，比如文本颜色、下划线；
    a { text-decoration: none; color: #0000ff; }
    a:hover { color: #ff0000; text-decoration: underline; }
    1. 对list选择器的标签使用hover事件，改变其子标签&lt;a&gt;的样式：.list:hover a{ ... }
    2. before、after：在原有文本的前面/后面，追加新的内容，且可以指定追加内容的样式；
    .box { font-size: 20px; color: #00ff00; }
    .box:before { content: &quot;CSSCSS&quot;; color: #000000; width:100px; }
    &lt;div class=&quot;box&quot;&gt;伪元素before&lt;/div&gt;
</code></pre><h3 id="表格样式"><a href="#表格样式" class="headerlink" title="表格样式"></a>表格样式</h3><pre><code>&lt;table&gt;的CSS样式属性：border-collapse: collapse，表示合并单元格之间的边框线、单元格与
表格的边框线：
</code></pre><p><img src="https://i.imgur.com/2yMnTu8.jpg" alt></p>
<h2 id="CSS盒子模型"><a href="#CSS盒子模型" class="headerlink" title="CSS盒子模型"></a>CSS盒子模型</h2><pre><code>&lt;table&gt;属于传统的布局，盒子标签div+CSS样式是一种新型布局方式：盒子+盒子；
</code></pre><p><img src="https://i.imgur.com/oQPeOLf.jpg" alt></p>
<pre><code>1. 把标签称之为盒子，设置对应的CSS样式：盒子大小width+height、背景色background-color、
   盒子的边框border、盒子内的内容、边框之间的间距padding、盒子与盒子之间的间距margin；
1. 设置边框border，比如顶部边框border-top
    1. border-top-color:red：设置顶部边框颜色为红色；
    2. border-top-width:10px：设置边框的粗细为10px；
    3. border-top-style:solid：设置边框的线性为实线，dashed 虚线，dotted 点线；
    4. 统一设置顶部边框：border-top:10px solid red;
    5. 左边框、右边框、底部边框分别是：border-left、border-right、border-bottom；
    6. 统一设置四个边框：border:10px solid red;
2. 设置内间距padding
    1. 上左右下：padding-top、padding-left、padding-right、padding-bottom；
    2. 统一设置四个内间距：padding:20px 30px 40px 50px; --&gt; 顺时针：上右下左；
    3. 设置三个值：padding:20px 30px 40px; --&gt; 上 (左右) 下；
    4. 设置两个值：padding:20px 30px; --&gt; (上下) (左右)；
    5. 设置一个值：padding:20px; --&gt; (上右下左)；
    6. 设置了padding之后，盒子会变大，所以width和height并不是盒子的实际宽高。
3. 盒子的真实宽高：
    1. width和height实际上是盒子内容的宽高，真实宽高需要加上padding和border；
    2. 宽度=width+padding左右+border左右，高度=height+padding上下+border上下；
    3. 设置盒子的height=auto，或者不设置盒子的height时，由盒子的内容撑起height；
    4. 对于文本，text-indent和line-height可以取代padding，且不会计入盒子的宽高；
    5. line-height的内部实现：在文本的顶部和底部加padding，且文本内容垂直居中。
4. 外间距margin，使用方式与padding相同；
    1. margin:10px auto：盒子在父标签内水平居中，与text-align不同，盒子中的内容不会
    相对于父标签居中；
    2. margin设置为负值，可以通过改变盒子边框的位置，实现移动盒子、合并边框。
5. 元素溢出：overflow
    当子标签的尺寸超过父标签的尺寸时，需要设置父标签显示溢出的方式：overflow；
    1. visible：默认值，内容会显示在标签之外；
    2. hidden：隐藏溢出盒子的内容，不会有滚动条；
    3. scroll：强制显示滚动条，以便查看溢出的内容；
    4. auto：自动模式，如果内容溢出，则显示滚动条，否则不显示；
    5. 拆分横向和纵向，可以分别设置属性值：overflow-x、overflow-y
</code></pre><h3 id="margin的问题"><a href="#margin的问题" class="headerlink" title="margin的问题"></a>margin的问题</h3><pre><code>1. 外边距合并：包括垂直外边距的合并和水平外边距合并
    1. 以垂直外边距为例：设置了margin-top和margin-bottom的两个盒子，在两个垂直方向上
    相遇时，两个盒子的间距不会是top+bottom，而是二者较大的一个；
    解决方式：
    1. 使用这种特性完成特定功能，比如文章的段落，每个段落的上下间距都要保持一致；
    2. 只设置一个方向上的外边距，一般只设置margin-top；
    3. 将标签浮动或定位，即开启BFC：BFC区域不会与float Box发生重叠。
2. margin-top坍塌：两个盒子嵌套时，设置内部盒子的margin-top，会作用于外部盒子；
    解决方式：
    1. 设置外部盒子的border，或者设置overflow: hidden;
    2. 对外部盒子再使用一个伪元素选择器：
    .content { width: 300px; height: 200px; background-color: #00ff00; }
    .content .inside { width: 200px; height: 100px; margin-top: 30px; }
    .clearfix:before{ content: &quot;&quot;; display: table; }
    &lt;div class=&quot;content clearfix&quot;&gt; &lt;div class=&quot;inside&quot;&gt;&lt;/div&gt; &lt;/div&gt;
</code></pre><h3 id="布局的三大标签"><a href="#布局的三大标签" class="headerlink" title="布局的三大标签"></a>布局的三大标签</h3><h4 id="块标签"><a href="#块标签" class="headerlink" title="块标签"></a>块标签</h4><pre><code>块标签：也称为行标签，如 div、p、ul、li、h1~h6、dl、dt、dd...
1. 支持全部的样式；
2. 如果没有设置宽度，默认宽度为父级宽度的100%；即使设置了宽度，盒子也独占一行。
3. &lt;div&gt;没有任何语义，不会为其子元素设置任何默认样式，主要用于页面的布局。
</code></pre><h4 id="内联标签"><a href="#内联标签" class="headerlink" title="内联标签"></a>内联标签</h4><pre><code>内联标签：也称为行内标签，如 a、span、img、iframe、em、b、strong、i...
在布局中的行为：
1. 支持部分样式，不支持宽高、margin上下、padding上下，宽高由内容决定，设置宽高也无效；
2. 盒子并在一行，不单独占据一行，超出父边距则自动换行；
3. 代码中的盒子标签换行，会使盒子之间产生间距，去除方式：
    1. 在代码中的内联标签都写在一行，不要使用Enter换行，也不要有间距；
    2. 内联标签的父标签样式设置font-size:0，在内联标签的样式中再设置文本的font-size；
    3. 浮动也可以去除默认间距。
4. &lt;span&gt;没有任何语义，专门用于选中文字，设置特定的样式；
5. &lt;a&gt;可以包括任意元素，除了自身；&lt;p&gt;只能包含内联元素，而不能包含块元素。
</code></pre><h4 id="内联块标签"><a href="#内联块标签" class="headerlink" title="内联块标签"></a>内联块标签</h4><pre><code>内联块标签：继承了块标签和内联标签的优点，也称为行内块标签，现有标签没有归于此类别的；
1. img和input标签的行为类似于内联块标签，但仍然归类于内联标签；
2. 完全去除&lt;input/&gt;作为输入框时的默认边框：input{ border:0; outline:none; }
3. &lt;img /&gt;的上下方会出现3像素的空白，清除其默认样式的方式
    1. 转为块标签：display:block;
    2. 设置font-size:0;
4. display属性可以将块标签/内联标签转化为内联标签；
5. 在布局中的行为：
    1. 支持全部样式，如果不设置宽高，则由内容决定宽高；
    2. 盒子并在一行，不单独占据一行；
    3. 代码中的盒子标签换行，会使盒子之间产生间距；
    4. 内联块标签之间没有margin的合并。
</code></pre><h4 id="display属性"><a href="#display属性" class="headerlink" title="display属性"></a>display属性</h4><pre><code>display属性：块标签、内联标签和内联块标签可以通过display属性相互转化；
1. display属性用于设置标签的类型及隐藏；
2. none：不占位置的隐藏标签(visibility:hidden的隐藏会占位)；block：显示出隐藏的标签；
3. block/inline/inline-block：标签转化为块标签/内联标签/内联块标签。
</code></pre><h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><pre><code>文档流：文档流处在网页的最底层，表示一个页面的位置，元素默认都处在文档流中；
1. 块标签在文档流中独占一行，自上向下排列；
    1. 默认宽度为父元素的100%(但宽度值是auto)，高度默认由内容撑开；
2. 内联标签在文档流中只占自身的大小，默认从左向右排列；
    1. 如果一行空间不足，则换到下一行，默认宽高都由内容撑开；
3. width为auto时，设置padding并不会影响可见框的大小，而是自动修正宽度，以适应内边距；
4. 浮动可以使元素脱离文档流，不再受文档流的布局约束，但浮动只提升半层(元素分两层)。
</code></pre><h3 id="浮动的特性"><a href="#浮动的特性" class="headerlink" title="浮动的特性"></a>浮动的特性</h3><pre><code>1. 浮动标签只有左浮动和右浮动两种：float:left/right;
2. 浮动元素不再占据文档流中的位置，后面的元素会向上移动，占据空缺的位置；
    1. 浮动元素会尽量向页面的左上/右上漂浮，直到遇见父元素的边界、浮动元素才会停下来；
    2. 如果浮动元素上面是一个没有浮动的块元素，则浮动元素不会超过该块元素；
    3. 浮动元素不会超过它上面的兄弟元素，最多处在同一行，且一边对齐；
    4. 如果父元素的宽度不足以容下浮动元素，则浮动元素会自动换行。
3. 文字绕图：浮动元素后面的兄弟元素(未浮动)，会占据浮动元素在文档流中的位置，而元素内的
   文字又会避开浮动元素，形成的文字绕图效果；
</code></pre><p><img src="https://i.imgur.com/vSz5iyq.jpg" alt></p>
<pre><code>    1. 浮动的初始目的就是为了制作文字绕图效果，而不是做布局；
    2. 文字绕图效果说明了一个元素分两层，浮动的元素只提升了半层。
4. 浮动让块元素/内联元素自动转化为内联块元素，宽高默认由内容撑开，具有内联块元素的特性。
</code></pre><h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><pre><code>1. 父元素的高度塌陷：
    1. 如果父元素没有设置宽高，其子元素又为浮动元素，脱离文档流，则无法撑开父元素；
    2. 开启BFC的元素，可以包含浮动元素，所以开启父元素的BFC，浮动元素就可以撑开父元素。
1. BFC：Block Formatting Context，W3C标准规定，BFC可以打开/关闭，默认是关闭的
2. 开启BFC的元素所具有的特性：
    1. 父元素的垂直外边距不会与子元素重叠；
    2. 开启BFC的元素不会被浮动元素所覆盖；
    3. 开启BFC的元素可以包含浮动的子元素。
3. CSS中没有专门针对BFC的属性，但能通过其他方式简介开启BFC：
    1. 设置元素的浮动/定位/inline-block
    2. 将元素的overflow设置为一个非visible的值，一般设置为hidden，副作用较小
    3. IE7以下不支持BFC，但IE7以下有一个隐含属性：hasLayout，开启方式也有很多；
    4. 父元素设置的width可以开启hasLayout，但副作用最小的方式为：zoom: 1;
    5. zoom属性只有IE支持，原意表示放大元素，1表示不放大。
4. 解决父元素的高度塌陷之一：在父元素的样式中使用 { overflow: hidden; zoom: 1; }
</code></pre><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><pre><code>1. {overflow: hidden; zoom: 1;} 解决父元素的高度塌陷是有副作用的；
2. 清除浮动：并不是让元素的浮动无效，而是清除浮动元素对当前元素的影响；
3. 清除浮动的属性：clear，在当前元素的样式中使用，而不是在浮动元素
    1. clear: left/right/both; 清楚左/右/两侧浮动元素对当前元素的影响；
    2. clear: both; 清除的是两侧浮动元素中、影响最大的一个浮动元素。
4. 解决父元素的高度塌陷之二：清除浮动
    1. 在最后一个元素后面添加一个空的&lt;div&gt;，设置其样式 clear:both; 清除浮动；
    2. 这种方式基本没有副作用，但会在页面中增加一个多余的结构。
5. 清除浮动的经典选择器clearfix，在浮动元素的父元素上使用，清除浮动的影响
    .clearfix:after, .clearfix:before { content: &quot;&quot;; display: table; }
    .clearfix:after{ clear: both; }
    .clearfix{ zoom: 1; }
</code></pre><h2 id="定位：position"><a href="#定位：position" class="headerlink" title="定位：position"></a>定位：position</h2><pre><code>CSS的定位属性：position，可以打破文档流，设置盒子的位置，默认值都是static，无定位；
</code></pre><h3 id="position的属性值"><a href="#position的属性值" class="headerlink" title="position的属性值"></a>position的属性值</h3><pre><code>1. relative：相对定位，以盒子的当前位置为参考，设置偏移量，从而重新布局盒子的位置；
    1. 设置偏移量的属性：top、left、right、bottom... 支持正负值；
    2. 相对定位会使标签提升一个层级，但在文档流中会有投影，所以仍占据保留原来的位置。
2. absolute：绝对定位，其参考系为使用了相对定位/绝对定位/固定定位的父节点；
    1. 如果没有任何父节点使用定位，则以&lt;body&gt;为参考；一般情况下，开启了元素的绝对定位，
    同时会开启其父元素的相对定位；
    2. 绝对定位的标签脱离了文档流，漂浮在文档流上方，原位置会被相邻标签自动填充，同理，
    元素的性质也会改变：内联元素变为块元素，块元素的高度和宽度默认都被内容撑开。
3. fixed：固定定位，相对于浏览器窗口进行定位，脱离文档流，与absolute类似；
    1. 不同的是：在没有父标签使用定位时，absolute相对于&lt;body&gt;，而fixed则永远相对于
    当前浏览器窗口的可视区域，且不会随滚动条滚动，漂浮在当前窗口；
    2. IE6不支持固定定位。
</code></pre><h3 id="定位的特性"><a href="#定位的特性" class="headerlink" title="定位的特性"></a>定位的特性</h3><pre><code>1. 绝对定位/固定定位的块标签和行内标签会自动转化为行内块标签；
2. 定位标签的层级：z-index
    1. 对于两个叠加的定位标签，默认后者会叠加在前者之上，z-index则可以设置层级；
    2. z-index的属性值为整数，值大的定位标签叠加在上面；
    3. z-index支持负值，层级会低于任何兄弟元素；
    3. 对于开启定位的父子元素，即使父元素的z-index高于子元素，父元素也不会在子元素之上。
</code></pre><h2 id="background属性"><a href="#background属性" class="headerlink" title="background属性"></a>background属性</h2><pre><code>background属性负责给盒子设置背景图和背景色；
1. background-color：设置背景色，background-color: transparent; --&gt;设置透明色
2. background-image：设置背景图，background-image: url(img/icon.png);
    1. background-image通常用于插入装饰性图片，&lt;img /&gt;用于插入内容图片；
    2. background是CSS属性，爬虫不容易爬取，而&lt;img /&gt;是HTML标签，更容易被爬取。
3. background-repeat：设置背景图的重复平铺方式，默认值repeat(重复平铺，填充整个盒子)
    2. repeat-x/repeat-y：只在水平/垂直方向上重复平铺；
    3. no-repeat：不重复平铺，只填充一次；
    4. space：与repeat不同，图片之间可能有间距，以保证图片的完整性；
    5. round：与space不同，图片会拉伸，填充图片之间的间距。
4. background-position：设置背景图的位置，支持负数和百分比，配合background-repeat
    1. 同时设置两个值(x, y)，分别表示在水平方向和垂直方向上的位移；
    2. 默认值为0% 0%，盒子的左上角，等效于：left top，top left，0px 0px
    3. 可使用关键字：left、right(水平方向)，top、bottom(垂直方向)，center(居中显示)
    4. left/right并不是在盒子的左/右上角，而是垂直居中，同理，top/bottom是水平居中；
    5. 百分比的参照尺寸：背景图所在区域的大小减去背景图自身的大小。
5. background-attachment：决定背景图是在视口中固定的，还是随包含它的区域滚动；
    1. 默认值scroll，背景图相对于元素本身固定，元素带有滚动条时，不会随着它的内容滚动；
    2. fixed：背景图相对于视口固定，元素随父级滚动条滚动时，背景图不动。
background是一个复合属性，可以合并设置：background:color image position repeat;
</code></pre><h2 id="CSS的样式重置"><a href="#CSS的样式重置" class="headerlink" title="CSS的样式重置"></a>CSS的样式重置</h2><pre><code>1. 去除标签默认的margin和padding：*{ margin: 0px; padding: 0px; }
2. font-size、font-family、color等属性具有继承性，可以定义在body标签中；
3. 相关的插件：reset.css、Normalize.css
    1. reset.css属于传统的样式重置，而Normalize.css只是一个很小的CSS文件，更加现代化
    2. Normalize.css保护了有价值的默认值，修复了浏览器的Bug，模块化结构
    3. Normalize.css同时支持移动端和PC端在内的超多浏览器，兼容性更好。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/05/01/HTML/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/01/HTML/" itemprop="url">HTML</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-01T00:00:00+08:00">
                2018-05-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML/" itemprop="url" rel="index">
                    <span itemprop="name">HTML</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="HTML简介"><a href="#HTML简介" class="headerlink" title="HTML简介"></a>HTML简介</h2><pre><code>HTML：Hyper Text Mark-up Language，超文本标记语言，超文本即超链接，标记即标签；
HTML是一种用于制作网页的语言，由一个个标签组成，文件的扩展名为html或htm。
</code></pre><h3 id="HTML的基本结构"><a href="#HTML的基本结构" class="headerlink" title="HTML的基本结构"></a>HTML的基本结构</h3><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;utf-8&quot; /&gt;
        &lt;title&gt;&lt;title&gt;
    &lt;head&gt;
    &lt;body&gt;&lt;/body&gt;
&lt;/html&gt;
1. &lt;!DOCTYPE html&gt;，H5的文档声明，表示兼容最低版本浏览器，如果不声明，有些浏览器会进入
    怪异模式，导致页面无法正常解析；
2. lang=&quot;en&quot;：表示定义网页的语言为英文，lang=&quot;zh-CN&quot;表示中文，不显示声明也并没有影响，
    一般用于分析统计；
3. &lt;meta /&gt;：用于声明，比如声明编码方式、缓存、网页关键字、网页描述 ...
4. HTML的注释：&lt;!-- 注释内容 --&gt;
5. 规范：
    1. 所有的标签必须小写，而且标签必须闭合；
    2. 所有的属性值必须用双引号；
    3. &lt;img /&gt;必须加alt属性，对图片进行描述。
</code></pre><h2 id="HTML标签"><a href="#HTML标签" class="headerlink" title="HTML标签"></a>HTML标签</h2><h3 id="基本标签"><a href="#基本标签" class="headerlink" title="基本标签"></a>基本标签</h3><pre><code>1. &lt;h1&gt;&lt;/h1&gt; -- &lt;h6&gt;&lt;/h6&gt;：标题标签，一到六级标题；
2. &lt;p&gt;&lt;/p&gt;：段落标签；
3. &lt;br /&gt;：换行标签，浏览器渲染网页时，不识别Enter键的换行； &lt;hr /&gt;：一条分割线；
4. 字符实体
    1. &amp;nbsp;：表示一个空格；
    2. 空格键输入的多个空格只会渲染成一个空格，而多个&amp;nbsp;对应多个空格；
    3. 如果文字之间需要2个以上的空格，通常会使用样式实现，而不使用&amp;nbsp;
    4. &amp;gt; --&gt; 大于号&gt;  &amp;lt; --&gt; 小于号&lt;  &amp;copy; --&gt; 版权符号
5. html块
    1. &lt;div&gt;&lt;/div&gt;：块元素，盒子标签，表示一块内容，没有任何语义；
    2. &lt;span&gt;&lt;/span&gt;：行内元素，表示一行中的一部分内容，也没有任何语义。
6. 自带样式和语义的标签
    1. &lt;em&gt;&lt;/em&gt;：行内元素，文字斜体的效果，表示语气中的强调词；
    2. &lt;i&gt;&lt;/i&gt;：行内元素，斜体效果，W3C强加了语义，表示专业词汇；
    3. &lt;b&gt;&lt;/b&gt;：行内元素，加粗效果，W3C强加了语义，表示文档中的关键字或产品名；
    4. &lt;strong&gt;&lt;/strong&gt;：行内元素，加粗效果，表示非常重要的内容。
7. 语义化的标签：搜索引擎在爬网时能认识这些标签，理解文档的结构，所以在布局时要多使用；
    1. &lt;h1&gt;表示标题，&lt;p&gt;表示段落，&lt;ul&gt;、&lt;li&gt;表示列表，&lt;a&gt;表示超链接，dl、dt、dd...
8. &lt;img /&gt;：在网页上插入图片，src属性用于定义图片的地址；
    1. alt属性用于定义图片的描述，也就是图片加载失败时显示的文字；
    2. 特性：只设置width时，图片的height也会随之等比缩放；
    3. 相对路径：相对于当前文件本身去定位被引入的文件，比如 ./image/1.jpg
        1. ./：表示当前目录下，可以省略；
        2. ../：表示当前目录的上一层目录下。
    4. 绝对路径：相对于磁盘去定位被引入的文件，比如 D:\test\oneday\image\1.jpg
9. &lt;a&gt;&lt;/a&gt;：超链接，href属性定义跳转的地址；
    1. href=&quot;#&quot;，href=&quot;&quot;：回到当前页面的顶部；
        1. href=&quot;&quot;：默认打开当前界面，即刷新一次当前界面；
        2. href=&quot;#&quot;：浏览器地址栏的网址会追加一个#，当前界面不会刷新。
    2. 让&lt;a&gt;的默认行为失效：href=&quot;javascript:void(0);&quot; --&gt;简写：javascript:;
    3. 如果点击一块内容，需要执行跳转操作，则必须用&lt;a&gt;作为该区域的父标签，比如 把图片做成
    超链接：&lt;a&gt; &lt;img /&gt; &lt;/a&gt;
    4. href=&quot;javascript:;&quot;：用一个空的JS语句，可以在有超链接样式的前提下，但又不允许做
    任何跳转，常作为缺省值使用；
    5. 锚点：对于一个内容很长的网页，在当前页面内跳转到指定位置；
        1. 页面内使用了id/name属性的标签(name可能不兼容)，&lt;a&gt;可以跳转到指定的标签位置；
        2. &lt;h1 id=&quot;mao1&quot;&gt;标题一&lt;/h1&gt;，&lt;a href=&quot;#mao1&quot;&gt;跳转到标题一&lt;/a&gt;
    6. target：默认值_self，在当前页面做链接，_blank 表示新开一个窗口做链接；
    7. title：每个标签都具有的属性，定义鼠标悬停在标签上时弹出的提示文字。
</code></pre><h3 id="布局标签"><a href="#布局标签" class="headerlink" title="布局标签"></a>布局标签</h3><pre><code>1. 列表
    1. 有序列表：&lt;ol&gt;
        1. &lt;ol&gt;，&lt;li&gt;：&lt;ol&gt;作为&lt;li&gt;的容器，&lt;li&gt;表示一行内容；
        2. 有序列表会为每一行&lt;li&gt;编号，从1开始；
        3. 快捷键：ol&gt;li*3+Tab键，表示生成3个&lt;li&gt;标签。
    2. 无序列表：&lt;ul&gt;，默认在每一行&lt;li&gt;的前面加一个实心圆；
    3. 定义列表：&lt;dl&gt;
        1. &lt;dt&gt;：用于定义标题
        2. &lt;dd&gt;：用于解释&lt;dd&gt;定义的标题，解释的内容相对于标题默认会有缩进的样式；
        3. 快捷键：dl&gt;(dt+dd)*3+Tab键，表示生成3对&lt;dt&gt;&lt;dd&gt;标签。
2. 表格
    1. &lt;table&gt;，&lt;tr&gt;：分别用于声明一个表格，表格中的一行；
    2. &lt;td&gt;，&lt;th&gt;：定义一行中的一个单元格，&lt;td&gt;是普通单元格，&lt;th&gt;是表头单元格，其内容
    带有加粗居中的样式；
    3. 表格的常用属性：
        1. border：定义表格的边框；
        2. height，width：定义表格的大小，可以使用百分比作为属性值；
        3. cellpadding：定义单元格内的内容与边框的距离；
        4. cellspacing：定义单元格与单元格之间的距离；
        5. align：设置单元格中内容的水平对齐方式，属性值包括left/center/right；
        6. valign：垂直对齐方式，属性值包括top/middle/bottom；
        7. &lt;table&gt;标签只有align属性，用于设置自身相对于父标签的水平对齐方式；
        8. colspan/rowspan：设置单元格水平/垂直合并。
    4. 传统布局：传统的布局方式使用table做整体页面的布局，布局的技巧：
        1. 定义表格的宽高，并将border、cellpadding、cellspacing设置为0；
        2. 单元格里嵌套表格；
        3. 单元格中的元素和嵌套的表格用align和valign设置对齐方式；
        4. 通过属性或者CSS样式设置单元格中的元素样式。
3. 表单
    1. &lt;form&gt;：定义一个表单区域
        1. action属性：定义表单提交的地址，对于POST请求，地址以&quot;/&quot;结束；
        2. method属性：设置提交方式，默认是GET方式；
        3. 上传文件：&lt;form action=&apos;post&apos; enctype=&quot;multipart/form-data&quot;&gt;
    2. &lt;lable&gt;：定义提示性文字，比如：用户名、密码...
        1. for属性：点击提示性文字，激活对应的输入框，其属性值为&lt;input /&gt;的id属性值；
        2. for属性的应用场景：对于一个单选框/多选框，点击提示性文字，选中对应的选框。
    3. &lt;filedset&gt;, &lt;legend&gt;：表单分组
    4. &lt;input /&gt;：输入框
        1. type属性：定义输入框的类型，比如用户名输入框的类型为&quot;text&quot;；
        1. placeholder属性：定义输入框中的提示文本；
        2. disabled属性：让表单控件失效，不能输入/点击；
        2. type=&quot;file&quot;：上传文件；
        3. type=&quot;hidden&quot;：隐藏内容，用于存储表单默认自带的一些信息；
        4. 提交按钮：&lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;
        可以自定义submit事件，通过return true/false控制是否提交表单。
        4. &lt;input type=&quot;image&quot; src=&quot;图片路径&quot; /&gt;：也有提交功能，但可能会提交两次；
        5. 重置按钮：清除表单输入的内容，&lt;input type=&quot;reset&quot; value=&quot;重置&quot; /&gt;
        6. type=&quot;button&quot;：普通按钮；
        7. id、name、value：id属性是input标签的唯一标记，name和value相当于键-值对，
        在提交表单时，输入框的内容是以&quot;key=value&quot;的形式提交到action地址的；
        8. 对于单选框type=&quot;radio&quot;和多选框type=&quot;checkbox&quot;，name属性值必须相同。
    5. &lt;select&gt;：下拉框
        1. &lt;option&gt;：作为&lt;select&gt;的子标签，用于定义下拉框的选择项；
        2. name属性设置在&lt;select&gt;中，value属性设置在&lt;option&gt;中，组成键-值对；
        也即，&lt;select&gt;的value值就是&lt;option&gt;的value值。
    6. &lt;textarea&gt;：可以输入多行文本
    7. &lt;button&gt;：按钮标签
        1. type=&quot;button&quot;：普通按钮
        2. type=&quot;submit&quot;：提交按钮
        3. type=&quot;reset&quot;：重置按钮
4. &lt;iframe&gt;：内嵌框架，在当前页面引入另一个页面，但搜索引擎会忽略iframe；
    1. src属性：定义另一个HTML页面的引用地址；
    2. width、height：设置框架的宽高；
    3. frameborder属性：定义边框；
    4. scrolling属性：是否有滚动条，auto/no/yes；
    5. &lt;iframe&gt;与&lt;a&gt;配合使用：
        1. 点击&lt;a&gt;标签的超链接，在&lt;iframe&gt;中显示链接的窗口；
        2. 设置&lt;a&gt;标签的target属性值为&lt;iframe&gt;标签的name属性值。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">大麦田怪圈</p>
              <p class="site-description motion-element" itemprop="description">敢做就能赢！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">61</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">35</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大麦田怪圈</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
