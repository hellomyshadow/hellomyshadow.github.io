<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="敢做就能赢！">
<meta property="og:type" content="website">
<meta property="og:title" content="大麦田程序猿">
<meta property="og:url" content="http://hellomyshadow.github.io/page/5/index.html">
<meta property="og:site_name" content="大麦田程序猿">
<meta property="og:description" content="敢做就能赢！">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="大麦田程序猿">
<meta name="twitter:description" content="敢做就能赢！">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hellomyshadow.github.io/page/5/">





  <title>大麦田程序猿</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大麦田程序猿</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/03/26/模块化与私服/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/26/模块化与私服/" itemprop="url">模块化与私服</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-26T00:00:00+08:00">
                2016-03-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="拆分与聚合"><a href="#拆分与聚合" class="headerlink" title="拆分与聚合"></a>拆分与聚合</h2><pre><code>1. 拆分：把一个完整的Maven工程拆成独立的模块，如Dao模块、Service模块、Controller(Web)模块、Utils模块;
2. 模块之间的关系：
    1. 模块之间是平级的，需要建立依赖关系，才能引用对方的功能;
    2. Service模块引用Dao模块的坐标，Controller模块引用Service模块的坐标;
    3. 如果想引用另一个Maven工程，则需要把工程打包发布到本地仓库中，再其坐标即可建立依赖关系;
3. 父工程：New Project --&gt; 不使用Maven骨架，只需保留一个pom.xml，其他的文件和目录都可以删除掉;
    1. 把公共的jar包依赖放在父工程中，供所有的子工程使用;
    2. 在 pom.xml 中配置JDK的编译版本，Tomcat7插件;
    3. 打包方式：pom
        &lt;packaging&gt;pom&lt;/packaging&gt;
    4. &lt;dependencyManagement&gt; 管理的依赖和插件不会传递给子工程，但能够统一管理它们的版本号
        &lt;properties&gt;
            &lt;mysql.version&gt;8.0.16&lt;/mysql.version&gt;
        &lt;/properties&gt;
        &lt;dependencyManagement&gt;
            &lt;dependencies&gt;
                &lt;dependency&gt;
                    &lt;groupId&gt;mysql&lt;/groupId&gt;
                    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
                    &lt;version&gt;${mysql.version}&lt;/version&gt;
                &lt;/dependency&gt;
            &lt;/dependencies&gt;
        &lt;/dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;!-- 这些依赖会直接传递给子工程 --&gt;
        &lt;/dependencies&gt;
    5. 在子工程中引入依赖 mysql-connector-java 时，无需再指定版本节点&lt;version&gt;
4. 子工程：右击父工程 --&gt; New Module --&gt; 创建Maven项目
    1. Dao模块和Service模块都不使用骨架，Web模块使用web骨架;
    2. 子工程的 pom.xml 中，会有一个 &lt;parent&gt;，表示继承的父工程;
    3. 父工程的 pom.xml 中，会多出一个 &lt;modules&gt;，列出拥有的子模块;
    4. 依赖包的作用域(scope)默认是compile，父工程的依赖包传递给子工程的过程中，scope为test的依赖可能丢失;
    5. 比如父工程引入了junit(test)，子工程可能无法使用，这种情况下，通常会在子工程中再加入junit依赖即可;
5. Dao模块：resources/spring/applicationContext-dao.xml，只配置Dao层相关
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;
            http://www.springframework.org/schema/beans
            https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

        &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
            &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
            &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;cn.ssm.domain&quot; /&gt;
        &lt;/bean&gt;

        &lt;bean id=&quot;mapperScanner&quot; class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
            &lt;property name=&quot;basePackage&quot; value=&quot;cn.ssm.dao&quot; /&gt;
        &lt;/bean&gt;

        &lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt;
        &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
            &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot; /&gt;
            &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot; /&gt;
            &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot; /&gt;
            &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;
        &lt;/bean&gt;
    &lt;/beans&gt;
6. Service模块
    1. resources/spring/applicationContext-service.xml，只配置Service层相关
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
        xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;
            http://www.springframework.org/schema/beans
            https://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            https://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/tx
            https://www.springframework.org/schema/tx/spring-tx.xsd
            http://www.springframework.org/schema/aop
            https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

        &lt;context:component-scan base-package=&quot;cn.ssm.service&quot; /&gt;
        &lt;bean id=&quot;manager&quot; 
                class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
            &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
        &lt;/bean&gt;
        &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;manager&quot;&gt;
            &lt;tx:attributes&gt;
                &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt;
                &lt;tx:method name=&quot;*&quot; isolation=&quot;DEFAULT&quot; /&gt;
            &lt;/tx:attributes&gt;
        &lt;/tx:advice&gt;
        &lt;aop:config&gt;
            &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* cn.ssm.service.impl.*.*(..))&quot; /&gt;
        &lt;/aop:config&gt;
    &lt;/beans&gt;
    2. pom.xml：引入Dao模块的坐标
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;cn.ssm&lt;/groupId&gt;
                &lt;artifactId&gt;ssmdao&lt;/artifactId&gt;
                &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
7. Web模块
    1. springmvc.xml、web.xml 都和未拆分前相同;
    2. Spring的配置文件：resources/applicationContext.xml，把Dao和Service的部分合并到一起;
        &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
        &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
            xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
            xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
            &lt;!-- 导入Dao部分和Service部分的Spring配置文件 --&gt;
            &lt;import resource=&quot;classpath:spring/applicationContext-dao.xml&quot;/&gt;
            &lt;import resource=&quot;classpath:spring/applicationContext-service.xml&quot;/&gt;
        &lt;/beans&gt;
    3. pom.xml：引入Service模块的坐标
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;cn.ssm&lt;/groupId&gt;
                &lt;artifactId&gt;ssmservice&lt;/artifactId&gt;
                &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    4. 删除 pom.xml 中默认生成的JDK版本相关的&lt;properties&gt;，使用父工程中配置的JDK版本;
    5. 默认也生成了的&lt;build&gt;，也可以删除，父工程中已经配置了Tomcat7插件;
</code></pre><h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><pre><code>1. log4j.properties 放在 Web模块/resources 目录中，启动项目;
2. 方式一：打开右侧的Maven面板 --&gt; 展开父工程的Plugins --&gt; 双击 tomcat7:run 启动;
3. 配置本地的Tomcat，启动服务器，运行项目;
4. 方式三：选择 Web 工程的 tomcat7:run
    1. Maven项目在运行时会扫描 pom.xml，如果本地仓库没有引入的依赖，则从中央仓库下载，再找不到就报错;
    2. Web工程中引入了Service工程的坐标，但Service工程是本地项目，并没有发布到本地仓库，所以运行失败;
    3. 因此要把Service工程发布到本地仓库，但Service工程又引入了Dao工程的坐标，所以只能去发布父工程;
    4. 在右侧的Maven面板上，双击父工程的Lifecycle -&gt; install，等待安装成功;
    5. 启动Web工程的 tomcat7:run，运行项目;
</code></pre><h2 id="私服"><a href="#私服" class="headerlink" title="私服"></a>私服</h2><h3 id="搭建私服-windows"><a href="#搭建私服-windows" class="headerlink" title="搭建私服(windows)"></a>搭建私服(windows)</h3><pre><code>1. 使用专门的Maven仓库管理软件来搭建私服，比如：Apache Archiva，Artifactory，Sonatype Nexus
2. 选择Sonatype Nexus，下载开源版的Nexus压缩包，解压后有两个目录：应用程序目录，私服仓库目录(sonatype-work);
3. 以管理员模式启动cmd窗口，进入应用程序目录，执行bin目录下的 nexus.bat 命令;
    1. 安装、卸载、运行：nexus.bat install，nexus.bat uninstall，nexus.bat start
    2. 查看启动后的服务：右击计算机 -&gt; 管理 -&gt; 服务和应用程序 -&gt; 服务，在列表中查找 nexus;
4. nuxus的全局配置文件：conf/nexus.properties，默认使用的端口号是8081;
5. 启动图形化界面时，确保8081端口未被占用：http://localhost:8081/nexus
    1. 默认用户名和密码：admin，admin123
    2. 左侧导航栏：点击Repositories --&gt; 浏览仓库，查看仓库信息、地址;
    3. Add添加仓库，选择仓库类型：Hosted、Proxy、Virtual，还可以创建仓库组;
6. 创建不同的仓库，管理不同的依赖包
    1. 存放测试包的仓库Snapshots(hosted)，发布包的仓库Releases(hosted);
    2. 第三方包的仓库3rd party(hosted)，中央仓库的代理仓库Central(proxy);
    3. 创建仓库组，把已有的仓库按顺序添加到组中，在本地仓库在私服中查找依赖包时，就能按照仓库的顺序查找，
    最后由代理仓库转到中央仓库中去查找;
</code></pre><h3 id="发布私服"><a href="#发布私服" class="headerlink" title="发布私服"></a>发布私服</h3><pre><code>1. Maven的 settings.xml，配置私服仓库的信息
    &lt;servers&gt;
        &lt;server&gt;
            &lt;id&gt;releases&lt;/id&gt;  ===&gt;指定私服仓库的ID
            &lt;username&gt;admin&lt;/username&gt;  ===&gt;私服的用户名密码
            &lt;password&gt;admin123&lt;/password&gt;
        &lt;/server&gt;
        &lt;server&gt;
            &lt;id&gt;snapshots&lt;/id&gt;  ===&gt;指定私服仓库的ID
            &lt;username&gt;admin&lt;/username&gt;
            &lt;password&gt;admin123&lt;/password&gt;
        &lt;/server&gt;
    &lt;/servers&gt;
2. 要发布哪个项目/模块，就配置它的 pom.xml
    &lt;distributionManagement&gt;
        &lt;!-- 配置发布的仓库ID和地址 --&gt;
        &lt;repository&gt;  ===&gt;正式版的配置，明确发布到存放正式包的仓库
            &lt;id&gt;releases&lt;/id&gt;  ===&gt;此ID必须在 settings.xml 中已经配置过了
            &lt;url&gt;http://localhost:8081/nexus/content/repositories/releases/&lt;/url&gt;
        &lt;/repository&gt;
        &lt;snapshotRepository&gt;
            &lt;id&gt;snapshots&lt;/id&gt;  ===&gt;测试版的配置，明确发布到存放测试包的仓库
            &lt;url&gt;http://localhost:8081/nexus/content/repositories/snapshots/&lt;/url&gt;
        &lt;/snapshotRepository&gt;
    &lt;/distributionManagement&gt;
    1. 执行Lifecycle --&gt; deploy
    2. 执行前面的生命周期时，其后面的生命周期也会执行，所以 install 命令的执行，会把项目/模块安装到本地仓库;
</code></pre><h3 id="从私服下载jar"><a href="#从私服下载jar" class="headerlink" title="从私服下载jar"></a>从私服下载jar</h3><pre><code>Maven的 settings.xml
    &lt;profiles&gt;
        &lt;profile&gt; 
            &lt;id&gt;dev&lt;/id&gt;  ===&gt;profile的id
            &lt;repositories&gt;
                &lt;repository&gt;  ==&gt;仓库id，repositories可以配置多个仓库，保证id不重复
                    &lt;id&gt;nexus&lt;/id&gt;  ==&gt;仓库地址，即nexus仓库组的地址
                    &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt;
                    &lt;releases&gt;
                        &lt;enabled&gt;true&lt;/enabled&gt; ==&gt;是否下载releases构件
                    &lt;/releases&gt;
                    &lt;snapshots&gt;
                        &lt;enabled&gt;true&lt;/enabled&gt;  ==&gt;是否下载snapshots构件
                    &lt;/snapshots&gt;
                &lt;/repository&gt;
            &lt;/repositories&gt;
            &lt;pluginRepositories&gt;  ==&gt;插件仓库，Maven的运行依赖插件，也需要从私服下载插件
                &lt;pluginRepository&gt; ==&gt;插件仓库的id不允许重复，否则后者会覆盖前者
                    &lt;id&gt;public&lt;/id&gt;  ==&gt;配置为仓库组，仓库组的id
                    &lt;name&gt;Public Repositories&lt;/name&gt;  ==&gt;仓库组的名字
                    &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt;  ==&gt;仓库组的地址
                &lt;/pluginRepository&gt;
            &lt;/pluginRepositories&gt;
        &lt;/profile&gt;
    &lt;/profiles&gt;
    &lt;activeProfiles&gt;
        &lt;activeProfile&gt;dev&lt;/activeProfile&gt;  ==&gt;激活id=dev的profile
    &lt;/activeProfiles&gt;
</code></pre><h3 id="按照第三方jar包"><a href="#按照第三方jar包" class="headerlink" title="按照第三方jar包"></a>按照第三方jar包</h3><pre><code>1. 把第三方jar包安装到本地仓库，如fastjson.jar
    1. 查看fastjson.jar的坐标：groupId、artifactId、version;
    2. 进入fastjson.jar所在的目录，执行命令:
    mvn install:install-file -DgroupId=com.alibaba -DartifactId=fastjson -Dversion=1.1.37 
    -Dfile=fastjson-1.1.37.jar -Dpackaging=jar
    3. 如果不在fastjson.jar的目录，则需要指定绝对路径： -Dfile=D:\download\fastjson-1.1.37.jar
2. 把第三方jar包安装到私服
    1. 在Maven的 settings.xml 中，添加存放第三方jar包的仓库信息
        &lt;server&gt;
            &lt;id&gt;thirdparty&lt;/id&gt;
            &lt;username&gt;admin&lt;/username&gt;
            &lt;password&gt;admin123&lt;/password&gt;
        &lt;/server&gt;
    2. 进入jar所在目录
        mvn deploy:deploy-file -DgroupId=com.alibaba -DartifactId=fastjson -Dversion=1.1.37 
        -Dfile=fastjson-1.1.37.jar -Dpackaging=jar  -DrepositoryId=thirdparty 
        -Durl=http://localhost:8081/nexus/content/repositories/thirdparty/
        1. -Durl：私服的仓库地址;
        2. -DrepositoryId：私服的仓库ID;
    3. 如果不在jar包所在目录，-Dfile=jar包的绝对路径;
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/03/25/SSM整合/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/25/SSM整合/" itemprop="url">SSM整合</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-25T00:00:00+08:00">
                2016-03-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><pre><code>1. 表现层SpringMVC，业务层Spring，持久层MyBatis，整合方向就是用Spring框架去整合另外两个框架;
2. 使用Maven的Web骨架，创建一个Web项目;
3. pom.xml
    1. 配置JDK的运行编译版本，以及jar包的版本锁定
        &lt;properties&gt;
            &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
            &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
            &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
            &lt;spring.version&gt;5.1.6.RELEASE&lt;/spring.version&gt;
        &lt;/properties&gt;
    2. 配置Tomcat7插件
        &lt;build&gt;
            &lt;plugins&gt;
                &lt;plugin&gt;
                    &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;
                    &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;
                    &lt;version&gt;2.2&lt;/version&gt;
                &lt;/plugin&gt;
            &lt;/plugins&gt;
        &lt;/build&gt;
4. 相关依赖
    1. aspectjweaver、spring-aop、spring-context、spring-context-support、spring-web
    2. spring-orm、spring-beans、spring-core、spring-webmvc、spring-tx、spring-test(test)
    3. junit(test)、mysql-connector-jave、servlet-api(provided)、jsp-api(provided)、jstl
    4. log4j、slf4j-api、slf4j-log4j12、jackson-databind、jackson-core、jackson-annotations
    5. mybatis、mybatis-spring、c3p0(type:jar，scope:compile)、druid(两套连接池，根据需要选择)
    6. spring-security-web、spring-security-config、spring-security-core、spring-security-taglibs
5. 基本结构
    1. 实体类：cn.ssm.domain.User
        public class User implements Serializable {
            private Integer id;
            private String name;
            private Double money;
            ...... //setter、getter
        }
    2. Dao层：cn.ssm.dao.IUserDao
        public interface IUserDao {
            List&lt;User&gt; findAll();
            User findById(Integer id);
        }
    3. Service层：
        cn.ssm.service.IUserService
        cn.ssm.service.impl.UserServiceImpl
    4. Controller层：cn.ssm.controller.UserController
6. 配置文件(resources目录)
    1. Spring：applicationContext.xml
    2. SpringMVC：springmvc.xml
    3. 数据库配置信息：db.properties
        jdbc.driver=com.mysql.cj.jdbc.Driver
        jdbc.url=jdbc:mysql:///db_mybatis?serverTimezone=Asia/Shanghai
        jdbc.username=root
        jdbc.password=123456
</code></pre><h2 id="Spring整合MyBatis"><a href="#Spring整合MyBatis" class="headerlink" title="Spring整合MyBatis"></a>Spring整合MyBatis</h2><pre><code>1. 借助 mybatis-spring 包中的对象，把Mybatis的相关配置转移到Spring的配置文件中;
    1. SqlSessionFactoryBean: SqlSessionFactory的工厂对象;
        1. dataSource属性: 配置连接池;
        2. typeAliasesPackage属性: 扫描实体类(POJO)的所在包，为POJO配置别名;
    2. MapperScannerConfigurer: 扫描Dao层的包，为所有Dao接口提供代理对象;
2. Spring的配置文件：applicationContext.xml
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
        xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;
            http://www.springframework.org/schema/beans
            https://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            https://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/tx
            https://www.springframework.org/schema/tx/spring-tx.xsd
            http://www.springframework.org/schema/aop
            https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
        &lt;!-- Dao层使用映射配置文件的方式，那么只扫描service包 --&gt;
        &lt;context:component-scan base-package=&quot;cn.ssm.service&quot; /&gt;
        &lt;!-- SqlSessionFactory的工厂对象 --&gt;
        &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
            &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
            &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;cn.ssm.domain&quot; /&gt;
        &lt;/bean&gt;
        &lt;!-- 为所有Dao接口提供代理对象 --&gt;
        &lt;bean id=&quot;mapperScanner&quot; class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
            &lt;property name=&quot;basePackage&quot; value=&quot;cn.ssm.dao&quot; /&gt;
        &lt;/bean&gt;
        &lt;!-- 事务管理器 --&gt;
        &lt;bean id=&quot;manager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
            &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
        &lt;/bean&gt;
        &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;manager&quot;&gt;
            &lt;tx:attributes&gt;
                &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt;
                &lt;tx:method name=&quot;*&quot; isolation=&quot;DEFAULT&quot; /&gt;
            &lt;/tx:attributes&gt;
        &lt;/tx:advice&gt;
        &lt;aop:config&gt;
            &lt;!--切入点表达式--&gt;
            &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* cn.ssm.service.impl.*.*(..))&quot; /&gt;
        &lt;/aop:config&gt;
        &lt;!-- c3p0连接池：引入数据库配置信息的文件db.properties --&gt;
        &lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt;
        &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
            &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot; /&gt;
            &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot; /&gt;
            &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot; /&gt;
            &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;
        &lt;/bean&gt;
    &lt;/beans&gt;
3. Dao的映射配置文件
    1. 文件路径和名称与Dao接口保持一致，如cn.ssm.dao.IUserDao -&gt; resources/cn/ssm/dao/IUserDao.xml;
    2. IUserDao.xml
        &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
        &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
                &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
        &lt;mapper namespace=&quot;cn.ssm.dao.IUserDao&quot;&gt;
            &lt;select id=&quot;findAll&quot; resultType=&quot;user&quot;&gt;
                select * from users
            &lt;/select&gt;
            &lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt;
                select * from users where id=#{id}
            &lt;/select&gt;
        &lt;/mapper&gt;
4. Dao层使用注解开发
    1. Spring配置文件中，配置注解扫描包(扫描service包和dao包)，有两种方式
        1. 直接配置要扫描的包
        &lt;context:component-scan base-package=&quot;cn.ssm.dao&quot; /&gt;
        &lt;context:component-scan base-package=&quot;cn.ssm.service&quot; /&gt;
        2. 扫描指定包下的注解时，忽略 @Controller 注解
    &lt;context:component-scan base-package=&quot;cn.ssm&quot;&gt;
        &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;
    &lt;/context:component-scan&gt;
    2. SQL语句的注解
        public interface IUserDao {
            @Select(&quot;select * from users&quot;)
            List&lt;User&gt; findAll();

            @Select(&quot;select * from users where id=#{id}&quot;)
            User findById(Integer id);
        }
5. Service层使用注解开发，注入Dao对象
    @Service(&quot;userService&quot;)
    public class UserServiceImpl implements IUserService {
        @Autowired
        private IUserDao dao;

        public List&lt;User&gt; findAll() {
            return dao.findAll();
        }
    }
6. 测试
    @RunWith(SpringJUnit4ClassRunner.class)
    @ContextConfiguration(locations=&quot;classpath:applicationContext.xml&quot;)
    public class TestService {
        @Autowired
        private IUserService service;

        @Test
        public void testFindAll() {
            List&lt;User&gt; users = service.findAll();
        }
    }
</code></pre><h2 id="Spring整合SpringMVC"><a href="#Spring整合SpringMVC" class="headerlink" title="Spring整合SpringMVC"></a>Spring整合SpringMVC</h2><pre><code>1. SpringMVC的配置文件：resources/springmvc.xml
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;
            http://www.springframework.org/schema/beans
            https://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/mvc
            https://www.springframework.org/schema/mvc/spring-mvc.xsd
            http://www.springframework.org/schema/context
            https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
        &lt;!-- 开启注解扫描，只扫描controller包 --&gt;
        &lt;context:component-scan base-package=&quot;cn.ssm.controller&quot; /&gt;
        &lt;!--视图解析器--&gt;
        &lt;bean id=&quot;internalResourceViewResolver&quot; 
                class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
            &lt;property name=&quot;prefix&quot; value=&quot;/pages/&quot; /&gt;
            &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
        &lt;/bean&gt;
        &lt;!--处理静态资源--&gt;
        &lt;mvc:default-servlet-handler /&gt;
        &lt;!-- 开启SpringMVC的注解支持，并注册处理器映射器和处理器适配器 --&gt;
        &lt;mvc:annotation-driven /&gt;
    &lt;/beans&gt;
2. 开启注解扫描的两种方式
    1. 直接配置要扫描的包;
    2. 配置扫描的注解类型，只去扫描 @Controller 注解;
    &lt;context:component-scan base-package=&quot;cn.ssm&quot;&gt;
        &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;
    &lt;/context:component-scan&gt;
3. 在 webapp 目录中，分别创建存放JSP页面的 pages 目录，存放静态资源的 css、images、js 目录;
4. web.xml
    &lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee
            http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;
        version=&quot;3.0&quot;&gt;
        &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;
        &lt;!--配置Spring的核心监听器，重新指定Spring配置文件的路径，加载Spring的配置文件--&gt;
        &lt;listener&gt;
            &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
        &lt;/listener&gt;
        &lt;context-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/context-param&gt;
        &lt;!--编码过滤器，解决中文乱码--&gt;
        &lt;filter&gt;
            &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
            &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
            &lt;init-param&gt;
                &lt;param-name&gt;encoding&lt;/param-name&gt;
                &lt;param-value&gt;UTF-8&lt;/param-value&gt;
            &lt;/init-param&gt;
        &lt;/filter&gt;
        &lt;filter-mapping&gt;
            &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
            &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
        &lt;/filter-mapping&gt;
        &lt;!--前端控制器：SpringMVC的核心Servlet，在服务器启动时就创建并初始化，加载SpringMVC的配置文件--&gt;
        &lt;servlet&gt;
            &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
            &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
            &lt;init-param&gt;
                &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
                &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;
            &lt;/init-param&gt;
            &lt;!-- 在服务器启动时，就创建并初始化核心Servlet --&gt;
            &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
        &lt;/servlet&gt;
        &lt;servlet-mapping&gt;
            &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
            &lt;url-pattern&gt;/&lt;/url-pattern&gt;
        &lt;/servlet-mapping&gt;
    &lt;/web-app&gt;
5. Controller层
    @Controller
    @RequestMapping(&quot;/hello&quot;)
    public class HelloController {
        @Autowired
        private IUserService service;  //注入Service对象

        @RequestMapping(&quot;/test&quot;)
        @ResponseBody
        public String testHello() {
            List&lt;User&gt; users = service.findUserAll();
            return users;
        }
    }
6. 运行项目
    1. 右侧Maven面板 --&gt; 展开项目/Plugins/tomcat7 --&gt; 双击 tomcat7:run 运行项目;
    2. 配置本地的Tomcat，添加项目，启动Tomcat;
7. 如果使用了log4j，还需要把 log4j.properties 放在 resources 目录中
    # Set root category priority to INFO and its only appender to CONSOLE.
    #log4j.rootCategory=INFO, CONSOLE            debug   info   warn error fatal
    log4j.rootCategory=debug, CONSOLE, LOGFILE
    # Set the enterprise logger category to FATAL and its only appender to CONSOLE.
    log4j.logger.org.apache.axis.enterprise=FATAL, CONSOLE
    # CONSOLE is set to be a ConsoleAppender using a PatternLayout.
    log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender
    log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout
    log4j.appender.CONSOLE.layout.ConversionPattern=%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\n
    # LOGFILE is set to be a File appender using a PatternLayout.
    log4j.appender.LOGFILE=org.apache.log4j.FileAppender
    log4j.appender.LOGFILE.File=d:\axis.log
    log4j.appender.LOGFILE.Append=true
    log4j.appender.LOGFILE.layout=org.apache.log4j.PatternLayout
    log4j.appender.LOGFILE.layout.ConversionPattern=%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\n
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/03/16/SpringMVC进阶/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/16/SpringMVC进阶/" itemprop="url">SpringMVC进阶</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-16T00:00:00+08:00">
                2016-03-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="控制器方法的返回值"><a href="#控制器方法的返回值" class="headerlink" title="控制器方法的返回值"></a>控制器方法的返回值</h2><pre><code>1. resources/springmvc.xml：配置的视图解析器
    &lt;bean id=&quot;internalResourceViewResolver&quot; 
        class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/pages/&quot; /&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;
2. String
    @RequestMapping(&quot;/test&quot;)
    public String testStr(Model model) {
        User user = new User();  user.setName(&quot;JavaEE&quot;);  user.setAge(20);
        model.addAttribute(&quot;user&quot;, user);
        return &quot;test&quot;;
    }
    1. 返回的字符串默认作为逻辑视图名，通过视图解析器解析为物理视图的真实地址;
    2. 物理视图的真实地址：webapp/pages/test.jsp，渲染页面并响应给客户端;
    3. Model默认把数据存入Request域中，在 test.jsp 中获取这些数据;
        &lt;div&gt;${user.name}&lt;/div&gt; &lt;div&gt;${user.age}&lt;/div&gt;
3. void
    1. 控制器方法没有返回值时，默认以URL的最后一级作为视图名去查找JSP文件;
    2. 使用Servlet API手动转发/重定向时，SpringMVC的视图解析器不会再介入，所以要声明完整的路径名;
    @RequestMapping(path=&quot;/hello&quot;)
    public void test(HttpServletRequest req, HttpServletResponse res) {
        //手动转发到test.jsp
        req.getRequestDispatcher(&quot;/pages/test.jsp&quot;).forward(req, res);
        //手动重定向到index.jsp
        req.sendRedirect(req.getContextPath() + &quot;/index.jsp&quot;);
    }
4. 响应流数据
    @RequestMapping(path=&quot;/hello&quot;)
    public void test(HttpServletRequest req, HttpServletResponse res) {
        res.setCharacterEncoding(&quot;UTF-8&quot;);
        res.setContentType(&quot;text/html;charset=UTF-8&quot;);
        res.getWriter().print(&quot;你好，Java&quot;);
    }
5. ModelAndView
    1. SpringMVC提供的对象，用于封装Model和视图名;
        @RequestMapping(path=&quot;/hello&quot;)
        public ModelAndView test() {
            ModelAndView mv = new ModelAndView();
            User user = new User();  user.setName(&quot;JavaEE&quot;);  user.setAge(20);
            mv.addObject(&quot;user&quot;, user);  //存入数据
            mv.setViewName(&quot;test&quot;);  //指定视图名
            return mv;
        }
    2. 控制器方法返回字符串时，底层其实也是用 ModelAndView 进行封装.
6. 请求转发和重定向的关键字
    1. 控制器方法在返回字符串时，默认使用的就是请求转发;
    2. 转发的关键字：forward;  重定向的关键字：redirect;
        @RequestMapping(path=&quot;/hello&quot;)
        public String test() {
            return &quot;forward:/pages/test.jsp&quot;;  //转发到test.jsp
            return &quot;redirect:/index.jsp&quot;;  //重定向到index.jsp
        }
</code></pre><h3 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h3><pre><code>1. 控制器方法的返回值默认会解析为跳转路径，注解@ResponseBody的返回值不会再交给视图解析器，而是被直接写入响应体中;
    @RequestMapping(&quot;/test&quot;)
    @ResponseBody
    public String test() {
        return &quot;Hello SpringBoot&quot;;  //返回的字符串直接响应给客户端
    }
2. 控制器方法返回对象时，通过 HttpMessageConverter(消息转换器) 接口转为指定格式的数据，如JSON、XML;
3. SpringMVC默认使用MappingJacksonHttpMessageConverter对JSON数据进行转换;
4. 引入转换格式的依赖包jackson
    jackson-databind、jackson-core、jackson-annotations
5. 在JSP页面发送一个AJAX请求，参数为JSON格式
    public class User {
        private String username;  private String password;
        ......//setter、getter
    }
    $.ajax({
        url: &quot;user/getList&quot;,
        type: &quot;post&quot;,
        dataType: &quot;json&quot;,
        data: &apos;{&quot;username&quot;: &quot;Jack&quot;, &quot;password&quot;: &quot;123&quot;}&apos;,
        success: data=&gt;{ ... }
    });
    @RequestMapping(path=&quot;/getList&quot;)
    public @ResponseBody User test(@RequestBody User user) {
        String username = user.getUsername();
        String password = user.getPassword();
        ... //操作数据库
        User u = new User();
        ......  //封装一个新的User对象并返回
        return u;
    }
    1. @RequestBody：获取请求体的内容，SpringMVC会把JSON格式的请求体封装到User对象中;
    2. @ResponseBody：将返回的对象交给消息转换器，直接写入响应体中，响应给客户端.
</code></pre><h2 id="静态资源的处理"><a href="#静态资源的处理" class="headerlink" title="静态资源的处理"></a>静态资源的处理</h2><pre><code>1. 访问静态资源时，不需要经过前端控制器和过滤器，直接响应即可;
2. 使用Servlet来处理静态资源：web.xml 中配置名称为 default 的&lt;servlet&gt;标签;
    1. 处理 webapp/css 目录中的静态资源：以 /css/ 开头的URL;
        &lt;servlet-mapping&gt;
            &lt;servlet-name&gt;default&lt;/servlet-name&gt;
            &lt;url-pattern&gt;/css/*&lt;/url-pattern&gt;
        &lt;/servlet-mapping&gt;
    2. 处理后缀名为 .css、.js 的静态资源;
        &lt;servlet-mapping&gt;
            &lt;servlet-name&gt;default&lt;/servlet-name&gt;
            &lt;url-pattern&gt;*.css&lt;/url-pattern&gt;
        &lt;/servlet-mapping&gt;
        &lt;servlet-mapping&gt;
            &lt;servlet-name&gt;default&lt;/servlet-name&gt;
            &lt;url-pattern&gt;*.js&lt;/url-pattern&gt;
        &lt;/servlet-mapping&gt;
3. 在SpringMVC的配置文件springmvc.xml 中，使用 &lt;mvc:resources&gt; 标签配置静态资源的访问;
    &lt;mvc:annotation-driven /&gt;
    &lt;mvc:resources location=&quot;/css/&quot; mapping=&quot;/css/**&quot; /&gt;
    &lt;mvc:resources location=&quot;/images/&quot; mapping=&quot;/images/**&quot; /&gt;
    &lt;mvc:resources location=&quot;/js/&quot; mapping=&quot;/js/**&quot; /&gt;
    1. location属性：指定目录文件的路径，如 /css/ 表示 webapp/css 目录;
    2. mapping属性：匹配的请求路径，如 /css/** 表示匹配以 /css 开头的所有URL;
4. 更简便的配置方式
    &lt;mvc:default-servlet-handler /&gt;
    1. 它会在SpringMVC上下文中定义一个DefaultServletHttpRequestHandler，筛选URL;
    2. 如果发现静态资源，则交给名称为 default 的Servlet;
</code></pre><h3 id="SpringMVC的路径匹配模式"><a href="#SpringMVC的路径匹配模式" class="headerlink" title="SpringMVC的路径匹配模式"></a>SpringMVC的路径匹配模式</h3><pre><code>1. Spring MVC中的路径匹配模式，使用的是Apache Ant的样式路径，有三种通配符：?、*、**
    1. /*：拦截所有目录，不包含子目录;
    2. /**：拦截所有目录及其子目录.
2. ?：匹配任何单字符;
    1. /user/a?bc：能够匹配/user/axbc、/user/aXbc，但不包括/user/abc;
3. *：匹配 n&gt;=0 个字符，只能匹配一级目录，不能匹配子目录;
    1. /user/*：匹配 /user/、 /user/abc，但不能匹配 /user/abc/123;
    2. /app/*.jsp：匹配app目录下的所有 .jsp 文件.
4. **：匹配 n&gt;=0 个目录;
    1. /user/**：匹配以 /user 开头的所有URL;
    2. /**/example：匹配 /example、 /app/example、 /app/foo/example...
    3. /app/**/dir/file.：匹配 /app/dir/file.jsp、 /app/foo/dir/file.html ...
5. /**/*.jsp：匹配任何目录下的所有 .jsp 文件;
6. 所以，以 mvc 为命名空间的标签，在设置路径时，都遵循此路径匹配模式.
</code></pre><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><pre><code>1. 必要前提
    1. form表单的 enctype(表单请求正文的类型) 属性值为 multipart/form-data;
    2. method 必须是 POST;
    3. 提供一个文件选择域：&lt;input type=&quot;file&quot; /&gt;
2. 文件上传的依赖包：commons-fileupload、commons-io
    &lt;form action=&quot;user/fileupload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
        &lt;input type=&quot;file&quot; name=&quot;upload&quot; /&gt;
        &lt;input type=&quot;submit&quot; value=&quot;上传&quot; /&gt;
    &lt;/form&gt;
3. 传统上传方式
    @RequestMapping(path=&quot;/fileupload&quot;)
    public String uploadFile(HttpServletRequest req) {
        //获取上传目录的绝对路径
        String path = req.getSession().getServletContext().getRealPath(&quot;/uploads/&quot;);
        File file = new File(path);
        if(!file.exists()) {
            file.mkdirs();  //目录不存在则创建
        }
        DiskFileItemFactory factory = new DiskFileItemFactory();
        ServletFileUpload upload = new ServletFileUpload(factory);
        List&lt;FileItem&gt; items = upload.parseRequest(req);  //解析request
        for(FileItem item: items) {
            if(item.isFormField()) {
                //item只是一个普通的表单项
            } else {
                //item是一个上传文件项
                String filename = item.getName();  //获取文件名
                String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);
                filename = uuid + &quot;_&quot; + filename;  //不重复的文件名
                item.write(new File(path, filename));  //完成文件上传
                item.delete();  //删除生成的临时文件
            }
        }
        return &quot;success&quot;;
    }
</code></pre><h3 id="SpringMVC处理文件上传"><a href="#SpringMVC处理文件上传" class="headerlink" title="SpringMVC处理文件上传"></a>SpringMVC处理文件上传</h3><pre><code>1. 前端控制器接收到文件上传的请求时，会调用文件解析器，由文件解析器处理此请求;
2. 文件解析器会将处理结果封装到MultipartFile对象中，并将返回给前端控制器;
3. 前端控制器将上传文件对象MultipartFile，再传给对应的控制器方法;
4. 在配置文件 springmvc.xml 中配置文件解析器，其id值是固定的：multipartResolver
    &lt;bean id=&quot;multipartResolver&quot; 
        class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
        &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot; /&gt;  ==&gt;最大上传文件
    &lt;/bean&gt;
5. 上传标签的name属性值为upload，方法参数MultipartFile的变量名也必须为upload;
    @RequestMapping(path=&quot;/fileupload&quot;)
    public String uploadFile(HttpServletRequest req, MultipartFile upload) {
        //获取其他参数
        String xxx = req.getParameter(&quot;xxx&quot;);

        //获取上传目录的绝对路径
        String path = req.getSession().getServletContext().getRealPath(&quot;/uploads/&quot;);
        File file = new File(path);
        if(!file.exists()) {
            file.mkdirs();  //目录不存在则创建
        }
        String filename = upload.getOriginalFilename();  //获取文件名
        String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);
        filename = uuid + &quot;_&quot; + filename;  //不重复的文件名
        upload.transferTo(new File(path, filename));  //完成文件上传
        return &quot;success&quot;;
    }
</code></pre><h3 id="跨服务器的文件上传"><a href="#跨服务器的文件上传" class="headerlink" title="跨服务器的文件上传"></a>跨服务器的文件上传</h3><pre><code>1. 实际开发中，可能会有很多负责不同功能的服务器
    1. 应用服务器：负责部署处理业务的应用;
    2. 数据库服务器：数据持久化;
    3. 缓存和消息服务器：负责处理高并发访问的缓存和消息;
    4. 文件服务器：负责存储用户上传的文件;
2. 注意：这并不是服务器集群;
3. 实现跨服务器的依赖：jersey-core、jersey-client
    @RequestMapping(path=&quot;/fileupload&quot;)
    public String uploadFile(MultipartFile upload) {
        String filename = upload.getOriginalFilename();  //获取文件名
        String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);
        filename = uuid + &quot;_&quot; + filename;  //不重复的文件名
        //文件服务器的上传URL，一定有uploads目录
        String fileServer = &quot;http://localhost:9090/uploads/&quot;;
        //创建客户端对象
        Client client = Client.create();
        //与文件服务器建立连接
        WebResource web = client.resource(fileServer + filename);
        //上传文件
        web.put(upload.getBytes());
        return &quot;success&quot;;
    }
</code></pre><h2 id="异常处理器"><a href="#异常处理器" class="headerlink" title="异常处理器"></a>异常处理器</h2><pre><code>1. 控制器方法在处理业务发生异常时，会向上抛出，最终由前端控制器查找异常处理器，如果没有则抛给浏览器;
2. 使用异常处理器的目的是，当发生异常时，由异常处理器响应给用户一个友好页面；
3. 自定义异常类
    public class SysException extends Exception {
        private String message;  //存储提示信息
        //getter、setter
        public SysException(String message) {
            this.message = message;
        }
    }
4. 抛出异常
    @RequestMapping(path=&quot;/except&quot;)
    public String test() throws SysException {
        try {
            int i = 10/0;  //发生异常
        } catch(Exception e) {
            throw new SysException(&quot;保存用户失败！&quot;);
        }
        return &quot;success&quot;;
    }
5. 异常处理器：实现接口HandlerExceptionResolver
    public class SysExceptionResolver implements HandlerExceptionResolver {
        public ModelAndView resolveException(HttpServletRequest req, 
                HttpServletResponse res, Object handler, Exception ex) {
            SysException e = null;
            if(ex instanceof SysException) {
                e = (SysException) ex;
            } else {
                e = new SysException(&quot;不好意思，系统维护中~&quot;);
            }
            ModelAndView mv = new ModelAndView();
            mv.addObject(&quot;errorMsg&quot;, e.getMessage());  //向Request域存入提示信息
            mv.setViewName(&quot;error&quot;);  //跳转到自定义的错误页error.jsp
            return mv;
        }
    }
6. 在配置文件 springmvc.xml 中，配置异常处理器
    &lt;bean id=&quot;sysExceptionResolver&quot; class=&quot;cn.test.exception.SysExceptionResolver&quot;&gt;&lt;/bean&gt;
</code></pre><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><pre><code>1. SpringMVC的处理器拦截器类似于Servlet中的过滤器，用于对处理器进行预处理和后处理;
    1. 预处理和后处理类似于Koa的洋葱图；
    2. 请求到达 --&gt; 执行拦截器放行前的代码(预处理) --&gt; 放行到控制器方法 --&gt; 
    执行拦截器放行后的代码 --&gt; 响应结果
2. 拦截器链：将拦截器按照一定的顺序连接成一条链，在访问被拦截的方法/属性时，拦截器就会按顺序被调用;
3. 过滤器与拦截器
    1. 过滤器是Servlet规范中的一部分，拦截器是SpringMVC框架提供的；
    2. 过滤器在 url-pattern 中配置了 /* 之后，可以拦截所有要访问的资源；
    3. 拦截器只会拦截访问的控制器方法，如果是JSP、HTML、CSS、image、JS资源，是不会被拦截的。
4. 拦截器也是AOP思想的具体应用，自定义拦截器必须实现接口HandlerInterceptor
5. JDK1.8对接口做了增强，方法可以不是抽象的，所以在实现HandlerInterceptor时，并不强制实现此接口方法;
    public class MyInterceptor implements HandlerInterceptor {
        // preHandle()、postHandle()、afterCompletion()
    }
6. 在配置文件 springmvc.xml 中，配置拦截器：&lt;mvc:interceptors&gt;
    &lt;mvc:interceptors&gt;
        &lt;mvc:interceptor&gt;
            &lt;mvc:mapping path=&quot;/user/*&quot; /&gt;
            &lt;!-- &lt;mvc:exclude-mapping path=&quot;&quot;&gt; --&gt;
            &lt;bean class=&quot;cn.test.interceptor.MyInterceptor&quot; /&gt;
        &lt;/mvc:interceptor&gt;
    &lt;/mvc:interceptors&gt;
    1. 每一组 &lt;mvc:interceptor&gt; 标签，表示一个拦截器，标签的顺序决定了拦截器的调用顺序;
    2. &lt;mvc:mapping&gt;：配置拦截的控制器方法;
    3. &lt;mvc:exclude-mapping&gt;：配置不拦截的控制器方法;
    4. path 属性：指定URL，也就是控制器方法.
</code></pre><h3 id="拦截器方法"><a href="#拦截器方法" class="headerlink" title="拦截器方法"></a>拦截器方法</h3><pre><code>1. preHandle()：预处理方法
    public boolean preHandle(HttpServletRequest req, HttpServletResponse res, 
        Object handler) {
        return true;
    }
    1. 在控制器方法执行之前执行，返回true表示放行，执行下一个拦截器，如果没有了，则执行控制器方法;
    2. 返回false表示不放行，可以使用req对象和res对象自行处理请求与响应.
    public boolean preHandle(HttpServletRequest req, HttpServletResponse res, 
        Object handler) {
        req.getRequestDispatcher(&quot;/pages/error.jsp&quot;).forward(req, res); //转发到error.jsp
        return false;  //不放行
    }
2. postHandle()：后处理方法
    @RequestMapping(path=&quot;/test&quot;)
    public String test() {
        ....
        return &quot;success&quot;;
    }
    public void postHandle(HttpServletRequest req, HttpServletResponse res, 
        Object handler， ModelAndView mv) {
    }
    1. 在控制器方法执行完之后，执行success.jsp之前，执行postHandle();
    public void postHandle(HttpServletRequest req, HttpServletResponse res, 
        Object handler, ModelAndView mv) {
        req.getRequestDispatcher(&quot;/pages/error.jsp&quot;).forward(req, res);
    }
    2. 虽然postHandle()自行请求转发给error.jsp，但控制器方法的 success.jsp 仍会执行，
    响应给浏览器也是 error.jsp.
3. afterCompletion()：控制器方法的 success.jsp 执行完之后，才会执行;
    public void afterCompletion(HttpServletRequest req, HttpServletResponse res, 
        Object handler， Exception ex) {
    }
4. 当配置了多组拦截器时(都放行)
    @Controller
    @RequestMapping(path = &quot;/user&quot;)
    public class HelloController {
        @RequestMapping(path=&quot;/test&quot;)
        public String test() {
            ....
            return &quot;success&quot;;
        }
    }
    &lt;mvc:interceptors&gt;
        &lt;mvc:interceptor&gt;
            &lt;mvc:mapping path=&quot;/user/*&quot; /&gt;
            &lt;bean class=&quot;cn.test.interceptor.MyInterceptor&quot; /&gt;
        &lt;/mvc:interceptor&gt;
        &lt;mvc:interceptor&gt;
            &lt;mvc:mapping path=&quot;/**&quot; /&gt;
            &lt;bean class=&quot;cn.test.interceptor.TestInterceptor&quot; /&gt;
        &lt;/mvc:interceptor&gt;
    &lt;/mvc:interceptors&gt;
    &lt;a href=&quot;user/test&quot;&gt;to test&lt;/a&gt;
1. 执行顺序：
    MyInterceptor.preHandle() --&gt; TestInterceptor.preHandle() --&gt; HelloController.test()
    --&gt; TestInterceptor.postHandle() --&gt; MyInterceptor.postHandle() --&gt; success.jsp --&gt; 
    TestInterceptor.afterCompletion() --&gt; MyInterceptor.afterCompletion()
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/03/15/SpringMVC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/15/SpringMVC/" itemprop="url">SpringMVC</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-15T00:00:00+08:00">
                2016-03-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h2><pre><code>1. 开发架构一般都是基于两种形式：C/S(客户端/服务器)、B/S(浏览器/服务器);
2. JavaEE开发几乎都是基于B/S架构，系统标准的三层架构：表现层、业务层、持久层;
3. 表现层：web层，负责接收客户端请求，响应结果;
    1. 表现层包括展示层(负责展示结果)和控制层(负责接收请求);
    2. 表现层依赖于业务层，用于对请求进行业务处理，并把结果响应给客户端;
    3. 表现层的设计一般都是用MVC模型，MVC属于表现层的设计模型，跟其他层没关系.
4. 业务层：service层，负责业务处理，持久化数据时会依赖于持久层;
5. 持久层：dao层，负责数据持久化;
</code></pre><h3 id="MVC模型"><a href="#MVC模型" class="headerlink" title="MVC模型"></a>MVC模型</h3><pre><code>1. MVC：模型(Model)-视图(View)-控制器(Controller)，一种用于设计创建Web应用表现层的模型;
2. Model：数据模型，如JavaBean;
3. View：展示数据，如JSP、HTML;
4. Controller：处理程序逻辑.
</code></pre><h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><pre><code>1. SpringMVC是一种基于Java的实现MVC设计模型的请求驱动类型的轻量级Web框架;
2. SpringMVC属于Spring Framework的后续产品，已经融合在Spring Web Flow中;
3. Spring框架提供了构建Web应用的全能MVC模块，可以选择使用SpringMVC或其他MVC框架，如Struts2;
    1. SpringMVC已成为最主流的MVC框架之一，Spring3.0开始就已经全面超越了Struts2;
    2. SpringMVC通过一套注解，让一个Java类称为处理请求的控制器，而无需实现任何接口;
    3. SpringMVC还支持RESTful编程风格的请求;
</code></pre><p><img src="//hellomyshadow.github.io/2016/03/15/SpringMVC/SSM.jpg" alt="SSM"></p>
<h2 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h2><pre><code>创建Web项目，搭建环境
1. 引入依赖：版本锁定，统一管理Spring的版本
    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; ==&gt;配置编译运行的JDK版本
        &lt;spring.version&gt;5.1.6.RELEASE&lt;/spring.version&gt;  ===&gt;锁定版本
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        javax.servlet-api(provided)
        javax.servlet.jsp-api(provided)
    &lt;/dependencies&gt;
2. 配置文件resources/springmvc.xml，加入mvc和context约束
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;
            http://www.springframework.org/schema/beans
            https://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/mvc
            https://www.springframework.org/schema/mvc/spring-mvc.xsd
            http://www.springframework.org/schema/context
            https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
        &lt;!-- 开启扫描哪个包下的注解 --&gt;
        &lt;context:component-scan base-package=&quot;cn.test&quot;&gt;&lt;/context:component-scan&gt;
        &lt;!-- 视图解析器 --&gt;
        &lt;bean id=&quot;internalResourceViewResolver&quot; 
            class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
            &lt;property name=&quot;prefix&quot; value=&quot;/pages/&quot; /&gt;  ===&gt;文件所在目录，根目录是webapp
            &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;  ===&gt;文件的后缀名
        &lt;/bean&gt;
        &lt;!-- 开启SpringMVC的注解支持 --&gt;
        &lt;mvc:annotation-driven /&gt;
    &lt;/beans&gt;
3. webapp/WEB-INF/web.xml
    &lt;web-app&gt;
        &lt;servlet&gt;
            &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
            &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
            &lt;!-- 让控制器去加载spring配置文件 --&gt;
            &lt;init-param&gt;
                &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
                &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;
            &lt;/init-param&gt;
            &lt;!-- 控制器在接收第一次请求时才创建，所以要让它在服务器启动时创建，以加载配置文件 --&gt;
            &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
        &lt;/servlet&gt;
        &lt;servlet-mapping&gt;
            &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
            &lt;url-pattern&gt;/&lt;/url-pattern&gt;
        &lt;/servlet-mapping&gt;
    &lt;/web-app&gt;
    1. &lt;init-param&gt;：配置当前对象创建时的初始化参数;
    2. &lt;load-on-startup&gt;：标记容器是否在启动时就加载当前的Servlet(创建并调用其init()方法);
    3. 一般情况下，Servlet在第一次收到请求时由服务器创建并初始化，&lt;load-on-startup&gt; 可以让它
    根据自己的需要改变加载的优先级;
    4. &lt;load-on-startup&gt;n&lt;/load-on-startup&gt;：n 必须是一个整数，表示Servlet应该被加载的顺序;
    5. 当 n&gt;=0 时，表示在容器(服务器)启动时就加载并初始化这个Servlet，值越小，优先级越高;
    6. 当 n 的值相同时，由容器自己选择优先加载哪个Servlet.
4. 创建控制类：cn.test.controller.HelloController，使用 @Controller 修饰
    @Controller
    public class HelloController {
        @RequestMapping(path=&quot;/hello&quot;)
        public String say() {
            System.out.println(&quot;Hello SpringMVC&quot;);
            return &quot;success&quot;;  ---&gt;控制器默认把返回值作为页面的名称，去查找success.jsp
        }
    }
5. 在 webapp/pages 目录下创建success.jsp
6. 在项目的默认首页 webapp/index.jsp 中配置一个跳转标签：&lt;a href=&quot;hello&quot;&gt;To Hello&lt;/a&gt;
7. 部署服务器Tomcat Server
</code></pre><h3 id="访问过程"><a href="#访问过程" class="headerlink" title="访问过程"></a>访问过程</h3><pre><code>1. 启动服务器时：创建DispatcherServlet对象 --&gt; 加载springmvc.xml --&gt; 创建HelloController对象
2. 点击&lt;a&gt;，发送请求
    /hello --&gt; DispatcherServlet --&gt; HelloController.say() --&gt; DispatcherServlet --&gt;
    InternalResourceViewResolver --&gt; success.jsp --&gt; DispatcherServlet --&gt; 响应结果
</code></pre><p><img src="//hellomyshadow.github.io/2016/03/15/SpringMVC/组件控制流程.jpg" alt="组件控制流程"></p>
<pre><code>    1. DispatcherServlet：前端控制器，MVC模式中的C，整个控制流程的中心，调用其他组件处理
    用户的请求，降低了组件之间的耦合性;
    2. HandlerMapping：处理器映射器，根据用户请求找到Handler(处理器)，SpringMVC提供了不同的
    映射器实现不同的映射方式，如配置配置文件方式、实现接口方式、注解方式...
    3. Handler：处理器，开发编写的具体业务控制器，对具体的用户请求进行处理，由DispatcherServlet
    把请求转发到Handler;
    4. HandlerAdapter：处理器适配器，适配器模式的应用，对处理器进行执行;
    5. View Resolver：视图解析器，将处理结果生成View视图，首先根据逻辑视图名解析成物理视图名，
    即具体的页面地址，再生成View视图对象，并对View进行渲染，将处理结果通过页面展示给用户;
    6. View：视图，SpringMVC提供了很多View视图类型的支持，如jstlView、freemarkerView、pdfView...
    最常见的视图就是JSP;
3. &lt;mvc:annotation-driven&gt;
    1. 在SpringMVC的各个组件中，处理器映射器、处理器适配器、视图解析器，称为Spring的三大组件;
    2. &lt;mvc:annotation-driven&gt; 会自动加载 RequestMappingHandlerMapping(处理映射器) 和
    RequestMappingHandlerAdapter(处理适配器)
4. @RequestMapping：用于建立请求URL和处理请求方法之间的对应关系;
    1. @RequestMapping 可以用在类上，定义路径的一级目录，在其方法上定义二级目录;
        @Controller
        @RequestMapping(path=&quot;/user&quot;)  ---&gt;一级目录
        public class HelloController {
            @RequestMapping(path=&quot;/hello&quot;)  ---&gt;二级目录
            public String say() { ... }
        }
        &lt;a href=&quot;user/hello&quot;&gt;To User Hello&lt;/a&gt;
    2. value、path属性：指定请求的URL;
    3. method属性：请求方式，如 method=RequestMethod.POST
    4. params属性：限制请求参数的条件，支持简单的表达式，要求请求参数的key-value必须服从于配置;
        1. params={&quot;username&quot;}，则请求参数中必须包含username;
        &lt;a href=&quot;user/hello?username=Java&quot;&gt;
        2. params={&quot;money=100&quot;}，则请求参数中的money必须是100.
        &lt;a href=&quot;user/hello?money=100&quot;&gt;
    5. headers属性：限制请求头的条件，如headers={&quot;Accept&quot;}，请求头中必须包含Accept;
</code></pre><h2 id="请求参数的绑定"><a href="#请求参数的绑定" class="headerlink" title="请求参数的绑定"></a>请求参数的绑定</h2><pre><code>1. 绑定机制
    1. 表单提交的参数都是 key-value 形式，如username=Java&amp;password=123;
        &lt;a href=&quot;hello?username=Java&amp;password=123&quot;&gt;to hello&lt;/a&gt;
        @RequestMapping(path=&quot;/hello&quot;)
        public String say(String username, String password) {
            System.out.println(username + &quot;, &quot; + password);  //Java, 123
            return &quot;success&quot;;
        }
    2. SpringMVC的参数绑定过程是，把表单提交的参数作为控制器中方法的参数进行绑定的;
    3. 表单提交的key和参数的名称是一致的，且区分大小写.
2. 支持的参数类型：基本类型、实体类、集合类型;
    1. 提交表单的key和实体类中的属性名必须一致;
    2. 如果实体类中还有其他引用类型，那么表单中key的形式为：对象.属性，如address.name;
3. 绑定基本类型、实体类、集合类型
    private class User implements Serializable {
        private String uname;  private int age;
        ...... //setter、getter
    }
    private class Account implements Serializable {
        private String username;  private double money;
        private User user;  //包含引用类型
        private List&lt;User&gt; list;  //List集合
        private Map&lt;String, User&gt; map;  //Map集合
        ...... //setter、getter
    }
    1. form表单：key必须与实体类Account的属性保持一致;
        &lt;form action=&quot;hello&quot; method=&quot;post&quot;&gt;   ==&gt;跟请求方式无关，也可以是GET请求
            &lt;!-- 基本类型 --&gt;
            &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;
            &lt;input type=&quot;text&quot; name=&quot;money&quot; /&gt;
            &lt;!-- 实体类 --&gt;
            &lt;input type=&quot;text&quot; name=&quot;user.uname&quot; /&gt;
            &lt;input type=&quot;text&quot; name=&quot;user.age&quot; /&gt;
            &lt;!-- 集合类型 --&gt;
            &lt;input type=&quot;text&quot; name=&quot;list[0].uname&quot; /&gt;
            &lt;input type=&quot;text&quot; name=&quot;list[0].age&quot; /&gt;
            &lt;input type=&quot;text&quot; name=&quot;map[&apos;one&apos;].uname&quot; /&gt;
            &lt;input type=&quot;text&quot; name=&quot;map[&apos;one&apos;].age&quot; /&gt;
            &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;
        &lt;/form&gt;
    2. 把请求参数封装到JavaBean中
        @RequestMapping(path=&quot;/hello&quot;)
        public String say(Account account) {
            System.out.println(account);
            return &quot;success&quot;;
        }
4. 参数中文乱码：在 web.xml 中配置Spring的过滤器，并初始化参数encoding=UTF-8
    &lt;filter&gt;  ===&gt;过滤器标签排列在&lt;servlet&gt;标签之前
        &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
5. 在控制器中获取Servlet API：直接把 HttpServletRequest、HttpServletResponse 加到方法的参数上;
    @RequestMapping(path=&quot;/hello&quot;)
    public String say(HttpServletRequest request, HttpServletResponse response) {
        HttpSession session = request.getSession();
        ServletContext context = session.getServletContext();
    }
</code></pre><h3 id="类型转换器"><a href="#类型转换器" class="headerlink" title="类型转换器"></a>类型转换器</h3><pre><code>1. 在参数传递过程中，key和value其实都是字符串，SpringMVC内部有类型转换器，负责转换参数类型;
2. 但是，对于一些特殊类型，如日期，SpringMVC并不能识别所有的日期格式，这就需要自定义类型转换器;
3. 类型转换器的接口：Converter&lt;S, T&gt;，S和T分别代表接受类型和目标类型
    public class String2DateConverter implements Converter&lt;String, Date&gt; {
        public Date convert(String source) {
            if(source == null) {
                throw new RuntimeException(&quot;请传入参数&quot;);
            }
            //字符串转日期的识别类型 yyyy-MM-dd
            DateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
            try {
                return df.parse(source);
            } catch(Exception e) {
                throw new RuntimeException(&quot;类型转换异常&quot;);
            }
        }
    }
4. springmvc.xml：配置自定义的类型转换器
    &lt;bean id=&quot;csfb&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt;
        &lt;property name=&quot;converters&quot;&gt;
            &lt;set&gt;
                &lt;bean class=&quot;cn.test.converter.String2DateConverter&quot; /&gt;
            &lt;/set&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;mvc:annotation-driven conversion-service=&quot;csfb&quot; /&gt;
    1. &lt;mvc:annotation-driven&gt; 标签开启SpringMVC的注解支持;
    2. conversion-service属性：让配置的自定义日期类型转换器生效.
5. 当遇到字符串需要转Date时，SpringMVC会自动调用自定义的类型转换器.
    &lt;a href=&quot;hello?date=2018-11-12&quot;&gt;to hello&lt;/a&gt;
    @RequestMapping(path=&quot;/hello&quot;)
    public String say(Date date) {  --&gt; &quot;2018-11-12&quot; 转 Date对象
        return &quot;success&quot;;
    }
</code></pre><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><pre><code>@Controller
@RequestMapping(&quot;/user&quot;)
public class TestController { ... }
1. @RequestParam：把请求中指定名称的参数，给控制器中的形参赋值;
    1. value、name属性：请求参数中的名称;
    2. required：请求参数中是否必须提供此参数，默认为true;
    3. defaultValue属性：设置默认值，如果参数中没有携带指定的属性，则使用默认值;
        @RequestMapping(path=&quot;/test&quot;)
        public String test(@RequestParam(name=&quot;uname&quot;) String username) {
            return &quot;success&quot;;
        }
    3. 请求参数中必须提供一个key为 uname 的键值对，uname的值会赋给形参username;
        &lt;a href=&quot;user/test?name=Java&quot;&gt;Welcome&lt;/a&gt;
    4. 不使用 @RequestParam 时，形参username 只会接收请求参数中key为 username 的值，
    如果请求参数中没有，则形参username 仍为默认值null.
2. @RequestBody：用于获取请求体的内容;
    1. HTTP请求头必须是content-type=application/json，且使用body传输数据，所以是POST请求;
    2. required属性：是否必须有请求体;
    3. 直接使用时会得到整个请求体的内容：key=value&amp;key=value...
        &lt;form action=&quot;user/test&quot; method=&quot;post&quot;&gt;
            &lt;input type=&quot;text&quot; name=&quot;uname&quot; /&gt;  ==&gt;Java
            &lt;input type=&quot;text&quot; name=&quot;age&quot; /&gt;  ====&gt;22
            &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;
        &lt;/form&gt;
        @RequestMapping(path=&quot;/test&quot;)
        public String test(@RequestBody String body) {
            System.out.println(body);  // uname=Java&amp;age=22
            return &quot;success&quot;;
        }
    3. 引入Jackson相关的依赖之后，可以把请求体封装到POJO对象中
        @RequestMapping(path=&quot;/test&quot;)
        public String test(@RequestBody User user) {
            return &quot;success&quot;;
        }
3. @PathVariable：用于绑定url中的占位符，如/delete/{id}，id就是url占位符;
    1. url支持占位符是在Spring3.0才加入的，它是SpringMVC支持RESTful风格URL的一个重要标志;
    2. value、name属性：指定URL中占位符的名称;
    3. required：是否必须提供占位符;
        @RequestMapping(path=&quot;/test/{uId}&quot;)
        public String test(@PathVariable(name=&quot;uId&quot;) String id) {
            System.out.println(id);  // 10
            return &quot;success&quot;;
        }
        &lt;a href=&quot;user/test/10&quot;&gt;Welcome&lt;/a&gt;
4. HiddentHttpMethodFilter
    1. 浏览器的form表单只支持GET与POST请求，无法模拟DELETE、PUT等RESTful method;
    2. Spring3.0提供了一个过滤器，可以将浏览器请求改为指定的请求的方式，再发给控制器方法.
5. @RequestHeader：获取请求头
    1. value属性：提供请求头的名称;
    2. required：是否必须有此请求头;
        @RequestMapping(path=&quot;/test&quot;)
        public String test(@RequestHeader(value=&quot;Accept&quot;) String header, int id) {
            System.out.println(header);
            return &quot;success&quot;;
        }
6. @CookieValue：把指定Cookie名称的值传给控制器方法的参数;
    1. value属性：指定Cookie的名称;
    2. required：是否必须有此Cookie;
        @RequestMapping(path=&quot;/test&quot;)
        public String test(@CookieValue(value=&quot;JSESSIONID&quot;) String cookieValue) {
            System.out.println(cookieValue);
            return &quot;success&quot;;
        }
</code></pre><h3 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="ModelAttribute"></a>ModelAttribute</h3><pre><code>1. @ModelAttribute：SpringMVC4.3新特性，可以修饰方法和参数;
    1. 修饰方法时：当前方法会在控制器的方法执行之前，优先执行;
    2. 可以修饰没有返回值的方法，也可以修饰有具体返回值的方法;
    3. 修饰参数时：获取指定的数据，并赋值给参数;
    4. value属性：获取数据的key，可以是POJO的属性名，也可以是Map结构的key;
2. 应用：当表单提交参数不是完整的实体类数据时，保证没有提交的字段使用数据库中的原数据;
    &lt;form action=&quot;user/test&quot; method=&quot;post&quot;&gt;
        &lt;input type=&quot;text&quot; name=&quot;uname&quot; /&gt;  ===&gt;只提交一个参数uname
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;
    &lt;/form&gt;
3. 修饰有返回值的方法
    @RequestMapping(path=&quot;/test&quot;)
    public String test(User user) {
        System.out.println(user);
        return &quot;success&quot;;
    }
    @ModelAttribute
    public User initTest(String uname) {
        User user = new User();
        user.setUname(uname);
        ...... //查询数据库，获取age字段
        user.setAge(20);
        return user;
    }
    1. initTest() 优先执行，形参uname 接收请求参数中的uname，返回一个User对象;
    2. test() 执行时，形参user 接收 initTest() 返回的User对象.
4. 修饰无返回值的方法
    @RequestMapping(path=&quot;/test&quot;)
    public String test(@ModelAttribute(&quot;abc&quot;) User user) {
        System.out.println(user);
        return &quot;success&quot;;
    }
    @ModelAttribute
    public void initTest(String uname, Map&lt;String, User&gt; map) {
        User user = new User();
        user.setUname(uname);
        ...... //查询数据库，获取age字段
        user.setAge(20);
        map.put(&quot;abc&quot;, user);
    }
    1. initTest() 优先执行，形参uname 接收请求参数中的uname，把User对象存入Map集合;
    2. test() 的形参user 通过 @ModelAttribute(&quot;Map集合的key&quot;) 获取Map中的User对象.
</code></pre><h3 id="SessionAttributes"><a href="#SessionAttributes" class="headerlink" title="SessionAttributes"></a>SessionAttributes</h3><pre><code>1. 为了向域中存储数据，在控制器方法的参数上直接使用Servlet API，这种方式耦合度太高;
2. 为了解决与Serlvet的耦合度问题，Spring提供了接口Model，并提供了很多实现类;
    @RequestMapping(path=&quot;/test&quot;)
    public String test(Model model) {
        model.addAttribute(&quot;msg&quot;, &quot;Java&quot;);  --&gt; 存入数据
        return &quot;success&quot;;
    }
    1. Model默认会把数据存到Request域中;
    2. 在JSP中取值：&lt;h2&gt;${ requestScope.msg }&lt;/h2&gt;
3. @SessionAttributes：用于多次执行控制器方法间的参数共享;
    1. 只能修饰类，让Model把数据被存入Session域中;
    2. value、names属性：String数组，用于指定存入数据的key;
    3. types：根据指定参数的类型，将模型中对应类型的参数存储到session中;
        @Controller
        @RequestMapping(&quot;/user&quot;)
        @SessionAttributes(value={&quot;msg&quot;})  ---&gt;指定key的名称
        public class TestController {
            @RequestMapping(path=&quot;/test&quot;)
            public String test(Model model) {
                model.addAttribute(&quot;msg&quot;, &quot;Java&quot;);  --&gt;向Session域中存入值
                return &quot;success&quot;;
            }

            @RequestMapping(path=&quot;/get&quot;)
            public String test(ModelMap map) {
                String msg = (String)map.get(&quot;msg&quot;);  --&gt;从Session域中获取值
                return &quot;get&quot;;
            }

            @RequestMapping(path=&quot;/del&quot;)
            public String test(SessionStatus status) {
                status.setComplete();  --&gt;从Session域中删除值
                return &quot;del&quot;;
            }
        }
    2. Model会将数据存入到Request域和Session域中;
    3. 在JSP中获取数据：
        &lt;h2&gt;${ requestScope.msg }&lt;/h2&gt;  &lt;h2&gt;${ sessionScope.msg }&lt;/h2&gt;
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/03/11/Spring5新特性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/11/Spring5新特性/" itemprop="url">Spring5新特性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-11T00:00:00+08:00">
                2016-03-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>1. Spring5.0在2017年9月发布了GA(通用)版本，基于JDK8，兼容JDK9，但JDK8以下版本无法使用;
    1. Tomcat版本要求最低8.5，使用JDK8构建工程，可以降版编译，但不能使用JDK8-构建工程;
    2. 随着JDK和Tomcat的更新，相应的IDE也要更新.
2. JDK8的更新
    1. 反射增强：大量创建对象、给对象的属性设置值、反射创建对象...的速度都大大加快;
    2. @NotNull、@Nullable
        1. 显示表明可为空的参数/返回值，实现在编译期处理空值，避免在运行期抛出Null异常;
    3. 日志记录
        1. Spring5.0新增Commons Logging桥接模块的封装，称为spring-jcl，并不是标准的CL;
        2. 当然，无需任何额外的桥接，新版本也会对Log4j2.x、SLF4J、JUL进行自动检测.
3. 核心容器的更新
    1. Spring5.0支持候选组件索引作为类路径扫描的替代方法;
    2. 从索引读取实体而不是扫描类路径，对小于200个类的小型项目没有明显差异，但对大型项目影响较大;
    3. 加载组建索引的耗费是廉价的，所以随着类的数量增长，启动时间仍可以维持一个常数;
    4. 对于Spring项目的开发者而言，应用程序的启动时间将被大大缩减.
4. 支持Kotlin：一种支持函数式编程的面向对象语言，运行在JVM之上，但运行环境又不仅限于JVM;
5. 响应式编程风格
    1. spring-webflux：支持响应式HTTP和WebSocket客户端;
    2. spring-webflux中包含两种独立的服务端编程模型;
        1. 基于注解：使用 @Controller 以及 SpringMVC的一些注解;
        2. 使用Java8 lambda表达式的函数式风格的路由和处理.
6. 支持JUnit5：JUnit5 = JUnit Platform + JUnit Jupiter + JUnit Vintage
7. 依赖类库的更新
    1. 不再支持的类库：Portlet、Velocity、JasperReports、XMLBeans、JDO、Guava
    2. 新支持的类库：Jackson2.6+、EhCache2.1+/3.0GA、Hibernate5.0+、JDBC4.0+、XmlUnit2.x+、
    OkHttp3.x+、Netty4.1+
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/03/09/Spring事务控制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/09/Spring事务控制/" itemprop="url">Spring事务控制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-09T00:00:00+08:00">
                2016-03-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h2><pre><code>1. JdbcTemplate是Spring提供的一个对象，对原始JDBC的一层简单封装；
    1. 操作关系型数据库：JdbcTemplate、HibernateTemplate
    2. 操作NoSQL数据库：RedisTemplate
    3. 操作消息队列：JmsTemplate
</code></pre><p><img src="//hellomyshadow.github.io/2016/03/09/Spring事务控制/持久层.jpg" alt="持久层"></p>
<pre><code>2. JdbcTemplate的依赖包：spring-jdbc，除此之外，还有事务相关的依赖：spring-tx
    spring-context、spring-jdbc、spring-tx、mysql-connector-java
3. JdbcTemplate的简单使用
    1. 实体类Account
        public class Account {
            private int id;  private String name;  private float money;
            //setter、getter
        }
    2. Spring的内置数据源DriverManagerDataSource
        DriverManagerDataSource ds = new DriverManagerDataSource();
        ds.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;);
        ds.setUrl(&quot;jdbc:mysql://...&quot;);  ds.setUsername(&quot;root&quot;);  ds.setPassword(&quot;123456&quot;);
        JdbcTemplate jt = new JdbcTemplate();
        jt.setDataSource(ds);
        jt.execute(&quot;insert into account(name, money) values(&apos;Java&apos;, 1000)&quot;);
4. JdbcTemplate的CRUD
    1. 插入一条数据
        jt.update(&quot;insert into account(name, money) values(?, ?)&quot;, &apos;AAA&apos;, 1000);
    2. 修改/删除
        jt.update(&quot;update/delete ...&quot;, ...);
    3. 查询
        jt.query(String sql, Object[] args, RowMapper&lt;T&gt; rowMapper); //通用方式
        jt.query(String sql, RowMapper&lt;T&gt; rowMapper, Object... args); //JDK1.5+
    4. RowMapper：接口，泛型就是实体类，其方法 mapRow() 用于把数据封装到实体类对象中
        class AccountRowMapper implements RowMapper&lt;Account&gt; {
            public Account mapRow(ResultSet rs, int rowNum) {
                Account account = new Account();
                account.setId(rs.getInt(&quot;id&quot;));
                account.setName(rs.getString(&quot;name&quot;));
                account.setMoney(rs.getFloat(&quot;money&quot;));
                return account;
            }
        }
    List&lt;Account&gt; ats = jt.query(&quot;select * from account where money&gt;?&quot;, new AccountRowMapper(), 100f);
    5. Spring也提供了RowMapper的实现类：BeanPropertyRowMapper
    jt.query(&quot;select * from account&quot;, new BeanPropertyRowMapper&lt;Account&gt;(Account.class));
5. 聚合函数
Integer count = jt.queryForObject(&quot;select count(id) from account where money&gt;?&quot;, Integer.class, 100f);
</code></pre><h3 id="基于Spring-IoC"><a href="#基于Spring-IoC" class="headerlink" title="基于Spring IoC"></a>基于Spring IoC</h3><pre><code>1. Dao层的接口及其实现类：IAccountDao、AccountDaoImpl
    public class AccountDaoImpl implements IAccountDao {
        private JdbcTemplate jt;
        ......//setter、CRUD
    }
2. IoC配置文件bean.xml
    &lt;bean id=&quot;accountDao&quot; class=&quot;cn.test.dao.impl.AccountDaoImpl&quot;&gt;
        &lt;property name=&quot;jt&quot; ref=&quot;jt&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;jt&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;ds&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;ds&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://...&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
3. 直接使用Dao层操作数据库
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
    IAccountDao dao = ac.getBean(&quot;accountDao&quot;, IAccountDao.class);
</code></pre><h3 id="JdbcDaoSupport"><a href="#JdbcDaoSupport" class="headerlink" title="JdbcDaoSupport"></a>JdbcDaoSupport</h3><pre><code>1. 如果有多个Dao，那么每个Dao中都会有属性JdbcTemplate及其setter，需要抽取其中的重复代码
    1. 定义一个Dao层的父类JdbcDaoSupport
        public class JdbcDaoSupport {
            private JdbcTemplate jdbcTemplate;
            //创建无参的JdbcTemplate对象
            public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {
                this.jdbcTemplate = jdbcTemplate;
            }
            public JdbcTemplate getJdbcTemplate() {
                return this.jdbcTemplate;
            }
            //创建带参DataSource的JdbcTemplate对象
            public void setDataSource(DataSource dataSource) {
                if(this.jdbcTemplate == null) {
                    this.jdbcTemplate = this.createJdbcTemplate(dataSource);
                }
                this.jdbcTemplate = jdbcTemplate;
            }
            private JdbcTemplate createJdbcTemplate(DataSource dataSource) {
                return new JdbcTemplate(dataSource);
            }
        }
    2. Dao层继承JdbcDaoSupport
        public class AccountDaoImpl extends JdbcDaoSupport implements IAccountDao {
            public List&lt;Account&gt; findAll() {
                return supper.getJdbcTemplate().query(&quot;select * from account&quot;, ...);
            }
            ......//CRUD
        }
    3. 在为 AccountDaoImpl 注入数据时，可以选择使用无参的JdbcTemplate还是有参的JdbcTemplate
        &lt;bean id=&quot;accountDao&quot; class=&quot;cn.test.dao.impl.AccountDaoImpl&quot;&gt;
            &lt;!-- 使用无参的JdbcTemplate对象 --&gt;
            &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jt&quot;&gt;&lt;/property&gt;
            &lt;!-- 使用有参DataSource的JdbcTemplate对象，二选一 --&gt;
            &lt;property name=&quot;dataSource&quot; ref=&quot;ds&quot;&gt;&lt;/property&gt;
        &lt;/bean&gt;
        ......// jt、ds
2. 另外，Spring提供了一个JdbcDaoSupport，功能和XML注入方式都与自定义的JdbcDaoSupport类似;
3. JdbcDaoSupport是Spring的内置类，一旦Dao层继承它，那么在Service层使用Dao对象时，就只能用配置文件的方式
   实现注入，而不能再使用 @Autowired 注入 Dao 了。
</code></pre><h2 id="注解AOP实现事务"><a href="#注解AOP实现事务" class="headerlink" title="注解AOP实现事务"></a>注解AOP实现事务</h2><pre><code>1. 连接的工具类
    @Commonent(&quot;connUtils&quot;)
    public class ConnectionUtils {
        private ThreadLocal&lt;Connection&gt; tl = new ThreadLocal&lt;&gt;();
        @Autowired
        private DataSource dataSource;

        public Connection getThreadConn() {
            Connection conn = tl.get();
            if(conn == null) { //从数据源中获取一个连接，并存入连接池
                conn = dataSource.getConnection();
                tl.set(conn);
            }
            return conn;
        }
        public void removeConn() {
            tl.remove();  // 移除ThreadLocal中当前线程的连接
        }
    }
2. 事务管理的工具类，声明为切面类
    @Commonent(&quot;manager&quot;)
    @Aspect
    public class TransactionManager {
        @Autowired
        private ConnectionUtils connUtils;
        @Pointcut(&quot;execution(* it.bank.service.impl.*.*(..))&quot;)
        private void pt1() {}
        @Before(&quot;pt1()&quot;)
        public void beginTransaction() {  //开启手动提交事务
            connUtils.getThreadConn().setAutoCommit(false);
        }
        @AfterReturning(&quot;pt1()&quot;)
        public void commit() {  //手动提交事务
            connUtils.getThreadConn().commit();
        }
        @AfterThrowing(&quot;pt1()&quot;)
        public void rollback() {  //回滚
            connUtils.getThreadConn().rollback();
        }
        @After(&quot;pt1()&quot;)
        public void release() {  //释放连接，并还给连接池
            connUtils.getThreadConn().close();
            connUtils.removeConn();
        }
    }
3. 但是在AOP注解中，通知方法的执行顺序有致命问题：Before --&gt; After --&gt; AfterReturning
    1. 最终通知优先于后置通知执行，导致连接已经被关闭了，事务无法正确提交！
    2. 连接关闭并还给连接池后，提交时又会从连接池中获取一个新的连接，但此连接又没有开启过事务，导致提交异常。
4. 使用环绕通知
    @Commonent(&quot;manager&quot;)
    @Aspect
    public class TransactionManager {
        @Autowired
        private ConnectionUtils connUtils;
        @Pointcut(&quot;execution(* it.bank.service.impl.*.*(..))&quot;)
        private void pt1() {}

        public void beginTransaction() { ... }
        public void commit() { ... }
        public void rollback() { ... }
        public void release() { ... }

        @Around(&quot;pt1()&quot;)
        public Object aroundPrint(ProceedingJoinPoint pjp) {
            Object rtValue = null;
            try {
                Object[] args = pjp.getArgs();  //1.获取切入点方法执行所需的参数
                this.beginTransaction();  //2.开启事务
                rtValue = pjp.proceed(args);  //3.明确调用切入点方法
                this.commit();  //4.提交事务
                return rtValue;  //5.返回结果
            } catch(Throwable t) {
                this.rollback();
                throw new RuntimeException(t);
            } finally {
                this.release();
            }
        }
    }
</code></pre><h2 id="Spring的事务控制"><a href="#Spring的事务控制" class="headerlink" title="Spring的事务控制"></a>Spring的事务控制</h2><pre><code>1. TransactionManager是自定义的事务管理，Spring也有自己的事务控制；
    1. JavaEE体系进行分层开发时，事务控制位于业务层，Spring提供了业务层的事务控制方案；
    2. Spring提供了一组事务控制的接口，这些API就在spring-tx中；
    3. Spring的事务控制都是基于AOP的，它既可以使用编程式实现，也可以使用配置实现。
2. 相关依赖：spring-context、spring-jdbc、spring-tx、mysql-connector-java、aspectjweaver
</code></pre><h3 id="事务控制的API"><a href="#事务控制的API" class="headerlink" title="事务控制的API"></a>事务控制的API</h3><pre><code>1. PlatformTransactionManager：提供事务操作的接口
    1. getTransaction(TransactionDefinition d)：获取事务的状态信息;
    2. commit(TransactionStatus status)：提交事务;
    3. rollback(TransactionStatus status)：回滚事务;
    4. 实现类：DataSourceTransactionManager、HibernateTransactionManager;
    5. DataSourceTransactionManager：用于Spring JDBC 或 iBatis;
    6. HibernateTransactionManager：用于hibernate.
2. TransactionDefinition：事务的定义信息
    1. getName()：获取事务的名称;
    2. getIsolationLevel()：获取事务的隔离级别;
    3. getPropagationBehavior()：获取事务的传播行为;
    4. 传播行为：何时才需要事务(增删改)，何时不需要事务(查询);
    5. getTimeout()：事务的超时时间，提交和回滚何时过期，可以配置为永不过期;
    6. isReadOnly()：事务是否只读，读写型事务(增删改)、只读型事务(查询);
3. 事务的隔离级别
    1. ISOLATION_DEFAULT：使用数据库的默认隔离级别;
    2. ISOLATION_READ_UNCOMMITTED：读未提交;
    3. ISOLATION_READ_COMMITTED：读已提交，Oracle的默认级别;
    4. ISOLATION_REPEATABLE_READ：不可重读，MySQL的默认隔离级别;
    5. ISOLATION_SERIALIZABLE：最高级别.
4. 事务的传播行为
    1. REQUIRED：默认值，如果当前没有事务，则新建一个，如果已存在一个事务，则加入到该事务中;
    2. SUPPORTS：支持当前事务，如果当前没有事务，则以非事务的方式执行(有就用，没有就不用);
    3. MANDATORY、REQUERS_NEW、NOT_SUPPORTED、NEVER、NESTED
5. 超时时间：以秒为单位，默认值-1，表示没有超时限制;
6. TransactionStatus：描述某个时间点上事务对象的状态信息;
    1. flush()：刷新事务;
    2. hasSavepoint()：是否存在存储点，将一个事务按步提交，如果某一步失败，只回滚到这一步前，而不是从头开始;
    3. isCompleted()：事务是否完成;
    4. isNewTransaction()：当前事务是不是一个新事务;
    5. isRollbackOnly()：事务是否回滚;
    6. setRollbackOnly()：设置事务回滚;
</code></pre><h3 id="声明式事务控制"><a href="#声明式事务控制" class="headerlink" title="声明式事务控制"></a>声明式事务控制</h3><pre><code>1. Dao层：IAccountDao、AccountDaoImpl(继承Spring的JdbcDaoSupport)
2. Service层：IAccountService、AccountServiceImpl
    public class AccountServiceImpl implements IAccountService {
        private IAccountDao dao; //setter
        public Account findById(int id) {
            return dao.findById(id);
        }
        public void transfer(String sourceName, String targetName, Float money) {
            Account source = dao.findByName(sourceName);
            Account target = dao.findByName(targetName);
            source.setMoney(source.getMoney() - money);
            target.setMoney(target.getMoney() + money);
            //更新数据库
            dao.updateAccount(source);
            int i = 1/0;  //发生异常，不再向下执行
            dao.updateAccount(target);
        }
    }
3. bean.xml：加入事务、AOP的约束
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
        xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
        xsi:schemaLocation=&quot;
            http://www.springframework.org/schema/beans
            https://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/tx
            https://www.springframework.org/schema/tx/spring-tx.xsd
            http://www.springframework.org/schema/aop
            https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
        &lt;bean id=&quot;accountService&quot; class=&quot;cn.test.service.impl.AccountServiceImpl&quot;&gt;
            &lt;property name=&quot;dao&quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt;
        &lt;/bean&gt;
        &lt;bean id=&quot;accountDao&quot; class=&quot;cn.test.dao.impl.AccountDaoImpl&quot;&gt;
            &lt;property name=&quot;dataSource&quot; ref=&quot;ds&quot;&gt;&lt;/property&gt;
        &lt;/bean&gt;
        &lt;bean id=&quot;ds&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
            ......
        &lt;/bean&gt;
4. 配置事务管理器：DataSourceTransactionManager
    &lt;bean id=&quot;manager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;ds&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
5. &lt;tx:advice&gt;：配置事务通知，关联事务管理器;
    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;manager&quot;&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name=&quot;transfer&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;
    1. id属性：此事务通知的唯一标识;
    2. transaction-manager：指定事务管理器的id，关联事务通知与事务管理器.
6. &lt;tx:method&gt;：配置事务管理的方法;
    1. name属性：用于指定方法名，支持正则通配符*
        1. name=&quot;find*&quot;：匹配以 find 开头的方法;
        2. 配置多个&lt;tx:method&gt;，为不同的方法设置不同的参数，name的范围越小，优先级越高;
        &lt;tx:method name=&quot;transfer&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&gt;
        &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt;
        3. 查询方法以 find 开头，设置为只读，且不使用事务.
    2. propagation：配置事务的传播行为;
        1. REQUIRED：默认值，表示一定会有事务，用于增删改;
        2. SUPPORTS：用于查询方法，通知数据库没必要加锁(事务)，提高效率.
    3. isolation：配置隔离级别，默认值DEFAULT，表示使用数据库的默认隔离级别;
    4. read-only：指定事务是否只读，默认为false，表示读写，只有查询方法才能设置为true;
    5. timeout：事务的超时时间，以秒为单位，默认值为-1，表示永不超时;
    6. rollback-for：指定一个异常，当产生该异常时，事务回滚，产生其他异常时，事务不会滚;
    7. no-rollback-for：与 rollback-for 相反，发生指定的异常时不回滚，发生其他异常时回滚;
    8. rollback-for 和 no-rollback-for 都没有默认值，不指定异常时，表示任何异常都回滚.
7. 配置AOP：建立事务通知与切入点表达式的关系
    &lt;aop:config&gt;
        &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* cn.test.service.impl.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;
        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:advisor&gt;
    &lt;/aop:config&gt;
    1. advice-ref：关联事务通知的id;
    2. pointcut-ref：关联切入点表达式的id.
8. 测试
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
    IAccountService service = ac.getBean(&quot;accountService&quot;, IAccountService.class);
    service.transfer(&quot;AAA&quot;, &quot;BBB&quot;, 100f);
</code></pre><h4 id="注解的声明式事务控制"><a href="#注解的声明式事务控制" class="headerlink" title="注解的声明式事务控制"></a>注解的声明式事务控制</h4><pre><code>1. bean.xml：加入AOP、事务、context的约束，开启Spring对注解事务的支持
    &lt;beans aop、tx、context...相关约束&gt;
        &lt;!-- Spring创建IoC容器时要扫描的包 --&gt;
        &lt;context:component-scan base-package=&quot;cn.test&quot;&gt;&lt;/context:component-scan&gt;
        &lt;bean id=&quot;jt&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
            &lt;property name=&quot;dataSource&quot; ref=&quot;ds&quot;&gt;&lt;/property&gt;
        &lt;/bean&gt;
        &lt;bean id=&quot;ds&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
            ......
        &lt;/bean&gt;
        &lt;!-- 配置事务管理器 --&gt;
        &lt;bean id=&quot;manager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
            &lt;property name=&quot;dataSource&quot; ref=&quot;ds&quot;&gt;&lt;/property&gt;
        &lt;/bean&gt;
        &lt;!-- 开启Spring支持注解事务 --&gt;
        &lt;tx:annotation-driven transaction-manager=&quot;manager&quot;&gt;&lt;/tx:annotation-driven&gt;
    &lt;/beans&gt;
2. Dao层不再继承Spring的JdbcDaoSupport
    @Repository(&quot;accountDao&quot;)
    public class AccountDaoImpl implements IAccountDao {
        @Autowired
        private JdbcTemplate jt;
        ......
    }
3. @Transactional：事务控制，注解在Service层的类/方法上，并配置事务的相关属性;
    @Service(&quot;accountService&quot;)
    @Transactional(propagation=Propagation.SUPPORTS, readOnly=true)  --&gt;对所有方法有效
    public class AccountServiceImpl implements IAccountService {
        @Autowired
        private IAccountDao dao;

        public Account findById(int id) { ... }

        @Transactional(propagation=Propagation.REQUIRED, readOnly=false) --&gt;单独配置
        public void transfer(String sourceName, String targetName, Float money) { ... }
    }
4. 测试
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
    IAccountService service = ac.getBean(&quot;accountService&quot;, IAccountService.class);
    service.transfer(&quot;AAA&quot;, &quot;BBB&quot;, 100f);
</code></pre><h4 id="纯注解取代XML"><a href="#纯注解取代XML" class="headerlink" title="纯注解取代XML"></a>纯注解取代XML</h4><pre><code>在java目录下创建包config，存放配置类;
1. resources/jdbcConf.properties：数据库的连接信息
    jdbc.driver=com.mysql.cj.jdbc.Driver
    jdbc.url=jdbc:mysql://...
    jdbc.username=root
    jdbc.password=123456
2. JDBC相关的配置类
    public class JdbcConfig {
        @Value(&quot;${jdbc.driver}&quot;)
        private String driver;
        ......//url、username、password

        @Bean(name=&quot;jt&quot;)
        public JdbcTemplate createJdbcTemplate(DataSource ds) {
            return new JdbcTemplate(ds);
        }
        @Bean(name=&quot;ds&quot;)
        public DataSource createDataSource() {
            DriverManagerDataSource ds = new DriverManagerDataSource();
            ds.setDriverClassName(driver);
            ds.setUrl(url);
            ds.setUsername(username);
            ds.setPassword(password);
            return ds;
        }
    }
3. 事务管理器相关的配置类
    public class TransactionConfig {
        @Bean(name=&quot;manager&quot;)
        public PlatformTransactionManager createTransactionManager(DataSource ds) {
            return new DataSourceTransactionManager(ds);
        }
    }
4. @EnableTransactionManagement：开启Spring支持注解事务
5. 主配置类SpringConfiguration
    @Configuration
    @ComponentScan(&quot;cn.test&quot;)
    @Import({JdbcConfig.class, TransactionConfig.class})
    @PropertySource(&quot;jdbcConf.properties&quot;)
    @EnableTransactionManagement
    public class SpringConfiguration { }
6. 测试
    ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class);
    IAccountService service = ac.getBean(&quot;accountService&quot;, IAccountService.class);
    service.transfer(&quot;AAA&quot;, &quot;BBB&quot;, 100f);
</code></pre><h3 id="编程式事务控制"><a href="#编程式事务控制" class="headerlink" title="编程式事务控制"></a>编程式事务控制</h3><pre><code>1. bean.xml：配置Dao、Service、DataSource、事务管理器DataSourceTransactionManager
2. 除此之外，还需要使用事务模板对象TransactionTemplate，所以也要配置;
    &lt;bean id=&quot;transactionTemplate&quot; class=&quot;org.springframework.transaction.support.TransactionTemplate&quot;&gt;
        &lt;property name=&quot;transactionManager&quot; ref=&quot;manager&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
3. 在Service中使用TransactionTemplate
    public class AccountServiceImpl implements IAccountService {
        private IAccountDao dao;
        private TransactionTemplate transactionTemplate;
        ......//setter

        public Account findById(int id) {
            return transactionTemplate.execute(new TransactionCallback&lt;Account&gt;() {
                public Account doInTransaction(TransactionStatus status) {
                    return dao.findById(id);
                }
            });
        }
        public void transfer(String sourceName, String targetName, Float money) {
            transactionTemplate.execute(new TransactionCallback&lt;Object&gt;() {
                public Object doInTransaction(TransactionStatus status) {
                    Account source = dao.findByName(sourceName);
                    Account target = dao.findByName(targetName);
                    source.setMoney(source.getMoney() - money);
                    target.setMoney(target.getMoney() + money);
                    dao.updateAccount(source);
                    int i = 1/0;  //发生异常，不再向下执行
                    dao.updateAccount(target);
                    return null;
                }
            });
        }
    }
    4. 每一个需要事务管理的方法里都要使用TransactionTemplate去管理，增加了大量的重复代码。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/03/08/Spring与AOP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/08/Spring与AOP/" itemprop="url">Spring与AOP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-08T00:00:00+08:00">
                2016-03-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><pre><code>1. AOP：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护；
    1. 简单来说：在运行期，利用动态代理技术，在不修改源码的情况下，对已有方法进行增强；
    2. AOP是OOP的延续，是函数式编程的一种衍生范型；
    3. 利用AOP可以分离业务逻辑的各个部分，从而降低耦合，提高程序的可重用性和开发效率。
2. Joinpoint：连接点，指那些被拦截的点，在Spring中就是被拦截的方法，因为Spring只支持方法类型的连接点；
3. Pointcut：切入点，在被拦截的方法中，只有被增强的方法才称为切入点；
4. Advice：通知/增强，拦截到Joinpoint之后要做的事情；
    1. 分类：前置通知、后置通知、异常通知、最终通知、环绕通知；
    public IAccountService getAccountService() {
        return (IAccountService) Proxy.newProxyInstance(
        service.getClass().getClassLoader(), service.getClass().getInterfaces(), 
        new InvocationHandler(){
            public Object invoke(Object proxy, Method method, Object[] args)  {
                object rtValue = null;
                try {
                    manager.beginTransaction();
                    rtValue = method.invoke(service, args);
                    manager.commit();
                    return rtValue;
                } catch(Exception e) {  ---&gt;异常通知
                    manager.rollback();
                    throw new RuntimeException(e);
                } finally {  ---&gt;最终通知
                    manager.release();
                }
            }
        });
    }
    2. 整个 invoke() 部分称为环绕通知，其中有明确的切入点方法调用：method.invoke(service, args);
    3. method.invoke(service, args); 之前的代码称为前置通知，后面的代码称为后置通知.
5. Introduction：引介，一种特殊的通知，在不修改类代码的情况下，可以在运行期动态地为类添加属性/方法；
6. Target：代理的目标对象；
7. Weaving：织入，把增强应用到目标对象，来创建新代理对象的过程；
    1. Spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入.
8. Proxy：一个类被AOP织入增强后，就产生一个代理类；
9. Aspect：切面，是切入点和通知/引介的结合。
</code></pre><h3 id="Spring的AOP"><a href="#Spring的AOP" class="headerlink" title="Spring的AOP"></a>Spring的AOP</h3><pre><code>1. 添加依赖：spring-context、aspectjweaver(解析切入点表达式)
2. 业务层Service
    public class AccountServiceImpl implements IAccountService {
        public void save() {  //无参无返回值
            System.out.println(&quot;save&quot;);
        }
        public void update(int i) { //有参无返回值
            System.out.println(&quot;update&quot;);
        }
        public int delete() {  //无参有返回值
            System.out.println(&quot;delete&quot;);
        }
    }
3. 提供一个记录日志的工具类，存放公共代码
    public class Logger {
        public void print() {
            //在切入点方法执行之前，执行此通知方法
            System.out.println(&quot;print&quot;);
        }
    }
4. Spring的配置文件 resources/bean.xml，添加AOP约束
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
        &lt;bean id=&quot;accountService&quot; class=&quot;cn.test.service.impl.AccountServiceImpl&quot;&gt;&lt;/bean&gt;
        &lt;bean id=&quot;logger&quot; class=&quot;cn.test.utils.Logger&quot;&gt;&lt;/bean&gt;
        &lt;!-- 配置AOP --&gt;
        &lt;aop:config&gt;
            &lt;!-- 配置切面 --&gt;
            &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt;
                &lt;!-- 配置通知类型，并建立通知方法与切入点方法的关联 --&gt;
                &lt;aop:before method=&quot;print&quot; pointcut=&quot;切入点表达式&quot;&gt;&lt;/aop:before&gt;
            &lt;/aop:aspect&gt;
        &lt;/aop:config&gt;
    &lt;/beans&gt;
    1. &lt;aop:config&gt;：开始AOP的配置;
    2. &lt;aop:aspect&gt;：配置切面;
        1. id属性：切面的唯一标识;
        2. ref属性：指定通知类bean的id，此时的通知类就是Logger
    3. &lt;aop:before&gt;：配置前置通知，也就是执行Logger.print()
        1. method属性：指定执行的通知方法;
        2. pointcut属性：指定切入点表达式，表示对业务层中的哪些方法增强;
        3. pointcut-ref属性：引用外部的切入点表达式标签&lt;aop:pointcut&gt;
        4. 只增强 AccountServiceImpl.save();
    pointcut=&quot;execution(public void cn.test.service.impl.AccountServiceImpl.save())&quot;
5. 开始执行
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
    IAccountService service = ac.getBean(&quot;accountService&quot;, IAccountService.class);
    service.save();  //print --&gt; save
    service.delete();  //delete，没有增强
6. 切入点表达式：execution(表达式)
    1. 表达式的标准格式：访问修饰符 返回值 包名.类名.方法名(参数列表)
    2. 访问修饰符可省略；
    3. 返回值使用通配符*，表示任意返回值；
    4. 包名使用通配符*，表示任意通配符，但有几级包，就需要写几个*.
        * *.*.*.*.AccountServiceImpl.save()
    5. 包名可以使用 .. , 表示当前包及其子包
        * *..AccountServiceImpl.save()
    6. 类名和方法名都可以使用 * 来实现通配：* *..*.*()
    7. 参数列表
        1. 基本类型直接用类型名，如int
        2. 引用类型则需要指明全类名，如java.lang.String
        3. 使用通配符*，匹配方法上的任意类型，但方法上必须有参数才可匹配;
        4. 使用 .. , 表示匹配方法上的任意多个、任意类型的参数，也可以没有参数.
    8. 由此可知，全通配的写法：* *..*.*(..)，匹配所有类的所有方法；
    9. 当然，一般也只会匹配业务层的所有方法：* cn.test.service.impl.*.*(..)
</code></pre><h2 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h2><pre><code>1. 通知方法
    public class Logger {
        public void beforePrint() { //前置通知
            System.out.println(&quot;before print&quot;);
        }
        public void afterPrint() { //后置通知
            System.out.println(&quot;after print&quot;);
        }
        public void catchPrint() { //异常通知
            System.out.println(&quot;catch print&quot;);
        }
        public void finalPrint() { //最终通知
            System.out.println(&quot;final print&quot;);
        }
        public void aroundPrint() { //环绕通知
            System.out.println(&quot;around print&quot;);
        }
    }
2. 配置四种常用通知
    1. 前置通知：切入点方法执行之前执行;
    &lt;aop:before method=&quot;beforePrint&quot; 
        pointcut=&quot;execution(* cn.test.service.impl.*.*(..))&quot;&gt;&lt;/aop:before&gt;
    2. 后置通知：切入点方法正常执行之后执行;
    &lt;aop:after-returning method=&quot;afterPrint&quot; 
        pointcut=&quot;execution(* cn.test.service.impl.*.*(..))&quot;&gt;&lt;/aop:after-returning&gt;
    3. 异常通知：切入点方法执行产生异常之后执行;
    &lt;aop:after-throwing method=&quot;catchPrint&quot; 
        pointcut=&quot;execution(* cn.test.service.impl.*.*(..))&quot;&gt;&lt;/aop:after-throwing&gt;
    4. 最终通知：不管切入点方法是否正常执行，都会在最后执行;
    &lt;aop:after method=&quot;finalPrint&quot; 
        pointcut=&quot;execution(* cn.test.service.impl.*.*(..))&quot;&gt;&lt;/aop:after&gt;
    5. 后置通知与异常通知始终只会执行一个.
3. &lt;aop:pointcut&gt;：单独配置切入点表达式
    1. id属性：此表达式的唯一id;
    2. expression属性：定义切入点表达式;
    &lt;aop:pointcut id=&quot;pt1&quot; 
        expression=&quot;execution(* it.aop.service.impl.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;
    &lt;aop:before method=&quot;beforePrint&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:before&gt;
    3. &lt;aop:pointcut&gt; 配置为 &lt;aop:aspect&gt; 的子标签时，只对当前切面有效;
    4. 配置为 &lt;aop:aspect&gt; 的兄弟标签时，必须配置在 &lt;aop:aspect&gt; 之前，对所有切面都有效.
</code></pre><h3 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h3><pre><code>&lt;aop:config&gt;
    &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* it.aop.service.impl.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;
    &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt;
        &lt;aop:around method=&quot;aroundPrint&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:before&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
1. invoke() 也称为环绕通知，所以一旦配置了&lt;aop:around&gt;，切入点方法不再执行，只执行了通知方法；
2. ProceedingJoinPoint：Spring提供的接口，它的 proceed() 用于明确调用切入点方法；
3. ProceedingJoinPoint可以作为环绕通知方法的参数，Spring会在运行期为此接口提供实现类；
    public Object aroundPrint(ProceedingJoinPoint pjp) {
        Object rtValue = null;
        try {
            //1.获取切入点方法执行所需的参数
            Object[] args = pjp.getArgs();
            //2.明确调用切入点方法
            rtValue = pjp.proceed(args);
            return rtValue;
        } catch(Throwable t) { //Exception拦不住此异常
            throw new RuntimeException(t);
        } finally {

        }
    }
    1. pjp.proceed(args); 之前的代码称为前置通知，之后的代码称为后置通知;
    2. catch部分称为异常通知，finally部分称为最终通知.
4. Spring的环绕通知，其实就是为了提供一种可以在代码中手动控制增强方法何时执行的方式；
5. 因为环绕通知与其他四种通知有关联性，如果同时配置这5种通知，会出现调用顺序的错乱；
6. 所以如果配置了环绕通知，就不要再配置其他四种通知，而是在环绕通知方法中手动调用其他四种通知方法。
</code></pre><h2 id="Spring的注解AOP"><a href="#Spring的注解AOP" class="headerlink" title="Spring的注解AOP"></a>Spring的注解AOP</h2><pre><code>1. 在配置文件 bean.xml 中添加aop和context的约束、创建容器时扫描的包、开启AOP注解支持
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
        &lt;!-- Spring创建IoC容器时要扫描的包 --&gt;
        &lt;context:component-scan base-package=&quot;cn.test&quot;&gt;&lt;/context:component-scan&gt;
        &lt;!-- 开启Spring的注解AOP支持 --&gt;
        &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;
    &lt;/beans&gt;
2. 业务层Service
    @Service(&quot;accountService&quot;)
    public class AccountServiceImpl implements IAccountService {
        ......
    }
3. @Aspect：声明当前类是一个切面类
    1. @Pointcut：用在方法上，定义切入点表达式；
    2. @Before、@AfterReturning、@AfterThrowing、@After：分别声明4种通知；
        @Component(&quot;logger&quot;)
        @Aspect
        public class Logger {
            @Pointcut(&quot;execution(* it.aop.service.impl.*.*(..))&quot;)
            private void pt1() {}

            @Before(&quot;pt1()&quot;)
            public void beforePrint() { ... }

            @AfterReturning(&quot;pt1()&quot;)
            public void afterPrint() { ... }

            @AfterThrowing(&quot;pt1()&quot;)
            public void catchPrint() { ... }

            @After(&quot;pt1()&quot;)
            public void finalPrint() { ... }
        }
    3. @Around：声明环绕通知，不要与其他四种通知的注解一起使用，调用顺序会错乱；
    4. 通知注解的value属性用于指定切入点表达式，必须是调用方法的形式：pt1()
4. 使用注解类取代配置文件：@EnableAspectJAutoProxy 声明支持AOP注解
    @Configuration
    @ComponentScan(basePackages=&quot;cn.test&quot;)
    @EnableAspectJAutoProxy
    public class SpringConfiguration { }
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/03/07/Spring与动态代理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/07/Spring与动态代理/" itemprop="url">Spring与动态代理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-07T00:00:00+08:00">
                2016-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="事务问题"><a href="#事务问题" class="headerlink" title="事务问题"></a>事务问题</h2><pre><code>public class Account {  //账户实体类
    private int id;
    private String name;
    private double money;
    //setter、getter
}
public AccountServiceImpl implements IAccountService {
    private IAccountDao dao;
    ...... //CRUD
    public void transfer(String sourceName, String targetName, float money) {
        //sourceName向targetName转向金额money
        Account source = dao.findByName(sourceName);
        Account target = dao.findByName(targetName);
        source.setMoney(source.getMoney() - money);
        target.setMoney(target.getMoney() + money);
        //更新数据库
        dao.updateAccount(source);
        int i = 1/0;  //发生异常，不再向下执行
        dao.updateAccount(target);
    }
}
1. 因为发生了异常，导致源账户的金额虽然变化了，但目标账户的金额并没有增加，根本原因在于事务
   没有回滚；
2. QueryRunner 的配置：
&lt;bean id=&quot;runner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot; scope=&quot;prototype&quot;&gt;
    &lt;constructor-arg name=&quot;ds&quot; ref=&quot;dataSource&quot;&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
    1. QueryRunner是多例的，每次数据库操作都会获取一个新连接，一个独立的新事务，操作成功之后，
    事务自动提交；
    2. 所以，所以发生异常时，没有一个总的事务控制，数据也就不会回滚。
3. 使用ThreadLocal把Connection和当前线程绑定，从而使一个线程只有一个能控制事务的对象；
    1. 当前的所有数据控制都在持久层，应该转到业务层上；
    2. 创建连接的工具类
        public class ConnectionUtils {
            private ThreadLocal&lt;Connection&gt; tl = new ThreadLocal&lt;&gt;();
            private DataSource dataSource;
            ...... //DataSource的setter
            public Connection getThreadConn() {
                Connection conn = tl.get();
                if(conn == null) { //从数据源中获取一个连接，并存入连接池
                    conn = dataSource.getConnection();
                    tl.set(conn);
                }
                return conn;
            }
            public void removeConn() {
                // 移除ThreadLocal中当前线程的连接
                tl.remove();
            }
        }
    3. 事务管理的工具类
        public class TransactionManager {
            private ConnectionUtils connUtils;
            ......//setter
            public void beginTransaction() {
                //开启事务，修改为手动提交
                connUtils.getThreadConn().setAutoCommit(false);
            }
            public void commit() {  //手动提交事务
                connUtils.getThreadConn().commit();
            }
            public void rollback() {  //回滚
                connUtils.getThreadConn().rollback();
            }
            public void release() {
                //释放连接，并还给连接池
                connUtils.getThreadConn().close();
                connUtils.removeConn();
            }
        }
4. 在Service中控制事务
    public AccountServiceImpl implements IAccountService {
        private IAccountDao dao;
        private TransactionManager manager;
        ......//setter
        public List&lt;Account&gt; findAll() {
            try {
                manager.beginTransaction(); //开启事务
                List&lt;Account&gt; accounts = dao.findAll();
                manager.commit(); //提交事务
                return accounts;
            } catch(Exception e) {
                manager.rollback(); //回滚
                throw new RuntimeExcepion(e);
            } finally {
                manager.release(); //释放连接
            }
        }
        ...... //带有事务的CRUD
        public void transfer(String sourceName, String targetName, float money) {
            //sourceName向targetName转向金额money
            try {
                manager.beginTransaction(); //开启事务
                Account source = dao.findByName(sourceName);
                Account target = dao.findByName(targetName);
                source.setMoney(source.getMoney() - money);
                target.setMoney(target.getMoney() + money);
                //更新数据库
                dao.updateAccount(source);
                int i = 1/0;  //发生异常，不再向下执行
                dao.updateAccount(target);
                manager.commit(); //提交事务
            } catch(Exception e) {
                manager.rollback(); //回滚
                throw new RuntimeExcepion(e);
            } finally {
                manager.release(); //释放连接
            }
        }
    }
5. 不为QueryRunner的构造方法提供DataSource，也就不注入连接
    &lt;bean id=&quot;runner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot; 
        scope=&quot;prototype&quot;&gt;&lt;/bean&gt;
6. 在Dao层，为QueryRunner手动提供Connection连接
    public AccountDaoImpl implements IAccountDao {
        private QueryRunner runner;
        private ConnectionUtils connUtils;
        ......//setter
        public List&lt;Account&gt; findAll() {
            //Connection对象作为第一个参数，表示手动提供连接对象
            return runner.query(connUtils.getThreadConn(), ......);
        }
        ......
    }
7. 在 bean.xml 中配置ConnectionUtils和TransactionManager;
    &lt;bean id=&quot;accountDao&quot; class=&quot;it.bank.dao.impl.AccountDaoImpl&quot;&gt;
        &lt;property name=&quot;runner&quot; ref=&quot;runner&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;connUtils&quot; ref=&quot;connUtils&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;accountService&quot; class=&quot;it.bank.service.impl.AccountServiceImpl&quot;&gt;
        &lt;property name=&quot;dao&quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;manager&quot; ref=&quot;manager&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;connUtils&quot; class=&quot;it.bank.utils.ConnectUtils&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;manager&quot; class=&quot;it.bank.utils.TransactionManager&quot;&gt;
        &lt;property name=&quot;connUtils&quot; ref=&quot;connUtils&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    ...... //runner、dataSource
</code></pre><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><pre><code>1. 虽然解决了事务控制，但是类与类之间存在较强的依赖关系，方法名的改变，可能导致毁灭性打击；
2. 动态代理：不同于装饰者模式，不需要实现创建类，而是随用随加载，通过字节码动态创建对象；
    1. 作用：不修改源码的基础上，对方法增强；
    2. 分类：基于接口的动态代理，基于子类的动态代理。
</code></pre><h3 id="基于接口的动态代理"><a href="#基于接口的动态代理" class="headerlink" title="基于接口的动态代理"></a>基于接口的动态代理</h3><pre><code>1. 创建代理对象的要求：被代理的类最少实现一个接口，否则不能使用；
    Proxy.newProxyInstance(ClassLoader, Class[], InvocationHandler)
2. ClassLoader：类加载器，用于加载代理对象的字节码，和被代理对象使用相同的类加载器；
    被代理对象.getClass().getClassLoader()
3. Class[]：字节码数组，用于让代理对象和被代理对象具有相同的方法；
    被代理对象.getClass().getInterfaces()
4. InvocationHandler：用于提供增强的代码，定义代理的方式，一般都是此接口的匿名内部类；
    new InvocationHandler() {
        public Object invoke(Object proxy, Method method, Object[] args) {
            //默认方式，相当于没有任何增强
            return method.invoke(被代理对象, args);
        }
    }
    1. 执行被代理对象的任何接口方法时，都会经过invoke();
    2. proxy：代理对象的引用;
    3. method：当前执行的方法;
    4. args：当前执行方法所需的参数;
    5. invoke()的返回值，将作为被代理对象的方法的返回值.
5. 生产商Producer，生产商的准则IProducer(代理商对生产商的要求)
    public interface IProducer {
        void sale(float money);
        void after(float money);
    }
    public class Producer implements IProducer {
        public void sale(float money) {  //销售
            System.out.println(&quot;生产商销售产品，拿到钱：&quot; + money);
        }
        public void after(float money) {  //售后
            System.out.println(&quot;生产商提供售后，拿到钱：&quot; + money);
        }
    }
6. 消费者Client
    final Producer p = new Producer();
    1. 创建动态代理
    IProducer proxyProducer = (IProducer)Proxy.newProxyInstance(
            p.getClass().getClassLoader(), p.getClass().getInterfaces(), 
        new InvocationHandler() {
            public Object invoke(Object proxy, Method method, Object[] args) {
                Object leftMoney = null;
                Float money = (Float)args[0];
                if(&quot;sale&quot;.equals(method.getName())) {
                    //购买时，代理商提取20%的回扣
                    leftMoney = method.invoke(p, money*0.8f);
                }
                return leftMoney;
            }
        });
    2. 消费者通过代理对象实现购买与服务
    proxyProducer.sale(10000f);  //生产商销售产品，拿到钱：8000
</code></pre><h3 id="基于子类的动态代理"><a href="#基于子类的动态代理" class="headerlink" title="基于子类的动态代理"></a>基于子类的动态代理</h3><pre><code>1. 为一个普通的类创建动态代理：
    1. 被代理的类不能是最终类(final class XXX)，因为它不能再创建子类；
    2. 借助第三方cglib库，Enhancer.create()
    &lt;dependency&gt;
        &lt;groupId&gt;cglib&lt;/groupId&gt;
        &lt;artifactId&gt;cglib&lt;/artifactId&gt;
        &lt;version&gt;3.2.10&lt;/version&gt;
    &lt;/dependency&gt;
2. Enhancer.create(Class, Callback)
    1. Class：被代理对象的字节码；
    2. Callback：提供增强的代码，通常使用其子类，如MethodInterceptor
3. 生产商Producer
    public class Producer {
        public void sale(float money) {  //销售
            System.out.println(&quot;生产商销售产品，拿到钱：&quot; + money);
        }
        public void after(float money) {  //售后
            System.out.println(&quot;生产商提供售后，拿到钱：&quot; + money);
        }
    }
4. 消费者Client
    final Producer p = new Producer();
    1. 创建代理对象
    Producer proxyProducer = (Producer)Enhancer.create(p.getClass(), 
        new MethodInterceptor() {
            public Object intercept(Object proxy, Method method, Object[] args, 
                MethodProxy methodProxy) throws Throwable {
                Object leftMoney = null;
                Float money = (Float)args[0];
                if(&quot;sale&quot;.equals(method.getName())) {
                    leftMoney = method.invoke(p, money*0.8f);
                }
                return leftMoney;
            }
        });
    2. 执行被代理对象的方法时，也都会经过intercept()
    3. methodProxy：当前执行方法的代理对象.
</code></pre><h3 id="动态代理控制事务"><a href="#动态代理控制事务" class="headerlink" title="动态代理控制事务"></a>动态代理控制事务</h3><pre><code>1. 分离Service中控制事务的部分，交给代理对象去控制事务;
    public AccountServiceImpl implements IAccountService {
        private IAccountDao dao;
        ......//setter
        public List&lt;Account&gt; findAll() {
            return dao.findAll();
        }
        public Account findByName(String name) {
            return dao.findByName(name);
        }
        public void update(Account account) {
            dao.update(account);
        }
        ......
    }
2. 创建Service的代理对象的工厂
    public class BeanFactory {
        private IAccountService service;
        private TransactionManager manager;
        ......//setter
        public IAccountService getAccountService() {
            return (IAccountService) Proxy.newProxyInstance(
            service.getClass().getClassLoader(), service.getClass().getInterfaces(), 
            new InvocationHandler(){
                public Object invoke(Object proxy, Method method, Object[] args)  {
                    object rtValue = null;
                    try { //增强方法: 在执行Service的方法时, 加入事务
                        manager.beginTransaction();
                        rtValue = method.invoke(service, args);
                        manager.commit();
                        return rtValue;
                    } catch(Exception e) {
                        manager.rollback();
                        throw new RuntimeException(e);
                    } finally {
                        manager.release();
                    }
                }
            });
        }
    }
3. 在 bean.xml 中，修改&lt;bean&gt;的关系，并配置工厂类BeanFactory
    &lt;bean id=&quot;proxyService&quot; factory-bean=&quot;beanFactory&quot; factory-method=&quot;getAccountService&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;beanFactory&quot; class=&quot;it.bank.factory.BeanFactory&quot;&gt;
        &lt;property name=&quot;service&quot; ref=&quot;accountService&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;manager&quot; ref=&quot;connUtils&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;accountService&quot; class=&quot;it.bank.service.impl.AccountServiceImpl&quot;&gt;
        &lt;property name=&quot;dao&quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    ...... //accountDao、connUtils、manager、runner、dataSource
    1. 此时的容器中，有两个类型相同的bean对象：proxyService、accountService
    2. 那么在注入使用时，需要明确指定使用代理对象创建的Service Bean对象
        @Autowired
        @Qualifier(&quot;proxyService&quot;)
        private IAccountService service;
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/03/06/Spring注解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/06/Spring注解/" itemprop="url">Spring注解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-06T00:00:00+08:00">
                2016-03-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="IoC注解"><a href="#IoC注解" class="headerlink" title="IoC注解"></a>IoC注解</h2><pre><code>1. @Component：创建对象，&lt;bean&gt;标签的功能，把类对象存入Spring容器中
    @Component(&quot;userService&quot;)  ---&gt;@Component(value=&quot;userService&quot;)
    public class UserServiceImpl implements IUserService {
        ......
    }
    1. value属性就是Bean对象的id，如果直接使用 @Component，而不指定value，则默认id为
    首字母小写的类名userServiceImpl;
    2. 在配置文件 bean.xml 中导入context命名空间和约束，并告知Spring扫描哪个包下的注解
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
        &lt;!-- 告知Spring在创建容器时要扫描的包 --&gt;
        &lt;context:component-scan base-package=&quot;项目的包名&quot;&gt;&lt;/context:component-scan&gt;
    &lt;/beans&gt;
    3. 通过注解创建对象
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
    IUserService us = (IUserService)ac.getBean(&quot;userService&quot;);
2. Spring为了三层架构更加清晰, 还有三个与 Component 功能相同的衍生注解
    1. Controller：一般用于表现层；
    2. Service：一般用于表现层；
    3. Repository：一般用在持久层。
3. Scope：指定Bean对象的作用范围，同&lt;bean&gt;上的scope属性；
    1. value属性：指定取值范围;
    2. 常用取值：singleton、prototype.
4. 生命周期相关
    1. PreDestroy：指定销毁方法，&lt;bean&gt;上的destroy-method;
    2. PostConstruct：指定初始化方法，&lt;bean&gt;上的init-method;
        @Component(&quot;userService&quot;)
        @Scope(&quot;prototype&quot;)  --------&gt;指定为多例
        public class UserServiceImpl implements IUserService {
            @PostConstruct
            public void init() {
                ......//Bean的初始化
            }
            @PreDestroy
            public void destroy() {
                ......//Bean的销毁
            }
        }
</code></pre><h3 id="注入数据的注解"><a href="#注入数据的注解" class="headerlink" title="注入数据的注解"></a>注入数据的注解</h3><pre><code>1. @Autowired：自动按照类型注入；
    1. 只要容器中有唯一的一个Bean对象与要注入的变量类型匹配，就可以注入成功；
    2. 可以用在变量上，也可以用在方法上；
    @Repository(&quot;userDao&quot;)
    public class UserDaoImpl implements IUserDao {
        public void saveUser() { ... }
    }
    @Service(&quot;userService&quot;)
    public class UserServiceImpl implements IUserService {
        @Autowired
        private IUserDao dao;
        public void saveUser() {
            dao.saveUser();
        }
    }
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
    //指定getBean()的第二个参数，则不需要再强转类型
    IUserService us = ac.getBean(&quot;userService&quot;, IUserService.class);
    us.saveUser();  //内部可以调用Dao对象的方法，dao不再是null
    3. 如果IoC有多个匹配的Bean对象，Spring会取出这些Bean对象的id，然后使用变量名与这些id
    进行匹配，有则匹配，否则报错；
        @Repository(&quot;userDao1&quot;)
        public class UserDao1Impl implements IUserDao {
            public void saveUser() { ... }
        }
        @Repository(&quot;userDao2&quot;)
        public class UserDao2Impl implements IUserDao {
            public void saveUser() { ... }
        }
        @Service(&quot;userService&quot;)
        public class UserServiceImpl implements IUserService {
            @Autowired
            private IUserDao userDao2;  //与 UserDao2Impl 相匹配
            ......
        }
    4. 不再需要setter
2. @Qualifier：在按照类中注入的基础上，再按照名称注入；
    1. 在给类成员注入时，不能单独使用; 但给方法参数注入时，可以单独使用;
    2. 属性value：指定注入Bean对象的id;
    @Service(&quot;userService&quot;)
    public class UserServiceImpl implements IUserService {
        @Autowired
        @Qualifier(&quot;userDao2&quot;)  --&gt; 注入 UserDao2Impl 对象
        private IUserDao dao;
        ......
    }
3. @Resource：按照Bean的id注入，且可以单独使用，属性name用于指定注入Bean的id;
    @Resource(name=&quot;userDao2&quot;)  --&gt;如果不指定name属性，默认把属性变量名作为Bean的id
    private IUserDao dao;
4. 这三种注解都只能注入IoC容器管理的Bean对象，不能注入基本数据类型，而集合类型只能使用XML实现注入;
5. Value：用于注入基本数据类型，属性value用于指定数据的值；
    1. 它可以使用Spring的SpEL(Spring的EL表达式);
    2. SpEL的写法：${表达式}，虽然与JSP的EL表达式写法相同，但出现的位置并不相同；
</code></pre><h2 id="Spring整合数据库操作"><a href="#Spring整合数据库操作" class="headerlink" title="Spring整合数据库操作"></a>Spring整合数据库操作</h2><pre><code>1. Dbutils：由Apache提供，主要封装了JDBC，简化Dao层的操作，又不会影响性能；
    1. 三个核心类：DbUtils、QueryRunner、ResultSetHandle
    2. DbUtils：连接数据库对象，控制连接，jdbc辅助方法的集合类，线程安全；
    3. QueryRunner：SQL语句的操作对象，线程安全；
        1. QueryRunner()：无参构造，创建一个与数据库无关的QueryRunner对象，需要提供一个
        Connection对象，它可以手动控制事务;
            Connection.setAutoCommit(false); //设置手动管理事务
            Connection.commit(); //手动提交事务
        2. QueryRunner(DataSource ds)：有参构造，创建一个与数据库关联的对象，不需要提供
        Connection对象，自动管理事务;
        3. DataSource：数据库连接池对象，由c3p0提供;
        4. update()：用于执行DDL(create、alter、drop);
        5. query()：用于执行DML(insert、update、delete);
        6. batch()：执行批处理.
    4. ResultSetHandle：封装数据的策略对象，将封装结果集中的数据转换到另一个对象。
2. c3p0：连接池，为了提高应用程序与数据库之间的访问效率，简单易用、连接复用、连接管理;
3. 引入依赖：spring-context、commons-dbutils、c3p0、mysql-connector-java
4. 持久层、业务层
    1. 实体类：com.test.domain.User
        public class User {
            //id、name、age
        }
    2. 持久层Dao：com.test.dao.IUserDao
        public interface IUserDao {
            //CRUD
        }
        public class UserDaoImpl implements IUserDao {
            private QueryRunner runner;
            //setter
            public List&lt;User&gt; findAll() { //查询所有
                return runner.query(&quot;select * from user&quot;, 
                            new BeanListHandler&lt;User&gt;(User.class));
            }
            public List&lt;User&gt; findById(int id) { //查询一个
                return runner.query(&quot;select * from user where id=?&quot;, 
                                    new BeanHandler&lt;User&gt;(User.class), id);
            }
            public void save(User u) { //保存
                runner.update(&quot;insert into user(name, age) values(?, ?)&quot;, 
                                                    u.getName(), u.getAge());
            }
            public void update(User u) { //更新
                runner.update(&quot;update user set name=?,age=? where id=?&quot;, 
                                        u.getName(), u.getAge(), u.getId());
            }
            public void delete(int id) { //删除
                runner.update(&quot;delete from user where id=?&quot;, id);
            }
        }
3. 业务层Service：com.test.service.IUserService
    public interface IUserService { ...... }
    public class UserServiceImpl implements IUserService {
        private IUserDao dao;
        //setter
        ......
    }
4. 配置Spring：resources/bean.xml
    &lt;bean id=&quot;userService&quot; class=&quot;com.test.service.impl.UserServiceImpl&quot;&gt;
        &lt;property name=&quot;dao&quot; ref=&quot;userDao&quot;&gt;&lt;property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;com.test.dao.impl.UserDaoImpl&quot;&gt;
        &lt;property name=&quot;runner&quot; ref=&quot;runner&quot;&gt;&lt;property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;runner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot; scope=&quot;prototype&quot;&gt;
        &lt;constructor-arg name=&quot;ds&quot; ref=&quot;dataSource&quot;&gt;&lt;/constructor-arg&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
        &lt;!-- 链接数据库的信息 --&gt;
        &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:......&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    1. QueryRunner设置为多例对象，避免多线程之间相互干扰;
    2. 开始使用：
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
    IUserService service = ac.getBean(&quot;userService&quot;, IUserService.class);
    List&lt;User&gt; us = service.findAll(); //查询所有
6. 修改为注解配置
    1. 在 bean.xml 的约束中，增加context的命名空间；
    2. 移除UserServiceImpl和UserDaoImpl的&lt;bean&gt;，告知Spring创建容器时要扫描的包；
    &lt;context:component-scan base-package=&quot;com.test&quot;&gt;&lt;/context:component-scan&gt;
    &lt;bean id=&quot;runner&quot; class=&quot;org.apache.commons.dbutils.QueryRunner&quot; scope=&quot;prototype&quot;&gt;
        &lt;constructor-arg name=&quot;ds&quot; ref=&quot;dataSource&quot;&gt;&lt;/constructor-arg&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
        ...... &lt;!-- 链接数据库的信息 --&gt;
    &lt;/bean&gt;
    3. 为 UserServiceImpl和UserDaoImpl 添加注解，并移除其中的setter.
        @Repository(&quot;userDao&quot;)
        public class UserDaoImpl implements IUserDao {
            @Autowired
            private QueryRunner runner;
            ......
        }
        @Service(&quot;userService&quot;)
        public class UserServiceImpl implements IUserService {
            @Autowired
            private IUserDao dao;
            ......
        }
</code></pre><h3 id="Spring新注解"><a href="#Spring新注解" class="headerlink" title="Spring新注解"></a>Spring新注解</h3><pre><code>1. Configuration：声明一个类为配置类，用于取代配置文件 bean.xml;
2. ComponentScan：指定创建容器时要扫描的包;
    1. value属性和basePackages属性的作用相同，都是指定包名;
    2. 此注解的功能等同于 bean.xml 中的 &lt;context:component-scan&gt;
3. Bean：把当前方法的返回值作为bean对象，存入Spring的IoC容器中;
    1. name属性：指定bean的id，不显式声明id时，默认为当前方法名;
    2. 此注解可以取代&lt;bean id=&quot;runner&quot; ···&gt; 和 &lt;bean id=&quot;dataSource&quot; ···&gt;
    3. @Scope：指定bean对象的作用范围;
        @Configuration
        @ComponentScan(basePackages=&quot;com.test&quot;)
        public class SpringConfiguration {
            @Bean(name=&quot;runner&quot;)
            @Scope(&quot;prototype&quot;)
            public QueryRunner createQueryRunner(DataSource dataSource) {
                return new QueryRunner(dataSource);
            }
            @Bean(name=&quot;dataSource&quot;)
            public DataSource createDataSource() {
                ComboPooledDataSource ds = new ComboPooledDataSource();
                ds.setDriverClass(&quot;com.mysql.cj.jdbc.Driver&quot;);
                ds.setJdbcUrl(&quot;jdbc:mysql:......&quot;);
                ds.setUser(&quot;root&quot;);
                ds.setPassword(&quot;123456&quot;);
                return ds;
            }
        }
    4. 在使用注解配置方法时，如果方法上有参数(也是bean对象)，Spring会去容器中查找有没有
    与此参数对应的bean对象，查找方式与Autowired相同;
        1. 如果有且只有一个匹配的bean对象，则匹配成功;
        2. 如果有多个匹配的bean对象，则根据参数名与bean的id进行匹配.
    5. 另外，方法的参数上可以单独使用 @Qualifier，明确指定要匹配的bean对象;
    @Bean(name=&quot;runner&quot;)
    @Scope(&quot;prototype&quot;)
    public QueryRunner createQueryRunner(@Qualifier(&quot;ds2&quot;) DataSource dataSource) {
        return new QueryRunner(dataSource);
    }
    @Bean(name=&quot;ds1&quot;)
    public DataSource createDataSource() { ... }

    @Bean(name=&quot;ds2&quot;)
    public DataSource createDataSource() { ... }
    6. @Qualifier(&quot;ds2&quot;) 指定去匹配 @Bean(name=&quot;ds2&quot;) 的方法.
4. 使用 AnnotationConfigApplicationContext 加载配置类，获取bean对象
    ApplicationContext ac = 
        new AnnotationConfigApplicationContext(SpringConfiguration.class);
    IUserService service = ac.getBean(&quot;userService&quot;, IUserService.class);
</code></pre><h3 id="分解注解类"><a href="#分解注解类" class="headerlink" title="分解注解类"></a>分解注解类</h3><pre><code>1. 为了便于管理，一个主配置类可以分为多个子配置类，如把JDBC相关的配置放在 JdbcConf类 中;
    @Configuration
    public class JdbcConf {   //全类名为config.JdbcConf
        @Bean(name=&quot;runner&quot;)
        @Scope(&quot;prototype&quot;)
        public QueryRunner createQueryRunner(DataSource ds) { ... }
        @Bean(name=&quot;ds&quot;)
        public DataSource createDataSource() { ... }
    }
2. 在主配置类中声明要扫描的包，包括子配置文件所在的包
    @Configuration
    @ComponentScan({&quot;com.test&quot;, &quot;config&quot;})
    public class SpringConfiguration { }
3. 在创建ApplicationContext对象时，如果直接把配置类作为参数，则可省略 @Configuration，
   也不需要扫描配置类所在的包；
    public class JdbcConf { ... }

    @ComponentScan({&quot;com.test&quot;})
    public class SpringConfiguration { }

    ApplicationContext ac = new AnnotationConfigApplicationContext(
                                    SpringConfiguration.class, JdbcConf.class);
4. Import：导入其他的配置类
    1. 被导入的配置类上可以使用 @Configuration，也可以不声明它所在的包;
    public class JdbcConf { ... }

    @ComponentScan({&quot;com.test&quot;})
    @Import(JdbcConf.class)
    public class SpringConfiguration { }

    ApplicationContext ac = 
            new AnnotationConfigApplicationContext(SpringConfiguration.class);
    2. 此时，SpringConfiguration称为父配置类，JdbcConf称为子配置类
5. PropertySource：加载properties文件;
    1. value属性：指定文件的名称和路径;
    2. classpath关键字：表示类路径下;
        resources/spring/conf/jdbc.properties ---&gt; 
                    @PropertySource(&quot;classpath:spring/conf/jdbc.properties&quot;)
6. 抽取出数据库连接的信息
    1. 在resources目录下创建 jdbcConf.properties
        jdbc.driver = com.mysql.cj.jdbc.Driver
        jdbc.url = jdbc:mysql:......
        jdbc.user = root
        jdbc.password = 123456
    2. 在主配置类上注解 @PropertySource，引入properties文件，那么其子配置类都可以通过EL表达式获取键-值
        @ComponentScan({&quot;com.test&quot;})
        @Import(JdbcConf.class)
        @PropertySource(&quot;classpath:jdbcConf.properties&quot;)
        public class SpringConfiguration { }
    3. 在子配置类JdbcConf 中使用Spring的EL表达式，获取properties中的key-value值
        public class JdbcConf { --&gt;亦或者直接在JdbcConf类上注解 @PropertySource(...)
            @Value(&quot;${jdbc.driver}&quot;)
            private String driver;

            @Value(&quot;${jdbc.url}&quot;)
            private String url;

            @Value(&quot;${jdbc.user}&quot;)
            private String user;

            @Value(&quot;${jdbc.password}&quot;)
            private String password;

            @Bean(name=&quot;dataSource&quot;)
            public DataSource createDataSource() {
                ComboPooledDataSource ds = new ComboPooledDataSource();
                ds.setDriverClass(driver);
                ds.setJdbcUrl(url);
                ds.setUser(user);
                ds.setPassword(password);
                return ds;
            }
            ......
        }
</code></pre><h2 id="Spring整合Junit"><a href="#Spring整合Junit" class="headerlink" title="Spring整合Junit"></a>Spring整合Junit</h2><pre><code>1. Junit单元测试中没有直接提供main()，是因为它集成了一个main()
    1. Junit会判断测试类中有哪些方法上使用了 @Test;
    2. Junit main()只会执行有 @Test 的方法.
2. Junit并不关心Spring框架;
    1. 在执行测试方法时，Junit也不会关心Spring的配置文件/配置类，更不会创建IoC容器;
    2. 没有IoC容器，在测试类中使用 @Autowired，也无法实现注入.
3. spring-test：Spring整合junit测试框架; 加入依赖：spring-test、junit
4. @RunWith：Junit提供的注解，把 main() 替换成Spring提供的;
5. @ContextConfiguration：告知Spring的运行器，创建IoC容器使用的是XML还是注解，并指定其位置;
    1. locations属性：指定XML文件的位置，使用classpath关键字，表示在类路径下;
        @ContextConfiguration(locations=&quot;classpath:bean.xml&quot;)
    2. classes属性：指定注解类所在的位置；
    @RunWith(SpringJUnit4ClassRunner.class)
    @ContextConfiguration(classes=SpringConfiguration.class)
    public class UserTest {
        @Autowired
        private IUserService service;

        @Test
        public void testFindAll() {
            List&lt;User&gt; us = service.findAll();
        }
    }
6. 另外，Spring5.x版本时，junit的版本必须为4.12+
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/03/05/Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/05/Spring/" itemprop="url">Spring</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-05T00:00:00+08:00">
                2016-03-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><pre><code>1. Spring是分层的JavaSE/EE应用full-stack(全栈)轻量级开源框架;
    1. 目的是解决企业级应用开发的复杂性，简化Java开发，适用于任何Java应用;
    2. Spring的成功来源于理念，而不是技术本身，以IoC(控制反转)和AOP(面向切面编程)为核心;
    3. 优势：.
2. 发展历程
    1. 1997年IBM提出了EJB的思想，1998年SUN制定并开发EJB1.0;
    2. Spring之父Rod Johnson，2002年阐述了J2EE使用EJB开发设计的优点及解决方案;
    3. 2004年Rod Johnson阐述了J2EE不使用EJB的解决方案，也就是Spring的雏形；
    4. 2017年9月发布了Spring的最新版Spring5.0通用版(GA).
3. 优势：低侵入/低耦合、声明式事务管理、无缝集成其他框架、降低Java开发难度
    1. 解耦：IoC容器可以将对象间的依赖关系交由Spring控制，降低耦合，专注于上层应用；
    2. AOP编程：Spring的AOP功能让许多传统OOP难以实现的功能，更加容易；
    3. 声明式事务管理：使用配置文件取代单调烦闷的事物管理；
    4. 方便程序的测试：可以用非容器依赖的编程方式，实现几乎所有的测试工作；
    5. 方便集成各种优秀的框架，提供直接支持，降低框架的使用难度；
    6. Spring对JavaEE API进行了一层简单的封装，但却大为降低了API的使用难度。
4. Spring Framework Runtime 体系结构
</code></pre><p><img src="//hellomyshadow.github.io/2016/03/05/Spring/framework.jpg" alt="Spring"></p>
<pre><code>1. Core Container：核心容器，Spring的IoC容器，其他部分的运行必须依赖于核心容器；
2. 核心容器的上面一层是AOP相关的部分；
3. Data Access：持久层解决方案；
4. Test：单元测试，也依赖于核心容器才能运行。
</code></pre><h2 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h2><pre><code>1. 耦合：程序间的依赖关系，包括类之间的依赖、方法间的依赖；
2. 解耦：降低程序间的依赖关系，应做到编译期不依赖，运行时才依赖；
</code></pre><h3 id="类之间的依赖"><a href="#类之间的依赖" class="headerlink" title="类之间的依赖"></a>类之间的依赖</h3><pre><code>1. 以装载数据库的驱动为例
    Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;);
    DriverManager.registerDriver(new com.mysql.cj.jdbc.Driver());
    1. 这两种方式都可以装载驱动，但第一种装载是通过字符串，第二种需要使用具体的类；
    2. 如果当前没有MySQL的相关依赖包，那么第二种在运行时就会报错，这就是类之间的依赖；
    3. 而且，如果切换成装载Oracle驱动，仍需要去修改全限定类名的字符串。
2. 解耦的思路
    1. 使用反射来创建对象，避免使用 new 关键字；
    2. 通过读取配置文件来获取类的全限定类名。
</code></pre><h3 id="工厂模式解耦"><a href="#工厂模式解耦" class="headerlink" title="工厂模式解耦"></a>工厂模式解耦</h3><pre><code>1. 非解耦的持久层Dao与业务层Service
    1. Dao接口及其实现类
        public interface IUserDao {
            void save(User u);
        }
        public class UserDaoImpl implements IUserDao {
            public void save(User u) {
                //连接数据库，插入一条记录
            }
        }
    2. Service接口及其实现类
        public interface IUserService {
            void save(User u);
        }
        public class UserServiceImpl implements IUserService {
            private IUserDao dao = new UserDaoImpl();
            public void save(User u) {
                ......//before
                dao.save(u);  //调用Dao的方法
                ......//after
            }
        }
    3. App调用Service
        IUserService service = new UserServiceImpl();
        service.save(new User());
2. 工厂模式解耦
    1. 在resource目录下创建配置文件，如bean.properties，配置Dao与Service的实现类；
        userService = it.demo.cn.service.impl.UserServiceImpl
        userDao = it.demo.cn.dao.impl.UserDaoImpl
    2. Bean工厂：用于反射创建/生产Service和Dao的对象；
        public class BeanFactory {
            private static Properties prop;
            static {
                try {
                    prop = new Properties();
                    //使用类加载器获取resources目录下的文件
                    InputStream is = BeanFactory.class.getClassLoader()
                                    .getResourceAsStream(&quot;bean.properties&quot;);
                    prop.load(is);
                } catch (Exception e) {
                    throw new ExceptionInInitializerError(&quot;初始化配置文件失败！&quot;);
                }
            }
            public static Object getBean(String beanName) {
                //根据Bean的名称获取Bean对象
                String beanPath = prop.getProperty(beanName);
                Object bean = Class.forName(beanPath).newInstance();
                return bean;
            }
        }
    3. 通过Bean工厂创建Dao对象和Service对象
        public class UserServiceImpl implements IUserService {
            private IUserDao dao = (IUserDao) BeanFactory.getBean(&quot;userDao&quot;);
            public void save(User u) {
                dao.save(u);
            }
        }
    IUserService service = (IUserService) BeanFactory.getBean(&quot;userService&quot;);
    service.save(new User());
3. 但是，这种方式并不能保证Dao和Service对象的单例，需要在Bean工厂中增加一个Map结构的容器，
   存储Dao和Service的对象；
    public class BeanFactory {
        private static Properties prop;
        private static Map&lt;String, Object&gt; beans;  //Map结构的容器
        static {
            try {
                prop = new Properties();
                InputStream is = BeanFactory.class.getClassLoader()
                                .getResourceAsStream(&quot;bean.properties&quot;);
                prop.load(is);
                beans = new HashMap&lt;String, Object&gt;();  //实例化容器
                Enumeration keys = prop.keys();  //取出配置文件中的所有key
                while (keys.hasMoreElements()) {
                    //事先创建好配置文件中的对象，存入容器，作为单例对象使用
                    String k = keys.nextElement().toString();
                    String beanPath = prop.getProperty(k);
                    Object val = Class.forName(beanPath).newInstance();
                    beans.put(k, val);
                }
            } catch (Exception e) {
                throw new ExceptionInInitializerError(&quot;初始化配置文件失败！&quot;);
            }
        }
        public static Object getBean(String beanName) {
            //直接返回容器中的Bean对象
            return beans.get(beanName);
        }
    }
</code></pre><h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><pre><code>private IUserDao dao = new UserDaoImpl(); 与
private IUserDao dao = (IUserDao) BeanFactory.getBean(&quot;userDao&quot;);
-----------------------------------------------------------------
IUserService service = new UserServiceImpl(); 与
IUserService service = (IUserService) BeanFactory.getBean(&quot;userService&quot;);
1. 与new创建对象相比，通过Bean工厂创建对象，切断了App与资源(Dao/Service)的直接联系，
   交由Bean工厂控制资源、提供资源，这就是IoC;
2. 之所以称为IoC，而不叫降低解耦，是因为把对象控制的权力交给了工厂(框架)，控制反转不再是
   面向对象编程的专业术语;
3. IoC包括依赖注入(DI)和依赖查找(DL);
4. IoC的作用：消减计算机程序的耦合，并不能完全消除.
</code></pre><h3 id="Spring的IoC"><a href="#Spring的IoC" class="headerlink" title="Spring的IoC"></a>Spring的IoC</h3><pre><code>1. 添加Spring的IoC依赖
    &lt;packaging&gt;jar&lt;/packaging&gt;  ---&gt;项目的打包方式为jar
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.1.6.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
2. 在resources目录下创建配置文件，bean.xml
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
        &lt;!--把对象的创建交给Spring来管理--&gt;
        &lt;bean id=&quot;userService&quot; class=&quot;cn.test.service.impl.UserServiceImpl&quot;&gt;&lt;/bean&gt;
        &lt;bean id=&quot;userDao&quot; class=&quot;cn.test.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;
    &lt;/beans&gt;
3. 获取Spring的IoC核心容器，根据id获取对象
    //1. 解析配置文件，获取核心容器对象
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
    //2. 根据id获取Bean对象
    IUserDao dao = (IUserDao) ac.getBean(&quot;userDao&quot;);
    IUserService service = ac.getBean(&quot;userService&quot;, IUserService.class);
4. ApplicationContext的三个常用实现类
    1. ClassPathXmlApplicationContext：加载类路径下的配置文件，配置文件必须在类路径下;
    2. FileSystemXmlApplicationContext：加载磁盘任意路径下的配置文件，必须有访问权限;
        new ClassPathXmlApplicationContext(&quot;D:\\workplace\\test\\bean.xml&quot;);
    3. AnnotationConfigApplicationContext：用于读取注解类创建的容器.
        new AnnotationConfigApplicationContext(XXXConfig.class);
5. Spring中，ApplicationContext与BeanFactory的区别
    1. ApplicationContext：它在构建核心容器时，会立即创建Bean对象，即一旦读取完配置文件，
    立即创建文件中配置的对象；
    2. BeanFactory：它是顶层接口，采用延迟加载的方式创建Bean对象，即在根据id获取对象时，
    才真正的创建Bean对象；
        Resource res = new ClassPathResource(&quot;bean.xml&quot;);
        BeanFactory factory = new XmlBeanFactory(res);
        IUserDao dao = (IUserDao) factory.getBean(&quot;userDao&quot;);
    3. ApplicationContext适用于单例对象，BeanFactory适用于多例对象。
</code></pre><h3 id="Spring对Bean的管理"><a href="#Spring对Bean的管理" class="headerlink" title="Spring对Bean的管理"></a>Spring对Bean的管理</h3><pre><code>1. 创建Bean的三种方式
    1. 使用默认构造函数创建，&lt;bean&gt;上只有id和class属性，此时类中必须要有默认构造函数，
    否则无法创建Bean对象;
    &lt;bean id=&quot;userService&quot; class=&quot;cn.test.service.impl.UserServiceImpl&quot;&gt;&lt;/bean&gt;
    2. 使用普通工厂中的方法创建Bean对象，并存入Spring的IoC容器;
        public class ServiceFactory {  //工厂类
            public IUserService getUserService() {
                return new UserServiceImpl();
            }
        }
    &lt;bean id=&quot;servFac&quot; class=&quot;cn.test.factory.ServiceFactory&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;userService&quot; factory-bean=&quot;servFac&quot; -----&gt;&gt;引用id为servFac的&lt;bean&gt;
                            factory-method=&quot;getUserService&quot;&gt;&lt;/bean&gt;
        //创建Bean对象
        IUserService service = (IUserService) ac.getBean(&quot;userService&quot;);
    3. 使用工厂中的静态方法创建对象
        public class ServiceFactory {  //工厂类
            public static IUserService getUserService() {
                return new UserServiceImpl();
            }
        }
    &lt;bean id=&quot;userService&quot; class=&quot;cn.test.service.factory.ServiceFactory&quot; 
                                    factory-method=&quot;getUserService&quot;&gt;&lt;/bean&gt;
    //创建Bean对象
    IUserService service = (IUserService) ac.getBean(&quot;userService&quot;);
2. Bean的作用范围
    1. Bean对象默认就是单例的;
        IUserService us1 = (IUserService) ac.getBean(&quot;userService&quot;);
        IUserService us2 = (IUserService) ac.getBean(&quot;userService&quot;);
        us1==us2;  --&gt;true
    2. &lt;bean&gt;的 scope 属性：用于指定bean的作用范围;
        1. singleton：默认值，单例;
        2. prototype：多例，每次 getBean() 时，Spring就会创建一个新的对象;
        3. request：作用于web应用的请求范围;
        4. session：作用于web应用的会话范围;
        5. global-session：作用于集群环境的全局会话范围，如果不是集群，等效于session.
3. Bean的生命周期
    &lt;bean id=&quot;userService&quot; class=&quot;cn.test.service.impl.UserServiceImpl&quot; 
        init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt;&lt;/bean&gt;
    1. init-method=&quot;init&quot;：指定Bean对象的初始化方法，UserServiceImpl.init();
    2. destory-method=&quot;destroy&quot;：指定Bean对象的销毁方法，UserServiceImpl.destory();  
    3. 单例对象：随着容器的创建而创建，随着容器的消亡而消亡;
        //1. 获取核心容器对象：执行 UserServiceImpl.init()
        ClassPathXmlApplicationContext ac = 
                new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
        //2. 根据id获取Bean对象
        IUserService service = (IUserService) ac.getBean(&quot;userService&quot;);
        //3. 手动销毁容器：执行 UserServiceImpl.destroy()
        ac.close();
    4. 多例对象：scope=&quot;prototype&quot;，每次使用对象时由Spring创建，但Spring无法控制销毁，
    只能由Java垃圾回收器销毁.
</code></pre><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><pre><code>1. IoC降低了程序间的耦合(依赖关系)，一个类需要引用另一个类对象时，我们只需要在Spring的
   配置文件中说明两个类的依赖关系，交由Spring去维护这种依赖关系，这就是依赖注入;
2. 能注入的数据：基本类型、Bean对象(在配置文件中或者注解配置过的bean)、复杂/集合类型;
3. 注入的三种方式：使用构造函数、setter、注解
</code></pre><h4 id="构造函数注入"><a href="#构造函数注入" class="headerlink" title="构造函数注入"></a>构造函数注入</h4><pre><code>public class UserServiceImpl implements IUserService {
    private String name;  //基本类型
    private int age;
    private Date birthday;  //对象
    private IUserDao dao;
    public UserServiceImpl(String name, int age, Date birthday, IUserDao dao){
        this.name = name;  this.age = age;
        this.birthday = birthday;  this.dao = dao;
    }
}
1. 使用&lt;bean&gt;的子标签 &lt;constructor-arg&gt;，相关属性：
    1. type：注入数据的类型，也就是构造函数上的某个参数类型;
    2. index: 参数的索引位置，从 0 开始;
    3. name：参数名称;
    4. value：参数值，提供基本数据类型的数据;
    5. ref：参数值，引用另一个&lt;bean&gt;对象的数据;
    &lt;bean id=&quot;userService&quot; class=&quot;cn.test.service.impl.UserServiceImpl&quot;&gt;
        &lt;constructor-arg name=&quot;name&quot; value=&quot;Java&quot;&gt;&lt;constructor-arg&gt;
        &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;constructor-arg&gt;
        &lt;constructor-arg name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;constructor-arg&gt;
        &lt;constructor-arg name=&quot;dao&quot; ref=&quot;userDao&quot;&gt;&lt;/constructor-arg&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;cn.test.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;
2. 弊端：这种方式只能匹配一个固定的构造函数，改变了Bean对象的实例化方式，在创建对象时，
   即使用不到这些数据，也必须提供，否则Spring无法创建对象.
</code></pre><h4 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h4><pre><code>public class UserServiceImpl implements IUserService {
    private String name;  //基本类型
    private int age;
    private Date birthday;  //对象
    private IUserDao dao;
    //setter是必须的，可以没有getter
}
1. 使用&lt;bean&gt;的子标签 &lt;property&gt;，相关属性：
    1. name：setter的方法名，取set后的字母、并把首字母转为小写;
        age--&gt;setUserAge()--&gt;userAge，
    2. value、ref
    &lt;bean id=&quot;userService&quot; class=&quot;cn.test.service.impl.UserServiceImpl&quot;&gt;
        &lt;property name=&quot;name&quot; value=&quot;Java&quot;&gt;&lt;property&gt;
        &lt;property name=&quot;age&quot; value=&quot;20&quot;&gt;&lt;property&gt;
        &lt;property name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;property&gt;
        &lt;property name=&quot;dao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;
    &lt;bean id=&quot;userDao&quot; class=&quot;cn.test.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;
2. 这种方式解决了构造函数注入的弊端，创建对象时没有明确的限制，直接使用默认构造函数;
3. 弊端：如果某个成员必须有值(构造函数被重载，存在有参构造函数)，获取对象时可能没有配置
   此成员的setter，导致此成员没有值.
</code></pre><h4 id="复杂类型-集合对象的注入"><a href="#复杂类型-集合对象的注入" class="headerlink" title="复杂类型/集合对象的注入"></a>复杂类型/集合对象的注入</h4><pre><code>public class UserServiceImpl implements IUserService {
    private String[] myArr;  //数组
    private List&lt;String&gt; myList;  //List集合
    private Set&lt;String&gt; mySet;  //Set集合
    private Map&lt;String, String&gt; myMap;  //Map集合
    private Properties myProp;  //Properties
    //setter是必须的
}
1. 使用&lt;property&gt;的子标签
    &lt;bean id=&quot;userService&quot; class=&quot;cn.test.service.impl.UserServiceImpl&quot;&gt;
        &lt;property name=&quot;myArr&quot;&gt;
            &lt;array&gt;
                &lt;value&gt;AAA&lt;/value&gt;
                &lt;value&gt;BBB&lt;/value&gt;
            &lt;/array&gt;
        &lt;property&gt;
        &lt;property name=&quot;myList&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;AAA&lt;/value&gt;
                &lt;value&gt;BBB&lt;/value&gt;
            &lt;/list&gt;
        &lt;property&gt;
        &lt;property name=&quot;mySet&quot;&gt;
            &lt;set&gt;
                &lt;value&gt;AAA&lt;/value&gt;
                &lt;value&gt;BBB&lt;/value&gt;
            &lt;/set&gt;
        &lt;property&gt;
        &lt;property name=&quot;myMap&quot;&gt;
            &lt;map&gt;
                &lt;!-- 两种配置key-value的方式 --&gt;
                &lt;entry key=&quot;testA&quot; value=&quot;AAA&quot;&gt;&lt;/entry&gt;
                &lt;entry key=&quot;testB&quot;&gt;
                    &lt;value&gt;BBB&lt;/value&gt;
                &lt;/entry&gt;
            &lt;/map&gt;
        &lt;property&gt;
        &lt;property name=&quot;myProp&quot;&gt;
            &lt;props&gt;
                &lt;prop key=&quot;testA&quot;&gt;AAA&lt;/prop&gt;
                &lt;prop key=&quot;testB&quot;&gt;BBB&lt;/prop&gt;
            &lt;/props&gt;
        &lt;property&gt;
    &lt;/bean&gt;
2. 结构相同，标签是可以互换的，list、array、set是一类，map、props是一类。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">大麦田怪圈</p>
              <p class="site-description motion-element" itemprop="description">敢做就能赢！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">61</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大麦田怪圈</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
