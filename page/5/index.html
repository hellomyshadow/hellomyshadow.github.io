<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="敢做就能赢！">
<meta property="og:type" content="website">
<meta property="og:title" content="大麦田程序猿">
<meta property="og:url" content="http://hellomyshadow.github.io/page/5/index.html">
<meta property="og:site_name" content="大麦田程序猿">
<meta property="og:description" content="敢做就能赢！">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="大麦田程序猿">
<meta name="twitter:description" content="敢做就能赢！">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hellomyshadow.github.io/page/5/">





  <title>大麦田程序猿</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大麦田程序猿</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/04/03/SpringBoot整合/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/03/SpringBoot整合/" itemprop="url">SpringBoot整合</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-03T00:00:00+08:00">
                2016-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="整合MyBatis"><a href="#整合MyBatis" class="headerlink" title="整合MyBatis"></a>整合MyBatis</h2><pre><code>1. mybatis的启动器，第三方框架的启动器通常不是以 spring- 开头;
    &lt;dependency&gt;
        &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
        &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
        &lt;version&gt;2.0.1&lt;/version&gt;
    &lt;/dependency&gt;
2. MySQL的连接驱动
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;8.0.16&lt;/version&gt;
    &lt;/dependency&gt;
3. 创建配置文件 resources/application.properties，配置数据库连接信息(覆盖默认配置)
    spring.datasource.driverClassName=com.mysql.cj.jdbc.Driver
    spring.datasource.url=jdbc:mysql://host:port/database?serverTimezone=Asia/Shanghai
    spring.datasource.username=root
    spring.datasource.password=123456
4. 实体类(POJO)：cn.boot.pojo.User
    public class User {
        private Integer id;  //尽量使用包装类型
        private String username;
        private String password;
        ... //getter、setter
    }
5. Dao层：cn.boot.mapper.IUserMapper，Mybatis的两个注解 @Mapper、@MapperScan
    @Mapper
    @Repository
    public interface IUserMapper {
        List&lt;User&gt; findAll();
    }
    1. @Mapper：修饰在Dao层接口上，为其生成实现类;
    2. @MapperScan：修饰在引导类上，指定Mapper接口所在的包，为包下的所有接口生成实现类;
        @SpringBootApplication
        @MapperScan(basePackages={&quot;cn.boot.mapper&quot;})
        public class BootdemoApplication {
             ...
        }
    3. 在使用 @Autowired 注入Dao时，IDE会报错，但能运行，在Dao层接口上注解 @Repository 可以消除错误.
6. 建立POJO与Dao的映射关系
    1. 映射配置文件的方式：resources/mapper/IUserMapper.xml
        &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
        &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
                &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
        &lt;mapper namespace=&quot;cn.boot.mapper.IUserMapper&quot;&gt;
            &lt;select id=&quot;findAll&quot; resultType=&quot;user&quot;&gt;
                select * from user
            &lt;/select&gt;
        &lt;/mapper&gt;
    2. 注解的方式
        @Mapper
        public interface IUserMapper {
            @Select(&quot;select * from user&quot;)
            List&lt;User&gt; findAll();
        }
7. 在 application.properties 中配置Mybatis的信息
    # 开启驼峰扫描
    mybatis.configuration.map-underscore-to-camel-case: true
    # 配置POJO别名的扫描包
    mybatis.type-aliases-package=cn.boot.pojo
    # 加载Mybatis的映射文件(如果使用映射配置文件的方式)
    mybatis.mapper-locations=classpath:mapper/*Mapper.xml
    # 在控制台打印生成的SQL语句
    mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl
8. 在Controller中，使用 @Autowired 注入Dao(Mapper)对象
    @Slf4j
    @RestController
    public class QuickController {
        @Autowired
        private IUserMapper userMapper;

        @RequestMapping(&quot;/test&quot;)
        public String test() {
            List&lt;User&gt; users = userMapper.findAll();
            return &quot;Hello SpringBoot&quot;;
        }
    }
</code></pre><h3 id="通用Mapper"><a href="#通用Mapper" class="headerlink" title="通用Mapper"></a>通用Mapper</h3><pre><code>1. 通用Mapper：一款中国人自己开发的框架，基于Mybatis，只支持单表的CRUD;
    1. 在单表的CURD中，其SQL语句的性能通常是固定的，不像多表的SQL语句那样、有很大的优化余地;
    2. 所以在单表操作时，完全可以为Dao层的方法自动生成SQL语句，这就是通用Mapper的作用.
2. 通用Mapper的启动器：mapper-spring-boot-starter
    1. 启动器中已经引入了 spring-boot-starter、spring-boot-starter-jdbc、mybatis、mybatis-spring
    2. 所以不能再引入 mybatis-spring-boot-starter、spring-boot-starter-jdbc
    3. 而且，通用Mapper 默认开启驼峰匹配，无需在 application.yaml 中手动开启;
    4. 在 application.yaml 中，选择使用Spring的默认连接池，配置数据库连接的4大参数.
    spring:
        datasource:
            ...... # driver-class-name、url、username、password
    mybatis:
        type-aliases-package: cn.boot.pojo
        configuration:
            log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
3. Dao层接口需要继承 Mapper 接口，泛型为实体类
    public interface UserMapper extends Mapper&lt;User&gt; {
        //Mapper中已经提供了常用的CRUD方法
    }
    1. 通用Mapper底层利用Mybatis的拦截器，动态生成SQL语句，并做了SQL缓存，所以性能很好;
    2. @MapperScan、@Mapper 要使用通用Mapper包下的注解，不能再使用Mybatis包下的了.
4. 在启动类上注解通用Mapper的 @MapperScan , 声明扫描Mapper/Dao层接口所在的包
    @SpringBootApplication
    @MapperScan(&quot;cn.boot.mapper&quot;)
    public class StartQuickBoot {
        ...
    }
5. 实体类相关
    1. 通用Mapper默认会使用实体类名作为数据库表名，@Table(name=&quot;表名&quot;) 用于指定数据库表名;
    2. @Id 注解在属性上，指定主键;
    3. 对于自增长的主键，还需要使用 @KeySql(userGeneratedKeys=true) 注解;
    4. 如果实体类的某个属性不作为数据库的字段，则使用 @Transient 注解;
    @Data
    @Table(name=&quot;tl_user&quot;)
    public class User {
        @Id
        @KeySql(userGeneratedKeys=true)
        private Integer id;  //自增长的主键
        private String username;
        @Transient
        private String remark;  //额外的属性
    }
6. Service层：使用 @Transactional 注解引入事务;
    @Service
    public class UserService {
        @Autowired
        private UserMapper mapper;

        public User findById(Integer id) {
            return mapper.selectByPrimaryKey(id);
        }
        @Transactional
        public void insertUser(User user) {  //插入数据时使用事务
            mapper.insert(user);
        }
    }
7. Controller层
    @Autowired
    private UserService service;  //注入Service对象

    @GetMapping(&quot;/{id}&quot;)
    public User test(@PathVariable(&quot;id&quot;) Integer id) {
        log.debug(&quot;test service: {}&quot;, id);
        return service.findById(id);
    }
</code></pre><h2 id="集成Spring-Data-JPA"><a href="#集成Spring-Data-JPA" class="headerlink" title="集成Spring Data JPA"></a>集成Spring Data JPA</h2><pre><code>1. 引入起步依赖：spring-boot-starter-data-jpa
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
    &lt;/dependency&gt;
2. 引入MySQL连接驱动：
    &lt;dependency&gt;
        &lt;groupId&gt;mysql&lt;/groupId&gt;
        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
        &lt;version&gt;8.0.16&lt;/version&gt;
    &lt;/dependency&gt;
3. application.properties
    # MySQL连接信息
    spring.datasource.driverClassName=com.mysql.cj.jdbc.Driver
    spring.datasource.url=jdbc:mysql:...
    spring.datasource.username=root
    spring.datasource.password=123456
    # JPA的配置信息
    spring.jpa.database=MySQL
    spring.jpa.show-sql=true
    spring.jpa.generate-ddl=true
    spring.jpa.hibernate.ddl-auto=update
    spring.jpa.hibernate.naming_strategy=org.hibernate.cfg.ImprovedNamingStrategy
4. 创建POJO
    @Entity  --&gt;javax.persistence.Entity
    public class User {
        @Id
        @GeneratedValue(strategy=GenerationType.IDENTITY)
        private Long id;  //使用包装类型
        private String username;
        private String password;
        ... //getter、setter
    }
5. Dao层接口：cn.boot.repository.UserRepository
    public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
        List&lt;User&gt; findAll();
    }
6. 使用junit测试：测试失败，等学了JPA再说吧
    @RunWith(SpringRunner.class)
    @SpringBootTest(classes=引导类.class)
    public class TestIbatis {
        @Autowired
        private UserRepository userRepository;  //注入Repository对象

        @Test
        public void test() {
            List&lt;User&gt; users = userRepository.findAll();
        }
    }
7. JDK9环境可能报异常：JAXBException，是因为缺少依赖;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;
        &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;
        &lt;version&gt;2.3.1&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><pre><code>1. Redis官方推荐的Java客户端有很多，常用的有Jedis、Redisson...
2. 其中，Redisson基于Redis实现了很多常用的结构，甚至还有分布式锁和同步器;
3. Spring对Redis做了集成，SpringDataRedis，最初是基于Jedis，Spring5.0开始转向响应式编程，
   所以 SpringDataRedis 重新采用一套响应式编程实现，性能比Jedis更高;
4. SpringDataRedis属于Spring Data的一部分，也为Redis提供了一个Template对象：RedisTemplate
</code></pre><h3 id="整合Redis"><a href="#整合Redis" class="headerlink" title="整合Redis"></a>整合Redis</h3><pre><code>1. Redis的启动器：spring-boot-starter-data-redis
2. 在 application.yml 中，配置Redis的连接信息
    1. 连接单台Redis服务
    spring:
        redis:
            host: 192.168.103.30
            port: 6379  # 默认6379
            database: 0  # 配置Redis的数据库编号，默认就是0
            timeout: 3000  # 连接超时时间3s
            jedis 或 lettuce:
                pool:  #连接池
                    max-idle=200  #最大空闲连接，默认值8
                    min-idle=200  #最小空闲连接，默认值0
                    max-active=2000  #最大连接实例，设置为-1，表示不做限制
                    max-wait=2000  #等待可用连接的超时时间，默认值-1，表示永不超时
    2. jedis和lettuce都是Redis提供的客户端，默认是jedis，但lettuce是基于netty的，并发性更好;
    3. 连接集群，指定集群的每个节点地址
    spring.redis.cluster.nodes=192.168.103.128:7001, ... ,192.168.103.128:7006
3. 在测试类中，注入 RedisTemplate 对象，操作Redis数据库
    @Autowired
    private RedisTemplate redis;

    @Test
    public void contest() { ... }
4. redis.opsForValue()、opsForList()、opsForSet()、opsForZSet()、opsForHash() 对应Redis中的5种数据结构，
   封装到不同的 Operations 对象中;
    1. 字符串操作对象：ValueOperations ops = redis.opsForValue();
    2. opsForXXX() 在获取Operations对象时做了单例优化，可以不创建Operations对象的变量;
5. redis.boundXXXOps(key)：以绑定key的方式创建 Operations 对象，后续操作不需要再指定key
</code></pre><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><pre><code>1. RedisTemplate 其实是带有泛型的：RedisTemplate&lt;K, V&gt;，分别代表Key、Value的类型;
2. 虽然Redis的key和value通常都是字符串类型：RedisTemplate&lt;String, String&gt;，但底层存储时仍是二进制字节;
3. 泛型的 K、V 可以指定任意类型，RedisTemplate自动把这些类型转为字节进行存储，因为默认使用JDK的序列化工具;
4. 在命令行上查看时，Redis不会转换JDK序列化的结果，可读性很差，所以通常把对象转为JSON字符串，然后存储到Redis中;
5. 考虑到这种转换会很频繁，所以Spring提供了RedisTemplate的子类：SpringRedisTemplate，它的序列化工具不再是JDK，
   而是string.getBytes()，在命令行上查看时，Redis能够自动再转为字符串;
6. 当然RedisTemplate也允许自定义序列化工具。
7. 短信验证码的发送
    1. 把发送事件推送到RabbitMQ中，由消费者调用短信的API;
    2. 短信发送成功后，使用Redis记录下当前手机号，key=sms:phone:手机号，value=当前时间戳，并设置过期时间;
    3. 每次收到发送短信的消息时，先从Redis中获取手机号，如果没有或者时间已经超过了1分钟，则发送，否则不发送，
    避免短信服务的限流;
</code></pre><h2 id="LogBack"><a href="#LogBack" class="headerlink" title="LogBack"></a>LogBack</h2><pre><code>1. 常用的日志组件：slf4j、log4j、logback、common-logging...
2. logback：基于log4j，不能单独使用，一般配合slf4j使用;
3. logback当前分为3个模块：logback-core(基础核心模块)、logback-classic、logback-access
    1. Logger：日志记录器;
    2. Appender：指定日志输出的目的地，控制台、文件;
    3. Layout：日志布局，格式化日志信息的输出;
5. 日志级别：debug &lt; info &lt; warn &lt; error
6. 在线工具：https://logback.qos.ch/translator/，把log4j.properties转为logback.xml
    ===========log4j.properties示例===========
    ### 设置###
    log4j.rootLogger = debug,stdout,D,E
    ### 输出信息到控制抬 ###
    log4j.appender.stdout = org.apache.log4j.ConsoleAppender
    log4j.appender.stdout.Target = System.out
    log4j.appender.stdout.layout = org.apache.log4j.PatternLayout
    log4j.appender.stdout.layout.ConversionPattern = [%-5p] %d{yyyy-MM-dd HH:mm:ss,SSS} method:%l%n%m%n
    ### 输出DEBUG 级别以上的日志到=D://logs/error.log ###
    log4j.appender.D = org.apache.log4j.DailyRollingFileAppender
    log4j.appender.D.File = D://logs/log.log
    log4j.appender.D.Append = true
    log4j.appender.D.Threshold = DEBUG
    log4j.appender.D.layout = org.apache.log4j.PatternLayout
    log4j.appender.D.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n
    ### 输出ERROR 级别以上的日志到=D://logs/error.log ###
    log4j.appender.E = org.apache.log4j.DailyRollingFileAppender
    log4j.appender.E.File =E://logs/error.log
    log4j.appender.E.Append = true
    log4j.appender.E.Threshold = ERROR
    log4j.appender.E.layout = org.apache.log4j.PatternLayout
    log4j.appender.E.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss}  [ %t:%r ] - [ %p ]  %m%n
</code></pre><h3 id="SpringBoot整合logback"><a href="#SpringBoot整合logback" class="headerlink" title="SpringBoot整合logback"></a>SpringBoot整合logback</h3><pre><code>1. Web启动器spring-boot-starter-web 中已经包含了 logback 的相关依赖;
2. 创建 resources/logback-spring.xml
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
    &lt;configuration&gt;
        &lt;appender name=&quot;consoleApp&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
            &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;
                &lt;pattern&gt;
                    %date{yyyy-MM-dd HH:mm:ss.SSS} %-5level[%thread]%logger{56}.%method:%L -%msg%n
                &lt;/pattern&gt;
            &lt;/layout&gt;
        &lt;/appender&gt;
        &lt;appender name=&quot;fileInfoApp&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
            &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;
                &lt;level&gt;ERROR&lt;/level&gt;
                &lt;onMatch&gt;DENY&lt;/onMatch&gt;
                &lt;onMismatch&gt;ACCEPT&lt;/onMismatch&gt;
            &lt;/filter&gt;
            &lt;encoder&gt;
                &lt;pattern&gt;
                    %date{yyyy-MM-dd HH:mm:ss.SSS} %-5level[%thread]%logger{56}.%method:%L -%msg%n
                &lt;/pattern&gt;
            &lt;/encoder&gt;
            &lt;!-- 滚动策略 --&gt;
            &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
                &lt;!-- 输出到文件的路径 --&gt;
                &lt;fileNamePattern&gt;app_log/log/app.info.%d.log&lt;/fileNamePattern&gt;
            &lt;/rollingPolicy&gt;
        &lt;/appender&gt;
        &lt;appender name=&quot;fileErrorApp&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
            &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;
                &lt;level&gt;ERROR&lt;/level&gt;
            &lt;/filter&gt;
            &lt;encoder&gt;
                &lt;pattern&gt;
                    %date{yyyy-MM-dd HH:mm:ss.SSS} %-5level[%thread]%logger{56}.%method:%L -%msg%n
                &lt;/pattern&gt;
            &lt;/encoder&gt;
            &lt;!-- 设置滚动策略 --&gt;
            &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
                &lt;!-- 输出到文件的路径 --&gt;
                &lt;fileNamePattern&gt;app_log/log/app.err.%d.log&lt;/fileNamePattern&gt;
                &lt;!-- 控制保留的归档文件的最大数量，超出数量就删除旧文件，假设设置每个月滚动，
                    且&lt;maxHistory&gt; 是1，则只保存最近1个月的文件，删除之前的旧文件 --&gt;
                &lt;MaxHistory&gt;1&lt;/MaxHistory&gt;
            &lt;/rollingPolicy&gt;
        &lt;/appender&gt;
        &lt;!-- 控制总的输出级别：level=&quot;INFO&quot; 表示只输出大于等于INFO级别的日志，不会有DEBUG日志 --&gt;
        &lt;root level=&quot;INFO&quot;&gt;  
            &lt;appender-ref ref=&quot;consoleApp&quot;/&gt;
            &lt;appender-ref ref=&quot;fileInfoApp&quot;/&gt;
            &lt;appender-ref ref=&quot;fileErrorApp&quot;/&gt;
        &lt;/root&gt;
    &lt;/configuration&gt;
3. 日志输出
    @GetMapping(&quot;log&quot;)
    public String testLog() {
        log.debug(&quot;this is debug level&quot;);
        log.info(&quot;this is info level&quot;);
        log.warn(&quot;this is warn level&quot;);
        log.error(&quot;this is error level&quot;);
    }
    http://localhost:8080/user/log
4. 在项目目录下生成 app_log/log 目录，其中包含日志文件 app.info.xx.log、app.err.xx.log
5. 日志文件不仅包括 log 打印的，还有大于INFO级别的系统日志;
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/04/02/SpringBoot进阶/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/02/SpringBoot进阶/" itemprop="url">SpringBoot进阶</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-02T00:00:00+08:00">
                2016-04-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="SpringMVC新增注解"><a href="#SpringMVC新增注解" class="headerlink" title="SpringMVC新增注解"></a>SpringMVC新增注解</h2><pre><code>1. Spring4.3中引进了 @GetMapping、@PostMapping、@PutMapping、@DeleteMapping、@PatchMapping
    1. @GetMapping 等效于 @RequestMapping(method=RequestMethod.GET);
    2. @PostMapping 是 @RequestMapping(method=RequestMethod.POST) 的缩写;
2. @RestController：相当于 @ResponseBody + @Controller 的组合;
    @RestController
    @RequestMapping(&quot;/user&quot;)
    public class RestController {
        @GetMapping(&quot;/getList&quot;)
        public List&lt;User&gt; getList() {
            List&lt;User&gt; us = dao.findAll();
            return us;
        }
    }
    1. @RestController 的方法都只能返回String、Object、Json等实体对象;
    2. SpringBoot已经引入了jackson, 返回的对象会被jackson转为JSON字符串，写入响应体中;
    3. 如果想要跳转页面，则用 ModelAndView 封装;
    @GetMapping(&quot;/index&quot;)
    public ModelAndView toIndex() {
        ModelAndView mv = new ModelAndView(&quot;index&quot;);
        return mv;
    }
</code></pre><h2 id="lombok"><a href="#lombok" class="headerlink" title="lombok"></a>lombok</h2><pre><code>    &lt;dependency&gt;
        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
        &lt;artifactId&gt;lombok&lt;/artifactId&gt;
        &lt;version&gt;1.18.6&lt;/version&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
1. @Data：注解在Java类上，在编译期自动生成getter、setter... 源码中没有变化，只存在于编译生成的class文件中;
2. @Setter、@Getter：分别生成 setter、getter 方法;
3. @AllArgsConstructor：添加一个构造函数，该构造函数含有所有已声明的属性参数;
4. @NoArgsConstructor：添加一个无参构造函数;
5. @Slf4j：等效于在Java类中创建Logger对象的属性 log=LoggerFactory.getLogger(类名.class);
    1. 日志的输出，如log.info()，依赖于日志相关的包，诸如log4j、slf4j
    2. 在SpringMVC的启动器中，已经包含日志启动器spring-boot-starter-logging
    3. 所以在使用lombok的日志输出功能时，如果没有引入SpringMVC的启动器，则必须引入日志启动器.
6. IDEA并不能自动识别 @Slf4j 提供的变量log，需要安装插件 Settings -&gt; Plugins -&gt; 搜索Lombok
</code></pre><h2 id="Jackson"><a href="#Jackson" class="headerlink" title="Jackson"></a>Jackson</h2><pre><code>1. 常用的JSON框架序列化JSON的性能：Jackson &gt; fastJson &gt; Gson &gt; Json-lib，各有所长，时间换空间、空间换时间;
2. web启动器默认集成了Jackson
    1. @JsonIgnore：指定忽略的字段，不返回给前端;
    2. @JsonFormat(pattern=&quot;yyyy-MM-dd hh:mm:ss&quot;, locale=&quot;zh&quot;, timezone=&quot;GMT+8&quot;)：指定日期格式化;
    3. @JsonInclude(Include.NON_NULL)：空字段不返回;
    4. @JsonProperty：指定别名，隐藏真实的字段名;
    @Data
    public class User {
        @JsonInclude(Include.NON_NULL)
        private Integer id;

        @JsonProperty(&quot;abcd&quot;)
        private String name;

        @JsonIgnore   ------&gt;完全忽略，客户端提交的age参数也会被忽略
        private Integer age;

        private String password;

        @JsonFormat(pattern=&quot;yyyy-MM-dd hh:mm:ss&quot;, locale=&quot;zh&quot;, timezone=&quot;GMT+8&quot;)
        private Date birthday;

        @JsonIgnore  ---&gt; 重写了getter，传递给客户端时忽略
        public String getPassword() {
            return password;
        }
        @JsonProperty  ---&gt; 重写了setter，接收时仍赋值
        public void setPassword(String password) {
            this.password = password;
        }
    }
3. Controller方法
    @RestController
    public class UserController {
        @GetMapping(&quot;/test&quot;)
        public Object test() {
            User user = new User();
            user.setName(&quot;Java&quot;);
            user.setName(&quot;123456&quot;);
            user.setBirthday(new Date())
            return user;  //发送给前端的JSON：{ &quot;abcd&quot;: &quot;123456&quot;, &quot;birthday&quot;: &quot;2019-05-12 07:50:31&quot; }
        }
    }
</code></pre><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><pre><code>1. @EnableScheduling：注解在启动类上，自动扫描，开启定时任务;
2. @Scheduled：注解在任务方法上;
    @Slf4j
    @Component  --&gt;定时任务类必须加入Spring IoC容器才能被扫描
    public class TestTask {
        @Scheduled(fixedRate=2000)  --&gt;每隔2s执行一次
        public void test() {
            log.info(&quot;当前时间：{}&quot;, new Date());
        }
    }
    1. corn：定时任务表达式，比如 cron=&quot;*/1 * * * * *&quot; 表示每秒执行一次，可以使用在线工具生成corn表达式;
    2. fixedRate：上次开始执行后，xx毫秒后再执行;
        @Scheduled(fixedRate=2000)
        public void test() {
            Thread.sleep(4000);   ---&gt;任务执行时间大于fixedRate，那么每隔 4s 执行一次
        }
    3. fixedDelay：上次任务结束之后，延迟xx毫秒再执行；
        @Scheduled(fixedDelay=2000)
        public void test() {
            Thread.sleep(4000);  --&gt; 任务执行时间4s + 延迟时间2s = 6s  --&gt;每隔6s执行一次
        }
    4. fixedRateString、fixedDelayString：字符串形式，可以把延迟时间配置在SpringBoot的配置文件中;
</code></pre><h2 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h2><pre><code>1. @EnableAsync：注解在启动类上，扫描异步任务的注解;
2. @Component：注解在任务类上，加入Spring IoC容器，不能把任务方法写在Controller类中;
3. @Async：注解在任务类或任务方法上，注解在任务类上时，它所有的方法都是异步任务;
    @Slf4j
    @Component
    public class AsyncTask {
        @Async
        public void task1() throws InterruptedException {
            long begin = System.currentTimeMillis();
            Thread.sleep(1000);
            long end = System.currentTimeMillis();
            log.info(&quot;任务-1: {}&quot;, (end-begin));
        }
    }
4. 调用异步任务，不会阻塞主线程
    @Autowired
    private AsyncTask t;

    @GetMapping(&quot;/task&quot;)
    public String task() {
        t.task1();
        return &quot;hello Task!&quot;;  --&gt;响应给前端，不会等待异步任务执行完成
    }
5. 获取异步任务的返回值
    @Async
    public Future&lt;String&gt; task2() throws InterruptedException {
        long begin = System.currentTimeMillis();
        Thread.sleep(2000);
        long end = System.currentTimeMillis();
        log.info(&quot;任务-2: {}&quot;, (end-begin));
        return new AsyncResult&lt;String&gt;(&quot;task2&quot;);
    }
    @Async
    public Future&lt;String&gt; task3() throws InterruptedException {
        long begin = System.currentTimeMillis();
        Thread.sleep(3000);
        long end = System.currentTimeMillis();
        log.info(&quot;任务-3: {}&quot;, (end-begin));
        return new AsyncResult&lt;String&gt;(&quot;task3&quot;);  //返回异步任务执行的结果
    }

    @GetMapping(&quot;/task1&quot;)
    public String task1() {
        Future&lt;String&gt; task2 = t.task2();//执行异步任务
        Future&lt;String&gt; task3 = t.task3();
        for(;;) {
            if(task2.isDone() &amp;&amp; task3.isDone()) { //检查异步任务是否全部执行完成
                break;
            }
        }  ---&gt; 大约耗时：3000，异步任务是同时执行的，所以耗时时间就是执行时间最长的一个异步任务
    }
    @GetMapping(&quot;/task2&quot;)
    public String task2() {
        long begin = System.currentTimeMillis();
        Future&lt;String&gt; task2 = t.task2();
        Future&lt;String&gt; task3 = t.task3();
        String res4 = task4.get();
        String res5 = task5.get();  //阻塞等待获取异步任务的结果
        long end = System.currentTimeMillis();
        System.out.println(&quot;耗时: &quot; + (end-begin)); //大约耗时：3000
    }
</code></pre><h2 id="全局异常"><a href="#全局异常" class="headerlink" title="全局异常"></a>全局异常</h2><pre><code>1. @ControllerAdvice：SpringMVC的注解，作用在类上，声明为异常捕获类;
2. @RestControllerAdvice：组合注解，@ControllerAdvice + @ResponseBody
3. @ExceptionHandler(value=Exception.class)：注解在异常处理的方法上，value属性指定捕获的异常;
    @ControllerAdvice
    public class CustomExtHandler {
        @ExceptionHandler(value=Exception.class)  --&gt;Exception表示捕获所有异常
        @ResponseBody
        Object handleException(Exception e, HttpServletRequest request) {
            Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
            map.put(&quot;code&quot;, 100);
            map.put(&quot;msg&quot;, e.getMessage());
            map.put(&quot;url&quot;, request.getRequestURL());
            return map;  //当应用程序中发生了异常时，响应给前台的数据
        }
    }
    1. 在Controller中抛出异常
        @GetMapping(&quot;/ply&quot;)
        public String home() {
            int i = 1/0;  -----&gt; 抛出异常
            ......
        }
    2. http://localhost:8080/ply  --&gt; { &quot;code&quot;: 100, &quot;msg&quot;: &quot;...&quot;, &quot;url&quot;: &quot;...&quot; }
4. 自定义异常，跳转到友好界面(引入依赖thymeleaf)
    1. 自定义异常
        public class PageException extends RuntimeException {
            public PageException(String code, String msg) {
                this.code = code;
                this.msg = msg;
            }
            ......
        }
    2. 在 CustomExtHandler 中追加一个新的处理方法，精确捕获自定义异常
        @ExceptionHandler(value = PageException.class)
        @ResponseBody
        Object handleException(PageException e) {
            ModelAndView mav = new ModelAndView();
            mav.setViewName(&quot;error.html&quot;);
            mav.addObject(&quot;msg&quot;, e.getMsg());
            return mav;
        }
    3. 在Controller中抛出自定义异常
        @GetMapping(&quot;/ply&quot;)
        public String home() {
            throw new PageException(&quot;102&quot;, &quot;错误异常&quot;);
        }
</code></pre><h2 id="Servlet3-0"><a href="#Servlet3-0" class="headerlink" title="Servlet3.0"></a>Servlet3.0</h2><pre><code>1. 在SpringBoot项目中，可以使用Servlet3.0的注解开发Filter、Listener、甚至原生Servlet;
2. @ServletComponentScan：注解在启动类上，进行扫描Servlet3.0的注解;
    @ServletComponentScan
    @SpringBootApplication
    public class BootTestApplication {
        ...
    }
3. 过滤器：@WebFilter
    1. Filter在服务器启动时加载，服务器关闭时销毁，SpringBoot启动时默认加载4个Filter
    characterEncodingFilter -&gt; hiddenHttpMethodFilter -&gt; httpPutFormContentFilter -&gt; requestContextFilter
    2. 使用Servlet3.0的注解自定义Filter时，避免和默认的Filter优先级相同，否则会冲突;
    3. 自定义的Filter 必须实现Filter接口，并注解 @WebFilter，用于配置过滤规则，并加入Spring容器;
    @WebFilter(urlPatterns = &quot;/api/*&quot;, filterName = &quot;loginFilter&quot;)
    public class LoginFilter implements Filter {
        init()、destroy()
        public void doFilter(ServletRequest servReq, ServletResponse servResp, FilterChain chain) {
            HttpServletRequest req = (HttpServletRequest)servReq;
            HttpServletResponse resp = (HttpServletResponse)servResp;
            String username = req.getParameter(&quot;username&quot;);
            if(&quot;admin&quot;.equals(username)) {
                chain.doFilter(servletRequest, servletResponse);
            } else {
                resp.sendRedirect(&quot;/error.html&quot;);
            }
        }
    }
4. 自定义原生Servlet：@WebServlet
    @WebServlet(name=&quot;userServlet&quot;, urlPatterns = &quot;/test/user&quot;)
    public class UserServlet extends HttpServlet {
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp) {
            resp.getWriter().print(&quot;user servlet&quot;);
            resp.getWriter().flush();
            resp.getWriter().close();
        }
    }
5. 自定义原生Listener：@WebListener
    1. 常用监听器：ServletContextListener、HttpSessionListener、ServletRequestListener
    2. ServletContextListener：服务器启动时初始化，常用于一些资源的加载;
    3. ServletRequestListener：一次请求，请求到达则初始化，响应结束则销毁;
    @WebListener
    public class RequestListener implements ServletRequestListener {
        public void requestDestroyed(ServletRequestEvent servletRequestEvent) {
            System.out.println(&quot;RequestListener requestDestroyed&quot;);
        }
        public void requestInitialized(ServletRequestEvent servletRequestEvent) {
            System.out.println(&quot;RequestListener requestInitialized&quot;);
        }
    }
</code></pre><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><pre><code>    public class LoginIntercepter implements HandlerInterceptor {
        preHandle()   --&gt;调用Controller方法之前
        postHandle()  --&gt;Controller方法调用之后，视图渲染之前，如果Controller方法出现异常，则不会执行
        afterCompletion()  --&gt;不管是否有异常，都会执行，常用于资源清理
    }
1. SpringBoot规定：
    1. 如果要保留SpringBoot的一些默认MVC特征，同时又想自定义一些MVC配置，如拦截器、格式化器、视图控制器、
    消息转发器... 就必须实现WebMvcConfigurer，并使用 @Configuration，但一定不能使用 @EnableWebMvc;
    2. 如果想要完全自定义SpringMVC，不保留默认的一切MVC特征，则使用 @Configuration 和 @EnableWebMvc;
2. SpringBoot2.0的拦截器与v2.0之前的配置方式是不同的
    1. 旧版本：extends WebMvcConfigurerAdapter
    @Configuration
    public class OldCusWebMvcConfigurer extends WebMvcConfigurerAdapter {
        public void addInterceptors(InterceptorRegistry registry) {
            //配置拦截器和拦截规则，Ant风格的路径匹配
            registry.addInterceptor(new LoginIntercepter()).addPathPatterns(&quot;/api2/*/**&quot;);
        }
    }
    2. 新版本：implements WebMvcConfigurer
    @Configuration
    public class CusWebMvcConfigurer implements WebMvcConfigurer {
        //配置拦截器和拦截规则
        registry.addInterceptor(new LoginIntercepter())
            .addPathPatterns(&quot;/api2/*/**&quot;)  ----&gt;拦截的资源访问
            .excludePathPatterns(&quot;/api2/xxx/**&quot;);  --&gt;某些不需要拦截的资源访问

        registry.addInterceptor(new LoginIntercepter()).addPathPatterns(&quot;/api2/*/**&quot;);
    }
    3. 配置多个拦截器时，拦截器的执行顺序与配置顺序相同;
3. 拦截器与过滤器
    1. 过滤器依赖于Servlet容器(Web应用)，基于函数回调；而拦截器则不依赖，基于Java的反射机制(AOP)；
    2. 拦截器中可以注入Spring IoC容器的所有Bean对象，实现业务逻辑的调用，而过滤器则不行；
    3. 执行顺序
        Filter --&gt; 拦截器 --&gt; action执行 --&gt; 拦截器 --&gt; 过滤器
</code></pre><h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><pre><code>1. DBCP是一款老牌的JDBC连接池，出自Apache;
2. cp30与Druid都是连接池，一个JDBC组件，速度都差不多;
    1. Hibernate默认使用c3p0;
    2. Druid可以监控每一条SQL语句的执行性能，从而优化SQL语句.
3. 速度最快的JDBC连接池是HikariCP(追光者)，Spring默认内置了HikariCP;
4. Spring提供的JDBC启动器：spring-boot-starter-jdbc，SpringBoot默认集成，无需手动引入;
5. 连接池只是一个JDBC组件，还需要配置数据库驱动，如MySQL的驱动依赖：mysql-connector-java
6. 在 application.yml 中，配置Spring启动器中的默认连接池：连接数据库的4大参数;
    spring:
        datasource:
            driver-class-name: com.mysql.cj.jdbc.Driver
            url: jdbc:mysql://host:port/database?serverTimezone=Asia/Shanghai
            username: root
            password: 123456
7. 默认使用的连接池是HikariCP，如果想使用其他连接池，如阿里的druid
    1. 引入druid的依赖，配置spring.datasource.type=com.zaxxer.hikari.HikariDataSource
    spring:
        datasource:
            type: com.alibaba.druid.pool.DruidDataSource
            ...... # driver-class-name、url、username、password
</code></pre><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><pre><code>1. Junit的起步依赖：spring-boot-starter-test
2. 在test目录下创建测试类
    @RunWith(SpringRunner.class)
    @SpringBootTest(classes=引导类.class)
    public class TestClient {
        @Autowired
        private IUserMapper userMapper;  //注入Mapper对象

        @Test
        public void test() {
            List&lt;User&gt; users = userMapper.findAll();
        }
    }
3. MockMvc：模拟 SpringMVC 的客户端请求
    @AutoConfigureMockMvc   ----&gt;MockMvc的注解
    @RunWith(SpringRunner.class)
    @SpringBootTest(classes={启动类.class})
    public class TestClient {
        @Autowired
        private MockMvc mvc;

        @Test
        public void test() {
            MvcResult res = mvc.perform(MockMvcRequestBuilders.get(&quot;/ply&quot;))
                .andExpect(MockMvcResultMatchers.status().isOk()).andReturn();  //发起get请求
            String str = res.getResponse().getContentAsString();  //获取请求的内容
        }
    }
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/04/01/SpringBoot/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/04/01/SpringBoot/" itemprop="url">SpringBoot</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-04-01T00:00:00+08:00">
                2016-04-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="SpringBoot与Spring"><a href="#SpringBoot与Spring" class="headerlink" title="SpringBoot与Spring"></a>SpringBoot与Spring</h2><pre><code>1. Spring的优点：Spring是JavaEE的轻量级框架，通过依赖注入和面向切面编程，用简单的POJO实现EJB的功能;
2. 但是，虽然Spring的组件代码是轻量级的，但是它的配置文件却是重量级的;
    1. Spring2.5引入基于注解的组件扫描，也是为了消除大量针对应用程序自身组件的XML配置;
    2. Spring3.0引入了基于Java的配置，这是一种类型安全的、可重构的配置方式，可以替代XML;
    3. 除了配置会消耗大量的开发时间，项目的依赖管理也是很麻烦的，版本选择困难，容易冲突.
3. Spring注解的发展
    1. Spring1.0时代因为JDK1.5刚出来，注解开发尚未盛行，所以一切Spring配置皆是XML格式;
    2. Spring2.0时代引入了注解开发，但并未完善，因此并未完全替代XML;
    3. Spring3.0时代的注解已经非常完善了，因此Spring推荐使用注解(Java配置)代替XML.
4. SpringBoot解决了Spring的缺点，基于约定优先于配置，开发者只需要关心逻辑业务的代码编写;
    1. 开箱即用，没有代码生成，也无需XML配置，通过修改默认值来满足特定的需求;
    2. 提供了一些大型项目中常见的非功能性的特性，如嵌入式服务器、安全、指标、健康检测、外部配置...
5. SpringBoot不是对Spring功能上的增强，而是提供一种基于Spring的快速开发方式.
6. 在SpringBoot中，默认采用Servlet3.0，它可以完全使用注解取代web.xml了，所以SpringBoot没有了web.xml.
</code></pre><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><pre><code>1. SpringBoot2.x的依赖环境和版本
    1. JDK8+，因为SpringBoot2.x底层是Spring Framework5
    2. Maven3.2+，Gradle4+
2. 创建一个普通Java项目的Maven工程，添加继承SpringBoot的起步依赖spring-boot-starter-parent
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.1.4.RELEASE&lt;/version&gt;
    &lt;/parent&gt;
    1. spring-boot-starter-parent 中管理了很多其他依赖的版本，所以 &lt;dependencies&gt; 中引入这些的依赖时，
    尽量不要配置它们的版本号，沿用 spring-boot-starter-parent 中的版本号;
    2. Spring对版本的要求比较严格，很多问题都是因为版本不匹配所致.
3. SpringBoot要集成SpringMVC、进行Web/Controller的开发时，只需要导入web的启动器即可;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;!-- 无需指定版本号(如果无法自动配置，则拷贝spring-boot-starter-parent中的版本号) --&gt;
    &lt;/dependency&gt;
4. 创建一个普通类，使用 @SpringBootApplication 声明为一个SpringBoot的引导类(引导应用程序的入口);
    1. 在 main() 中运行引导类：SpringApplication.run(引导类.class, 可选参数);
    @SpringBootApplication
    public class StartSpringBoot {
        public static void main(String[] args) {
            SpringApplication.run(StartSpringBoot.class, args);
        }
    }
5. SpringBoot中内置有Tomcat插件，直接运行 main()，在控制台提示Tomcat启动信息：
    Tomcat started on port(s): 8080 (http) with context path &apos;&apos;
    1. context path &apos;&apos;：表示web应用的名称(虚拟项目名)为空字符串，访问 http://localhost:8080/ ;
    2. 当前没有编写任何页面，所以展示的是 Error Page，但表示已经启动成功了;
6. 无需任何配置，就可以直接编写Controller层
    @Controller
    public class QuickController {
        @RequestMapping(&quot;/test&quot;)
        @ResponseBody
        public String test() {
            return &quot;Hello SpringBoot&quot;;
        }
    }    ---&gt;http://localhost:8080/test  ---&gt; Hello SpringBoot
7. IDEA快速创建SpringBoot工程
    New Project -&gt; Spring Initializr -&gt; Next -&gt; 设置项目信息 -&gt; Next -&gt; 手动选择依赖 -&gt; Finish
</code></pre><h2 id="SpringBoot的原理"><a href="#SpringBoot的原理" class="headerlink" title="SpringBoot的原理"></a>SpringBoot的原理</h2><pre><code>1. SpringBoot的核心功能：起步依赖、自动配置
</code></pre><h3 id="起步依赖"><a href="#起步依赖" class="headerlink" title="起步依赖"></a>起步依赖</h3><pre><code>1. 本质上是一个Maven项目对象模型(POM)，定义了对其他库的传递依赖;
2. 简单来说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认功能;
3. 所有的SpringBoot工程都必须继承 spring-boot-starter-parent，它会对依赖的版本进行管理;
4. SpringBoot项目引入的依赖往往都是starter，它是一个工具集合，里面包含了很多常用的依赖，便于版本管理;
5. 比如spring-boot-starter-web，包含了诸如spring-webmvc、spring-web、Tomcat、jackson ...
6. 第三方框架要对接SpringBoot项目，必须提供起步依赖(启动器)，Spring的官方启动器通常以 spring- 开头;
</code></pre><h3 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h3><pre><code>1. @SpringBootApplication是组合注解：@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan
2. @SpringBootConfiguration 其实就是 @Configuration，所以引导类也就是一个配置类;
3. @EnableAutoConfiguration 是自动配置的核心注解，@Import({AutoConfigurationImportSelector.class})
4. AutoConfigurationImportSelector 中就是自动配置的核心源码;
5. @ComponentScan：配置扫描的包，默认就会扫描引导类所在包下的所有注解;
    1. 所以在使用注解时，注解的类所在包一定不能高于启动类所在包，只能是平级或者下一级包;
    2. 否则会因为没有扫描而无法加载，导致无法使用.
</code></pre><h2 id="SpringBoot的配置文件"><a href="#SpringBoot的配置文件" class="headerlink" title="SpringBoot的配置文件"></a>SpringBoot的配置文件</h2><pre><code>1. SpringBoot是基于约定的，所以很多配置都是默认值;
2. 在需要自定义配置时，根据启动器提供的key名，在SpringBoot的配置文件中指定value值即可;
3. spring-boot-starter-parent 会自动加载 resources 目录下的三类配置文件;
    1. application*.yml、application*.yaml、application*.properties;
    2. 加载顺序：yml --&gt; yaml --&gt; properties，当有相同的key名配置时，properties中的优先级最高.
4. 创建 resources/application.properties，实现一些个性化配置;
    server.port=9090    # 配置Tomcat启动的端口号，默认是8080
    server.servlet.context-path=/demo    # 配置web应用虚拟目录名，默认是空字符串
5. YML一种新型配置文件，也是一种标记语言，有两种扩展名：.yml、.yaml
    1. YML文件格式是由YAML编写的，YAML是一种能够被电脑识别的数据序列化格式，且易读性强，以数据为核心，比XML更简洁;
    2. YML文件与脚本语言的交互性强，可以被支持YAML库的编程语言程序导入，如C/C++、Python、Java、C#、PHP、Ruby...
</code></pre><h3 id="yml配置文件"><a href="#yml配置文件" class="headerlink" title="yml配置文件"></a>yml配置文件</h3><pre><code>1. 普通数据
    key: value  # key和value之间必须有一个空格
2. 对象数据/Map数据
    1. 形式一：缩进形式
        key:
            key1: value1
            key2: value2
    2. key1、key2前面的空格个数不限定，相同缩进代表同一级别;
        person:
            name: Java
            age: 20
    3. 形式二：行内形式
        key: {key1: value1,key2: value2}
3. 数组、List、Set
    1. 存放普通字符串
        key:
            - value1
            - value2
        key: [value1,value2]
    2. 存放对象
        key:
            - key11: value11
              key12: value12
            - key22: value22
              key23: value23
        key: [{key11: value11,key12: value12}, {key22: value22,key23: value23}]
4. resources/application.yaml
    1. 自定义SpringMVC的默认配置
        server:
            port: 8888    # 配置服务器的端口号
            servlet:
                path: &quot;*.do&quot;    # 访问映射路径，默认是&quot;/&quot;，会影响所有的请求路径
    2. Log4j相关
        logging:    # 日志配置(log4j相关的依赖已经被集成)
            level:    # 控制日志级别，是一个Map集合
                cn.boot: debug    # cn.boot包下的日志级别为debug
                org.springframework: debug
</code></pre><h3 id="属性映射"><a href="#属性映射" class="headerlink" title="属性映射"></a>属性映射</h3><pre><code>1. 配置文件被加载后，其中的键-值将会被存放到Spring IoC容器中，那么就可以映射到Spring管理的Bean对象中;
2. application.yml
    jdbc:
        driverClassName: com.mysql.cj.jdbc.Driver
        url: jdbc:mysql://host:port/database?serverTimezone=Asia/Shanghai
        username: root
        password： 123456
3. @Value 的映射：指定配置文件的key名，映射到Spring IoC管理的对象属性上，适合数据量较小的情况;
    @Component
    public class JdbcConf {
        @Value(&quot;${jdbc.driverClassName}&quot;)
        private String driverClassName;

        @Value(&quot;${jdbc.url}&quot;)
        private String url;

        @Value(&quot;${jdbc.username}&quot;)
        private String username;

        @Value(&quot;${jdbc.password}&quot;)
        private String password;
    }
4. @ConfigurationProperties：把配置文件中的键值数据映射到当前Java类的属性上;
    @ConfigurationProperties(prefix=&quot;jdbc&quot;)
    public class JdbcConf {
        private String driverClassName;
        private String url;
        private String username;
        private String password;
    }
    1. prefix属性：声明配置文件中的字段前缀，自动映射到Java类的同名属性上;
    2. 使用 @ConfigurationProperties 时，还需要引入其执行器;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
    3. 先在Bean中定义需要的属性，然后在配置文件中配置时，执行器就会提示可配置的属性.
5. @EnableConfigurationProperties：使用 @ConfigurationProperties 注解的Java类;
    @Configuration
    @EnableConfigurationProperties(JdbcConf.class)
    public class TestConfigure {
        @Autowired
        private JdbcConf jdbc;  //1. @Autowired的方式注入JdbcConf对象

        public TestConfigure(JdbcConf jdbc) { //2.构造方法的方式注入JdbcConf对象

        }
        @Bean
        public DataSource getDataSource(JdbcConf prop) {  //3.方法参数的方式注入
            //阿里的druid
            DruidDataSource ds = new DruidDataSource();
            ds.setDriverClassName(prop.getDriverClassName());  ds.setUrl(prop.getUrl());
            ds.setUsername(prop.getUsername());  ds.setPassword(prop.getPassword());
            return ds;
        }
    }
6. 如果只有一个Bean对象使用JDBC的连接信息，还可以优雅地映射配置文件中的键-值
    @Configuration
    public class JdbcConfig {
        @Bean
        @ConfigurationProperties(prefix=&quot;jdbc&quot;)
        public DataSource getDataSource(JdbcProperties prop) {
            return new DruidDataSource();
        }
    }
    1. 这种方式不再需要映射配置类JdbcConf，直接在对应Bean对象上使用 @ConfigurationProperties;
    2. DruidDataSource对象中有同名属性：driverClassName、url、username、password，从而实现映射;
</code></pre><h3 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h3><pre><code>1. ResourceProperties中定义了静态资源的查找方向
    classpath:/META-INF/resources/ --&gt;classpath:/resources/ --&gt;classpath:/static/ --&gt;classpath:/public/
2. 注意：classpath 指的就是 src/main/resources 目录，这4个目录都在 src/main/resources 目录下;
3. 这些静态资源目录不受Controller管控，可以直接被访问，用于放入图片、CSS、JS、HTML等静态资源;
4. 创建 resources/static/index.html，访问 http://localhost:8080/index.html
5. 在配置文件 application.yml 中，可以加入自定义的静态资源目录：
    spring:
        resources:
            static-locations:
                - classpath:/META-INF/resources/
                - classpath:/resources/
                - classpath:/static/
                - classpath:/public/
                - classpath:/abc/
</code></pre><h2 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h2><pre><code>1. 添加起步依赖
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
    &lt;/dependency&gt;
2. IDEA默认不支持热部署，需要设置
    1. Settings --&gt; Compiler --&gt; 勾选 Build project automatically
    2. Ctrl+Shift+Alt+/ --&gt; Registry --&gt; 勾选 compiler.automake.allow.when.app.running
3. 每次修改了Controller层之后，等待服务器重启，刷新浏览器页面;
4. 在配置文件 application.properties  中，配置不被热部署的文件
    spring.devtools.restart.exclude=static/**, application.properties
5. 通过触发器，手动控制热部署
    1. 创建 resources/trigger.txt，添加内容 verion=1
    2. 在 application.properties 中，配置触发器
        spring.devtools.restart.trigger-file=trigger.txt
    3. 需要热部署时，修改触发器：version=2，保存文件即触发热加载部署;
</code></pre><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><pre><code>1. 使用 MultipartFile 对象接收上传的文件时，有两种方式控制文件的大小;
    1. 在启动类中注册 MultipartConfigElement
        @Bean
        public MultipartConfigElement getMultipartConfigElement() {
            MultipartConfigFactory factory = new MultipartConfigElement();
            factory.setMaxFileSize(&quot;10240KB&quot;);  //单个文件最大10240KB
            factory.setMaxRequestSize(&quot;102400KB&quot;);  //总上传数据最大102400KB
            return factory.createMultipartConfig();
        }
    2. 在 application.yml 中配置上传文件的大小
        spring:
            servlet:
                multipart:
                    max-file-size: 5MB
                    max-request-size: 10MB
2. 文件服务器：fastdfs，阿里云oss，nginx搭建一个简单的文件服务器;
3. 上传过程操作的是磁盘的绝对路径，打成jar包之后，无法直接访问磁盘目录，需要把目录加入静态资源目录列表中;
    images-path: D:\report\
    spring:
        resources:
            static-locations:
                - classpath:/META-INF/resources/
                ······
                - file:${images-path}
</code></pre><h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><pre><code>1. 主流的JavaWeb模板引擎：JSP、Velocity、Freemarker、Thymeleaf
    1. JSP：动态网页技术，JavaWeb官方推荐，支持EL、JSTL表达式，本质上也是一个Servlet，占用JVM内存;
    2. Freemarker：文件一般保存为 xxx.ftl，严格依赖MVC模式，不依赖Servlet容器(不占用JVM内存)，内建函数;
    3. Thymeleaf：SpringBoot主推，轻量级模板引擎，后缀名就是.html，浏览器可以直接访问;
2. Thymeleaf不推荐在页面中做复杂的逻辑业务，因为解析DOM/XML会占用较大的内存;
3. Thymeleaf的启动器：spring-boot-starter-thymeleaf
    spring.thymeleaf.cache=false #是否缓存
    spring.thymeleaf.mode=HTML5
    spring.thymeleaf.encoding=UTF-8  #编码
    spring.thymeleaf.content-type=text/html  #类型
    spring.thymeleaf.suffix=.html  #文件后缀名
    spring.thymeleaf.prefix=classpath:/templates/  #前缀：存放路径
4. 创建 resources/templates/user/info.html
        @GetMapping(&quot;info&quot;)
        public String info() {
            return &quot;user/info&quot;;  ---&gt;渲染resources/templates/user/info.html
        }
5. resources/templates 目录不是静态资源目录，需要放在静态资源列表中才能直接访问
    spring.resources.static-locations = classpath:/META-INF/resources/, ... ,classpath:/templates/
6. 页面静态化
    1. Thymeleaf不仅可以把渲染结果写入Response，还可以写到本地文件中，从而实现页面静态化;
    2. 页面静态化：把动态渲染的HTML页面变成静态内容保存，比如部署在Nginx中;
    3. 以后的用户请求到来时，直接访问静态页面，不再经过服务的渲染，从而大大提高并发能力，减小Tomcat的压力.
</code></pre><h2 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h2><pre><code>1. 多环境：开发环境、测试环境、预发布环境、生产环境...  不同环境使用不同的配置，如数据库配置;
2. 多环境切换有很多方式，以 spring.profiles.active 为例
    1. 创建 resources/config 目录，管理SpringBoot的配置文件，注意：config目录名是固定的;
    2. 在 config 中创建 application.properties、application-dev.properties、application-test.properties
    3. application-dev.properties
        db.url=dev.com
    4. application-test.properties
        db.url=test.com
    5. application.properties
        db=local.com
        # 指定使用哪个profile，如果不指定，默认使用当前文件中的配置
        spring.profiles.active=test  # 使用 application-test 中的配置 db.url=test.com
3. 映射到Spring IoC容器中的Java类属性上
    @Value(&quot;${db.url}&quot;)
    private String url;  //test.com
</code></pre><h2 id="打包与容器"><a href="#打包与容器" class="headerlink" title="打包与容器"></a>打包与容器</h2><pre><code>1. SpringBoot项目打成jar包
    1. pom.xml 配置Maven插件
        &lt;packaging&gt;jar&lt;/packaging&gt;
        &lt;build&gt;
            &lt;plugins&gt;
                &lt;plugin&gt;
                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
                &lt;/plugin&gt;
            &lt;/plugins&gt;
        &lt;/build&gt;
    2. 打开右侧Maven面板 --&gt; Lifecycle --&gt; 双击执行 install --&gt; 在target目录下生成xxx.jar
    3. 如果没有添加插件，执行 java -jar xxx.jar 命令运行jar包时，会报错：no main manifest attribute
2. SpringBoot项目打成war包
    1. 修改打包方式
        &lt;packaging&gt;war&lt;/packaging&gt;
    2. 配置打包的项目名称，也就是项目的虚拟目录名
        &lt;build&gt;
            &lt;finalName&gt;boottest&lt;/finalName&gt;
            &lt;plugins&gt;
                &lt;plugin&gt;
                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
                &lt;/plugin&gt;
            &lt;/plugins&gt;
        &lt;/build&gt;
    3. 修改启动类
    @SpringBootApplication
    public class BootTestApplication extends SpringBootServletInitializer {
        protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
            return builder.sources(BootTestApplication.class);
        }
        public static void main(String[] args) {
            SpringApplication.run(BootTestApplication.class, args);
        }
    }
    4. 执行Lifecycle --&gt; clean，然后执行 install 命令，在target目录下生成 xxx.war
    5. 把 xxx.war 放在 Tomcat/webapps 目录中，启动Tomcat服务器，xxx.war自动解压;
    6. 访问：http://localhost:8080/boottest/xxx
3. SpringBoot默认使用Tomcat容器启动，也可以配置成其他容器
    1. 去除spring-boot-starter-web中集成的Tomcat
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                    &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
    2. 配置为jetty容器
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;
        &lt;/dependency&gt;
    3. 配置为undertow容器
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.undertow&lt;/groupId&gt;
            &lt;artifactId&gt;undertow.core&lt;/artifactId&gt;
            &lt;version&gt;1.3.24.Final&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.undertow&lt;/groupId&gt;
            &lt;artifactId&gt;undertow.servlet&lt;/artifactId&gt;
            &lt;version&gt;1.3.24.Final&lt;/version&gt;
        &lt;/dependency&gt;
4. 使用JMeter测试各个容器的性能;
</code></pre><h3 id="部署到阿里云"><a href="#部署到阿里云" class="headerlink" title="部署到阿里云"></a>部署到阿里云</h3><pre><code>1. winscp、secureCRT、FileZilla：远程连接Linux的工具，可视化操作
2. 在Linux上安装JDK
    1. cd /usr/local/  --&gt; mkdir software --&gt; 下载JDK8压缩包、解压、重命名为jdk8
    2. 配置环境变量：vim /etc/profile，在尾部插入以下内容
    export JAVA_HOME=/usr/local/software/jdk8
    export PATH=$PATH:$JAVA_HOME/bin
    export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
    export JAVA_HOME PATH CLASSPATH
    3. 让配置立刻生效：source /etc/profile
    4. 测试：java -version
3. 入门级：把SpringBoot项目部署到Linux云服务器上，要开放对应的端口号;
    1. 去除对生产环境没用的依赖，如热部署spring-boot-starter-test，测试spring-boot-starter-test
    2. 打成jar包，并上传到Linux服务器上 /usr/local/software/app/
    3. 启动：java -jar xxx.jar
4. 守护进程的方式启动：nohup java -jar xxx.jar &amp;   ---&gt; 生成启动日志文件nohup.out
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/03/26/模块化与私服/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/26/模块化与私服/" itemprop="url">模块化与私服</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-26T00:00:00+08:00">
                2016-03-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="拆分与聚合"><a href="#拆分与聚合" class="headerlink" title="拆分与聚合"></a>拆分与聚合</h2><pre><code>1. 拆分：把一个完整的Maven工程拆成独立的模块，如Dao模块、Service模块、Controller(Web)模块、Utils模块;
2. 模块之间的关系：
    1. 模块之间是平级的，需要建立依赖关系，才能引用对方的功能;
    2. Service模块引用Dao模块的坐标，Controller模块引用Service模块的坐标;
    3. 如果想引用另一个Maven工程，则需要把工程打包发布到本地仓库中，再其坐标即可建立依赖关系;
3. 父工程：New Project --&gt; 不使用Maven骨架，只需保留一个pom.xml，其他的文件和目录都可以删除掉;
    1. 把公共的jar包依赖放在父工程中，供所有的子工程使用;
    2. 在 pom.xml 中配置JDK的编译版本，Tomcat7插件;
    3. 打包方式：pom
        &lt;packaging&gt;pom&lt;/packaging&gt;
    4. &lt;dependencyManagement&gt; 管理的依赖和插件不会传递给子工程，但能够统一管理它们的版本号
        &lt;properties&gt;
            &lt;mysql.version&gt;8.0.16&lt;/mysql.version&gt;
        &lt;/properties&gt;
        &lt;dependencyManagement&gt;
            &lt;dependencies&gt;
                &lt;dependency&gt;
                    &lt;groupId&gt;mysql&lt;/groupId&gt;
                    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
                    &lt;version&gt;${mysql.version}&lt;/version&gt;
                &lt;/dependency&gt;
            &lt;/dependencies&gt;
        &lt;/dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;!-- 这些依赖会直接传递给子工程 --&gt;
        &lt;/dependencies&gt;
    5. 在子工程中引入依赖 mysql-connector-java 时，无需再指定版本节点&lt;version&gt;
4. 子工程：右击父工程 --&gt; New Module --&gt; 创建Maven项目
    1. Dao模块和Service模块都不使用骨架，Web模块使用web骨架;
    2. 子工程的 pom.xml 中，会有一个 &lt;parent&gt;，表示继承的父工程;
    3. 父工程的 pom.xml 中，会多出一个 &lt;modules&gt;，列出拥有的子模块;
    4. 依赖包的作用域(scope)默认是compile，父工程的依赖包传递给子工程的过程中，scope为test的依赖可能丢失;
    5. 比如父工程引入了junit(test)，子工程可能无法使用，这种情况下，通常会在子工程中再加入junit依赖即可;
5. Dao模块：resources/spring/applicationContext-dao.xml，只配置Dao层相关
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;
            http://www.springframework.org/schema/beans
            https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

        &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
            &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
            &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;cn.ssm.domain&quot; /&gt;
        &lt;/bean&gt;

        &lt;bean id=&quot;mapperScanner&quot; class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
            &lt;property name=&quot;basePackage&quot; value=&quot;cn.ssm.dao&quot; /&gt;
        &lt;/bean&gt;

        &lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt;
        &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
            &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot; /&gt;
            &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot; /&gt;
            &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot; /&gt;
            &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;
        &lt;/bean&gt;
    &lt;/beans&gt;
6. Service模块
    1. resources/spring/applicationContext-service.xml，只配置Service层相关
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
        xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;
            http://www.springframework.org/schema/beans
            https://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            https://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/tx
            https://www.springframework.org/schema/tx/spring-tx.xsd
            http://www.springframework.org/schema/aop
            https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

        &lt;context:component-scan base-package=&quot;cn.ssm.service&quot; /&gt;
        &lt;bean id=&quot;manager&quot; 
                class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
            &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
        &lt;/bean&gt;
        &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;manager&quot;&gt;
            &lt;tx:attributes&gt;
                &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt;
                &lt;tx:method name=&quot;*&quot; isolation=&quot;DEFAULT&quot; /&gt;
            &lt;/tx:attributes&gt;
        &lt;/tx:advice&gt;
        &lt;aop:config&gt;
            &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* cn.ssm.service.impl.*.*(..))&quot; /&gt;
        &lt;/aop:config&gt;
    &lt;/beans&gt;
    2. pom.xml：引入Dao模块的坐标
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;cn.ssm&lt;/groupId&gt;
                &lt;artifactId&gt;ssmdao&lt;/artifactId&gt;
                &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
7. Web模块
    1. springmvc.xml、web.xml 都和未拆分前相同;
    2. Spring的配置文件：resources/applicationContext.xml，把Dao和Service的部分合并到一起;
        &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
        &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
            xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
            xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
            &lt;!-- 导入Dao部分和Service部分的Spring配置文件 --&gt;
            &lt;import resource=&quot;classpath:spring/applicationContext-dao.xml&quot;/&gt;
            &lt;import resource=&quot;classpath:spring/applicationContext-service.xml&quot;/&gt;
        &lt;/beans&gt;
    3. pom.xml：引入Service模块的坐标
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;cn.ssm&lt;/groupId&gt;
                &lt;artifactId&gt;ssmservice&lt;/artifactId&gt;
                &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    4. 删除 pom.xml 中默认生成的JDK版本相关的&lt;properties&gt;，使用父工程中配置的JDK版本;
    5. 默认也生成了的&lt;build&gt;，也可以删除，父工程中已经配置了Tomcat7插件;
</code></pre><h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><pre><code>1. log4j.properties 放在 Web模块/resources 目录中，启动项目;
2. 方式一：打开右侧的Maven面板 --&gt; 展开父工程的Plugins --&gt; 双击 tomcat7:run 启动;
3. 配置本地的Tomcat，启动服务器，运行项目;
4. 方式三：选择 Web 工程的 tomcat7:run
    1. Maven项目在运行时会扫描 pom.xml，如果本地仓库没有引入的依赖，则从中央仓库下载，再找不到就报错;
    2. Web工程中引入了Service工程的坐标，但Service工程是本地项目，并没有发布到本地仓库，所以运行失败;
    3. 因此要把Service工程发布到本地仓库，但Service工程又引入了Dao工程的坐标，所以只能去发布父工程;
    4. 在右侧的Maven面板上，双击父工程的Lifecycle -&gt; install，等待安装成功;
    5. 启动Web工程的 tomcat7:run，运行项目;
</code></pre><h2 id="私服"><a href="#私服" class="headerlink" title="私服"></a>私服</h2><h3 id="搭建私服-windows"><a href="#搭建私服-windows" class="headerlink" title="搭建私服(windows)"></a>搭建私服(windows)</h3><pre><code>1. 使用专门的Maven仓库管理软件来搭建私服，比如：Apache Archiva，Artifactory，Sonatype Nexus
2. 选择Sonatype Nexus，下载开源版的Nexus压缩包，解压后有两个目录：应用程序目录，私服仓库目录(sonatype-work);
3. 以管理员模式启动cmd窗口，进入应用程序目录，执行bin目录下的 nexus.bat 命令;
    1. 安装、卸载、运行：nexus.bat install，nexus.bat uninstall，nexus.bat start
    2. 查看启动后的服务：右击计算机 -&gt; 管理 -&gt; 服务和应用程序 -&gt; 服务，在列表中查找 nexus;
4. nuxus的全局配置文件：conf/nexus.properties，默认使用的端口号是8081;
5. 启动图形化界面时，确保8081端口未被占用：http://localhost:8081/nexus
    1. 默认用户名和密码：admin，admin123
    2. 左侧导航栏：点击Repositories --&gt; 浏览仓库，查看仓库信息、地址;
    3. Add添加仓库，选择仓库类型：Hosted、Proxy、Virtual，还可以创建仓库组;
6. 创建不同的仓库，管理不同的依赖包
    1. 存放测试包的仓库Snapshots(hosted)，发布包的仓库Releases(hosted);
    2. 第三方包的仓库3rd party(hosted)，中央仓库的代理仓库Central(proxy);
    3. 创建仓库组，把已有的仓库按顺序添加到组中，在本地仓库在私服中查找依赖包时，就能按照仓库的顺序查找，
    最后由代理仓库转到中央仓库中去查找;
</code></pre><h3 id="发布私服"><a href="#发布私服" class="headerlink" title="发布私服"></a>发布私服</h3><pre><code>1. Maven的 settings.xml，配置私服仓库的信息
    &lt;servers&gt;
        &lt;server&gt;
            &lt;id&gt;releases&lt;/id&gt;  ===&gt;指定私服仓库的ID
            &lt;username&gt;admin&lt;/username&gt;  ===&gt;私服的用户名密码
            &lt;password&gt;admin123&lt;/password&gt;
        &lt;/server&gt;
        &lt;server&gt;
            &lt;id&gt;snapshots&lt;/id&gt;  ===&gt;指定私服仓库的ID
            &lt;username&gt;admin&lt;/username&gt;
            &lt;password&gt;admin123&lt;/password&gt;
        &lt;/server&gt;
    &lt;/servers&gt;
2. 要发布哪个项目/模块，就配置它的 pom.xml
    &lt;distributionManagement&gt;
        &lt;!-- 配置发布的仓库ID和地址 --&gt;
        &lt;repository&gt;  ===&gt;正式版的配置，明确发布到存放正式包的仓库
            &lt;id&gt;releases&lt;/id&gt;  ===&gt;此ID必须在 settings.xml 中已经配置过了
            &lt;url&gt;http://localhost:8081/nexus/content/repositories/releases/&lt;/url&gt;
        &lt;/repository&gt;
        &lt;snapshotRepository&gt;
            &lt;id&gt;snapshots&lt;/id&gt;  ===&gt;测试版的配置，明确发布到存放测试包的仓库
            &lt;url&gt;http://localhost:8081/nexus/content/repositories/snapshots/&lt;/url&gt;
        &lt;/snapshotRepository&gt;
    &lt;/distributionManagement&gt;
    1. 执行Lifecycle --&gt; deploy
    2. 执行前面的生命周期时，其后面的生命周期也会执行，所以 install 命令的执行，会把项目/模块安装到本地仓库;
</code></pre><h3 id="从私服下载jar"><a href="#从私服下载jar" class="headerlink" title="从私服下载jar"></a>从私服下载jar</h3><pre><code>Maven的 settings.xml
    &lt;profiles&gt;
        &lt;profile&gt; 
            &lt;id&gt;dev&lt;/id&gt;  ===&gt;profile的id
            &lt;repositories&gt;
                &lt;repository&gt;  ==&gt;仓库id，repositories可以配置多个仓库，保证id不重复
                    &lt;id&gt;nexus&lt;/id&gt;  ==&gt;仓库地址，即nexus仓库组的地址
                    &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt;
                    &lt;releases&gt;
                        &lt;enabled&gt;true&lt;/enabled&gt; ==&gt;是否下载releases构件
                    &lt;/releases&gt;
                    &lt;snapshots&gt;
                        &lt;enabled&gt;true&lt;/enabled&gt;  ==&gt;是否下载snapshots构件
                    &lt;/snapshots&gt;
                &lt;/repository&gt;
            &lt;/repositories&gt;
            &lt;pluginRepositories&gt;  ==&gt;插件仓库，Maven的运行依赖插件，也需要从私服下载插件
                &lt;pluginRepository&gt; ==&gt;插件仓库的id不允许重复，否则后者会覆盖前者
                    &lt;id&gt;public&lt;/id&gt;  ==&gt;配置为仓库组，仓库组的id
                    &lt;name&gt;Public Repositories&lt;/name&gt;  ==&gt;仓库组的名字
                    &lt;url&gt;http://localhost:8081/nexus/content/groups/public/&lt;/url&gt;  ==&gt;仓库组的地址
                &lt;/pluginRepository&gt;
            &lt;/pluginRepositories&gt;
        &lt;/profile&gt;
    &lt;/profiles&gt;
    &lt;activeProfiles&gt;
        &lt;activeProfile&gt;dev&lt;/activeProfile&gt;  ==&gt;激活id=dev的profile
    &lt;/activeProfiles&gt;
</code></pre><h3 id="按照第三方jar包"><a href="#按照第三方jar包" class="headerlink" title="按照第三方jar包"></a>按照第三方jar包</h3><pre><code>1. 把第三方jar包安装到本地仓库，如fastjson.jar
    1. 查看fastjson.jar的坐标：groupId、artifactId、version;
    2. 进入fastjson.jar所在的目录，执行命令:
    mvn install:install-file -DgroupId=com.alibaba -DartifactId=fastjson -Dversion=1.1.37 
    -Dfile=fastjson-1.1.37.jar -Dpackaging=jar
    3. 如果不在fastjson.jar的目录，则需要指定绝对路径： -Dfile=D:\download\fastjson-1.1.37.jar
2. 把第三方jar包安装到私服
    1. 在Maven的 settings.xml 中，添加存放第三方jar包的仓库信息
        &lt;server&gt;
            &lt;id&gt;thirdparty&lt;/id&gt;
            &lt;username&gt;admin&lt;/username&gt;
            &lt;password&gt;admin123&lt;/password&gt;
        &lt;/server&gt;
    2. 进入jar所在目录
        mvn deploy:deploy-file -DgroupId=com.alibaba -DartifactId=fastjson -Dversion=1.1.37 
        -Dfile=fastjson-1.1.37.jar -Dpackaging=jar  -DrepositoryId=thirdparty 
        -Durl=http://localhost:8081/nexus/content/repositories/thirdparty/
        1. -Durl：私服的仓库地址;
        2. -DrepositoryId：私服的仓库ID;
    3. 如果不在jar包所在目录，-Dfile=jar包的绝对路径;
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/03/25/SSM整合/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/25/SSM整合/" itemprop="url">SSM整合</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-25T00:00:00+08:00">
                2016-03-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><pre><code>1. 表现层SpringMVC，业务层Spring，持久层MyBatis，整合方向就是用Spring框架去整合另外两个框架;
2. 使用Maven的Web骨架，创建一个Web项目;
3. pom.xml
    1. 配置JDK的运行编译版本，以及jar包的版本锁定
        &lt;properties&gt;
            &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
            &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
            &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
            &lt;spring.version&gt;5.1.6.RELEASE&lt;/spring.version&gt;
        &lt;/properties&gt;
    2. 配置Tomcat7插件
        &lt;build&gt;
            &lt;plugins&gt;
                &lt;plugin&gt;
                    &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;
                    &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;
                    &lt;version&gt;2.2&lt;/version&gt;
                &lt;/plugin&gt;
            &lt;/plugins&gt;
        &lt;/build&gt;
4. 相关依赖
    1. aspectjweaver、spring-aop、spring-context、spring-context-support、spring-web
    2. spring-orm、spring-beans、spring-core、spring-webmvc、spring-tx、spring-test(test)
    3. junit(test)、mysql-connector-jave、servlet-api(provided)、jsp-api(provided)、jstl
    4. log4j、slf4j-api、slf4j-log4j12、jackson-databind、jackson-core、jackson-annotations
    5. mybatis、mybatis-spring、c3p0(type:jar，scope:compile)、druid(两套连接池，根据需要选择)
    6. spring-security-web、spring-security-config、spring-security-core、spring-security-taglibs
5. 基本结构
    1. 实体类：cn.ssm.domain.User
        public class User implements Serializable {
            private Integer id;
            private String name;
            private Double money;
            ...... //setter、getter
        }
    2. Dao层：cn.ssm.dao.IUserDao
        public interface IUserDao {
            List&lt;User&gt; findAll();
            User findById(Integer id);
        }
    3. Service层：
        cn.ssm.service.IUserService
        cn.ssm.service.impl.UserServiceImpl
    4. Controller层：cn.ssm.controller.UserController
6. 配置文件(resources目录)
    1. Spring：applicationContext.xml
    2. SpringMVC：springmvc.xml
    3. 数据库配置信息：db.properties
        jdbc.driver=com.mysql.cj.jdbc.Driver
        jdbc.url=jdbc:mysql:///db_mybatis?serverTimezone=Asia/Shanghai
        jdbc.username=root
        jdbc.password=123456
</code></pre><h2 id="Spring整合MyBatis"><a href="#Spring整合MyBatis" class="headerlink" title="Spring整合MyBatis"></a>Spring整合MyBatis</h2><pre><code>1. 借助 mybatis-spring 包中的对象，把Mybatis的相关配置转移到Spring的配置文件中;
    1. SqlSessionFactoryBean: SqlSessionFactory的工厂对象;
        1. dataSource属性: 配置连接池;
        2. typeAliasesPackage属性: 扫描实体类(POJO)的所在包，为POJO配置别名;
    2. MapperScannerConfigurer: 扫描Dao层的包，为所有Dao接口提供代理对象;
2. Spring的配置文件：applicationContext.xml
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
        xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;
            http://www.springframework.org/schema/beans
            https://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context
            https://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/tx
            https://www.springframework.org/schema/tx/spring-tx.xsd
            http://www.springframework.org/schema/aop
            https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
        &lt;!-- Dao层使用映射配置文件的方式，那么只扫描service包 --&gt;
        &lt;context:component-scan base-package=&quot;cn.ssm.service&quot; /&gt;
        &lt;!-- SqlSessionFactory的工厂对象 --&gt;
        &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
            &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
            &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;cn.ssm.domain&quot; /&gt;
        &lt;/bean&gt;
        &lt;!-- 为所有Dao接口提供代理对象 --&gt;
        &lt;bean id=&quot;mapperScanner&quot; class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;
            &lt;property name=&quot;basePackage&quot; value=&quot;cn.ssm.dao&quot; /&gt;
        &lt;/bean&gt;
        &lt;!-- 事务管理器 --&gt;
        &lt;bean id=&quot;manager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
            &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
        &lt;/bean&gt;
        &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;manager&quot;&gt;
            &lt;tx:attributes&gt;
                &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot;/&gt;
                &lt;tx:method name=&quot;*&quot; isolation=&quot;DEFAULT&quot; /&gt;
            &lt;/tx:attributes&gt;
        &lt;/tx:advice&gt;
        &lt;aop:config&gt;
            &lt;!--切入点表达式--&gt;
            &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut=&quot;execution(* cn.ssm.service.impl.*.*(..))&quot; /&gt;
        &lt;/aop:config&gt;
        &lt;!-- c3p0连接池：引入数据库配置信息的文件db.properties --&gt;
        &lt;context:property-placeholder location=&quot;classpath:db.properties&quot; /&gt;
        &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;
            &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot; /&gt;
            &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot; /&gt;
            &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot; /&gt;
            &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;
        &lt;/bean&gt;
    &lt;/beans&gt;
3. Dao的映射配置文件
    1. 文件路径和名称与Dao接口保持一致，如cn.ssm.dao.IUserDao -&gt; resources/cn/ssm/dao/IUserDao.xml;
    2. IUserDao.xml
        &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
        &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
                &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
        &lt;mapper namespace=&quot;cn.ssm.dao.IUserDao&quot;&gt;
            &lt;select id=&quot;findAll&quot; resultType=&quot;user&quot;&gt;
                select * from users
            &lt;/select&gt;
            &lt;select id=&quot;findById&quot; parameterType=&quot;int&quot; resultType=&quot;user&quot;&gt;
                select * from users where id=#{id}
            &lt;/select&gt;
        &lt;/mapper&gt;
4. Dao层使用注解开发
    1. Spring配置文件中，配置注解扫描包(扫描service包和dao包)，有两种方式
        1. 直接配置要扫描的包
        &lt;context:component-scan base-package=&quot;cn.ssm.dao&quot; /&gt;
        &lt;context:component-scan base-package=&quot;cn.ssm.service&quot; /&gt;
        2. 扫描指定包下的注解时，忽略 @Controller 注解
    &lt;context:component-scan base-package=&quot;cn.ssm&quot;&gt;
        &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;
    &lt;/context:component-scan&gt;
    2. SQL语句的注解
        public interface IUserDao {
            @Select(&quot;select * from users&quot;)
            List&lt;User&gt; findAll();

            @Select(&quot;select * from users where id=#{id}&quot;)
            User findById(Integer id);
        }
5. Service层使用注解开发，注入Dao对象
    @Service(&quot;userService&quot;)
    public class UserServiceImpl implements IUserService {
        @Autowired
        private IUserDao dao;

        public List&lt;User&gt; findAll() {
            return dao.findAll();
        }
    }
6. 测试
    @RunWith(SpringJUnit4ClassRunner.class)
    @ContextConfiguration(locations=&quot;classpath:applicationContext.xml&quot;)
    public class TestService {
        @Autowired
        private IUserService service;

        @Test
        public void testFindAll() {
            List&lt;User&gt; users = service.findAll();
        }
    }
</code></pre><h2 id="Spring整合SpringMVC"><a href="#Spring整合SpringMVC" class="headerlink" title="Spring整合SpringMVC"></a>Spring整合SpringMVC</h2><pre><code>1. SpringMVC的配置文件：resources/springmvc.xml
    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;
            http://www.springframework.org/schema/beans
            https://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/mvc
            https://www.springframework.org/schema/mvc/spring-mvc.xsd
            http://www.springframework.org/schema/context
            https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
        &lt;!-- 开启注解扫描，只扫描controller包 --&gt;
        &lt;context:component-scan base-package=&quot;cn.ssm.controller&quot; /&gt;
        &lt;!--视图解析器--&gt;
        &lt;bean id=&quot;internalResourceViewResolver&quot; 
                class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
            &lt;property name=&quot;prefix&quot; value=&quot;/pages/&quot; /&gt;
            &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
        &lt;/bean&gt;
        &lt;!--处理静态资源--&gt;
        &lt;mvc:default-servlet-handler /&gt;
        &lt;!-- 开启SpringMVC的注解支持，并注册处理器映射器和处理器适配器 --&gt;
        &lt;mvc:annotation-driven /&gt;
    &lt;/beans&gt;
2. 开启注解扫描的两种方式
    1. 直接配置要扫描的包;
    2. 配置扫描的注解类型，只去扫描 @Controller 注解;
    &lt;context:component-scan base-package=&quot;cn.ssm&quot;&gt;
        &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;
    &lt;/context:component-scan&gt;
3. 在 webapp 目录中，分别创建存放JSP页面的 pages 目录，存放静态资源的 css、images、js 目录;
4. web.xml
    &lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee
            http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;
        version=&quot;3.0&quot;&gt;
        &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt;
        &lt;!--配置Spring的核心监听器，重新指定Spring配置文件的路径，加载Spring的配置文件--&gt;
        &lt;listener&gt;
            &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
        &lt;/listener&gt;
        &lt;context-param&gt;
            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
            &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;
        &lt;/context-param&gt;
        &lt;!--编码过滤器，解决中文乱码--&gt;
        &lt;filter&gt;
            &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
            &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
            &lt;init-param&gt;
                &lt;param-name&gt;encoding&lt;/param-name&gt;
                &lt;param-value&gt;UTF-8&lt;/param-value&gt;
            &lt;/init-param&gt;
        &lt;/filter&gt;
        &lt;filter-mapping&gt;
            &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
            &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
        &lt;/filter-mapping&gt;
        &lt;!--前端控制器：SpringMVC的核心Servlet，在服务器启动时就创建并初始化，加载SpringMVC的配置文件--&gt;
        &lt;servlet&gt;
            &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
            &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
            &lt;init-param&gt;
                &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
                &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;
            &lt;/init-param&gt;
            &lt;!-- 在服务器启动时，就创建并初始化核心Servlet --&gt;
            &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
        &lt;/servlet&gt;
        &lt;servlet-mapping&gt;
            &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
            &lt;url-pattern&gt;/&lt;/url-pattern&gt;
        &lt;/servlet-mapping&gt;
    &lt;/web-app&gt;
5. Controller层
    @Controller
    @RequestMapping(&quot;/hello&quot;)
    public class HelloController {
        @Autowired
        private IUserService service;  //注入Service对象

        @RequestMapping(&quot;/test&quot;)
        @ResponseBody
        public String testHello() {
            List&lt;User&gt; users = service.findUserAll();
            return users;
        }
    }
6. 运行项目
    1. 右侧Maven面板 --&gt; 展开项目/Plugins/tomcat7 --&gt; 双击 tomcat7:run 运行项目;
    2. 配置本地的Tomcat，添加项目，启动Tomcat;
7. 如果使用了log4j，还需要把 log4j.properties 放在 resources 目录中
    # Set root category priority to INFO and its only appender to CONSOLE.
    #log4j.rootCategory=INFO, CONSOLE            debug   info   warn error fatal
    log4j.rootCategory=debug, CONSOLE, LOGFILE
    # Set the enterprise logger category to FATAL and its only appender to CONSOLE.
    log4j.logger.org.apache.axis.enterprise=FATAL, CONSOLE
    # CONSOLE is set to be a ConsoleAppender using a PatternLayout.
    log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender
    log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout
    log4j.appender.CONSOLE.layout.ConversionPattern=%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\n
    # LOGFILE is set to be a File appender using a PatternLayout.
    log4j.appender.LOGFILE=org.apache.log4j.FileAppender
    log4j.appender.LOGFILE.File=d:\axis.log
    log4j.appender.LOGFILE.Append=true
    log4j.appender.LOGFILE.layout=org.apache.log4j.PatternLayout
    log4j.appender.LOGFILE.layout.ConversionPattern=%d{ISO8601} %-6r [%15.15t] %-5p %30.30c %x - %m\n
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/03/16/SpringMVC进阶/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/16/SpringMVC进阶/" itemprop="url">SpringMVC进阶</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-16T00:00:00+08:00">
                2016-03-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="控制器方法的返回值"><a href="#控制器方法的返回值" class="headerlink" title="控制器方法的返回值"></a>控制器方法的返回值</h2><pre><code>1. resources/springmvc.xml：配置的视图解析器
    &lt;bean id=&quot;internalResourceViewResolver&quot; 
        class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/pages/&quot; /&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;
2. String
    @RequestMapping(&quot;/test&quot;)
    public String testStr(Model model) {
        User user = new User();  user.setName(&quot;JavaEE&quot;);  user.setAge(20);
        model.addAttribute(&quot;user&quot;, user);
        return &quot;test&quot;;
    }
    1. 返回的字符串默认作为逻辑视图名，通过视图解析器解析为物理视图的真实地址;
    2. 物理视图的真实地址：webapp/pages/test.jsp，渲染页面并响应给客户端;
    3. Model默认把数据存入Request域中，在 test.jsp 中获取这些数据;
        &lt;div&gt;${user.name}&lt;/div&gt; &lt;div&gt;${user.age}&lt;/div&gt;
3. void
    1. 控制器方法没有返回值时，默认以URL的最后一级作为视图名去查找JSP文件;
    2. 使用Servlet API手动转发/重定向时，SpringMVC的视图解析器不会再介入，所以要声明完整的路径名;
    @RequestMapping(path=&quot;/hello&quot;)
    public void test(HttpServletRequest req, HttpServletResponse res) {
        //手动转发到test.jsp
        req.getRequestDispatcher(&quot;/pages/test.jsp&quot;).forward(req, res);
        //手动重定向到index.jsp
        req.sendRedirect(req.getContextPath() + &quot;/index.jsp&quot;);
    }
4. 响应流数据
    @RequestMapping(path=&quot;/hello&quot;)
    public void test(HttpServletRequest req, HttpServletResponse res) {
        res.setCharacterEncoding(&quot;UTF-8&quot;);
        res.setContentType(&quot;text/html;charset=UTF-8&quot;);
        res.getWriter().print(&quot;你好，Java&quot;);
    }
5. ModelAndView
    1. SpringMVC提供的对象，用于封装Model和视图名;
        @RequestMapping(path=&quot;/hello&quot;)
        public ModelAndView test() {
            ModelAndView mv = new ModelAndView();
            User user = new User();  user.setName(&quot;JavaEE&quot;);  user.setAge(20);
            mv.addObject(&quot;user&quot;, user);  //存入数据
            mv.setViewName(&quot;test&quot;);  //指定视图名
            return mv;
        }
    2. 控制器方法返回字符串时，底层其实也是用 ModelAndView 进行封装.
6. 请求转发和重定向的关键字
    1. 控制器方法在返回字符串时，默认使用的就是请求转发;
    2. 转发的关键字：forward;  重定向的关键字：redirect;
        @RequestMapping(path=&quot;/hello&quot;)
        public String test() {
            return &quot;forward:/pages/test.jsp&quot;;  //转发到test.jsp
            return &quot;redirect:/index.jsp&quot;;  //重定向到index.jsp
        }
</code></pre><h3 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h3><pre><code>1. 控制器方法的返回值默认会解析为跳转路径，注解@ResponseBody的返回值不会再交给视图解析器，而是被直接写入响应体中;
    @RequestMapping(&quot;/test&quot;)
    @ResponseBody
    public String test() {
        return &quot;Hello SpringBoot&quot;;  //返回的字符串直接响应给客户端
    }
2. 控制器方法返回对象时，通过 HttpMessageConverter(消息转换器) 接口转为指定格式的数据，如JSON、XML;
3. SpringMVC默认使用MappingJacksonHttpMessageConverter对JSON数据进行转换;
4. 引入转换格式的依赖包jackson
    jackson-databind、jackson-core、jackson-annotations
5. 在JSP页面发送一个AJAX请求，参数为JSON格式
    public class User {
        private String username;  private String password;
        ......//setter、getter
    }
    $.ajax({
        url: &quot;user/getList&quot;,
        type: &quot;post&quot;,
        dataType: &quot;json&quot;,
        data: &apos;{&quot;username&quot;: &quot;Jack&quot;, &quot;password&quot;: &quot;123&quot;}&apos;,
        success: data=&gt;{ ... }
    });
    @RequestMapping(path=&quot;/getList&quot;)
    public @ResponseBody User test(@RequestBody User user) {
        String username = user.getUsername();
        String password = user.getPassword();
        ... //操作数据库
        User u = new User();
        ......  //封装一个新的User对象并返回
        return u;
    }
    1. @RequestBody：获取请求体的内容，SpringMVC会把JSON格式的请求体封装到User对象中;
    2. @ResponseBody：将返回的对象交给消息转换器，直接写入响应体中，响应给客户端.
</code></pre><h2 id="静态资源的处理"><a href="#静态资源的处理" class="headerlink" title="静态资源的处理"></a>静态资源的处理</h2><pre><code>1. 访问静态资源时，不需要经过前端控制器和过滤器，直接响应即可;
2. 使用Servlet来处理静态资源：web.xml 中配置名称为 default 的&lt;servlet&gt;标签;
    1. 处理 webapp/css 目录中的静态资源：以 /css/ 开头的URL;
        &lt;servlet-mapping&gt;
            &lt;servlet-name&gt;default&lt;/servlet-name&gt;
            &lt;url-pattern&gt;/css/*&lt;/url-pattern&gt;
        &lt;/servlet-mapping&gt;
    2. 处理后缀名为 .css、.js 的静态资源;
        &lt;servlet-mapping&gt;
            &lt;servlet-name&gt;default&lt;/servlet-name&gt;
            &lt;url-pattern&gt;*.css&lt;/url-pattern&gt;
        &lt;/servlet-mapping&gt;
        &lt;servlet-mapping&gt;
            &lt;servlet-name&gt;default&lt;/servlet-name&gt;
            &lt;url-pattern&gt;*.js&lt;/url-pattern&gt;
        &lt;/servlet-mapping&gt;
3. 在SpringMVC的配置文件springmvc.xml 中，使用 &lt;mvc:resources&gt; 标签配置静态资源的访问;
    &lt;mvc:annotation-driven /&gt;
    &lt;mvc:resources location=&quot;/css/&quot; mapping=&quot;/css/**&quot; /&gt;
    &lt;mvc:resources location=&quot;/images/&quot; mapping=&quot;/images/**&quot; /&gt;
    &lt;mvc:resources location=&quot;/js/&quot; mapping=&quot;/js/**&quot; /&gt;
    1. location属性：指定目录文件的路径，如 /css/ 表示 webapp/css 目录;
    2. mapping属性：匹配的请求路径，如 /css/** 表示匹配以 /css 开头的所有URL;
4. 更简便的配置方式
    &lt;mvc:default-servlet-handler /&gt;
    1. 它会在SpringMVC上下文中定义一个DefaultServletHttpRequestHandler，筛选URL;
    2. 如果发现静态资源，则交给名称为 default 的Servlet;
</code></pre><h3 id="SpringMVC的路径匹配模式"><a href="#SpringMVC的路径匹配模式" class="headerlink" title="SpringMVC的路径匹配模式"></a>SpringMVC的路径匹配模式</h3><pre><code>1. Spring MVC中的路径匹配模式，使用的是Apache Ant的样式路径，有三种通配符：?、*、**
    1. /*：拦截所有目录，不包含子目录;
    2. /**：拦截所有目录及其子目录.
2. ?：匹配任何单字符;
    1. /user/a?bc：能够匹配/user/axbc、/user/aXbc，但不包括/user/abc;
3. *：匹配 n&gt;=0 个字符，只能匹配一级目录，不能匹配子目录;
    1. /user/*：匹配 /user/、 /user/abc，但不能匹配 /user/abc/123;
    2. /app/*.jsp：匹配app目录下的所有 .jsp 文件.
4. **：匹配 n&gt;=0 个目录;
    1. /user/**：匹配以 /user 开头的所有URL;
    2. /**/example：匹配 /example、 /app/example、 /app/foo/example...
    3. /app/**/dir/file.：匹配 /app/dir/file.jsp、 /app/foo/dir/file.html ...
5. /**/*.jsp：匹配任何目录下的所有 .jsp 文件;
6. 所以，以 mvc 为命名空间的标签，在设置路径时，都遵循此路径匹配模式.
</code></pre><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><pre><code>1. 必要前提
    1. form表单的 enctype(表单请求正文的类型) 属性值为 multipart/form-data;
    2. method 必须是 POST;
    3. 提供一个文件选择域：&lt;input type=&quot;file&quot; /&gt;
2. 文件上传的依赖包：commons-fileupload、commons-io
    &lt;form action=&quot;user/fileupload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
        &lt;input type=&quot;file&quot; name=&quot;upload&quot; /&gt;
        &lt;input type=&quot;submit&quot; value=&quot;上传&quot; /&gt;
    &lt;/form&gt;
3. 传统上传方式
    @RequestMapping(path=&quot;/fileupload&quot;)
    public String uploadFile(HttpServletRequest req) {
        //获取上传目录的绝对路径
        String path = req.getSession().getServletContext().getRealPath(&quot;/uploads/&quot;);
        File file = new File(path);
        if(!file.exists()) {
            file.mkdirs();  //目录不存在则创建
        }
        DiskFileItemFactory factory = new DiskFileItemFactory();
        ServletFileUpload upload = new ServletFileUpload(factory);
        List&lt;FileItem&gt; items = upload.parseRequest(req);  //解析request
        for(FileItem item: items) {
            if(item.isFormField()) {
                //item只是一个普通的表单项
            } else {
                //item是一个上传文件项
                String filename = item.getName();  //获取文件名
                String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);
                filename = uuid + &quot;_&quot; + filename;  //不重复的文件名
                item.write(new File(path, filename));  //完成文件上传
                item.delete();  //删除生成的临时文件
            }
        }
        return &quot;success&quot;;
    }
</code></pre><h3 id="SpringMVC处理文件上传"><a href="#SpringMVC处理文件上传" class="headerlink" title="SpringMVC处理文件上传"></a>SpringMVC处理文件上传</h3><pre><code>1. 前端控制器接收到文件上传的请求时，会调用文件解析器，由文件解析器处理此请求;
2. 文件解析器会将处理结果封装到MultipartFile对象中，并将返回给前端控制器;
3. 前端控制器将上传文件对象MultipartFile，再传给对应的控制器方法;
4. 在配置文件 springmvc.xml 中配置文件解析器，其id值是固定的：multipartResolver
    &lt;bean id=&quot;multipartResolver&quot; 
        class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
        &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot; /&gt;  ==&gt;最大上传文件
    &lt;/bean&gt;
5. 上传标签的name属性值为upload，方法参数MultipartFile的变量名也必须为upload;
    @RequestMapping(path=&quot;/fileupload&quot;)
    public String uploadFile(HttpServletRequest req, MultipartFile upload) {
        //获取其他参数
        String xxx = req.getParameter(&quot;xxx&quot;);

        //获取上传目录的绝对路径
        String path = req.getSession().getServletContext().getRealPath(&quot;/uploads/&quot;);
        File file = new File(path);
        if(!file.exists()) {
            file.mkdirs();  //目录不存在则创建
        }
        String filename = upload.getOriginalFilename();  //获取文件名
        String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);
        filename = uuid + &quot;_&quot; + filename;  //不重复的文件名
        upload.transferTo(new File(path, filename));  //完成文件上传
        return &quot;success&quot;;
    }
</code></pre><h3 id="跨服务器的文件上传"><a href="#跨服务器的文件上传" class="headerlink" title="跨服务器的文件上传"></a>跨服务器的文件上传</h3><pre><code>1. 实际开发中，可能会有很多负责不同功能的服务器
    1. 应用服务器：负责部署处理业务的应用;
    2. 数据库服务器：数据持久化;
    3. 缓存和消息服务器：负责处理高并发访问的缓存和消息;
    4. 文件服务器：负责存储用户上传的文件;
2. 注意：这并不是服务器集群;
3. 实现跨服务器的依赖：jersey-core、jersey-client
    @RequestMapping(path=&quot;/fileupload&quot;)
    public String uploadFile(MultipartFile upload) {
        String filename = upload.getOriginalFilename();  //获取文件名
        String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);
        filename = uuid + &quot;_&quot; + filename;  //不重复的文件名
        //文件服务器的上传URL，一定有uploads目录
        String fileServer = &quot;http://localhost:9090/uploads/&quot;;
        //创建客户端对象
        Client client = Client.create();
        //与文件服务器建立连接
        WebResource web = client.resource(fileServer + filename);
        //上传文件
        web.put(upload.getBytes());
        return &quot;success&quot;;
    }
</code></pre><h2 id="异常处理器"><a href="#异常处理器" class="headerlink" title="异常处理器"></a>异常处理器</h2><pre><code>1. 控制器方法在处理业务发生异常时，会向上抛出，最终由前端控制器查找异常处理器，如果没有则抛给浏览器;
2. 使用异常处理器的目的是，当发生异常时，由异常处理器响应给用户一个友好页面；
3. 自定义异常类
    public class SysException extends Exception {
        private String message;  //存储提示信息
        //getter、setter
        public SysException(String message) {
            this.message = message;
        }
    }
4. 抛出异常
    @RequestMapping(path=&quot;/except&quot;)
    public String test() throws SysException {
        try {
            int i = 10/0;  //发生异常
        } catch(Exception e) {
            throw new SysException(&quot;保存用户失败！&quot;);
        }
        return &quot;success&quot;;
    }
5. 异常处理器：实现接口HandlerExceptionResolver
    public class SysExceptionResolver implements HandlerExceptionResolver {
        public ModelAndView resolveException(HttpServletRequest req, 
                HttpServletResponse res, Object handler, Exception ex) {
            SysException e = null;
            if(ex instanceof SysException) {
                e = (SysException) ex;
            } else {
                e = new SysException(&quot;不好意思，系统维护中~&quot;);
            }
            ModelAndView mv = new ModelAndView();
            mv.addObject(&quot;errorMsg&quot;, e.getMessage());  //向Request域存入提示信息
            mv.setViewName(&quot;error&quot;);  //跳转到自定义的错误页error.jsp
            return mv;
        }
    }
6. 在配置文件 springmvc.xml 中，配置异常处理器
    &lt;bean id=&quot;sysExceptionResolver&quot; class=&quot;cn.test.exception.SysExceptionResolver&quot;&gt;&lt;/bean&gt;
</code></pre><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><pre><code>1. SpringMVC的处理器拦截器类似于Servlet中的过滤器，用于对处理器进行预处理和后处理;
    1. 预处理和后处理类似于Koa的洋葱图；
    2. 请求到达 --&gt; 执行拦截器放行前的代码(预处理) --&gt; 放行到控制器方法 --&gt; 
    执行拦截器放行后的代码 --&gt; 响应结果
2. 拦截器链：将拦截器按照一定的顺序连接成一条链，在访问被拦截的方法/属性时，拦截器就会按顺序被调用;
3. 过滤器与拦截器
    1. 过滤器是Servlet规范中的一部分，拦截器是SpringMVC框架提供的；
    2. 过滤器在 url-pattern 中配置了 /* 之后，可以拦截所有要访问的资源；
    3. 拦截器只会拦截访问的控制器方法，如果是JSP、HTML、CSS、image、JS资源，是不会被拦截的。
4. 拦截器也是AOP思想的具体应用，自定义拦截器必须实现接口HandlerInterceptor
5. JDK1.8对接口做了增强，方法可以不是抽象的，所以在实现HandlerInterceptor时，并不强制实现此接口方法;
    public class MyInterceptor implements HandlerInterceptor {
        // preHandle()、postHandle()、afterCompletion()
    }
6. 在配置文件 springmvc.xml 中，配置拦截器：&lt;mvc:interceptors&gt;
    &lt;mvc:interceptors&gt;
        &lt;mvc:interceptor&gt;
            &lt;mvc:mapping path=&quot;/user/*&quot; /&gt;
            &lt;!-- &lt;mvc:exclude-mapping path=&quot;&quot;&gt; --&gt;
            &lt;bean class=&quot;cn.test.interceptor.MyInterceptor&quot; /&gt;
        &lt;/mvc:interceptor&gt;
    &lt;/mvc:interceptors&gt;
    1. 每一组 &lt;mvc:interceptor&gt; 标签，表示一个拦截器，标签的顺序决定了拦截器的调用顺序;
    2. &lt;mvc:mapping&gt;：配置拦截的控制器方法;
    3. &lt;mvc:exclude-mapping&gt;：配置不拦截的控制器方法;
    4. path 属性：指定URL，也就是控制器方法.
</code></pre><h3 id="拦截器方法"><a href="#拦截器方法" class="headerlink" title="拦截器方法"></a>拦截器方法</h3><pre><code>1. preHandle()：预处理方法
    public boolean preHandle(HttpServletRequest req, HttpServletResponse res, 
        Object handler) {
        return true;
    }
    1. 在控制器方法执行之前执行，返回true表示放行，执行下一个拦截器，如果没有了，则执行控制器方法;
    2. 返回false表示不放行，可以使用req对象和res对象自行处理请求与响应.
    public boolean preHandle(HttpServletRequest req, HttpServletResponse res, 
        Object handler) {
        req.getRequestDispatcher(&quot;/pages/error.jsp&quot;).forward(req, res); //转发到error.jsp
        return false;  //不放行
    }
2. postHandle()：后处理方法
    @RequestMapping(path=&quot;/test&quot;)
    public String test() {
        ....
        return &quot;success&quot;;
    }
    public void postHandle(HttpServletRequest req, HttpServletResponse res, 
        Object handler， ModelAndView mv) {
    }
    1. 在控制器方法执行完之后，执行success.jsp之前，执行postHandle();
    public void postHandle(HttpServletRequest req, HttpServletResponse res, 
        Object handler, ModelAndView mv) {
        req.getRequestDispatcher(&quot;/pages/error.jsp&quot;).forward(req, res);
    }
    2. 虽然postHandle()自行请求转发给error.jsp，但控制器方法的 success.jsp 仍会执行，
    响应给浏览器也是 error.jsp.
3. afterCompletion()：控制器方法的 success.jsp 执行完之后，才会执行;
    public void afterCompletion(HttpServletRequest req, HttpServletResponse res, 
        Object handler， Exception ex) {
    }
4. 当配置了多组拦截器时(都放行)
    @Controller
    @RequestMapping(path = &quot;/user&quot;)
    public class HelloController {
        @RequestMapping(path=&quot;/test&quot;)
        public String test() {
            ....
            return &quot;success&quot;;
        }
    }
    &lt;mvc:interceptors&gt;
        &lt;mvc:interceptor&gt;
            &lt;mvc:mapping path=&quot;/user/*&quot; /&gt;
            &lt;bean class=&quot;cn.test.interceptor.MyInterceptor&quot; /&gt;
        &lt;/mvc:interceptor&gt;
        &lt;mvc:interceptor&gt;
            &lt;mvc:mapping path=&quot;/**&quot; /&gt;
            &lt;bean class=&quot;cn.test.interceptor.TestInterceptor&quot; /&gt;
        &lt;/mvc:interceptor&gt;
    &lt;/mvc:interceptors&gt;
    &lt;a href=&quot;user/test&quot;&gt;to test&lt;/a&gt;
1. 执行顺序：
    MyInterceptor.preHandle() --&gt; TestInterceptor.preHandle() --&gt; HelloController.test()
    --&gt; TestInterceptor.postHandle() --&gt; MyInterceptor.postHandle() --&gt; success.jsp --&gt; 
    TestInterceptor.afterCompletion() --&gt; MyInterceptor.afterCompletion()
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/03/15/SpringMVC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/15/SpringMVC/" itemprop="url">SpringMVC</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-15T00:00:00+08:00">
                2016-03-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h2><pre><code>1. 开发架构一般都是基于两种形式：C/S(客户端/服务器)、B/S(浏览器/服务器);
2. JavaEE开发几乎都是基于B/S架构，系统标准的三层架构：表现层、业务层、持久层;
3. 表现层：web层，负责接收客户端请求，响应结果;
    1. 表现层包括展示层(负责展示结果)和控制层(负责接收请求);
    2. 表现层依赖于业务层，用于对请求进行业务处理，并把结果响应给客户端;
    3. 表现层的设计一般都是用MVC模型，MVC属于表现层的设计模型，跟其他层没关系.
4. 业务层：service层，负责业务处理，持久化数据时会依赖于持久层;
5. 持久层：dao层，负责数据持久化;
</code></pre><h3 id="MVC模型"><a href="#MVC模型" class="headerlink" title="MVC模型"></a>MVC模型</h3><pre><code>1. MVC：模型(Model)-视图(View)-控制器(Controller)，一种用于设计创建Web应用表现层的模型;
2. Model：数据模型，如JavaBean;
3. View：展示数据，如JSP、HTML;
4. Controller：处理程序逻辑.
</code></pre><h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><pre><code>1. SpringMVC是一种基于Java的实现MVC设计模型的请求驱动类型的轻量级Web框架;
2. SpringMVC属于Spring Framework的后续产品，已经融合在Spring Web Flow中;
3. Spring框架提供了构建Web应用的全能MVC模块，可以选择使用SpringMVC或其他MVC框架，如Struts2;
    1. SpringMVC已成为最主流的MVC框架之一，Spring3.0开始就已经全面超越了Struts2;
    2. SpringMVC通过一套注解，让一个Java类称为处理请求的控制器，而无需实现任何接口;
    3. SpringMVC还支持RESTful编程风格的请求;
</code></pre><p><img src="//hellomyshadow.github.io/2016/03/15/SpringMVC/SSM.jpg" alt="SSM"></p>
<h2 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h2><pre><code>创建Web项目，搭建环境
1. 引入依赖：版本锁定，统一管理Spring的版本
    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; ==&gt;配置编译运行的JDK版本
        &lt;spring.version&gt;5.1.6.RELEASE&lt;/spring.version&gt;  ===&gt;锁定版本
    &lt;/properties&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-web&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
            &lt;version&gt;${spring.version}&lt;/version&gt;
        &lt;/dependency&gt;
        javax.servlet-api(provided)
        javax.servlet.jsp-api(provided)
    &lt;/dependencies&gt;
2. 配置文件resources/springmvc.xml，加入mvc和context约束
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xsi:schemaLocation=&quot;
            http://www.springframework.org/schema/beans
            https://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/mvc
            https://www.springframework.org/schema/mvc/spring-mvc.xsd
            http://www.springframework.org/schema/context
            https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
        &lt;!-- 开启扫描哪个包下的注解 --&gt;
        &lt;context:component-scan base-package=&quot;cn.test&quot;&gt;&lt;/context:component-scan&gt;
        &lt;!-- 视图解析器 --&gt;
        &lt;bean id=&quot;internalResourceViewResolver&quot; 
            class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
            &lt;property name=&quot;prefix&quot; value=&quot;/pages/&quot; /&gt;  ===&gt;文件所在目录，根目录是webapp
            &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;  ===&gt;文件的后缀名
        &lt;/bean&gt;
        &lt;!-- 开启SpringMVC的注解支持 --&gt;
        &lt;mvc:annotation-driven /&gt;
    &lt;/beans&gt;
3. webapp/WEB-INF/web.xml
    &lt;web-app&gt;
        &lt;servlet&gt;
            &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
            &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
            &lt;!-- 让控制器去加载spring配置文件 --&gt;
            &lt;init-param&gt;
                &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
                &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;
            &lt;/init-param&gt;
            &lt;!-- 控制器在接收第一次请求时才创建，所以要让它在服务器启动时创建，以加载配置文件 --&gt;
            &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
        &lt;/servlet&gt;
        &lt;servlet-mapping&gt;
            &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;
            &lt;url-pattern&gt;/&lt;/url-pattern&gt;
        &lt;/servlet-mapping&gt;
    &lt;/web-app&gt;
    1. &lt;init-param&gt;：配置当前对象创建时的初始化参数;
    2. &lt;load-on-startup&gt;：标记容器是否在启动时就加载当前的Servlet(创建并调用其init()方法);
    3. 一般情况下，Servlet在第一次收到请求时由服务器创建并初始化，&lt;load-on-startup&gt; 可以让它
    根据自己的需要改变加载的优先级;
    4. &lt;load-on-startup&gt;n&lt;/load-on-startup&gt;：n 必须是一个整数，表示Servlet应该被加载的顺序;
    5. 当 n&gt;=0 时，表示在容器(服务器)启动时就加载并初始化这个Servlet，值越小，优先级越高;
    6. 当 n 的值相同时，由容器自己选择优先加载哪个Servlet.
4. 创建控制类：cn.test.controller.HelloController，使用 @Controller 修饰
    @Controller
    public class HelloController {
        @RequestMapping(path=&quot;/hello&quot;)
        public String say() {
            System.out.println(&quot;Hello SpringMVC&quot;);
            return &quot;success&quot;;  ---&gt;控制器默认把返回值作为页面的名称，去查找success.jsp
        }
    }
5. 在 webapp/pages 目录下创建success.jsp
6. 在项目的默认首页 webapp/index.jsp 中配置一个跳转标签：&lt;a href=&quot;hello&quot;&gt;To Hello&lt;/a&gt;
7. 部署服务器Tomcat Server
</code></pre><h3 id="访问过程"><a href="#访问过程" class="headerlink" title="访问过程"></a>访问过程</h3><pre><code>1. 启动服务器时：创建DispatcherServlet对象 --&gt; 加载springmvc.xml --&gt; 创建HelloController对象
2. 点击&lt;a&gt;，发送请求
    /hello --&gt; DispatcherServlet --&gt; HelloController.say() --&gt; DispatcherServlet --&gt;
    InternalResourceViewResolver --&gt; success.jsp --&gt; DispatcherServlet --&gt; 响应结果
</code></pre><p><img src="//hellomyshadow.github.io/2016/03/15/SpringMVC/组件控制流程.jpg" alt="组件控制流程"></p>
<pre><code>    1. DispatcherServlet：前端控制器，MVC模式中的C，整个控制流程的中心，调用其他组件处理
    用户的请求，降低了组件之间的耦合性;
    2. HandlerMapping：处理器映射器，根据用户请求找到Handler(处理器)，SpringMVC提供了不同的
    映射器实现不同的映射方式，如配置配置文件方式、实现接口方式、注解方式...
    3. Handler：处理器，开发编写的具体业务控制器，对具体的用户请求进行处理，由DispatcherServlet
    把请求转发到Handler;
    4. HandlerAdapter：处理器适配器，适配器模式的应用，对处理器进行执行;
    5. View Resolver：视图解析器，将处理结果生成View视图，首先根据逻辑视图名解析成物理视图名，
    即具体的页面地址，再生成View视图对象，并对View进行渲染，将处理结果通过页面展示给用户;
    6. View：视图，SpringMVC提供了很多View视图类型的支持，如jstlView、freemarkerView、pdfView...
    最常见的视图就是JSP;
3. &lt;mvc:annotation-driven&gt;
    1. 在SpringMVC的各个组件中，处理器映射器、处理器适配器、视图解析器，称为Spring的三大组件;
    2. &lt;mvc:annotation-driven&gt; 会自动加载 RequestMappingHandlerMapping(处理映射器) 和
    RequestMappingHandlerAdapter(处理适配器)
4. @RequestMapping：用于建立请求URL和处理请求方法之间的对应关系;
    1. @RequestMapping 可以用在类上，定义路径的一级目录，在其方法上定义二级目录;
        @Controller
        @RequestMapping(path=&quot;/user&quot;)  ---&gt;一级目录
        public class HelloController {
            @RequestMapping(path=&quot;/hello&quot;)  ---&gt;二级目录
            public String say() { ... }
        }
        &lt;a href=&quot;user/hello&quot;&gt;To User Hello&lt;/a&gt;
    2. value、path属性：指定请求的URL;
    3. method属性：请求方式，如 method=RequestMethod.POST
    4. params属性：限制请求参数的条件，支持简单的表达式，要求请求参数的key-value必须服从于配置;
        1. params={&quot;username&quot;}，则请求参数中必须包含username;
        &lt;a href=&quot;user/hello?username=Java&quot;&gt;
        2. params={&quot;money=100&quot;}，则请求参数中的money必须是100.
        &lt;a href=&quot;user/hello?money=100&quot;&gt;
    5. headers属性：限制请求头的条件，如headers={&quot;Accept&quot;}，请求头中必须包含Accept;
</code></pre><h2 id="请求参数的绑定"><a href="#请求参数的绑定" class="headerlink" title="请求参数的绑定"></a>请求参数的绑定</h2><pre><code>1. 绑定机制
    1. 表单提交的参数都是 key-value 形式，如username=Java&amp;password=123;
        &lt;a href=&quot;hello?username=Java&amp;password=123&quot;&gt;to hello&lt;/a&gt;
        @RequestMapping(path=&quot;/hello&quot;)
        public String say(String username, String password) {
            System.out.println(username + &quot;, &quot; + password);  //Java, 123
            return &quot;success&quot;;
        }
    2. SpringMVC的参数绑定过程是，把表单提交的参数作为控制器中方法的参数进行绑定的;
    3. 表单提交的key和参数的名称是一致的，且区分大小写.
2. 支持的参数类型：基本类型、实体类、集合类型;
    1. 提交表单的key和实体类中的属性名必须一致;
    2. 如果实体类中还有其他引用类型，那么表单中key的形式为：对象.属性，如address.name;
3. 绑定基本类型、实体类、集合类型
    private class User implements Serializable {
        private String uname;  private int age;
        ...... //setter、getter
    }
    private class Account implements Serializable {
        private String username;  private double money;
        private User user;  //包含引用类型
        private List&lt;User&gt; list;  //List集合
        private Map&lt;String, User&gt; map;  //Map集合
        ...... //setter、getter
    }
    1. form表单：key必须与实体类Account的属性保持一致;
        &lt;form action=&quot;hello&quot; method=&quot;post&quot;&gt;   ==&gt;跟请求方式无关，也可以是GET请求
            &lt;!-- 基本类型 --&gt;
            &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;
            &lt;input type=&quot;text&quot; name=&quot;money&quot; /&gt;
            &lt;!-- 实体类 --&gt;
            &lt;input type=&quot;text&quot; name=&quot;user.uname&quot; /&gt;
            &lt;input type=&quot;text&quot; name=&quot;user.age&quot; /&gt;
            &lt;!-- 集合类型 --&gt;
            &lt;input type=&quot;text&quot; name=&quot;list[0].uname&quot; /&gt;
            &lt;input type=&quot;text&quot; name=&quot;list[0].age&quot; /&gt;
            &lt;input type=&quot;text&quot; name=&quot;map[&apos;one&apos;].uname&quot; /&gt;
            &lt;input type=&quot;text&quot; name=&quot;map[&apos;one&apos;].age&quot; /&gt;
            &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;
        &lt;/form&gt;
    2. 把请求参数封装到JavaBean中
        @RequestMapping(path=&quot;/hello&quot;)
        public String say(Account account) {
            System.out.println(account);
            return &quot;success&quot;;
        }
4. 参数中文乱码：在 web.xml 中配置Spring的过滤器，并初始化参数encoding=UTF-8
    &lt;filter&gt;  ===&gt;过滤器标签排列在&lt;servlet&gt;标签之前
        &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
        &lt;init-param&gt;
            &lt;param-name&gt;encoding&lt;/param-name&gt;
            &lt;param-value&gt;UTF-8&lt;/param-value&gt;
        &lt;/init-param&gt;
    &lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
5. 在控制器中获取Servlet API：直接把 HttpServletRequest、HttpServletResponse 加到方法的参数上;
    @RequestMapping(path=&quot;/hello&quot;)
    public String say(HttpServletRequest request, HttpServletResponse response) {
        HttpSession session = request.getSession();
        ServletContext context = session.getServletContext();
    }
</code></pre><h3 id="类型转换器"><a href="#类型转换器" class="headerlink" title="类型转换器"></a>类型转换器</h3><pre><code>1. 在参数传递过程中，key和value其实都是字符串，SpringMVC内部有类型转换器，负责转换参数类型;
2. 但是，对于一些特殊类型，如日期，SpringMVC并不能识别所有的日期格式，这就需要自定义类型转换器;
3. 类型转换器的接口：Converter&lt;S, T&gt;，S和T分别代表接受类型和目标类型
    public class String2DateConverter implements Converter&lt;String, Date&gt; {
        public Date convert(String source) {
            if(source == null) {
                throw new RuntimeException(&quot;请传入参数&quot;);
            }
            //字符串转日期的识别类型 yyyy-MM-dd
            DateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
            try {
                return df.parse(source);
            } catch(Exception e) {
                throw new RuntimeException(&quot;类型转换异常&quot;);
            }
        }
    }
4. springmvc.xml：配置自定义的类型转换器
    &lt;bean id=&quot;csfb&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt;
        &lt;property name=&quot;converters&quot;&gt;
            &lt;set&gt;
                &lt;bean class=&quot;cn.test.converter.String2DateConverter&quot; /&gt;
            &lt;/set&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;mvc:annotation-driven conversion-service=&quot;csfb&quot; /&gt;
    1. &lt;mvc:annotation-driven&gt; 标签开启SpringMVC的注解支持;
    2. conversion-service属性：让配置的自定义日期类型转换器生效.
5. 当遇到字符串需要转Date时，SpringMVC会自动调用自定义的类型转换器.
    &lt;a href=&quot;hello?date=2018-11-12&quot;&gt;to hello&lt;/a&gt;
    @RequestMapping(path=&quot;/hello&quot;)
    public String say(Date date) {  --&gt; &quot;2018-11-12&quot; 转 Date对象
        return &quot;success&quot;;
    }
</code></pre><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><pre><code>@Controller
@RequestMapping(&quot;/user&quot;)
public class TestController { ... }
1. @RequestParam：把请求中指定名称的参数，给控制器中的形参赋值;
    1. value、name属性：请求参数中的名称;
    2. required：请求参数中是否必须提供此参数，默认为true;
    3. defaultValue属性：设置默认值，如果参数中没有携带指定的属性，则使用默认值;
        @RequestMapping(path=&quot;/test&quot;)
        public String test(@RequestParam(name=&quot;uname&quot;) String username) {
            return &quot;success&quot;;
        }
    3. 请求参数中必须提供一个key为 uname 的键值对，uname的值会赋给形参username;
        &lt;a href=&quot;user/test?name=Java&quot;&gt;Welcome&lt;/a&gt;
    4. 不使用 @RequestParam 时，形参username 只会接收请求参数中key为 username 的值，
    如果请求参数中没有，则形参username 仍为默认值null.
2. @RequestBody：用于获取请求体的内容;
    1. HTTP请求头必须是content-type=application/json，且使用body传输数据，所以是POST请求;
    2. required属性：是否必须有请求体;
    3. 直接使用时会得到整个请求体的内容：key=value&amp;key=value...
        &lt;form action=&quot;user/test&quot; method=&quot;post&quot;&gt;
            &lt;input type=&quot;text&quot; name=&quot;uname&quot; /&gt;  ==&gt;Java
            &lt;input type=&quot;text&quot; name=&quot;age&quot; /&gt;  ====&gt;22
            &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;
        &lt;/form&gt;
        @RequestMapping(path=&quot;/test&quot;)
        public String test(@RequestBody String body) {
            System.out.println(body);  // uname=Java&amp;age=22
            return &quot;success&quot;;
        }
    3. 引入Jackson相关的依赖之后，可以把请求体封装到POJO对象中
        @RequestMapping(path=&quot;/test&quot;)
        public String test(@RequestBody User user) {
            return &quot;success&quot;;
        }
3. @PathVariable：用于绑定url中的占位符，如/delete/{id}，id就是url占位符;
    1. url支持占位符是在Spring3.0才加入的，它是SpringMVC支持RESTful风格URL的一个重要标志;
    2. value、name属性：指定URL中占位符的名称;
    3. required：是否必须提供占位符;
        @RequestMapping(path=&quot;/test/{uId}&quot;)
        public String test(@PathVariable(name=&quot;uId&quot;) String id) {
            System.out.println(id);  // 10
            return &quot;success&quot;;
        }
        &lt;a href=&quot;user/test/10&quot;&gt;Welcome&lt;/a&gt;
4. HiddentHttpMethodFilter
    1. 浏览器的form表单只支持GET与POST请求，无法模拟DELETE、PUT等RESTful method;
    2. Spring3.0提供了一个过滤器，可以将浏览器请求改为指定的请求的方式，再发给控制器方法.
5. @RequestHeader：获取请求头
    1. value属性：提供请求头的名称;
    2. required：是否必须有此请求头;
        @RequestMapping(path=&quot;/test&quot;)
        public String test(@RequestHeader(value=&quot;Accept&quot;) String header, int id) {
            System.out.println(header);
            return &quot;success&quot;;
        }
6. @CookieValue：把指定Cookie名称的值传给控制器方法的参数;
    1. value属性：指定Cookie的名称;
    2. required：是否必须有此Cookie;
        @RequestMapping(path=&quot;/test&quot;)
        public String test(@CookieValue(value=&quot;JSESSIONID&quot;) String cookieValue) {
            System.out.println(cookieValue);
            return &quot;success&quot;;
        }
</code></pre><h3 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="ModelAttribute"></a>ModelAttribute</h3><pre><code>1. @ModelAttribute：SpringMVC4.3新特性，可以修饰方法和参数;
    1. 修饰方法时：当前方法会在控制器的方法执行之前，优先执行;
    2. 可以修饰没有返回值的方法，也可以修饰有具体返回值的方法;
    3. 修饰参数时：获取指定的数据，并赋值给参数;
    4. value属性：获取数据的key，可以是POJO的属性名，也可以是Map结构的key;
2. 应用：当表单提交参数不是完整的实体类数据时，保证没有提交的字段使用数据库中的原数据;
    &lt;form action=&quot;user/test&quot; method=&quot;post&quot;&gt;
        &lt;input type=&quot;text&quot; name=&quot;uname&quot; /&gt;  ===&gt;只提交一个参数uname
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;
    &lt;/form&gt;
3. 修饰有返回值的方法
    @RequestMapping(path=&quot;/test&quot;)
    public String test(User user) {
        System.out.println(user);
        return &quot;success&quot;;
    }
    @ModelAttribute
    public User initTest(String uname) {
        User user = new User();
        user.setUname(uname);
        ...... //查询数据库，获取age字段
        user.setAge(20);
        return user;
    }
    1. initTest() 优先执行，形参uname 接收请求参数中的uname，返回一个User对象;
    2. test() 执行时，形参user 接收 initTest() 返回的User对象.
4. 修饰无返回值的方法
    @RequestMapping(path=&quot;/test&quot;)
    public String test(@ModelAttribute(&quot;abc&quot;) User user) {
        System.out.println(user);
        return &quot;success&quot;;
    }
    @ModelAttribute
    public void initTest(String uname, Map&lt;String, User&gt; map) {
        User user = new User();
        user.setUname(uname);
        ...... //查询数据库，获取age字段
        user.setAge(20);
        map.put(&quot;abc&quot;, user);
    }
    1. initTest() 优先执行，形参uname 接收请求参数中的uname，把User对象存入Map集合;
    2. test() 的形参user 通过 @ModelAttribute(&quot;Map集合的key&quot;) 获取Map中的User对象.
</code></pre><h3 id="SessionAttributes"><a href="#SessionAttributes" class="headerlink" title="SessionAttributes"></a>SessionAttributes</h3><pre><code>1. 为了向域中存储数据，在控制器方法的参数上直接使用Servlet API，这种方式耦合度太高;
2. 为了解决与Serlvet的耦合度问题，Spring提供了接口Model，并提供了很多实现类;
    @RequestMapping(path=&quot;/test&quot;)
    public String test(Model model) {
        model.addAttribute(&quot;msg&quot;, &quot;Java&quot;);  --&gt; 存入数据
        return &quot;success&quot;;
    }
    1. Model默认会把数据存到Request域中;
    2. 在JSP中取值：&lt;h2&gt;${ requestScope.msg }&lt;/h2&gt;
3. @SessionAttributes：用于多次执行控制器方法间的参数共享;
    1. 只能修饰类，让Model把数据被存入Session域中;
    2. value、names属性：String数组，用于指定存入数据的key;
    3. types：根据指定参数的类型，将模型中对应类型的参数存储到session中;
        @Controller
        @RequestMapping(&quot;/user&quot;)
        @SessionAttributes(value={&quot;msg&quot;})  ---&gt;指定key的名称
        public class TestController {
            @RequestMapping(path=&quot;/test&quot;)
            public String test(Model model) {
                model.addAttribute(&quot;msg&quot;, &quot;Java&quot;);  --&gt;向Session域中存入值
                return &quot;success&quot;;
            }

            @RequestMapping(path=&quot;/get&quot;)
            public String test(ModelMap map) {
                String msg = (String)map.get(&quot;msg&quot;);  --&gt;从Session域中获取值
                return &quot;get&quot;;
            }

            @RequestMapping(path=&quot;/del&quot;)
            public String test(SessionStatus status) {
                status.setComplete();  --&gt;从Session域中删除值
                return &quot;del&quot;;
            }
        }
    2. Model会将数据存入到Request域和Session域中;
    3. 在JSP中获取数据：
        &lt;h2&gt;${ requestScope.msg }&lt;/h2&gt;  &lt;h2&gt;${ sessionScope.msg }&lt;/h2&gt;
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/03/11/Spring5新特性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/11/Spring5新特性/" itemprop="url">Spring5新特性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-11T00:00:00+08:00">
                2016-03-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>1. Spring5.0在2017年9月发布了GA(通用)版本，基于JDK8，兼容JDK9，但JDK8以下版本无法使用;
    1. Tomcat版本要求最低8.5，使用JDK8构建工程，可以降版编译，但不能使用JDK8-构建工程;
    2. 随着JDK和Tomcat的更新，相应的IDE也要更新.
2. JDK8的更新
    1. 反射增强：大量创建对象、给对象的属性设置值、反射创建对象...的速度都大大加快;
    2. @NotNull、@Nullable
        1. 显示表明可为空的参数/返回值，实现在编译期处理空值，避免在运行期抛出Null异常;
    3. 日志记录
        1. Spring5.0新增Commons Logging桥接模块的封装，称为spring-jcl，并不是标准的CL;
        2. 当然，无需任何额外的桥接，新版本也会对Log4j2.x、SLF4J、JUL进行自动检测.
3. 核心容器的更新
    1. Spring5.0支持候选组件索引作为类路径扫描的替代方法;
    2. 从索引读取实体而不是扫描类路径，对小于200个类的小型项目没有明显差异，但对大型项目影响较大;
    3. 加载组建索引的耗费是廉价的，所以随着类的数量增长，启动时间仍可以维持一个常数;
    4. 对于Spring项目的开发者而言，应用程序的启动时间将被大大缩减.
4. 支持Kotlin：一种支持函数式编程的面向对象语言，运行在JVM之上，但运行环境又不仅限于JVM;
5. 响应式编程风格
    1. spring-webflux：支持响应式HTTP和WebSocket客户端;
    2. spring-webflux中包含两种独立的服务端编程模型;
        1. 基于注解：使用 @Controller 以及 SpringMVC的一些注解;
        2. 使用Java8 lambda表达式的函数式风格的路由和处理.
6. 支持JUnit5：JUnit5 = JUnit Platform + JUnit Jupiter + JUnit Vintage
7. 依赖类库的更新
    1. 不再支持的类库：Portlet、Velocity、JasperReports、XMLBeans、JDO、Guava
    2. 新支持的类库：Jackson2.6+、EhCache2.1+/3.0GA、Hibernate5.0+、JDBC4.0+、XmlUnit2.x+、
    OkHttp3.x+、Netty4.1+
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/03/09/Spring事务控制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/09/Spring事务控制/" itemprop="url">Spring事务控制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-09T00:00:00+08:00">
                2016-03-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h2><pre><code>1. JdbcTemplate是Spring提供的一个对象，对原始JDBC的一层简单封装；
    1. 操作关系型数据库：JdbcTemplate、HibernateTemplate
    2. 操作NoSQL数据库：RedisTemplate
    3. 操作消息队列：JmsTemplate
</code></pre><p><img src="//hellomyshadow.github.io/2016/03/09/Spring事务控制/持久层.jpg" alt="持久层"></p>
<pre><code>2. JdbcTemplate的依赖包：spring-jdbc，除此之外，还有事务相关的依赖：spring-tx
    spring-context、spring-jdbc、spring-tx、mysql-connector-java
3. JdbcTemplate的简单使用
    1. 实体类Account
        public class Account {
            private int id;  private String name;  private float money;
            //setter、getter
        }
    2. Spring的内置数据源DriverManagerDataSource
        DriverManagerDataSource ds = new DriverManagerDataSource();
        ds.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;);
        ds.setUrl(&quot;jdbc:mysql://...&quot;);  ds.setUsername(&quot;root&quot;);  ds.setPassword(&quot;123456&quot;);
        JdbcTemplate jt = new JdbcTemplate();
        jt.setDataSource(ds);
        jt.execute(&quot;insert into account(name, money) values(&apos;Java&apos;, 1000)&quot;);
4. JdbcTemplate的CRUD
    1. 插入一条数据
        jt.update(&quot;insert into account(name, money) values(?, ?)&quot;, &apos;AAA&apos;, 1000);
    2. 修改/删除
        jt.update(&quot;update/delete ...&quot;, ...);
    3. 查询
        jt.query(String sql, Object[] args, RowMapper&lt;T&gt; rowMapper); //通用方式
        jt.query(String sql, RowMapper&lt;T&gt; rowMapper, Object... args); //JDK1.5+
    4. RowMapper：接口，泛型就是实体类，其方法 mapRow() 用于把数据封装到实体类对象中
        class AccountRowMapper implements RowMapper&lt;Account&gt; {
            public Account mapRow(ResultSet rs, int rowNum) {
                Account account = new Account();
                account.setId(rs.getInt(&quot;id&quot;));
                account.setName(rs.getString(&quot;name&quot;));
                account.setMoney(rs.getFloat(&quot;money&quot;));
                return account;
            }
        }
    List&lt;Account&gt; ats = jt.query(&quot;select * from account where money&gt;?&quot;, new AccountRowMapper(), 100f);
    5. Spring也提供了RowMapper的实现类：BeanPropertyRowMapper
    jt.query(&quot;select * from account&quot;, new BeanPropertyRowMapper&lt;Account&gt;(Account.class));
5. 聚合函数
Integer count = jt.queryForObject(&quot;select count(id) from account where money&gt;?&quot;, Integer.class, 100f);
</code></pre><h3 id="基于Spring-IoC"><a href="#基于Spring-IoC" class="headerlink" title="基于Spring IoC"></a>基于Spring IoC</h3><pre><code>1. Dao层的接口及其实现类：IAccountDao、AccountDaoImpl
    public class AccountDaoImpl implements IAccountDao {
        private JdbcTemplate jt;
        ......//setter、CRUD
    }
2. IoC配置文件bean.xml
    &lt;bean id=&quot;accountDao&quot; class=&quot;cn.test.dao.impl.AccountDaoImpl&quot;&gt;
        &lt;property name=&quot;jt&quot; ref=&quot;jt&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;jt&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;ds&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;ds&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
        &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://...&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;username&quot; value=&quot;root&quot;&gt;&lt;/property&gt;
        &lt;property name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
3. 直接使用Dao层操作数据库
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
    IAccountDao dao = ac.getBean(&quot;accountDao&quot;, IAccountDao.class);
</code></pre><h3 id="JdbcDaoSupport"><a href="#JdbcDaoSupport" class="headerlink" title="JdbcDaoSupport"></a>JdbcDaoSupport</h3><pre><code>1. 如果有多个Dao，那么每个Dao中都会有属性JdbcTemplate及其setter，需要抽取其中的重复代码
    1. 定义一个Dao层的父类JdbcDaoSupport
        public class JdbcDaoSupport {
            private JdbcTemplate jdbcTemplate;
            //创建无参的JdbcTemplate对象
            public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {
                this.jdbcTemplate = jdbcTemplate;
            }
            public JdbcTemplate getJdbcTemplate() {
                return this.jdbcTemplate;
            }
            //创建带参DataSource的JdbcTemplate对象
            public void setDataSource(DataSource dataSource) {
                if(this.jdbcTemplate == null) {
                    this.jdbcTemplate = this.createJdbcTemplate(dataSource);
                }
                this.jdbcTemplate = jdbcTemplate;
            }
            private JdbcTemplate createJdbcTemplate(DataSource dataSource) {
                return new JdbcTemplate(dataSource);
            }
        }
    2. Dao层继承JdbcDaoSupport
        public class AccountDaoImpl extends JdbcDaoSupport implements IAccountDao {
            public List&lt;Account&gt; findAll() {
                return supper.getJdbcTemplate().query(&quot;select * from account&quot;, ...);
            }
            ......//CRUD
        }
    3. 在为 AccountDaoImpl 注入数据时，可以选择使用无参的JdbcTemplate还是有参的JdbcTemplate
        &lt;bean id=&quot;accountDao&quot; class=&quot;cn.test.dao.impl.AccountDaoImpl&quot;&gt;
            &lt;!-- 使用无参的JdbcTemplate对象 --&gt;
            &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jt&quot;&gt;&lt;/property&gt;
            &lt;!-- 使用有参DataSource的JdbcTemplate对象，二选一 --&gt;
            &lt;property name=&quot;dataSource&quot; ref=&quot;ds&quot;&gt;&lt;/property&gt;
        &lt;/bean&gt;
        ......// jt、ds
2. 另外，Spring提供了一个JdbcDaoSupport，功能和XML注入方式都与自定义的JdbcDaoSupport类似;
3. JdbcDaoSupport是Spring的内置类，一旦Dao层继承它，那么在Service层使用Dao对象时，就只能用配置文件的方式
   实现注入，而不能再使用 @Autowired 注入 Dao 了。
</code></pre><h2 id="注解AOP实现事务"><a href="#注解AOP实现事务" class="headerlink" title="注解AOP实现事务"></a>注解AOP实现事务</h2><pre><code>1. 连接的工具类
    @Commonent(&quot;connUtils&quot;)
    public class ConnectionUtils {
        private ThreadLocal&lt;Connection&gt; tl = new ThreadLocal&lt;&gt;();
        @Autowired
        private DataSource dataSource;

        public Connection getThreadConn() {
            Connection conn = tl.get();
            if(conn == null) { //从数据源中获取一个连接，并存入连接池
                conn = dataSource.getConnection();
                tl.set(conn);
            }
            return conn;
        }
        public void removeConn() {
            tl.remove();  // 移除ThreadLocal中当前线程的连接
        }
    }
2. 事务管理的工具类，声明为切面类
    @Commonent(&quot;manager&quot;)
    @Aspect
    public class TransactionManager {
        @Autowired
        private ConnectionUtils connUtils;
        @Pointcut(&quot;execution(* it.bank.service.impl.*.*(..))&quot;)
        private void pt1() {}
        @Before(&quot;pt1()&quot;)
        public void beginTransaction() {  //开启手动提交事务
            connUtils.getThreadConn().setAutoCommit(false);
        }
        @AfterReturning(&quot;pt1()&quot;)
        public void commit() {  //手动提交事务
            connUtils.getThreadConn().commit();
        }
        @AfterThrowing(&quot;pt1()&quot;)
        public void rollback() {  //回滚
            connUtils.getThreadConn().rollback();
        }
        @After(&quot;pt1()&quot;)
        public void release() {  //释放连接，并还给连接池
            connUtils.getThreadConn().close();
            connUtils.removeConn();
        }
    }
3. 但是在AOP注解中，通知方法的执行顺序有致命问题：Before --&gt; After --&gt; AfterReturning
    1. 最终通知优先于后置通知执行，导致连接已经被关闭了，事务无法正确提交！
    2. 连接关闭并还给连接池后，提交时又会从连接池中获取一个新的连接，但此连接又没有开启过事务，导致提交异常。
4. 使用环绕通知
    @Commonent(&quot;manager&quot;)
    @Aspect
    public class TransactionManager {
        @Autowired
        private ConnectionUtils connUtils;
        @Pointcut(&quot;execution(* it.bank.service.impl.*.*(..))&quot;)
        private void pt1() {}

        public void beginTransaction() { ... }
        public void commit() { ... }
        public void rollback() { ... }
        public void release() { ... }

        @Around(&quot;pt1()&quot;)
        public Object aroundPrint(ProceedingJoinPoint pjp) {
            Object rtValue = null;
            try {
                Object[] args = pjp.getArgs();  //1.获取切入点方法执行所需的参数
                this.beginTransaction();  //2.开启事务
                rtValue = pjp.proceed(args);  //3.明确调用切入点方法
                this.commit();  //4.提交事务
                return rtValue;  //5.返回结果
            } catch(Throwable t) {
                this.rollback();
                throw new RuntimeException(t);
            } finally {
                this.release();
            }
        }
    }
</code></pre><h2 id="Spring的事务控制"><a href="#Spring的事务控制" class="headerlink" title="Spring的事务控制"></a>Spring的事务控制</h2><pre><code>1. TransactionManager是自定义的事务管理，Spring也有自己的事务控制；
    1. JavaEE体系进行分层开发时，事务控制位于业务层，Spring提供了业务层的事务控制方案；
    2. Spring提供了一组事务控制的接口，这些API就在spring-tx中；
    3. Spring的事务控制都是基于AOP的，它既可以使用编程式实现，也可以使用配置实现。
2. 相关依赖：spring-context、spring-jdbc、spring-tx、mysql-connector-java、aspectjweaver
</code></pre><h3 id="事务控制的API"><a href="#事务控制的API" class="headerlink" title="事务控制的API"></a>事务控制的API</h3><pre><code>1. PlatformTransactionManager：提供事务操作的接口
    1. getTransaction(TransactionDefinition d)：获取事务的状态信息;
    2. commit(TransactionStatus status)：提交事务;
    3. rollback(TransactionStatus status)：回滚事务;
    4. 实现类：DataSourceTransactionManager、HibernateTransactionManager;
    5. DataSourceTransactionManager：用于Spring JDBC 或 iBatis;
    6. HibernateTransactionManager：用于hibernate.
2. TransactionDefinition：事务的定义信息
    1. getName()：获取事务的名称;
    2. getIsolationLevel()：获取事务的隔离级别;
    3. getPropagationBehavior()：获取事务的传播行为;
    4. 传播行为：何时才需要事务(增删改)，何时不需要事务(查询);
    5. getTimeout()：事务的超时时间，提交和回滚何时过期，可以配置为永不过期;
    6. isReadOnly()：事务是否只读，读写型事务(增删改)、只读型事务(查询);
3. 事务的隔离级别
    1. ISOLATION_DEFAULT：使用数据库的默认隔离级别;
    2. ISOLATION_READ_UNCOMMITTED：读未提交;
    3. ISOLATION_READ_COMMITTED：读已提交，Oracle的默认级别;
    4. ISOLATION_REPEATABLE_READ：不可重读，MySQL的默认隔离级别;
    5. ISOLATION_SERIALIZABLE：最高级别.
4. 事务的传播行为
    1. REQUIRED：默认值，如果当前没有事务，则新建一个，如果已存在一个事务，则加入到该事务中;
    2. SUPPORTS：支持当前事务，如果当前没有事务，则以非事务的方式执行(有就用，没有就不用);
    3. MANDATORY、REQUERS_NEW、NOT_SUPPORTED、NEVER、NESTED
5. 超时时间：以秒为单位，默认值-1，表示没有超时限制;
6. TransactionStatus：描述某个时间点上事务对象的状态信息;
    1. flush()：刷新事务;
    2. hasSavepoint()：是否存在存储点，将一个事务按步提交，如果某一步失败，只回滚到这一步前，而不是从头开始;
    3. isCompleted()：事务是否完成;
    4. isNewTransaction()：当前事务是不是一个新事务;
    5. isRollbackOnly()：事务是否回滚;
    6. setRollbackOnly()：设置事务回滚;
</code></pre><h3 id="声明式事务控制"><a href="#声明式事务控制" class="headerlink" title="声明式事务控制"></a>声明式事务控制</h3><pre><code>1. Dao层：IAccountDao、AccountDaoImpl(继承Spring的JdbcDaoSupport)
2. Service层：IAccountService、AccountServiceImpl
    public class AccountServiceImpl implements IAccountService {
        private IAccountDao dao; //setter
        public Account findById(int id) {
            return dao.findById(id);
        }
        public void transfer(String sourceName, String targetName, Float money) {
            Account source = dao.findByName(sourceName);
            Account target = dao.findByName(targetName);
            source.setMoney(source.getMoney() - money);
            target.setMoney(target.getMoney() + money);
            //更新数据库
            dao.updateAccount(source);
            int i = 1/0;  //发生异常，不再向下执行
            dao.updateAccount(target);
        }
    }
3. bean.xml：加入事务、AOP的约束
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
        xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;
        xsi:schemaLocation=&quot;
            http://www.springframework.org/schema/beans
            https://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/tx
            https://www.springframework.org/schema/tx/spring-tx.xsd
            http://www.springframework.org/schema/aop
            https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
        &lt;bean id=&quot;accountService&quot; class=&quot;cn.test.service.impl.AccountServiceImpl&quot;&gt;
            &lt;property name=&quot;dao&quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt;
        &lt;/bean&gt;
        &lt;bean id=&quot;accountDao&quot; class=&quot;cn.test.dao.impl.AccountDaoImpl&quot;&gt;
            &lt;property name=&quot;dataSource&quot; ref=&quot;ds&quot;&gt;&lt;/property&gt;
        &lt;/bean&gt;
        &lt;bean id=&quot;ds&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
            ......
        &lt;/bean&gt;
4. 配置事务管理器：DataSourceTransactionManager
    &lt;bean id=&quot;manager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
        &lt;property name=&quot;dataSource&quot; ref=&quot;ds&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
5. &lt;tx:advice&gt;：配置事务通知，关联事务管理器;
    &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;manager&quot;&gt;
        &lt;tx:attributes&gt;
            &lt;tx:method name=&quot;transfer&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&gt;
        &lt;/tx:attributes&gt;
    &lt;/tx:advice&gt;
    1. id属性：此事务通知的唯一标识;
    2. transaction-manager：指定事务管理器的id，关联事务通知与事务管理器.
6. &lt;tx:method&gt;：配置事务管理的方法;
    1. name属性：用于指定方法名，支持正则通配符*
        1. name=&quot;find*&quot;：匹配以 find 开头的方法;
        2. 配置多个&lt;tx:method&gt;，为不同的方法设置不同的参数，name的范围越小，优先级越高;
        &lt;tx:method name=&quot;transfer&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot; /&gt;
        &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt;
        3. 查询方法以 find 开头，设置为只读，且不使用事务.
    2. propagation：配置事务的传播行为;
        1. REQUIRED：默认值，表示一定会有事务，用于增删改;
        2. SUPPORTS：用于查询方法，通知数据库没必要加锁(事务)，提高效率.
    3. isolation：配置隔离级别，默认值DEFAULT，表示使用数据库的默认隔离级别;
    4. read-only：指定事务是否只读，默认为false，表示读写，只有查询方法才能设置为true;
    5. timeout：事务的超时时间，以秒为单位，默认值为-1，表示永不超时;
    6. rollback-for：指定一个异常，当产生该异常时，事务回滚，产生其他异常时，事务不会滚;
    7. no-rollback-for：与 rollback-for 相反，发生指定的异常时不回滚，发生其他异常时回滚;
    8. rollback-for 和 no-rollback-for 都没有默认值，不指定异常时，表示任何异常都回滚.
7. 配置AOP：建立事务通知与切入点表达式的关系
    &lt;aop:config&gt;
        &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* cn.test.service.impl.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;
        &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:advisor&gt;
    &lt;/aop:config&gt;
    1. advice-ref：关联事务通知的id;
    2. pointcut-ref：关联切入点表达式的id.
8. 测试
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
    IAccountService service = ac.getBean(&quot;accountService&quot;, IAccountService.class);
    service.transfer(&quot;AAA&quot;, &quot;BBB&quot;, 100f);
</code></pre><h4 id="注解的声明式事务控制"><a href="#注解的声明式事务控制" class="headerlink" title="注解的声明式事务控制"></a>注解的声明式事务控制</h4><pre><code>1. bean.xml：加入AOP、事务、context的约束，开启Spring对注解事务的支持
    &lt;beans aop、tx、context...相关约束&gt;
        &lt;!-- Spring创建IoC容器时要扫描的包 --&gt;
        &lt;context:component-scan base-package=&quot;cn.test&quot;&gt;&lt;/context:component-scan&gt;
        &lt;bean id=&quot;jt&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;
            &lt;property name=&quot;dataSource&quot; ref=&quot;ds&quot;&gt;&lt;/property&gt;
        &lt;/bean&gt;
        &lt;bean id=&quot;ds&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
            ......
        &lt;/bean&gt;
        &lt;!-- 配置事务管理器 --&gt;
        &lt;bean id=&quot;manager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
            &lt;property name=&quot;dataSource&quot; ref=&quot;ds&quot;&gt;&lt;/property&gt;
        &lt;/bean&gt;
        &lt;!-- 开启Spring支持注解事务 --&gt;
        &lt;tx:annotation-driven transaction-manager=&quot;manager&quot;&gt;&lt;/tx:annotation-driven&gt;
    &lt;/beans&gt;
2. Dao层不再继承Spring的JdbcDaoSupport
    @Repository(&quot;accountDao&quot;)
    public class AccountDaoImpl implements IAccountDao {
        @Autowired
        private JdbcTemplate jt;
        ......
    }
3. @Transactional：事务控制，注解在Service层的类/方法上，并配置事务的相关属性;
    @Service(&quot;accountService&quot;)
    @Transactional(propagation=Propagation.SUPPORTS, readOnly=true)  --&gt;对所有方法有效
    public class AccountServiceImpl implements IAccountService {
        @Autowired
        private IAccountDao dao;

        public Account findById(int id) { ... }

        @Transactional(propagation=Propagation.REQUIRED, readOnly=false) --&gt;单独配置
        public void transfer(String sourceName, String targetName, Float money) { ... }
    }
4. 测试
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
    IAccountService service = ac.getBean(&quot;accountService&quot;, IAccountService.class);
    service.transfer(&quot;AAA&quot;, &quot;BBB&quot;, 100f);
</code></pre><h4 id="纯注解取代XML"><a href="#纯注解取代XML" class="headerlink" title="纯注解取代XML"></a>纯注解取代XML</h4><pre><code>在java目录下创建包config，存放配置类;
1. resources/jdbcConf.properties：数据库的连接信息
    jdbc.driver=com.mysql.cj.jdbc.Driver
    jdbc.url=jdbc:mysql://...
    jdbc.username=root
    jdbc.password=123456
2. JDBC相关的配置类
    public class JdbcConfig {
        @Value(&quot;${jdbc.driver}&quot;)
        private String driver;
        ......//url、username、password

        @Bean(name=&quot;jt&quot;)
        public JdbcTemplate createJdbcTemplate(DataSource ds) {
            return new JdbcTemplate(ds);
        }
        @Bean(name=&quot;ds&quot;)
        public DataSource createDataSource() {
            DriverManagerDataSource ds = new DriverManagerDataSource();
            ds.setDriverClassName(driver);
            ds.setUrl(url);
            ds.setUsername(username);
            ds.setPassword(password);
            return ds;
        }
    }
3. 事务管理器相关的配置类
    public class TransactionConfig {
        @Bean(name=&quot;manager&quot;)
        public PlatformTransactionManager createTransactionManager(DataSource ds) {
            return new DataSourceTransactionManager(ds);
        }
    }
4. @EnableTransactionManagement：开启Spring支持注解事务
5. 主配置类SpringConfiguration
    @Configuration
    @ComponentScan(&quot;cn.test&quot;)
    @Import({JdbcConfig.class, TransactionConfig.class})
    @PropertySource(&quot;jdbcConf.properties&quot;)
    @EnableTransactionManagement
    public class SpringConfiguration { }
6. 测试
    ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class);
    IAccountService service = ac.getBean(&quot;accountService&quot;, IAccountService.class);
    service.transfer(&quot;AAA&quot;, &quot;BBB&quot;, 100f);
</code></pre><h3 id="编程式事务控制"><a href="#编程式事务控制" class="headerlink" title="编程式事务控制"></a>编程式事务控制</h3><pre><code>1. bean.xml：配置Dao、Service、DataSource、事务管理器DataSourceTransactionManager
2. 除此之外，还需要使用事务模板对象TransactionTemplate，所以也要配置;
    &lt;bean id=&quot;transactionTemplate&quot; class=&quot;org.springframework.transaction.support.TransactionTemplate&quot;&gt;
        &lt;property name=&quot;transactionManager&quot; ref=&quot;manager&quot;&gt;&lt;/property&gt;
    &lt;/bean&gt;
3. 在Service中使用TransactionTemplate
    public class AccountServiceImpl implements IAccountService {
        private IAccountDao dao;
        private TransactionTemplate transactionTemplate;
        ......//setter

        public Account findById(int id) {
            return transactionTemplate.execute(new TransactionCallback&lt;Account&gt;() {
                public Account doInTransaction(TransactionStatus status) {
                    return dao.findById(id);
                }
            });
        }
        public void transfer(String sourceName, String targetName, Float money) {
            transactionTemplate.execute(new TransactionCallback&lt;Object&gt;() {
                public Object doInTransaction(TransactionStatus status) {
                    Account source = dao.findByName(sourceName);
                    Account target = dao.findByName(targetName);
                    source.setMoney(source.getMoney() - money);
                    target.setMoney(target.getMoney() + money);
                    dao.updateAccount(source);
                    int i = 1/0;  //发生异常，不再向下执行
                    dao.updateAccount(target);
                    return null;
                }
            });
        }
    }
    4. 每一个需要事务管理的方法里都要使用TransactionTemplate去管理，增加了大量的重复代码。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/03/08/Spring与AOP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/03/08/Spring与AOP/" itemprop="url">Spring与AOP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-08T00:00:00+08:00">
                2016-03-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><pre><code>1. AOP：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护；
    1. 简单来说：在运行期，利用动态代理技术，在不修改源码的情况下，对已有方法进行增强；
    2. AOP是OOP的延续，是函数式编程的一种衍生范型；
    3. 利用AOP可以分离业务逻辑的各个部分，从而降低耦合，提高程序的可重用性和开发效率。
2. Joinpoint：连接点，指那些被拦截的点，在Spring中就是被拦截的方法，因为Spring只支持方法类型的连接点；
3. Pointcut：切入点，在被拦截的方法中，只有被增强的方法才称为切入点；
4. Advice：通知/增强，拦截到Joinpoint之后要做的事情；
    1. 分类：前置通知、后置通知、异常通知、最终通知、环绕通知；
    public IAccountService getAccountService() {
        return (IAccountService) Proxy.newProxyInstance(
        service.getClass().getClassLoader(), service.getClass().getInterfaces(), 
        new InvocationHandler(){
            public Object invoke(Object proxy, Method method, Object[] args)  {
                object rtValue = null;
                try {
                    manager.beginTransaction();
                    rtValue = method.invoke(service, args);
                    manager.commit();
                    return rtValue;
                } catch(Exception e) {  ---&gt;异常通知
                    manager.rollback();
                    throw new RuntimeException(e);
                } finally {  ---&gt;最终通知
                    manager.release();
                }
            }
        });
    }
    2. 整个 invoke() 部分称为环绕通知，其中有明确的切入点方法调用：method.invoke(service, args);
    3. method.invoke(service, args); 之前的代码称为前置通知，后面的代码称为后置通知.
5. Introduction：引介，一种特殊的通知，在不修改类代码的情况下，可以在运行期动态地为类添加属性/方法；
6. Target：代理的目标对象；
7. Weaving：织入，把增强应用到目标对象，来创建新代理对象的过程；
    1. Spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入.
8. Proxy：一个类被AOP织入增强后，就产生一个代理类；
9. Aspect：切面，是切入点和通知/引介的结合。
</code></pre><h3 id="Spring的AOP"><a href="#Spring的AOP" class="headerlink" title="Spring的AOP"></a>Spring的AOP</h3><pre><code>1. 添加依赖：spring-context、aspectjweaver(解析切入点表达式)
2. 业务层Service
    public class AccountServiceImpl implements IAccountService {
        public void save() {  //无参无返回值
            System.out.println(&quot;save&quot;);
        }
        public void update(int i) { //有参无返回值
            System.out.println(&quot;update&quot;);
        }
        public int delete() {  //无参有返回值
            System.out.println(&quot;delete&quot;);
        }
    }
3. 提供一个记录日志的工具类，存放公共代码
    public class Logger {
        public void print() {
            //在切入点方法执行之前，执行此通知方法
            System.out.println(&quot;print&quot;);
        }
    }
4. Spring的配置文件 resources/bean.xml，添加AOP约束
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
        &lt;bean id=&quot;accountService&quot; class=&quot;cn.test.service.impl.AccountServiceImpl&quot;&gt;&lt;/bean&gt;
        &lt;bean id=&quot;logger&quot; class=&quot;cn.test.utils.Logger&quot;&gt;&lt;/bean&gt;
        &lt;!-- 配置AOP --&gt;
        &lt;aop:config&gt;
            &lt;!-- 配置切面 --&gt;
            &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt;
                &lt;!-- 配置通知类型，并建立通知方法与切入点方法的关联 --&gt;
                &lt;aop:before method=&quot;print&quot; pointcut=&quot;切入点表达式&quot;&gt;&lt;/aop:before&gt;
            &lt;/aop:aspect&gt;
        &lt;/aop:config&gt;
    &lt;/beans&gt;
    1. &lt;aop:config&gt;：开始AOP的配置;
    2. &lt;aop:aspect&gt;：配置切面;
        1. id属性：切面的唯一标识;
        2. ref属性：指定通知类bean的id，此时的通知类就是Logger
    3. &lt;aop:before&gt;：配置前置通知，也就是执行Logger.print()
        1. method属性：指定执行的通知方法;
        2. pointcut属性：指定切入点表达式，表示对业务层中的哪些方法增强;
        3. pointcut-ref属性：引用外部的切入点表达式标签&lt;aop:pointcut&gt;
        4. 只增强 AccountServiceImpl.save();
    pointcut=&quot;execution(public void cn.test.service.impl.AccountServiceImpl.save())&quot;
5. 开始执行
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
    IAccountService service = ac.getBean(&quot;accountService&quot;, IAccountService.class);
    service.save();  //print --&gt; save
    service.delete();  //delete，没有增强
6. 切入点表达式：execution(表达式)
    1. 表达式的标准格式：访问修饰符 返回值 包名.类名.方法名(参数列表)
    2. 访问修饰符可省略；
    3. 返回值使用通配符*，表示任意返回值；
    4. 包名使用通配符*，表示任意通配符，但有几级包，就需要写几个*.
        * *.*.*.*.AccountServiceImpl.save()
    5. 包名可以使用 .. , 表示当前包及其子包
        * *..AccountServiceImpl.save()
    6. 类名和方法名都可以使用 * 来实现通配：* *..*.*()
    7. 参数列表
        1. 基本类型直接用类型名，如int
        2. 引用类型则需要指明全类名，如java.lang.String
        3. 使用通配符*，匹配方法上的任意类型，但方法上必须有参数才可匹配;
        4. 使用 .. , 表示匹配方法上的任意多个、任意类型的参数，也可以没有参数.
    8. 由此可知，全通配的写法：* *..*.*(..)，匹配所有类的所有方法；
    9. 当然，一般也只会匹配业务层的所有方法：* cn.test.service.impl.*.*(..)
</code></pre><h2 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h2><pre><code>1. 通知方法
    public class Logger {
        public void beforePrint() { //前置通知
            System.out.println(&quot;before print&quot;);
        }
        public void afterPrint() { //后置通知
            System.out.println(&quot;after print&quot;);
        }
        public void catchPrint() { //异常通知
            System.out.println(&quot;catch print&quot;);
        }
        public void finalPrint() { //最终通知
            System.out.println(&quot;final print&quot;);
        }
        public void aroundPrint() { //环绕通知
            System.out.println(&quot;around print&quot;);
        }
    }
2. 配置四种常用通知
    1. 前置通知：切入点方法执行之前执行;
    &lt;aop:before method=&quot;beforePrint&quot; 
        pointcut=&quot;execution(* cn.test.service.impl.*.*(..))&quot;&gt;&lt;/aop:before&gt;
    2. 后置通知：切入点方法正常执行之后执行;
    &lt;aop:after-returning method=&quot;afterPrint&quot; 
        pointcut=&quot;execution(* cn.test.service.impl.*.*(..))&quot;&gt;&lt;/aop:after-returning&gt;
    3. 异常通知：切入点方法执行产生异常之后执行;
    &lt;aop:after-throwing method=&quot;catchPrint&quot; 
        pointcut=&quot;execution(* cn.test.service.impl.*.*(..))&quot;&gt;&lt;/aop:after-throwing&gt;
    4. 最终通知：不管切入点方法是否正常执行，都会在最后执行;
    &lt;aop:after method=&quot;finalPrint&quot; 
        pointcut=&quot;execution(* cn.test.service.impl.*.*(..))&quot;&gt;&lt;/aop:after&gt;
    5. 后置通知与异常通知始终只会执行一个.
3. &lt;aop:pointcut&gt;：单独配置切入点表达式
    1. id属性：此表达式的唯一id;
    2. expression属性：定义切入点表达式;
    &lt;aop:pointcut id=&quot;pt1&quot; 
        expression=&quot;execution(* it.aop.service.impl.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;
    &lt;aop:before method=&quot;beforePrint&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:before&gt;
    3. &lt;aop:pointcut&gt; 配置为 &lt;aop:aspect&gt; 的子标签时，只对当前切面有效;
    4. 配置为 &lt;aop:aspect&gt; 的兄弟标签时，必须配置在 &lt;aop:aspect&gt; 之前，对所有切面都有效.
</code></pre><h3 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h3><pre><code>&lt;aop:config&gt;
    &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* it.aop.service.impl.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;
    &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt;
        &lt;aop:around method=&quot;aroundPrint&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:before&gt;
    &lt;/aop:aspect&gt;
&lt;/aop:config&gt;
1. invoke() 也称为环绕通知，所以一旦配置了&lt;aop:around&gt;，切入点方法不再执行，只执行了通知方法；
2. ProceedingJoinPoint：Spring提供的接口，它的 proceed() 用于明确调用切入点方法；
3. ProceedingJoinPoint可以作为环绕通知方法的参数，Spring会在运行期为此接口提供实现类；
    public Object aroundPrint(ProceedingJoinPoint pjp) {
        Object rtValue = null;
        try {
            //1.获取切入点方法执行所需的参数
            Object[] args = pjp.getArgs();
            //2.明确调用切入点方法
            rtValue = pjp.proceed(args);
            return rtValue;
        } catch(Throwable t) { //Exception拦不住此异常
            throw new RuntimeException(t);
        } finally {

        }
    }
    1. pjp.proceed(args); 之前的代码称为前置通知，之后的代码称为后置通知;
    2. catch部分称为异常通知，finally部分称为最终通知.
4. Spring的环绕通知，其实就是为了提供一种可以在代码中手动控制增强方法何时执行的方式；
5. 因为环绕通知与其他四种通知有关联性，如果同时配置这5种通知，会出现调用顺序的错乱；
6. 所以如果配置了环绕通知，就不要再配置其他四种通知，而是在环绕通知方法中手动调用其他四种通知方法。
</code></pre><h2 id="Spring的注解AOP"><a href="#Spring的注解AOP" class="headerlink" title="Spring的注解AOP"></a>Spring的注解AOP</h2><pre><code>1. 在配置文件 bean.xml 中添加aop和context的约束、创建容器时扫描的包、开启AOP注解支持
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
        &lt;!-- Spring创建IoC容器时要扫描的包 --&gt;
        &lt;context:component-scan base-package=&quot;cn.test&quot;&gt;&lt;/context:component-scan&gt;
        &lt;!-- 开启Spring的注解AOP支持 --&gt;
        &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;
    &lt;/beans&gt;
2. 业务层Service
    @Service(&quot;accountService&quot;)
    public class AccountServiceImpl implements IAccountService {
        ......
    }
3. @Aspect：声明当前类是一个切面类
    1. @Pointcut：用在方法上，定义切入点表达式；
    2. @Before、@AfterReturning、@AfterThrowing、@After：分别声明4种通知；
        @Component(&quot;logger&quot;)
        @Aspect
        public class Logger {
            @Pointcut(&quot;execution(* it.aop.service.impl.*.*(..))&quot;)
            private void pt1() {}

            @Before(&quot;pt1()&quot;)
            public void beforePrint() { ... }

            @AfterReturning(&quot;pt1()&quot;)
            public void afterPrint() { ... }

            @AfterThrowing(&quot;pt1()&quot;)
            public void catchPrint() { ... }

            @After(&quot;pt1()&quot;)
            public void finalPrint() { ... }
        }
    3. @Around：声明环绕通知，不要与其他四种通知的注解一起使用，调用顺序会错乱；
    4. 通知注解的value属性用于指定切入点表达式，必须是调用方法的形式：pt1()
4. 使用注解类取代配置文件：@EnableAspectJAutoProxy 声明支持AOP注解
    @Configuration
    @ComponentScan(basePackages=&quot;cn.test&quot;)
    @EnableAspectJAutoProxy
    public class SpringConfiguration { }
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">大麦田怪圈</p>
              <p class="site-description motion-element" itemprop="description">敢做就能赢！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">64</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大麦田怪圈</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
