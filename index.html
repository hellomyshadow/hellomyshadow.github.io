<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="敢做就能赢！">
<meta property="og:type" content="website">
<meta property="og:title" content="大麦田程序猿">
<meta property="og:url" content="http://hellomyshadow.github.io/index.html">
<meta property="og:site_name" content="大麦田程序猿">
<meta property="og:description" content="敢做就能赢！">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="大麦田程序猿">
<meta name="twitter:description" content="敢做就能赢！">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hellomyshadow.github.io/">





  <title>大麦田程序猿</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大麦田程序猿</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/05/13/HTML5-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/13/HTML5-2/" itemprop="url">HTML5-2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-13T00:00:00+08:00">
                2018-05-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML/" itemprop="url" rel="index">
                    <span itemprop="name">HTML</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><h2 id="音视频标签"><a href="#音视频标签" class="headerlink" title="音视频标签"></a>音视频标签</h2><pre><code>1. H5之前对音视频没有一个标准，在网页中的音视频都是通过第三方插件的方式嵌入的；
2. 视频：&lt;video src=&quot;video/test.mp4&quot; controls width=&quot;500&quot; height=&quot;500&quot;&gt;
    1. controls：布尔值属性，显示/隐藏控制播放的控件，但不同浏览器上渲染的样式不同；
    2. src还可以加载网络视频资源：src=&quot;http://······&quot;
    3. poster：一个海报帧(图片)的地址，用于在用户播放或跳帧之前的展示；
    4. autoplay/loop/muted：是否自动播放/循环/静音；
    5. preload：none(告诉浏览器不要预加载该视频，点击播放时再加载)，metada(只抓取该视频的
    元数据，如长度、海报帧等，并显示给用户，但不会预加载该视频)，auto(预加载该视频)
    6. preload: &quot;&quot;; --&gt; 等效于 preload: auto;
    7. 这些都是attribute属性
    8. property属性：
3. 音频：&lt;audio src=&quot;res/test.mp3&quot; controls&gt;
    1. attribute属性：src、controls、autoplay、loop、muted、preload
    2. 对音视频标签支持最好的是FireFox；
    3. property属性：
4. 容器
    1. 实际上，.avi、.mp4并不是视频文件本身，而是容器的格式，它只是决定了视频存储的方式，
    而不关心存储的内容，类似于.zip
    2. 视频容器包含音频轨道、视频轨道和其他一些元数据，视频播放时，音频轨道和视频轨道是绑定
    在一起的，元数据包含了视频的封面、标题、子标题、字幕等相关信息；
    3. 主流容器格式(视频文件格式)：MPEG-4(以.mp4为扩展名)，Flash视频(.flv)，Ogg(.ogv)，
    WebM(.webm)，音频视频交错(.avi)
    4. 主流音频文件格式：MPEG-3(.mp3)，Acc音频(.acc)，Ogg音频(.ogg)
5. 编解码器
    1. 音频和视频的编码/解码是一组算法，用来对一段特定音频/视频进行解码和编码，使音频和视频
    能够播放；
    2. 原始的媒体文件体积非常巨大，如果不编码，数据量很大，在互联网上传输也会消耗大量时间；
    如果不解码，也无法将编码后的数据重组为原始的媒体数据；
    3. 视频编解码器：H.264(又称为MPEG-4的第十部份)、VP8、Ogg Theora
    4. 音频编解码器：ACC、MPEG-3、Ogg Vorbis
    5. 编解码器的配置分为基本配置、主配置、高级配置，手机上支持基本配置，电视机上支持基本配置
    和主配置，电脑上支持三种配置；
    6. 目前还没有一种编解码器和容器的组合能够适配所有浏览器，因此要对视频做格式转化；
    7. 音视频的格式转化工具：FFmpeg
6. 音视频的兼容模式
    1. &lt;video&gt;可以包裹&lt;source&gt;，提供不同格式的视频，不支持视频标签，则提供视频的下载链接；
    &lt;video width=&quot;800&quot; height=&quot;800&quot; controls&gt;
        &lt;source src=&quot;res/test.mp4&quot; type=&quot;video/mp4&quot;&gt;&lt;/source&gt;
        &lt;source src=&quot;res/test.ogv&quot; type=&quot;video/ogg&quot;&gt;&lt;/source&gt;
        &lt;source src=&quot;res/test.webm&quot; type=&quot;video/webm&quot;&gt;&lt;/source&gt;
        当前浏览器不支持video直接播放，点击下载：&lt;a href=&quot;res/test.mp4&quot;&gt;下载视频&lt;/a&gt;
    &lt;/video&gt;
    2. 浏览器通过检查&lt;source&gt;的type属性，查找所支持的视频格式，达到浏览器的兼容效果；
    3. 同理，&lt;audio&gt;也可以包裹&lt;source&gt;，提供不同格式的音频。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/05/12/HTML5-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/12/HTML5-1/" itemprop="url">HTML5-1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-12T00:00:00+08:00">
                2018-05-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML/" itemprop="url" rel="index">
                    <span itemprop="name">HTML</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><pre><code>1. HTML5：HTML标准的的最新版本，是一个更大的技术集，具有新的元素、属性、行为；
2. 跨平台：H5本身并不能跨平台，但浏览器是跨平台的，如Java语言不跨平台，但JVM是跨平台的；
3. HTML运行在浏览器上，是唯一可以通吃PC、MAC、iPhone、Android、Linux等主流平台的语言。
</code></pre><h3 id="H5与H4"><a href="#H5与H4" class="headerlink" title="H5与H4"></a>H5与H4</h3><pre><code>1. &lt;meta charset=&quot;UTF-8&quot;&gt;：告诉浏览器以utf-8渲染当前的html文档；
2. DOCTYPE
    1. DOCTYPE：Document Type Declaration，文档类型声明，简称DTD
    2. 通常情况下，DOCTYPE在HTML文档的首行位置，因为浏览器在解析HTML正文之前，必须确定
    当前文档的类型，再决定需要采用的渲染模式；
    3. 不同的渲染模式会影响浏览器对于CSS、JS的解析。
3. 浏览器的渲染模式
    1. 目前为止，浏览器主要包括三种渲染模式，在H5草案中规定了模式的定义；
    2. 现代主流浏览器，包括IE9以上的浏览器，三种模式在渲染方面几乎没有区别；
    3. IE7/8/9理论上存在怪异模式，但实际上只有标准模式；
    4. 在IE6中，标准模式和怪异模式的差别最大，而IE6以下的浏览器只有怪异模式。
4. document.compatMode：查看当前的渲染模式，返回两个值CSS1Compat、BackCompat
    1. 标准兼容模式：CSS1Compat，怪异模式：BackCompat
    2. H5文件的首行声明：&lt;!DOCTYPE html&gt; ==&gt;&gt;表示开启标准模式，必须放在首行才有效
    3. 如果不声明&lt;!DOCTYPE html&gt;，或者&lt;!DOCTYPE html&gt;的位置不正确，则开启怪异模式。
5. H4的声明、根标签、META
    &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; ······&gt;
    &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;&quot; charset=&quot;UTF-8&quot; /&gt;
    1. xmlns：XHTML1.0的概念，声明命名空间，而H5中的每个元素都具有此空间，不需要声明；
    2. H5中已经简化了根标签的声明：&lt;html&gt;&lt;/html&gt;
    3. META类型：Content-Type:text/html; 在网络传输声明当前数据类型为html；
    4. 在H5中，Content-Type的声明已经被移植到HTTP中，不需要在&lt;meta /&gt;上声明。
</code></pre><h3 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h3><pre><code>1. 常用的H5语义化标签：&lt;hgroup&gt;、&lt;header&gt;、&lt;nav&gt;、&lt;section&gt;、&lt;footer&gt;、&lt;article&gt;...
    1. 各大浏览器厂商在分析了大量的页面之后，发现&lt;div&gt;的id名称大量重复，如id=&quot;footer&quot;
    标记页脚内容，所以引入了语义化标签；
    2. 这些语义化标签其实也是&lt;div&gt;，它们也没有任何默认样式，除了会让文本另起一行之外；
    3. HTML5通过这些语义化、结构化的代码标签，代替无意义的&lt;div&gt;，提升了网页的质量和语义，
    对搜索引擎也更加友好。
2. 测试H5文档的语义化站点：https://gsnedders.html5.org/outliner/
3. &lt;hgroup&gt;：多个h1-h6的容器，比如文章的主标题和副标题
    1. 如果有连续多个h1-h6标签，就用&lt;hgroup&gt;包裹，如果只有一个h1-h6标签，则不需要；
    2. 如果有连续多个标题和其他数据，则标题放入&lt;hgroup&gt;，并和其他数据一起放入&lt;header&gt;
4. &lt;header&gt;：网页或&lt;section&gt;的页眉，没有个数限制，通常会包含h1-h6或者&lt;hgroup&gt;
5. &lt;nav&gt;：页面的导航区域，用于定义整个页面的主要导航部分
6. &lt;section&gt;：h5文档中的片段，节
7. &lt;article&gt;：表示一个文档，在页面中自成一体的内容
8. &lt;aside&gt;：可用于侧边栏、副导航、附属信息如名词解释
</code></pre><h2 id="prop与attribute"><a href="#prop与attribute" class="headerlink" title="prop与attribute"></a>prop与attribute</h2><pre><code>1. 以复选框为例，checked表示勾选，其属性值并没有类型之分，都是字符串，只要使用了此属性，
   复选框都会被勾选；
    &lt;input type=&quot;checkbox&quot; checked=&quot;checked&quot; /&gt;
    &lt;input type=&quot;checkbox&quot; checked=&quot;true&quot; /&gt;
    &lt;input type=&quot;checkbox&quot; checked=&quot;234&quot; /&gt; &lt;input type=&quot;checkbox&quot; checked /&gt;
2. 标签上固有的属性，称为html预定义属性，如type、check，除此之外，还有html自定义属性；
    &lt;input type=&quot;checkbox&quot; checked=&quot;true&quot; abc=&quot;abc&quot; /&gt; --&gt;abc就是自定义属性
    1. 预定义属性和自定义属性统称为attribute，在元素对象的attributes属性中管理；
    2. JS原生对象的直接属性，被称为property，如attributes
    3. 每一个预定义的attribute都会有一个property与之对应，即attributes中管理的预定义
    属性，在对象的直接属性上也会有一份，但自定义属性不会有；
    元素对象==&gt; {
        attributes: { type:&quot;checkbox&quot;, check:&quot;true&quot;, abc:&quot;abc&quot; },
        type:&quot;checkbox&quot;,
        check:&quot;true&quot;
    }
    4. attributes中管理的属性，是以对象的形式管理的，这些属性对象被称为属性节点，它们都
    具有3个通用的属性，分别是：nodeName、nodeType、nodeValue
    5. 属性节点的nodeType都是2，以type属性为例：&quot;type&quot;, 2, &quot;checkbox&quot;
    6. 操作attributes中的属性：setAttribute()、getAttribute()、removeAttribute()
3. 调试的关键字：debugger
4. attribute与property的关系
    &lt;input type=&quot;checkbox&quot; checked=&quot;true&quot; name=&quot;user&quot; /&gt;
    let pt = document.querySelector(&apos;input[type=checkbox]&apos;)
    1. pt.setAttribute(&apos;checked&apos;, false); --&gt; 操作的是attribute
    2. pt.checked=false; pt[&apos;name&apos;]=&apos;psd&apos;; ---&gt; 操作的是property
    3. 布尔值属性：property是布尔值类型，如checked
    pt.checked=&apos;123&apos;; --&gt;&apos;123&apos;会转为布尔型 --&gt;console.log(pt.checked)--&gt;true
    4. 非布尔值属性：property是非布尔值类型，如name、type
</code></pre><h3 id="attribute与property的同步"><a href="#attribute与property的同步" class="headerlink" title="attribute与property的同步"></a>attribute与property的同步</h3><pre><code>1. 非布尔值属性：attribute与property会立刻实时同步，修改任意一方，另一方也会随之改变；
2. 布尔值属性
    1. 改变property，不会同步修改attribute
    2. 在没有修改过property时，修改attribute，会同步修改property
    3. 一旦修改过property，则不会再同步给attribute
    4. property保存的始终是布尔值，而attribute中保存的则是当前设置的值
    pt.setAttribute(&apos;checked&apos;, &apos;abc&apos;) --&gt;attribute：checked:&apos;abc&apos;
3. 浏览器界面上的操作，影响的是property，还是attributes
    1. 对于非布尔值属性，property和attributes是相互同步的，相对来说，操作attribute的
    成本更低，因为操作property会有一个转换过程；
    2. 鼠标选中/取消复选框，即操作布尔值属性，改变的也是property，不会影响attribute
    3. 即：只有property变化了，浏览器界面上的属性效果才会随之变化，所以操作布尔值属性时，
    务必使用property
</code></pre><h2 id="新增功能"><a href="#新增功能" class="headerlink" title="新增功能"></a>新增功能</h2><pre><code>    &lt;div id=&quot;box&quot; data-test=&quot;123&quot; data-user-name=&quot;Mack&quot;&gt;&lt;/div&gt;
    let node = document.querySelector(&quot;#box&quot;)
1. classList：标签上的CSS选择器的集合
    1. node.classList.add(&quot;test&quot;); --&gt; 添加一个新的选择器test
    2. node.classList.remove(&quot;test&quot;); --&gt; 移出选择器test
    3. node.classList.toggle(&quot;test&quot;); --&gt; 如果有，则移出，反之则添加
2. dataset：标签上的自定义属性的集合
    1. 对于以 data- 开头的自定义属性，都会保存在元素的 dataset 中；
    2. node.dataset.test：获取自定义属性test的属性值，同时可以直接修改此属性值；
    3. 对于 - 连接的自定义属性，必须使用驼峰式操作：node.dataset.userName
    node.dataset[&apos;userName&apos;]，不能使用node.dataset[&apos;user-name&apos;]
    4. node.dataset.password=&apos;abcde&apos;; --&gt;在dataset中新增/修改自定义属性
    5. delete node.dataset[&apos;userName&apos;]; --&gt;删除dataset中的自定义属性
    6. for-in 可以遍历dataset，但for-of不能。
3. attribute操作dataset
    1. node.attributes：获取当前标签显式使用的属性，包括自定义属性；
    2. node.attributes中管理的标签属性，就是标签上的名称，即使是自定义属性，也不会改变
        node.attributes：NamedNodeMap{ id, data-test, data-user-name }
    3. attributes必须使用 for-of 遍历，不能用 for-in
    4. setAttribute()、getAttribute()：也可以操作自定义属性
        node.setAttribute(&apos;data-user-name&apos;, &apos;abc&apos;); --&gt;修改自定义属性
    5. setAttribute(&apos;data-evty&apos;, &apos;12&apos;)：添加自定义属性，因为是以&quot;data-&quot;开头的属性，
    所以该属性也会被 dataset 管理。
4. 让标签内的字符串文本可编辑：contenteditable=&quot;true&quot;
    &lt;div id=&quot;box&quot; contenteditable=&quot;true&quot;&gt;新增标签属性&lt;/div&gt;
</code></pre><h2 id="其他新增标签"><a href="#其他新增标签" class="headerlink" title="其他新增标签"></a>其他新增标签</h2><pre><code>1. &lt;meter&gt;：用于显示已知范围的标量值/分数值，默认样式类似于进度条
    1. value：当前数值
    2. min/max：最小/最大边界值，如果没有设置，默认为0/1
    3. low/high：定义了低值/高值区间的上限值/下限值，value处在低值与高值区间的样式不同
    4. optimum：用于指示最优/最佳的取值。
&lt;meter value=&quot;80&quot; min=&quot;0&quot; max=&quot;100&quot; low=&quot;40&quot; high=&quot;60&quot; optimum=&quot;50&quot;&gt;&lt;/meter&gt;
2. &lt;progress&gt;：用于显示一项任务的完成进度，默认样式为带有单元格的进度条
    1. max：总进度
    2. value：当前完成的进度，如果不设置，进度条不会显示任何进度。
3. 列表标签：datalist、detail、summary
    1. datalist：让input输入框具备可选列表，类似于&lt;select&gt;的列表
    &lt;input type=&quot;text&quot; list=&quot;zdy&quot; /&gt;
    &lt;datalist id=&quot;zdy&quot;&gt; -------------------&gt;通过id属性绑定input
        &lt;option value=&quot;1&quot;&gt;列表标签&lt;/option&gt;
    &lt;/datalist&gt;
    2. detail、summary：展开/折叠
    &lt;detail&gt;
        &lt;summary&gt;用于展开折叠的文本&lt;/summary&gt;
        &lt;p&gt;被折叠的内容&lt;/p&gt;
        &lt;p&gt;被折叠的内容&lt;/p&gt;
    &lt;/detail&gt;
4. 注释标签：ruby、rt，展示文字注音或字符注释
    &lt;span&gt;&lt;ruby&gt;注&lt;rt&gt;zhu&lt;/rt&gt;释单词&lt;/ruby&gt;&lt;/span&gt;  --&gt;&quot;注&quot;的上面会有注音&quot;zhu&quot;
5. 标记标签：&lt;mark&gt;着重内容&lt;/mark&gt;
</code></pre><h3 id="新增表单属性"><a href="#新增表单属性" class="headerlink" title="新增表单属性"></a>新增表单属性</h3><pre><code>1. placeholder：输入框的提示信息，&lt;input type=&quot;text&quot; placeholder=&quot;请输入账号&quot; /&gt;
2. autofocus：指定表单获取输入焦点，布尔值属性，&lt;input type=&quot;text&quot; autofocus /&gt;
3. required：必填项、必选项，不能为空；如果没有内容/选项，在提交表单时会弹框提示；
4. pattern：自定义正则校验，如果不符合正则，提交时会弹框提示；
    &lt;input type=&quot;text&quot; pattern=&quot;\d{1,5}&quot; /&gt;
5. formaction：自定义submit的提交地址；
&lt;form action=&quot;http://www.sina.com&quot;&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交1&quot; /&gt;
    &lt;input type=&quot;submit&quot; value=&quot;提交2&quot; formaction=&quot;http://www.baidu.com&quot; /&gt;
&lt;/form&gt;
6. list属性与&lt;datalist&gt;：为输入框构造一个选择列表。
</code></pre><h3 id="新增表单type类型"><a href="#新增表单type类型" class="headerlink" title="新增表单type类型"></a>新增表单type类型</h3><pre><code>1. type=&quot;email&quot;：email地址类型，type=&quot;tel&quot;：电话类型，type=&quot;url&quot;：URL地址类型
    1. 它们并不会限制输入内容，只是在输入的内容不符合指定的类型格式时，提交不会成功；
    2. 但是在移动端，它们获得焦点时会弹出对应类型的键盘。
2. type=&quot;range&quot;：可拖动的进度条
    1. min(最小值)、max(最大值)、value(当前值)
    2. step：一步跳动的值，如取值范围0-100，step=&quot;20&quot;，相当于分了5步，每一步跳动20
    &lt;input type=&quot;range&quot; min=&quot;0&quot; max=&quot;100&quot; value=&quot;20&quot; step=&quot;20&quot; /&gt;
3. type=&quot;search&quot;：输入框的内右侧会有一个&quot;x&quot;，用于便捷式清空输入的内容；
4. type=&quot;number&quot;：只允许输入数字，输入框获取焦点时，内右侧会有增大(+1)和减小(-1)的按钮；
5. type=&quot;color&quot;：颜色选择器，可以调出颜色选择的面板；
6. 日期时间：type=&quot;datetime&quot;、&quot;datetime-local&quot;、&quot;date&quot;、&quot;time&quot;、&quot;week&quot;、&quot;month&quot;
</code></pre><h3 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h3><pre><code>1. validity对象：通过注册 invalid 事件，查看验证是否通过；
    input.addEventListener(&quot;invalid&quot;, function(){ this.validity }, false)
    1. 提交表单时，如果验证失败，则会触发此事件；
    2. 在回调函数中，通过 this.validity 获取验证对象。
2. validity.valueMissing：输入内容为空时返回true
    &lt;input type=&quot;text&quot; required /&gt; --&gt;没有输入内容时，valueMissing为true
3. validity.typeMismatch：输入的内容与预期类型不匹配时返回true
    &lt;input type=&quot;email&quot; /&gt; --&gt;输入内容不是Email类型时，typeMismatch为true
4. validity.patternMismatch：输入内容不匹配pattern正则时返回true
5. 鸡肋的属性
    1. tooLong：maxLenght属性已经限制了输入内容的长度，所以不会触发此验证属性
    2. rangeUnderflow、rangeOverflow、stepMismatch：&lt;input type=&quot;range&quot; /&gt;相关
6. validity.customError：不符合自定义验证时，则返回true
    1. setCustomValidity()：用于设置自定义验证的提示内容；
    2. setCustomValidity(&quot;&quot;)：设置为空字符串，表示放行，验证通过；
    &lt;form&gt; &lt;input type=&quot;text&quot; name=&quot;user&quot; id=&quot;user&quot; /&gt;
        &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;/form&gt;
    let name = document.querySelector(&quot;#user&quot;)
    let submit = document.querySelector(&quot;input[type=submit]&quot;)
    submit.onclick = function() {
        if(name.value === &apos;123&apos;) { ---&gt; 当输入框中的内容为&quot;123&quot;时，会弹框提示
            name.setCustomValidity(&apos;请不要输入敏感词&apos;) ---&gt; 设置提示框的内容
            console.log(name.validity) --&gt; validity.customError返回true
        } else {
            name.setCustomValidity(&apos;&apos;)
        }
    }
    3. 验证失败时，会阻止表单继续提交。
7. 关闭验证：formnovalidate属性
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/05/09/CSS3-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/09/CSS3-3/" itemprop="url">CSS3-3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-09T00:00:00+08:00">
                2018-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML/" itemprop="url" rel="index">
                    <span itemprop="name">HTML</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="新增布局"><a href="#新增布局" class="headerlink" title="新增布局"></a>新增布局</h2><pre><code>1. table布局是CSS2中唯一为布局为生的，专门为做布局而生的一套属性；
    1. display:table; 可以将一个元素转为table
    2. 但是，table布局并不是流式的，而div布局是流式的；
    3. 网络数据是以流的形式进行传输，对于流式布局，浏览器接收到一段数据，就可以开始渲染；
    4. table布局则不然，必须等到接受完所有数据，浏览器才能开始渲染，性能极其低下；
    4. 而且，更改table布局中的任何一部分数据，整个table都要重新开始渲染。
2. CSS3为布局而生的扩展：flex布局，响应式布局，多列布局(分栏布局)
</code></pre><h2 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h2><pre><code>1. 弹性盒子/布局：使页面布局适应不同的屏幕尺寸和不同的显示设备，所以常用于移动端布局；
    1. 弹性盒子模型提供了对块盒子模型的改进，因为它不使用浮动；
    2. flex容器的边缘也不会与其内容的边缘发生折叠。
2. flex布局经历了2个版本：老版本display:box; 新版本display:flex;
    1. Android4.4之前只支持老版本，4.4开始支持新版flex；
    2. Less、Sass和Stylus是CSS预处理器，使CSS可以工程化开发；
    3. PostCSS是CSS后处理器，但它像是一种插件系统，用于处理CSS的兼容性问题；
    4. Autoprefixer就是PostCSS的一个非常受欢迎的插件。
3. flex布局在容器上声明，作用于容器中的子元素，且新版与老版的布局效果是不同的；
    &lt;div id=&quot;box&quot;&gt; ---&gt; 容器
        &lt;div class=&quot;item&quot;&gt;1&lt;/div&gt; ---&gt; 项目
        &lt;div class=&quot;item&quot;&gt;2&lt;/div&gt;
        ......
    &lt;/div&gt;
    #box {
        display: -webkit-box;  --&gt; 老版
        display: flex; --&gt; 新版
    }
    1. 容器内管理的子元素称为项目，容器与项目上分别使用不同的flex属性；
    2. flex布局中存在两条坐标轴：主轴、侧轴，由flex-direction/-webkit-box-orient控制
    3. 当指定X轴为主轴时，Y轴为侧轴，反之亦然！项目永远排列在主轴的正方向上！
4. 富裕空间：容器box的宽高为(400px,400px)，每个项目的宽高为(50px,50px)，共用4个项目；
    1. 假设项目的margin都是0px，X轴为主轴，那么主轴的富裕空间为(400-50*4=200px, 50px)
    2. 侧轴的富裕空间为(width:400px, height:400-50=350px)
</code></pre><h3 id="了解老版本的容器"><a href="#了解老版本的容器" class="headerlink" title="了解老版本的容器"></a>了解老版本的容器</h3><pre><code>1. 尽管PostCSS的插件系统可以处理大部分CSS3的兼容性问题，但仍需要了解以下老版flex布局；
2. 容器中的布局方向：-webkit-box-orient
    1. -webkit-box-orient的本质是确定X轴和Y轴中的哪一根为主轴，默认是X轴；
    2. -webkit-box-orient: horizontal(X轴)/vertical(Y轴);
    3. 项目排列在主轴上，主轴改变了，项目的排列位置也随之改变！
3. 容器中的排列方向：-webkit-box-direction，用于控制主轴的正方向
    1. -webkit-box-direction: normal/reverse(反向);
    2. 项目沿着主轴的正方向排列，主轴的正方向改变了，项目的排列方式也随之改变。
4. 富裕空间管理：-webkit-box-pack(主轴)，-webkit-box-align(侧轴)
    1. 它们不会给项目去分配任何空间，只是用于确定富裕空间的位置；
    2. 老版本管理富裕空间的位置与主轴/侧轴的正方向无关，造成新老版本的项目排列位置不同。
5. -webkit-box-pack: start/end/center/justify; --&gt; 管理主轴的富裕空间
    1. X轴是主轴：在主轴的右边(start)/左边(end)/两边(center)/项目之间(justify)
    2. Y轴是主轴：在主轴的下面(start)/上面(end)/两边(center)/项目之间(justify)
6. -webkit-box-align: start/end/center; --&gt; 管理侧轴的富裕空间
    1. X轴是侧轴：在侧轴的右边(start)/左边(end)/两边(center)
    2. Y轴是侧轴：在侧轴的下面(start)/上面(end)/两边(center)
</code></pre><h3 id="新版本的容器"><a href="#新版本的容器" class="headerlink" title="新版本的容器"></a>新版本的容器</h3><pre><code>1. 容器中的布局方向和排列方向：flex-direction
    1. flex-direction: row/column/row-reverse/column-reverse;
    2. row、row-reverse：主轴为x轴，正方向分别是从左往右、从右往左
    3. column、column-reverse：主轴为y轴，正方向分别是从上往下、从下往上
2. 富裕空间管理：justify-content，align-items
    1. justify-content、align-items分别管理主轴、侧轴的富裕空间；
    2. 富裕空间的位置与主轴/侧轴的正方向有关。
3. justify-content：管理主轴的富裕空间
    1. flex-start/flex-end：富裕空间在主轴的正方向上/反方向上；
    2. center：在主轴的两边，即项目会在主轴上居中显示；
    4. space-between：在项目之间，第一个和最后一个分别只有一边有富裕空间；
    5. space-around：富裕空间在项目两边，每个项目的两边都有富裕空间；
4. align-items：管理单行/列项目时侧轴的富裕空间
    1. flex-start/flex-end/center：富裕空间在侧轴的正方向/反方向/两边；
    2. baseline：按基线对齐，基线是line-height的相关概念；
    3. stretch：默认值，等高布局，如果项目没有设置高度，则把它们拉伸到相同的高度。
5. flex-wrap：当容器的主轴空间不足时，控制项目是否换行；
    1. nowrap：默认值，不换行，压缩项目的宽度/高度，不让它们超出容器；
    2. wrap/wrap-reverse：换行，以行为单位、沿着侧轴的正/反方向排列；
    3. 换行时，默认会等分侧轴的富裕空间，此时由align-content属性管理侧轴的富裕空间。
6. align-content：管理多行/列项目时的侧轴富裕空间，只有一行/列则无效；
    1. 属性值：flex-start/flex-end/center/space-between/space-around/stretch
    2. 只有在设置了flex-wrap:wrap/wrap-reverse; 设置的align-content才有效。
7. flex-flow：flex-direction和flex-wrap的简写形式，默认值row nowrap
</code></pre><h3 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h3><pre><code>1. order：默认值为0，数值越大，项目越靠后排列，精确控制每个项目的排列顺序，如order:5;
2. align-self：管理单个项目的侧轴富裕空间
    1. 属性值：auto/flex-start/flex-end/center/baseline/stretch
    2. auto：默认使用容器上的align-items属性值，如果容器上没有设置，则使用stretch
    3. 多行项目时，align-self相对于当前行的侧轴富裕空间，且优先级小于align-content
    4. 单行时，align-self的优先级大于align-items
</code></pre><h4 id="弹性空间管理"><a href="#弹性空间管理" class="headerlink" title="弹性空间管理"></a>弹性空间管理</h4><pre><code>1. flex-grow、flex-shrink、flex-basis
2. flex-grow：定义弹性盒子(项目)的拉伸因子，默认值为0
    flex-grow: 1; --&gt;对应的老版本：-webkit-box-flex: 1;
    1. 把主轴上的富裕空间按比例分配到每个项目的width(X轴)/height(Y轴)上；
    2. 属性值为弹性因子，也就是分配富裕空间时所占的权重、比例，弹性因子越大，分配越多。
3. flex-shrink：收缩因子，容器空间不足时，指定项目被压缩的比例(项目不能换行)，默认值为1
4. flex-basis：项目在主轴的方向的初始大小，也就是伸缩的基准值
    1. 默认值是auto，但在flex简写属性中，默认值为0
    2. X轴为主轴时，如果没有设置项目的flex-basis，那么flex-basis的值为项目的width
5. flex-grow的拉伸规则(X轴为主轴)
    1. 可用空间 = 容器大小 - 所有相邻项目flex-basis的总和
    2. 可扩展空间 = 可用空间 / 所有相邻项目flex-grow的总和
    3. 每个项目伸缩后的真实大小 = flex-basis + 可扩展空间 x flex-grow
    &lt;div id=&quot;box&quot;&gt; ---------&gt; #box{ width:400px; height:300px; display:flex; }
        &lt;div&gt;11&lt;/div&gt; &lt;div&gt;22&lt;/div&gt; &lt;div&gt;33&lt;/div&gt; &lt;div&gt;44&lt;/div&gt; &lt;div&gt;55&lt;/div&gt;
    &lt;/div&gt; --------------&gt; #box &gt; div{ width:50px; height:50px; flex-grow:1; }
    #box &gt; div:nth-child(1){ flex-grow:4; }
    1. 可用空间 = 400 - 5*50 = 150px
    2. 可扩展空间 = 150/(1*4+4) = 18.75px
    3. 第1项伸缩后的width：50 + 18.75 * 4 = 125px
    4. 第2/3/4/5项伸缩后的width：50 + 18.75 * 1 = 68.75px
6. flex-shrink的收缩规则(X轴为主轴)
    1. 计算收缩因子与基准值乘的总和 = 所有项目的(flex-basis x flex-shrink)之和
    2. 计算收缩因数 = 项目的收缩因子 x 项目flex-basis / 收缩因子与基准值乘的总和
    3. 每个项目需要减去的大小 = 收缩因数 x 项目溢出容器的大小
    #box{ width:100px; height:300px; display:flex; }
    #box &gt; div{ width:50px; height:50px; flex-shrink:1; }
    #box &gt; div:nth-child(1){ width:200px; }
    1. 收缩因子与基准值乘的总和 = 200*1 + 50*1*4 = 400
    2. 第1项的收缩因数 = 1*200/400 = 1/2，第2/3/4/5项的收缩因数 = 1*50/400 = 1/8
    3. 第1项需要减去的大小 = 1/2 * (200 + 50*4 - 100) = 150px
    4. 第2/3/4/5项需要减去的大小 = 1/8 * (200 + 50*4 - 100) = 37.5px
    5. 第1项收缩后的width = 200 - 150 = 50px
    6. 第2/3/4/5项收缩后的width = 50 - 37.5 = 12.5px
7. flex-shrink收缩规则的前提(X轴为主轴)
    1. flex-shrink不会把项目的width缩减为0，flex布局会考虑项目的内容；
    2. 如果项目中的内容宽度大于最终收缩后的项目宽度，那么项目的实际宽度就是内容所占的宽度，
    至于多占用的宽度，会让其他项目一起承担；
    3. 所以，在设计flex布局时，需要精确考虑项目中的内容，不能太多；
    4. 老版本并没有这些专用控制伸缩的属性，在老版本上有可能把项目收缩为0
8. flex的简写属性
    1. flex: 1; --&gt; flex-grow:1; flex-shrink:1; flex-basis:0%;
    2. flex: 1; 实现等分布局，每个项目在主轴上的width/height是相同的；
    2. flex实现有规律的布局极其简单，如等比例、等分、居中... ，所以在移动端大行其道。
</code></pre><h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><pre><code>1. CSS3的媒体查询是响应式布局方案的核心技术，媒体查询选择器以 @media 开头；
2. 媒体查询选择器不会对CSS的特殊性有任何贡献，即不会影响选择器的优先级。
</code></pre><h3 id="媒体类型"><a href="#媒体类型" class="headerlink" title="媒体类型"></a>媒体类型</h3><pre><code>1. all(所有媒体，默认)，screen(彩色屏幕)，print(打印预览)
2. projection(手持设备)，tv(电视)，braille，embossed，speech，tty...
3. PC端、移动端都是彩色屏幕，属于screen的范围
    @media screen { --&gt;定义彩色屏幕上的选择器样式，类似于if-else条件表达式
        #wrap{ background:red; } --&gt;在彩色屏幕上，id选择器wrap上的背景色为red
    }
</code></pre><h3 id="媒体属性"><a href="#媒体属性" class="headerlink" title="媒体属性"></a>媒体属性</h3><pre><code>1. width、height：浏览器窗口的宽度、高度，可以加max、min前缀，height很少使用
    @media screen and (min-width:800px) {
        #wrap{ background:red; } --&gt;彩色屏幕且浏览器窗口的宽度&gt;=800px时，样式生效
    }
2. device-width：设备宽度，屏幕分辨率，如1280X720，可以加max、min前缀
    @media screen and (min-device-width:1280px) { ... }
    1. 彩色屏幕且设备分辨率的宽度&gt;=1280px时，样式生效
3. device-pixel-ratio：像素比，DPR，必须加webkit前缀，也可以加max、min前缀
    @media screen and (-webkit-min-device-pixel-ratio:1) { ... }
    1. 彩色屏幕且DPR&gt;=1时，样式生效
4. orientation：portrait(竖屏width=&lt;height)，landscape(横屏width&gt;height)
    @media screen and (orientation:landscape) { ... }
    1. 彩色屏幕且浏览器窗口为横屏时，样式生效
</code></pre><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><pre><code>操作符/关键字：only，and，or，not
1. and、or、not：连接媒体类型与媒体属性，分别表示与、或、非；其中，or用&quot;,&quot;表示
    @media screen and (max-width:800px), (orientation:landscape) { ... }
    1. 彩色屏幕且浏览器窗口的宽度&lt;=800px时生效，亦或者屏幕为横屏时生效；
    2. or(,)后面只有媒体属性，没有声明媒体类型，则默认媒体类型为all
2. only：与浏览器的兼容性有关，老版本浏览器只支持媒体类型，不支持带有媒体属性的选择器
    @media screen and (min-width:800px){ ... }
    1. 老版本浏览器会解析为：@media screen { ... } --&gt;在老版本浏览器中，不管浏览器窗口
    的宽度是否&gt;=800px，样式始终生效
    2. 老版本浏览器只识别到 @media 后的第一个标识符，如果该标识符不属于媒体类型，则忽略
    @media only screen and (width:800px){ } --&gt;老版本浏览器解析为：@media only { }
    3. only不属于媒体类型，该媒体查询会被老版本浏览器忽略，该媒体查询选择器不会生效；
    4. 防止老旧浏览器不支持带媒体属性的查询，所以建议在媒体查询时都加上only
3. not
    @media not screen and (width:800px), (orientation:landscape) { ... }
    1. 生效条件：(不是彩色屏幕 || 浏览器尺寸!=800px) || (屏幕为横屏)
    2. 老版浏览器会解析成 @media not{ }，而not不属于媒体类型，所以该媒体查询选择器也不会
    生效，也就不需要再加only
</code></pre><h2 id="多列布局"><a href="#多列布局" class="headerlink" title="多列布局"></a>多列布局</h2><pre><code>&lt;div id=&quot;box&quot;&gt;多列布局······分栏布局······多列布局······分栏布局&lt;/div&gt;
#box{ width:600px; border:1px solid #000000; }
1. 栏目宽度：column-width，指定每一列的宽度
    1. column-width: 100px; --&gt;每一列的宽度为100px
    2. 尽管指定了每一列的宽度，但很难均分容器的width，最后分出来的列数可能只有5列
2. 栏目列数：column-count，指定需要分成多少列
    1. column-count:3; --&gt;把容器的内容分为3列
    2. 比column-width更友好、更强大，只需要指定列数，每一列的宽度会自动配分
3. 列与列的间距：column-gap，列与列之间的距离
4. 列与列的分割线：column-rule，列与列之间添加分割线，并设置分割线的样式
    column-rule: 1px solid red;
</code></pre><h2 id="CSS3的兼容性前缀"><a href="#CSS3的兼容性前缀" class="headerlink" title="CSS3的兼容性前缀"></a>CSS3的兼容性前缀</h2><pre><code>1. -ms-：兼容IE
2. -moz-：兼容firefox
3. -o-：兼容opera
4. -webkit-：兼容chrome和safari
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/05/08/CSS3-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/08/CSS3-2/" itemprop="url">CSS3-2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-08T00:00:00+08:00">
                2018-05-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML/" itemprop="url" rel="index">
                    <span itemprop="name">HTML</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h2><pre><code>1. transition：过渡动画
    1. CSS的效率极高，速度极快，为此，CSS transition提供了一种在更改CSS属性时，控制动画
    速度的方法，它让属性变化持续一段时间，而不是立即生效；
    2. 比如，改变一个元素的颜色时，可以用transition逐渐从原色变为目标色；
    3. 对于transition作用的属性，不管以哪种方式发生了变化，即使是JS操作，也会执行；
    4. 但是，并不是所有的属性变化都支持transition，比如display:none;
    5. transition只关心元素的初始状态和结束状态，无法定制过渡动画中的每一帧状态。
2. transition-property：指定使用过渡的属性，可指定多个，默认为all(所有变化的属性)
3. transition-duration：动画执行的时间，必须以秒(s)和毫秒(ms)为单位，默认值为0s
    &lt;div id=&quot;wrap&quot;&gt; &lt;div id=&quot;inner&quot;&gt;&lt;/div&gt; &lt;/div&gt;
    #wrap { width:600px; height:600px; border:1px solid red; }
    #inner { width:200px; height:200px; background:red; }
    1. 鼠标悬浮在wrap上时，让inner的宽高变小
    #wrap:hover #inner{ width:100px; height:100px; background:green; }
    2. 让wrap的宽度变化有过渡动画，且动画时间为5s
    #inner{ transition-property:width; transition-duration:5s; }
    3. 动画会执行两次，分别是悬停在wrap上(hover事件)、移出wrap(恢复初始状态)
    4. -duration的复制原理：当指定的属性列表大于时间列表时，时间列表会拷贝一份
    transition-property: width,height,background;
    transition-duration: 5s,2s; --&gt; 5s,2s,5s,2s --&gt; 最后一个2s会被裁剪
    5. 时间列表中有任何一个值不加单位，整个动画机制都会失效。
4. transition-timing-function：变化的过程，变化速率的曲线，默认ease(加速然后减速)
    1. 如果速率列表小于属性列表，缺少的速率会被设置为默认值ease，反之会被裁剪；
    2. liear(匀速)、ease-in(加速)、ease-out(减速)、ease-in-out(加速然后减速)
    3. cubic-bezier(贝塞尔曲线)、step-start、step-end、steps(number, ...)
    4. step-start、step-end分别等同于steps(1,start)、steps(1,end)
    5. steps(start, end)：第一个参数必须是正整数，表示函数的步数，第二个值表示每一步发生
    变化的时间点，默认值end
5. transition-delay：动画执行的延迟时间，复制原理与-duration相同；
6. 过渡动画的完成事件
    1. 标准浏览器下的完成事件是transitionend，而webkit下是webkitTransitionEnd
    2. 每一个拥有过渡动画的属性，在完成动画时都会分别触发一次transitionend事件；
    3. 在过渡动画完成之前，设置display:none; 不会再触发transitionend事件。
7. transition的天然缺陷
    1. 缺陷一：动画是浏览器的渲染机制进行渲染的，其渲染速度要小于CSS、JS的解析速度
    #inner { transition-property:width; transition-duration:2s; }
    #wrap:hover #inner{ transition-property:height; --&gt;修改过渡动画作用的属性
        width:100px; height:100px; }
    2. hover事件迅速修改了transition作用的属性，等到浏览器的渲染机制执行动画时，发现使用
    过渡动画的属性是height，所以对height执行transition动画；
    3. 鼠标移出wrap时，transition作用的属性又恢复为width，所以渲染机制对width执行动画。
    2. 缺陷二：transition在元素首次渲染还没有结束的情况下，是不会被执行的；
    let inner = document.querySelector(&quot;#inner&quot;)
    inner.style[&apos;width&apos;] = &apos;100px&apos; --&gt;虽然放在&lt;body&gt;之后执行，但也不会触发动画
    3. JS要触发transition，必须在window.onload的回调函数中执行，等待页面渲染完成。
8. transition的简写：transition: property,duration,timing-function,delay
    1. 同时设置多个属性：transition: 2s 3s width, 3s height;
    2. 第一个时间被解析为动画执行的时间，第二个时间被解析为动画的延迟时间；
    3. width的动画时间为2s，延迟时间为3s，height的执行时间为3s，延迟时间为0s
</code></pre><h2 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h2><pre><code>1. transform：变形，2D变换，只对块级元素有效；
2. transform是静态效果，并不会有过渡动画，需要配合transition属性；
3. 旋转：transform: rotate(360deg);
4. 平移
    1. 水平移动：transform: translateX(200px); --&gt; 向右平移200px
    2. 垂直移动：transform: translateY(400px); --&gt; 向下平移400px
    3. 指定坐标点的移动：transform: translate(100px,100px); --&gt;坐标(100,100)
    4. 设置为负值表示反向移动，translate()只设置一个值时，表示Y轴为0px
    5. translate(x,y)使用百分比时，分别参照自身的width和height
5. 斜切：skewX(45deg)、skewY(45deg)、skew(45deg, 45deg)
    transform: skewX(45deg); --&gt;沿X轴斜切45°，支持负值
6. 缩放：scale()、scaleX()、scaleY()
    1. 缩小的范围为0-1，放大的范围则大于1，负值有旋转效果，不推荐使用；
    transform: scaleX(.5); --&gt; 0.5, 缩小一倍
    2. scale(x, y)：只设置一个值时，表示x与y相等。
7. 基点的变换：transform-origin，改变元素变形的基点
    1. 支持关键字：left、right、top、bottom、center
    #inner{ transition:2s; transform-origin:left top; } -&gt;以盒子左上角为基点
    2. 也支持px值和百分比，以盒子的左上角为原点(0, 0)
    #inner{ transition:2s; transform-origin:10px 10px; } -&gt;基点(10,10)
    3. 旋转、斜切、缩放的基点默认都是盒子的中心点(50%,50%)
8. transform不会影响文档流，盒子的位移、缩放等不会改变相邻盒子的位置，性能更高。
</code></pre><h3 id="变换组合"><a href="#变换组合" class="headerlink" title="变换组合"></a>变换组合</h3><pre><code>1. 所有2D变换的底层实现都是依靠矩阵：transform: matrix(a,b,c,d,e,f);
    1. 平移对应的矩阵：transform: matrix(1,0,0,1,X,Y);
    2. transform: matrix(1,0,0,1,300,0); --&gt;平移300px
2. 变换组合的底层渲染就是矩阵计算，且矩阵计算的方向是从右向左
    transform: translateX(100px) scale(0.5); --&gt;平移与缩放的组合
    1. 原理：先计算缩放的矩阵，再计算位移的矩阵，且矩阵的运算是不可逆的；
    2. 组合变换的位置不同，矩阵的计算结果也不同，展现的过程和结果也不相同。
3. 在切换组合变换的样式时，必须保证组合变换的个数、位置相同，否则可能不会执行过渡；
    if(flag) {
        box.style.transform = &apos;rotate(-720deg) scale(1)&apos;
    } else {
        box.style.transform = &apos;rotate(0deg) scale(1)&apos;
    }
4. 扇形导航：定位、transform、勾股定理、三角函数、角度与弧度的转化
5. 时钟：通过JS批量处理HTML节点与style样式，transform-origin改变元素变换的基点
</code></pre><h2 id="3D变换"><a href="#3D变换" class="headerlink" title="3D变换"></a>3D变换</h2><pre><code>1. 3D变换：3D缩放、3D旋转、3D平移
2. 3D旋转
    1. transform: rotate(360deg); 默认就是按照Z轴旋转，等同于rotateZ(360deg);
    2. rotateX(360deg); rotateY(360deg); 分别按照X轴、Y轴旋转
    3. rotate3d(x,y,z,deg)：(x,y,z)表示3D空间的一个点，坐标原点到(x,y,z)形成一条射线，
    元素按照这条射线旋转。
3. 3D平移
    1. transform: translateZ(100px); Z轴不支持百分比，只有X轴和Y轴支持；
    2. translate3d(x,y,z);
4. 3D缩放：transform: scaleZ(2);
</code></pre><h3 id="景深"><a href="#景深" class="headerlink" title="景深"></a>景深</h3><pre><code>1. 景深：激活3D空间，元素会有近大远小的效果，营造立体空间感
    1. 简单讲，景深就是肉眼距离显示器的距离，景深越大，元素离眼睛越远，反之越近；
    2. 景深是不可继承属性，但其所有的后代元素都会受影响，应用景深的元素称为舞台元素。
2. 两种使用方式：transform:perspective(depth);  perspective:depth;
    1. transform:perspective(depth); 直接作用的当前元素本身，且必须放在transform的
    第一个位置，否则会被忽略；
    2. perspective:depth; 作用在子元素上，使用该属性的元素只是作为一个包裹器；
    3. depth的默认值为none，可以设置一个px值，表示沿着Z轴到坐标原点的距离。
3. 原理：景深越大，灭点越远，元素变形越小，反之亦然；
    1. 灭点：元素变形后，一直向远处的方向，会有一个交叉点，称之为灭点
    2. 以火车铁轨为例，一直沿着铁轨向远处眺望，会发现两条铁轨逐渐靠近，最终交叉成一个点。
4. perspictive-origin：控制景深的基点，默认值是盒模型宽高的(50% 50%)
5. 景深叠加
    1. 如果当前元素已经使用了景深，其后代元素也应用了景深，效果会叠加，而不是覆盖；
    2. 每款浏览器的景深叠加是不同的，所以尽量避免景深叠加，后代元素不要再使用景深。
</code></pre><h3 id="3d舞台"><a href="#3d舞台" class="headerlink" title="3d舞台"></a>3d舞台</h3><pre><code>1. 3D舞台：只有近大远小的效果是不够的，需要营造具有层级的3d舞台；
2. transform-style：3D舞台，不可继承，作用于子元素，而不是元素自身；
    transform-style: preserve-3d;
3. backface-visibility：是否显示元素的背面，默认值visible(显示)，hidden(隐藏)
    1. 对于立体的元素，设置了透明度后，可以看到其他位面，此属性可以隐藏其他位面；
    2. 以立方体为例，隐藏其他位面之后，只保留正向的位面。
</code></pre><h4 id="transition旧版"><a href="#transition旧版" class="headerlink" title="transition旧版"></a>transition旧版</h4><pre><code>待整理
1. transition-property：设置过度的属性，比如width、height、background-color；
2. transition-duration：设置过度的时间，比如 1s，500ms；
3. transition-timing-function：设置过度的运动方式；
    1. linear 匀速；ease 开始和结束慢速；ease-in/ease-out 开始/结束是慢速；
    2. ease-in-out 开始和结束时慢速；cubic-bezier(n,n,n,n) 设置曲线；
4. transition-delay：设置动画的延迟；
5. 复合属性的设置：transition:property duration timing-function delay;
6. 动画播放：
    1. 为盒子添加hover事件，当鼠标悬停在盒子上时，开始播放动画；
    1. width、height、background-color、border-radius的播放顺序与排列顺序有关；
    2. 每种动画同时播放：transition:all 500ms ease;
    3. 曲线设置的网站：https://matthewlein.com/tools/ceaser
</code></pre><h4 id="transform旧版"><a href="#transform旧版" class="headerlink" title="transform旧版"></a>transform旧版</h4><pre><code>待整理
1. translate(x, y)：盒子位移到(x, y)的像素坐标点，单位是px；
    1. 三维移动：translateX(10px)、translateY(10px)、translateZ(10px)
2. scale(x, y)：盒子缩放，x=y=1，表示原始大小，x=y=0.5，表示盒子大小的一半；
3. rotate(x)：盒子旋转，x表示角度，单位是deg，支持正负值，默认是Z轴旋转；
    1. 三维旋转：rotateX(30deg)、rotateY(30deg)、rotateZ(30deg)
4. skew(x, y)：斜切，x、y表示X轴和Y轴斜切的角度，单位是deg；
5. perspective(x)：设置透视距离，单位是px；
    1. 三维操作需要配合透视距离才能显现效果，特征：近大远小；
    2. 通常设置为800px，更容易欺骗眼睛。
6. transform-style：盒子是否按3D空间显示，flat/perserve-3d；
8. backface-visibility：设置盒子背面是否可见，默认可见visible，hidden表示不可见；
    1. rotateY(180deg)：盒子沿Y轴旋转180度，若设置背面不可见，盒子会隐藏；
</code></pre><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><pre><code>1. animation：动画，作用的元素一旦加载就会执行动画，不会等待页面完全渲染；
    1. 人类具有视觉暂留的特性，人的眼睛在看到一幅画或一个物体后，在0.34s内不会消失；
    2. 动画的原理：把人物的表情、动作、变化等分解后，画成许多动作瞬间的画幅，利用视觉暂留的
    特性，在一幅画消失之前，播放下一幅画，就会给人造成一种流畅的视觉变化效果。
    3. CSS3动画：将元素从一个样式逐渐过渡到另一种样式的效果。
2. @keyfrmes 关键帧(动画的标识) { from{ //动画的初始状态 }  to{ //动画的结束状态 } }
</code></pre><h3 id="动画属性"><a href="#动画属性" class="headerlink" title="动画属性"></a>动画属性</h3><pre><code>1. animation-name：关键帧的名称，none表示无关键帧；
2. animation-duration：动画的时间，默认值为0s，表示无动画，单位为s、ms
    &lt;div id=&quot;box&quot;&gt;&lt;/div&gt; --&gt;div{ width:100px; height:100px; }
    #box{ animation-name:move; animation-duration:3s; }
    @keyframes move { ---&gt; 旋转360°的动画关键帧
        from{ transform: rotate(0deg); }
        to{ transform: rotate(360deg); }
    }
3. animation-timing-function：动画的执行函数，默认是由慢变快再变慢
    1. linear：线性过渡，等同于贝塞尔曲线(0, 0, 1, 1)
    2. ease：平滑过渡，等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0)
    3. ease-in：慢-&gt;快，等同于贝塞尔曲线(0.42, 0, 1, 1)
    4. ease-out：快-&gt;慢，等同于贝塞尔曲线(0, 0, 0.58, 1)
    5. ease-in-out：慢-&gt;快-&gt;慢，等同于贝塞尔曲线(0.42, 0, 0.58, 1)
    6. steps(n, start|end)：第一个参数表示把动画分成n等分，第二个参数默认为end
4. animation-delay：动画执行的延迟时间，属于动画外的范畴；
5. animation-iteration-count：动画的执行次数，重复执行的是关键帧，from-&gt;to
    1. 与name、duration、function都是属于表示动画内的范畴；
    2. 动画的执行时间为1s，执行次数为3，延迟时间为1s，那么动画只会在开始时延迟1次，重复时
    不会再延迟；
    3. infinite：无限循环。
6. animation-direction：动画执行的方向，默认值normal，reverse表示反向
    1. reverse反向的是关键帧和执行函数，关键帧：to-&gt;from，ease-in：快-&gt;慢
    2. alternate：执行次数大于1时，让动画连续执行，from-&gt;to-&gt;from-&gt;to-&gt;from-&gt;...
    3. alternate-reverse：to-&gt;from-&gt;to-&gt;from-&gt;to-&gt;...
7. animation-fill-mode：元素在动画外的状态，默认情况下，动画执行完还会回到元素的初始状态
    1. backwards：元素的初始状态与from中定义的状态保持一致；
    2. forwards：动画执行结束后，元素的状态与to中定义的状态保持一致；
    3. both：元素的初始状态和结束状态分别与from、to中定义的状态保持一致。
8. animation-play-state：动画的执行与暂停，paused(暂停)，running(执行)
    #box:hover { animation-play-state:parsed; } --&gt;鼠标悬停在box上时，动画暂停
9. 简写属性：animation: name duration function delay count direction mode state;
    1. 第一个time会分配给duration，第二个time会分配给delay
    2. animation: 2s 3s; --&gt; 动画执行时间为2s，延迟时间为3s
</code></pre><h3 id="关键帧"><a href="#关键帧" class="headerlink" title="关键帧"></a>关键帧</h3><pre><code>1. 关键帧：@keyframes
    @keyframes name {
        keyframes-selector { css声明; }
    }
    1. name：动画的名称，必选项；
    2. keyframes-selector：动画持续时间的百分比，from相当于0%，to相当于100%
    @keyframes move {
        0% { transform: translateY(-100px); } --&gt;动画的初始状态
        50% { transform: translateY(-50px); } --&gt;动画时间执行50%时的状态
        100% { transform: translateY(100px); } --&gt;动画时间执行结束时的状态
    }
    1. animation-timing-function作用于一个动画周期，而非整个动画周期；
    2. 0% -&gt; 50%，50% -&gt; 100% 表示两个动画周期
2. animation-timing-function: steps(n, start|end);
    @keyframes move {
        0%{ transform: translateY(-100px); }
        25%{ transform: translateY(-90px); }
        50%{ transform: translateY(0px); }
        75%{ transform: translateY(90px); }
        100%{ transform: translateY(100px); }
    }
    animation: move 4s both running 3 alternate steps(1, end);
    1. n：表示把一个动画周期分成n步执行，1 表示一步执行完，跳变执行，没有过渡动画；
    2. 执行时间为4s，执行次数为3，那么总的动画执行时间为3*4s=12s
1. steps(1, end)的执行过程：
    0% 等待1s -&gt; 25% 等待1s -&gt; 50% 等待1s -&gt; 75% 等待1s =&gt; 动画执行1次=&gt; 75% 等待1s
    -&gt; 50% 等待1s -&gt; 25% 等待1s -&gt; 0% 等待1s =&gt; 执行2次=&gt; 0% 等待1s -&gt; 25% 等待1s-
    -&gt; 50% 等待1s -&gt; 75% 等待1s =&gt; 执行3次=&gt; 100% =&gt; 动画结束
    1. 动画执行1次结束、开始执行第2次时，还会在75%的状态等待1s，相当于在75%等待了2s
    2. 同理，第2次执行结束、开始执行第3次时，也会在0%再等待1s
    3. 其实，第3次执行结束后，动画已经结束了，但因为animation-fill-mode:both; 所以元素
    最后的状态必须处在最后一帧，即100%的状态；
    4. 综上所述，end是看不到最后一帧的，也就是100%时的状态。
2. steps(1, start)的执行过程：
    25% 等待1s -&gt; 50% 等待1s -&gt; 75% 等待1s -&gt; 100% 等待1s =&gt; 执行1次 =&gt; 100% 等待1s
    -&gt; 75% 等待1s -&gt; 50% 等待1s -&gt; 25% 等待1s =&gt; 执行2次=&gt; 25% 等待1s -&gt; 50% 等待1s
    -&gt; 75% 等待1s -&gt; 100% 等待1s =&gt; 动画结束
    1. 动画开始执行时，已经从0%跳变到25%，所以在这个动画的执行过程中，都没有0%的状态；
    2. 所以，start是看不到第一帧的，也就是0%时的状态。
3.steps()的跳变动画，可用于实现连环画的效果，比如GIF表情包
    1. 以微信的兔斯基表情为例，一张连续动作的静态图片，假设一共12个动作，加上最后一张空白
    2. 把图片设置为background-image的属性值，再通过animation修改background-position
    @keyframes move { from{} to{}}
    3. steps(12, end)：把 from-&gt;to 的一个周期划分为12步，即12帧，再设置次数为infinite
    4. end看不到最后一帧，但动作表情是12个，第13个是空白，用于占位，所以刚好看不到第13帧
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/05/07/CSS3-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/07/CSS3-1/" itemprop="url">CSS3-1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-07T00:00:00+08:00">
                2018-05-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/HTML/" itemprop="url" rel="index">
                    <span itemprop="name">HTML</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><pre><code>1. 基本选择器的扩展
    1. E &gt; F { ... }：直接后代选择器，匹配E的直接后代F，第一层级的子元素；
    2. E + F：相邻兄弟选择器，只匹配与E相邻的下一个兄弟F；
    3. E ~ F：通用兄弟选择，匹配E的所有兄弟F；
    4. 测试时不能使用可继承的属性，如color，必须使用不可继承的属性。
2. CSS没有版本之分，只有级别，CSS3指的是CSS的第三个级别；
3. 属性选择器
    1. E[attr]：使用了选择器E，且使用了属性attr，如#box[name]{ color: #0000ff; }
    2. E[attr=&quot;val&quot;]：属性名为attr，且属性值为val，如div[name=&quot;box&quot;]{ ... }
    3. E[attr~=&quot;val&quot;]：属性值是一个以空格作为分割的列表，其中至少一个值为val
    &lt;div name=&quot;box cnb cty&quot; class=&quot;test&quot;&gt;&lt;/div&gt; ===&gt; .test[name~=&quot;cnb&quot;]{...}
    4. E[attr|=&quot;val&quot;]：attr的属性值为val，或以&quot;val-&quot;开头；
    5. E[attr^=&quot;val&quot;]：属性值以&quot;val&quot;开头；
    6. E[attr$=&quot;val&quot;]：属性值以&quot;val&quot;结尾；
    7. E[attr*=&quot;val&quot;]：属性值的字符串中包含&quot;val&quot;
    8. E并不是属性选择器的构成部分，也是选择器，是为了限制属性选择器的作用范围。
</code></pre><h3 id="伪类与伪元素选择器"><a href="#伪类与伪元素选择器" class="headerlink" title="伪类与伪元素选择器"></a>伪类与伪元素选择器</h3><pre><code>1. 伪类：并存在于DOM树中，只是为了让CSS有能力获取DOM节点以外的元素状态；
2. 链接伪类：只能应用与&lt;a&gt;，:link、:visited、:target(选中锚点URI对应的id样式)
    a:link{ color: black; } --&gt;未访问过的样式
    a:visited{ color: red; } --&gt;访问过的样式，必须清除浏览器的历史纪录才能还原样式
    1. :visited与浏览器地址栏上的URL有关，如果&lt;a href=&quot;javascript:;&quot;&gt;，点击&lt;a&gt;，
    地址栏的URL是不变的，即浏览器不认为&lt;a&gt;被访问过，那么:visited也不会相应；
    2. 与href=&quot;javascript:;&quot;不同，href=&quot;#&quot;虽然也能阻止&lt;a&gt;的默认跳转，但地址栏的URL
    尾部会添加&quot;#&quot;，:visited也会响应；
    3. :visited中只有3个样式属性有效：color、background-color、border-color
    4. :target：href=&quot;#box&quot;时，地址栏URL后会添加&quot;#box&quot;，:target则匹配id=&quot;box&quot;的
    元素，同理，点击&lt;a href=&quot;box2&quot;&gt;，:target又会重新匹配id=&quot;box2&quot;的元素；
    :target{ color: green; }
    &lt;div id=&quot;box&quot;&gt;BOX&lt;/div&gt; &lt;a href=&quot;#box&quot;&gt;ToBox&lt;/a&gt;
    &lt;div id=&quot;box2&quot;&gt;BOX2&lt;/div&gt; &lt;a href=&quot;#box2&quot;&gt;ToBox2&lt;/a&gt;
3. 动态伪类：:hover(鼠标悬停在元素上的样式)、:active(鼠标点击/按下时的元素样式)
    1. :hover和:active可以作用在任意元素上，使用的CSS属性也不受限制；
    &lt;div id=&quot;box&quot;&gt; &lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt; &lt;/div&gt;
    #box ul { display: none; } ------&gt; 正常情况下，&lt;ul&gt;是隐藏的
    #box:hover ul { display: block; } ---&gt; 当鼠标悬停在box上时，让&lt;ul&gt;显示
    2. :link、:visited、:hover、:active同时使用时，必须遵循一定的顺序：l-v-h-a
4. 表单相关伪类：:enabled、:disable、:checked、:focus
    1. :enabled、:disable分别匹配可编辑和被禁用的表单；
    2. :checked、:focus分别匹配被选中和获得焦点的表单；
    3. 自定义单选框：只用CSS实现，不借助JS
    label { float:left; width:100px; height:100px; border 2px solid;
    border-radius:50%; overflow:hidden; position:relative; } --&gt;label做单选框
    label &gt; span { position:absolute; left:0; top:0; right:0; bottom:0; }
    input { position:absolute; left:-50px; top:-50px; } --&gt; 隐藏掉原单选框
    input:checked + span { blackground:red; } --&gt;选中input时，让span模拟选中样式
    &lt;label&gt;
        &lt;input type=&quot;radio&quot; name=&quot;hobby&quot; /&gt; &lt;span&gt;&lt;/span&gt;
    &lt;/label&gt;
    &lt;label&gt;
        input type=&quot;radio&quot; name=&quot;hobby&quot; /&gt; &lt;span&gt;&lt;/span&gt;
    &lt;/label&gt;
    ---&gt; &lt;label&gt;是内联元素，使用浮动是为了让其转为内联块元素，支持宽高
    4. 原理：&lt;label&gt;与&lt;input type=&quot;radio&quot; /&gt;一起使用时，点击&lt;label&gt;可会选中单选框，
    再利用同name的单选框是互斥的，隐藏&lt;input&gt;，选中用&lt;span&gt;的样式代替。
</code></pre><h4 id="结构性伪类"><a href="#结构性伪类" class="headerlink" title="结构性伪类"></a>结构性伪类</h4><pre><code>1. 类型：:nth-child(index)系列、:nth-of-type(index)系列、:not、:empty
2. 索引index从1开始计数，且可以设置为变量n或n的表达式，n从0开始计数，如偶数2n、奇数2n+1
3. E:nth-child(1){ ... }：匹配使用了E选择器的元素、且是其父元素下的第一个子元素；
    1. 如果不指定E，则匹配整个文档的、符合条件的元素；
    &lt;ul id=&quot;warpper&quot;&gt;
        &lt;li&gt;Test1&lt;/li&gt; &lt;li&gt;Test2&lt;/li&gt; &lt;li&gt;Test3&lt;/li&gt;
    &lt;/ul&gt;
    #wrapper li:nth-child(1){ color:red; } ---&gt;匹配Test1
    2. :nth-child(index)系列的其他类型：:first-child、:last-child、:only-child、
    :nth-last-child(index)
    3. E:first-child{ ... }、E:last-child{ ... } 分别匹配第一个和最后一个；
    4. E:nth-last-child(index){ ... } 表示倒序匹配；
    5. E:only-child{ ... } 匹配父元素只有一个子元素、且子元素类型为E
4. E:nth-of-type(1){ ... }：查找父元素下的所有类型为E的子元素，再匹配其中的第一个；
    &lt;ul id=&quot;warpper&quot;&gt;
        &lt;li&gt;Test1&lt;/li&gt; &lt;li&gt;Test2&lt;/li&gt; &lt;p&gt;Test4&lt;/p&gt;
    &lt;/ul&gt;
    #wrapper p:nth-of-type(1){ color:red; } --&gt;匹配Test4
    1. :nth-of-type系列的其他类型：:first-of-type、:last-of-type、:only-of-type、
    :nth-last-type(index)
5. 两种系列的区别：
    1. E:nth-of-type(index)以元素为中心，E始终是标签名，即使把E指定为class选择器，
    解析时也会被替换为元素的标签名；而E:nth-child(index)则不会；
    &lt;div id=&quot;wrap&quot;&gt;
        &lt;div class=&quot;inner&quot;&gt;div&lt;/div&gt;
        &lt;p class=&quot;inner&quot;&gt;p&lt;/p&gt;
        &lt;span class=&quot;inner&quot;&gt;span&lt;/span&gt;
    &lt;/div&gt;
    #wrap .inner:nth-of-type(1) { ... } ---&gt;相当于：#wrap div:nth-of-type(1),
    #wrap p:nth-of-type(1), #wrap span:nth-of-type(1) { ... }，所以都会匹配
6. E:empty{ ... }：E不能包含任何子元素、文本、空格，如&lt;div id=&quot;box&quot;&gt;&lt;/div&gt;
7. E:not(F){ ... }：E和F都可以是选择器，匹配所有E，除了F
    &lt;div id=&quot;box&quot;&gt;
        &lt;p&gt;container&lt;/p&gt; &lt;p&gt;container&lt;/p&gt; &lt;p&gt;container&lt;/p&gt;
    &lt;/div&gt;
    #box &gt; p:not(:last-child){ ... } --&gt;除了最后一个&lt;p&gt;，其他子元素都匹配
</code></pre><h4 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h4><pre><code>1. 伪元素：仍是元素，只是不在DOM树中，是为了让CSS操作DOM树以外的元素；
    #box::before{ display:block; content:&quot;&quot;; width:80px; height:80px;
        border:1px solid black; position:absolute; left:0; top:20px; }
    1. 伪元素仍是元素，像使用普通DOM元素一样，对其使用定位，默认参照的仍是初始包含块；
    2. 伪元素建议使用双冒号：E::after{ ... }、E::before{ ... }
    3. 伪元素中必须使用content属性，用于添加文本内容，如果不需要，则设置为空字符串。
2. E::after、E::before：可以向DOM文档中插入新的元素，但并不存在于DOM树中；
    1. E::after、E::before分别是向元素E的末尾/开始插入一个子元素。
3. E::first-letter、E::first-line：分别匹配E中的第一个文字、第一行文字；
4. E::selection{ color:#ff0; background:red; }：文本被鼠标选中时的样式；
</code></pre><h3 id="CSS声明的优先级"><a href="#CSS声明的优先级" class="headerlink" title="CSS声明的优先级"></a>CSS声明的优先级</h3><pre><code>1. 选择器的特殊性：由选择器本身的组件确定，特殊性的值表述为4个部分，如 0,0,0,0
    1. id选择器的特殊性为：0,1,0,0 --&gt; #box{ ... }
    2. 类属性选择器、属性选择器、或伪类选择器的特殊性为：0,0,1,0
    3. 元素和伪元素选择器的特殊性为：0,0,0,1 ---&gt; div{ ... }
    4. 通配符选择器的特殊性为：0,0,0,0 --&gt; *{ ... }
    5. 结合符对特殊性没有任何贡献，如body,ul,li{ ... }
    6. 内联声明的特殊性都是1,0,0,0
    7. 继承没有特殊性，比0,0,0,0的优先级还要低；
    8. 特殊性的值可以累加，但不会进位，比如12个0,1,0,0的累加值为0,12,0,0
    9. 选择器的特殊性最终都会授予其对应的声明，构成CSS的优先级。
    div[id=&quot;test&quot;]{ ... } --&gt;0,0,1,1   #test{ ... } --&gt;0,1,0,0
2. 重要声明：对于某个比较重要的声明，超过了其他所有声明，CSS2.1称为重要声明；
    1. 在重要声明的结尾、分号之前插入 !important 来标志，如color: red !important;
    2. 实际上，浏览器会把重要声明和普通声明分别划分成一组，在各自的分组内部解决冲突；
    3. 重要声明虽然没有特殊值，但重要声明与普通声明产生冲突时，重要声明总是胜出。
3. CSS的来源决定了CSS的权重
    1. CSS样式的来源大致有三种：创作人员(开发者)、读者(用户)、用户代理(浏览器)
    2. 来源的权重：读者的重要声明&gt;创作人员的重要声明&gt;创作人员的普通声明&gt;读者的普通声明&gt;
    用户代理的声明，用户代理不会加重要声明，所以用户代理没有重要声明；
    3. 在浏览器的开发者模式下，查看样式时，用户代理的样式标识：user agent stylesheet
    4. 开发者模式下直接手动修改样式，也是属于创作人员的声明；
    5. Chrome和Firefox并没有提供读者的样式接口，需要借助插件(Stylish)导入样式表；
    6. IE提供了读者的样式接口，可以导入外部的CSS文件，属于读者的样式声明。
4. 层叠样式表：CSS声明优先级的真正体现
    1. 找出所有的相关规则，这些规则都包含一个CSS选择器；
    2. 计算声明的优先级：先按来源排序，如果来源相同，再按选择器的特殊性排序，如果特殊性也
    相同，则按排列的顺序.
</code></pre><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><pre><code>1. CSS3的自定义字体：@font-face
    1. @font-face：允许为网页指定在线字体，通过这种方式可以消除对用户电脑字体的依赖；
    @font-face { font-family: &quot;Test&quot;; src: url(font/BAUHS93.TTF) }
    #box { font: 16px &quot;Test&quot;; } ---&gt; 使用自定义字体Test
    2. font-family：指定字体的名称，用于font/font-family属性；
    3. src：字体资源的地址；把字体保存在服务器上，就不再依赖用户电脑上的字体，保持统一。
2. 字体图标：只需要下载一次字体包，降低了网络的负担，使得操作更加友好，而且是矢量图；
    1. 与位图相比，矢量图放大后不会失真，但矢量图的色调通常比较单一；
    2. 字体图标也是一种字体，通过color和font-size可以控制图标的颜色和大小。
    3. 制作矢量图(Ai) --&gt; 把矢量图与字符绑定，生成字体图标(FontLab Studio) --&gt; 把生成
    的字体图标制作成自定义字体(网站工具) --&gt; 引入自定义字体，使用该字符时，就会自动转为所
    绑定的矢量图
    4. www.fontsquirrel.com/tools/webfont-generator：字体兼容性处理网站，可以把字体
    转为自定义字体，生成stylesheet.css
3. 批量生成自定义字体：https://icomoon.io/#home，把矢量图与字符绑定，制作字体图标
    1. 生成style.css，其内部是伪元素选择器:before{ content: &quot;字体图标的绑定字符&quot; }
    2. 在使用style.css中的字体图标时，只需要使用其中的选择器即可。
</code></pre><h2 id="CSS3新增UI方案"><a href="#CSS3新增UI方案" class="headerlink" title="CSS3新增UI方案"></a>CSS3新增UI方案</h2><h3 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h3><pre><code>1. opacity：设置盒子的透明度，属性值的范围是 0-1
    1. 虽然不可继承，但透明度也会同时作用在其子元素上；
    2. 为了兼容IE浏览器，还必须设置filter: alpha(opacity=30);
2. rgba：同时设置颜色及颜色的透明度，如rgba(0, 0, 0, .8)，透明度为0.8
3. text-shadow：文字阴影，可以添加多层，每层用&quot;,&quot;隔开，第一个阴影在最上面
    text-shadow: 阴影色 水平偏移量 垂直偏移量 模糊值, 阴影色 水平偏移量 ...
    1. 浮雕文字：h1 { color: white; text-shadow: black 1px 1px 10px; }
    2. 文字模糊：h1:hover{ color:rgba(0,0,0,0); text-shadow:black 0 0 100px; }
4. -webkit-text-stroke：文字描边，不算是CSS3，只有webkit内核才支持
5. direction：控制文字的方向，一定要与 unicode-bidi:bidi-override; 配合使用；
    .content { direction:rtl; unicode-bidi:bidi-override; } --&gt;文字从右向左排列
6. text-overflow：未显示内容的溢出信号，显示省略号，但不支持内联元素；
    1. 配合 white-space:nowrap; overflow:hidden; 实现溢出内容显示省略号；
    .wraper { white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
</code></pre><h3 id="盒模型样式"><a href="#盒模型样式" class="headerlink" title="盒模型样式"></a>盒模型样式</h3><pre><code>1. box-shadow：盒模型阴影
    box-shadow: inset 阴影色 水平偏移量 垂直偏移量 模糊值 阴影扩展大小, inset ...
    1. 阴影的真实大小=盒子大小+阴影扩展大小，默认的阴影大小就是盒子大小；
    2. box-shadow默认是外阴影，在盒子的右下角，偏移量可以设置为负值，改变阴影的位置；
    3. inset表示设置内阴影，阴影扩展大小也可以设置为负值，阴影也可以叠加，用&quot;,&quot;隔开。
2. -webkit-box-reflect：元素的倒影，只有webkit内核支持
    1. -webkit-box-reflect: 倒影的方向(above,below,right,left) 倒影的距离 渐变
    2. 移动端的浏览器(IOS、Android)都是webkit内核，所以倒影和文字描边常用于移动端。
3. box-sizing：更改计算元素真实宽高的默认CSS盒子模型，默认属性值为content-box
    1. 默认情况下，设置盒子的padding会增大盒子的真实大小；
    2. box-sizing:border-box; --&gt;盒子的真实大小始终为width/height，设置的padding会
    占用width/height的大小，类似于Android上的EditText
4. resize：允许控制一个元素的可调整大小，必须与 overflow:auto/hidden; 配合使用；
    1. 不可继承，默认值为none，元素不能被缩放；
    2. horizontal/vertical：只允许在水平/垂直方向上调整元素的大小。
    3. both：允许在水平和垂直方向上调整元素大小，原理是在盒子上动态添加style样式。
</code></pre><h3 id="新增UI样式"><a href="#新增UI样式" class="headerlink" title="新增UI样式"></a>新增UI样式</h3><pre><code>1. border-radius：圆角，设置为百分比时参照盒子的width和height
    1. border-radius: 10px(左上角) 20px(右上角) 30px(右下角) 40px(左下角)
    2. border-radius: 10px(左上角、右下角) 30px(右上角、左下角)
    3. border-radius: 10px(左上角) 20px(右上角、左下角) 30px(右下角)
    4. border-radius: 50%; --&gt; 同时设置4个角，不支持负数
    5. 第二种语法：border-radius:10px/20px; 10px/20px 30px; 10px/20px 30px 40px;
    border-radius: 10px/20px 30px 40px 50px;
2. border-radius使用百分比的兼容性
    1. 在旧版本的Chrome和Safari中不支持使用百分比值(fixed in 09/2010)
    2. Opera11.50之前的版本中也不支持百分比值；
    3. Gecko2.0(Firefox4)版本之前的实现不标准：水平/垂直半轴都相对于盒子的宽度；
    4. IOS5之前、Android webkit532之前都不支持百分比值，所以移动端开发尽量使用px值。
3. border-image：边框图片，允许CSS属性在元素的边框上绘制图像，会替换掉border-style
    1. border-image-source：设置边框上的图片，替换border-style，默认值为none
    border-image-source: url(img/border.png); --&gt; 如果不设置，仍使用border-style
    2. border-image-slice：可以设置4个值，来控制切片线的位置，默认值100%，相对于图片；
    3. border-image-repeat：填充边框的模式，默认值stretch(拉伸)，repeat/round(平铺)
    单个值表示设置所有边框，两个值表示分别设置水平与垂直的边框；
    4. border-image-width：默认值为1，如果不指定，图像边框的宽度使用border-width
    5. border-image-outset：边框图像可超出边框盒的大小，放大边框。
4. background：背景新增属性
    1. background-image支持设置多张背景图，且前者叠加在后者之上；
    background-image: url(img/a.png) url(img/b.png) url(img/c.png);
    2. 默认从padding box开始绘制，从border box开始剪裁，超出盒子边框的部分被裁剪；
    3. background-origin：设置背景渲染的起始位置，默认值padding-box，不填充边框
    background-origin:content-box; --&gt; 从内容区开始渲染，不填充边框和内边距
    background-origin:border-box; --&gt; 从border box开始渲染，填充边框和内边距
    4. background-clip：设置背景的裁剪位置，默认值border-box，即超出盒子的部分被裁剪
    background-clip: padding-box; --&gt; 从padding box开始裁剪，即超出内边距就裁剪
    background-clip: content-box; --&gt; 从内容区开始裁剪，即超出内容区就裁剪
    5. background-origin和background-clip不只是设置背景图，对背景颜色也有效；
    6. -webkit-background-clip: text; --&gt;只支持webkit内核，让背景只在文字区域渲染
    文字要设置为半透明才能看到背景的效果；
    7. background-size：设置背景图的大小，默认值auto auto; 分别表示图片的宽度和高度；
    8. 图片的特性就是高宽自适应，保持图片不变形，设置单个值，表示宽度，高度为auto
    9. background-size设置为百分比：背景图相对于背景区域的百分比，真实渲染的背景区域由
    background-origin设置，默认为盒模型的内容区+内边距；
    background-size: 100% 100%; --&gt; 让图片完全填充背景区域，图片可能变形。
</code></pre><h3 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h3><pre><code>1. 渐变是CSS3新增的图片类型(不是颜色)，加快页面的载入时间，页面的缩放效果也比图片更好；
2. 浏览器支持两种类型的渐变：线性渐变(linear-gradient)，径向渐变(radial-gradient)
3. 渐变的方向
    1. 默认从上到下的渐变：background-image:linear-gradient(red, blue); red-&gt;blue
    2. 多颜色的渐变：background-image:linear-gradient(red, yellow, green);
    3. 渐变的方向：top、bottom、left、right
    background-image: linear-gradient(to right, red, blue); --&gt;由左向右的渐变
4. 使用角度：
    1. 以盒子的中心点为圆心，水平方向为-90°~90°(从左到右)，垂直方向为0~180°(从上到下)
    2. 45度方向的多色渐变：linear-gradient(45deg, red, yellow, green);
    3. 控制颜色的分布：linear-gradient(red 长度px/百分比, blue 长度px/百分比, ...)
    background-image: linear-gradient(90deg, red 10%, blue, gray);
    4. 10%的含义并不是red占10%，而是纯色的red占10%，从10%处开始渐变。
5. 渐变区间的判定
    1. 如果每个颜色上都是用了长度px或百分比，它们之间必须存在差值，否则不会发生渐变；
    1. linear-gradient(90deg, red 10px, blue 10px)：两个颜色值的占比相同时，并不会
    发生渐变，而是red占盒子的10%，而blue占盒子的90%；
    2. linear-gradient(90deg, red 10px, blue 20px)：10px的差值，则red占盒子的10%，
    渐变色占10%，blue占80%，即在red和blue之间的渐变色只有10px的长度。
6. 透明色的渐变：linear-gradient(90deg, rgba(0,0,0,0) 10px, rgba(0,0,0,1) 50px)
7. 重复的渐变：repeating-linear-gradient(90deg, blue, red 100px);
    1. 对于重复的渐变色，通常只指定最后一个颜色的长度/百分比，渐变色块的分布会更均匀；
    2. 如果每种颜色的长度/百分比设置的都一样，最后一种颜色会占据整个盒子，没有渐变。
8. 发廊灯效果
    &lt;div id=&quot;box&quot;&gt; &lt;div id=&quot;hear&quot;&gt;&lt;/div&gt; &lt;/div&gt;
    #box{ width:50px; height:300px; border:1px solid black; overflow:hidden; }
    #hear{ height:600px; background: repeating-linear-gradient(135deg, 
        black 0px, black 10px, white 10px, white 20px); }
    let hear = document.querySelector(&apos;#hear&apos;)
    let flag = 0
    setInterval(()=&gt;{
        flag++
        if(flag &gt;= 300) flag = 0
        hear.style[&apos;margin-top&apos;] = -flag + &apos;px&apos;
    }, 1000/60)
    1. hear的高度比父元素box更大，动态改变hear的margin-top，让hear向上移动；
    2. 缺陷：hear向上移动到临界值时，margin-top重置为0px，会造成瞬间的卡断问题。
9. 光斑动画：文字的闪亮效果
    body { background: black; }
    h1 {
        color: rgba(255,255,255, .3);  font: bold 80px &quot;microsoft yahei&quot;;
        background: linear-gradient(120deg, rgba(255,255,255,0) 100px, 
            rgba(255,255,255,1) 180px, rgb(255,255,255,0) 260px);
        background-repeat: no-repeat;
        -webkit-background-clip: text; --&gt; 让背景只渲染文字所在的区域
    }
    let h1 = document.querySelector(&apos;h1&apos;)
    let flag = -160
    setInterval(() =&gt; {
        flag+=10
        if(flag &gt;= 600) flag = -160
        h1.style[&apos;background-position&apos;] = flag + &apos;px&apos;
    }, 30)
    1. 让背景图(渐变色)只渲染文字区域，且不能重复平铺，同时设置文字为半透明；
    2. 通过改变背景图的background-position，以动态改变背景图的位置，达到闪亮效果。
</code></pre><h3 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变"></a>径向渐变</h3><pre><code>1. radial-gradient()由渐变中心点向四周辐射的颜色渐变，默认均匀分布；
    background-image:radial-gradient(red, blue, green); ==&gt; red-&gt;blue-&gt;green
2. 不均匀分布：radial-gradient(red 50%, blue 70%); --&gt;渐变色只有20%，50%为纯红色
3. 径向渐变默认是椭圆ellipse，指定为圆形：radial-gradient(circle, red, blue);
4. 改变渐变形状的大小
    1. 默认是最近角：radial-gradient(closest-corner circle, red, blue);
    2. farthest-side(最远边)、 closest-side(最近边)、farthest-corner(最远角)
5. 改变圆心(渐变中心)
    radial-gradient(closest-corner circle at 10px 10px, red, blue);
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2017/10/10/Scrapy-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/10/Scrapy-1/" itemprop="url">Scrapy-1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-10T00:00:00+08:00">
                2017-10-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Scrapy"><a href="#Scrapy" class="headerlink" title="Scrapy"></a>Scrapy</h2><pre><code>1. Scrapy是用纯Python实现的，用于爬取网站数据、提取结构性数据；
2. Scrapy使用Twisted(主要竞争者是Tornado)异步网络框架来处理网络通讯，加快下载速度；
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2017/10/07/爬虫基础-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/07/爬虫基础-3/" itemprop="url">爬虫基础-3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-07T00:00:00+08:00">
                2017-10-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="多线程爬虫"><a href="#多线程爬虫" class="headerlink" title="多线程爬虫"></a>多线程爬虫</h2><pre><code>1. 多进程通常应用于计算密集型，多线程通常应用于IO密集型，网络数据传输其实就是IO数据流，
   所以爬虫大多使用多线程，配合队列Queue实现线程间的数据交互；
2. 尽管多线程在Python中比较鸡肋，但对于多路IO复用，通常还是使用多线程；
3. from Queue import Queue：先进先出
    1. queue = Queue(10)：创建队列，并指定队列的最大容量；不指定，则表示无限大；
    2. queue.qsize()：查看队列的大小；
    3. queue.empty()：如果队列为空，则返回True；
    4. queue.full()：如果队列满了，则返回True；
    5. queue.put()：向队列中存放一个数据；
    6. queue.get([block[, timeout]])：获取队列中的一个数据，timeout等待时间；
    block默认值为True，当队列为空时，则进入阻塞状态，不会结束，直到队列中有新的值；
    block=False，当队列为空时，不会等待，直接报一个Queue.empty的异常。
</code></pre><h2 id="动态HTML"><a href="#动态HTML" class="headerlink" title="动态HTML"></a>动态HTML</h2><pre><code>1. 动态HTML的技术：JavaScript、jQuery、Ajax、DHTML
    1. jQuery可以动态创建HTML内容，只有在JS代码执行之后才会显示，而传统方法只能采集
    JS代码执行之前的内容；
    2. AJAX不是一门语言，而是用来完成网络任务的一系列技术，可以在网页不刷新的情况下，
    完成与服务器的网络交互，收发数据；
    3. DHTML：动态HTML，与AJAX一样，也是一系列用于解决网络问题的技术集合；
    DHTML是用客户端语言改变页面的HTML元素，比如页面上的按钮只有当移动鼠标之后才出现，
    背景色可能每次点击都会改变，或者用一个Ajax请求触发页面加载一段新内容；
    网页是否属于DHTML，关键是有没有用JS控制 HTML和CSS元素。
2. 解决动态HTML：
    1. 直接从JavaScript代码里采集内容，但过于费时费力；
    2. 用Python的第三方库运行JavaScript，直接采集在浏览器里看到的页面。
</code></pre><h3 id="Selenium与PhantomJS"><a href="#Selenium与PhantomJS" class="headerlink" title="Selenium与PhantomJS"></a>Selenium与PhantomJS</h3><pre><code>1. Selenium是一个Web的自动化测试工具，最初是为网站自动化测试而开发的；
    1. Selenium可以按指定的命令自动操作，可以直接运行在浏览器上，支持所有主流浏览器，
    包括PhantomJS这些无界面的浏览器。
    2. Selenium可以根据指定的命令，让浏览器自动加载页面，获取需要的数据；
    3. Selenium还提供页面截屏功能，查看浏览器当前的行为；
    4. Selenium本身并不带浏览器，不支持浏览器的功能，需要与第三方浏览器结合才能使用；
    但有时候需要让它内嵌在代码中运行，所以就可以使用PhantomJS代替真实的浏览器。
    5. 安装：pip install selenium
2. PhantomJS是一个基于Webkit的无界面浏览器，它会把网站加载到内存、并执行页面上的JS；
    1. PhantomJS不会展示图形界面，所以运行起来比完整的浏览器要高效；
    2. 尽管PhantomJS是无界面的，但Selenium的页面截屏功能可以查看页面的行为；
    3. 把Selenium和PhantomJS结合在一起，就可以运行一个非常强大的网络爬虫了，这个爬虫
    可以处理JS、Cookie、headers，以及任何真实用户需要做的事情。
    4. PhantomJS是一个功能完善的浏览器(无界面)，并不是一个python库，所以不能像py库
    一样安装，但可以通过Selenium调用PhantomJS来直接使用；
3. Selenium与PhantomJS虽然是很强大的工具，但性能上比真实浏览器要低，使用后及时关闭。
4. Selenium里有WebDriver API，WebDriver有点儿像可以加载网站的浏览器，但它也可以像
   BeautifulSoup或者其他Selector对象一样用来查找页面元素、与页面上的元素进行交互(发送
   文本、点击等)、执行其他动作来运行网络爬虫：from selenium import webdriver
    1. ubuntu下载PhantomJS，引用其bin目录下的phantomjs文件，创建浏览器对象；
    driver = webdriver.PhantomJS(executable_path=&quot;./phantomjs&quot;)
    2. 配置环境变量~/.bashrc，指定phantomjs文件的路径：
    PHANTOMJS_HOME=/home/python/phantomjs
    export PATH=$PATH:$PHANTOMJS_HOME
    3. 让环境变量生效：source ~/.bashrc --&gt; driver = webdriver.PhantomJS()
    4. 访问豆瓣网：driver.get(&apos;https://www.douban.com/&apos;)
    5. driver.title：获取页面标题；    driver.current_url：获取当前的URL；
    6. html = driver.page_source：获取页面源码；
    7. driver.save_screenshot(&quot;douban.png&quot;)：生成当前页面快照/截图并保存；
    8. driver.close()：关闭当前页面，如果只有一个页面，则关闭浏览器；
    9. driver.quit()：退出，关闭浏览器。
5. driver = webdriver.Chrome()/Firefox()/Ie() --&gt; 启动Chrome/Firefox/IE浏览器
   同理，也需要分别安装三大浏览器的驱动driver，并配置环境变量。
</code></pre><h4 id="页面操作"><a href="#页面操作" class="headerlink" title="页面操作"></a>页面操作</h4><pre><code>&lt;input type=&quot;text&quot; name=&quot;uname&quot; id=&quot;uname&quot; class=&quot;box&quot; /&gt;
1. 获取标签--&gt; driver.find_element_by...()，driver.find_elements_by...()
    1. driver.find_element_by...()：获取一个标签；
    2. driver.find_elements_by...()：获取一组标签；
    3. element = driver.find_element_by_id(&quot;uname&quot;)
    4. find_element_by_name(&quot;uname&quot;)、find_element_by_tag_name(&quot;input&quot;)
    5. find_element_by_class_name(&quot;box&quot;)、find_element_by_css_selector()
    6. find_element_by_xpath(&apos;//input[@id=&quot;uname&quot;]&apos;)
    7. find_element_by_link_text()、find_element_by_partial_link_text()
2. 获取标签--&gt; driver.find_element()、driver.find_elements()
    1. from selenium.webdriver.common.by import By
    2. find_element/find_elements： --&gt; 获取一个/一组标签
    3. element = driver.find_element(by=By.ID, value=&quot;uname&quot;)
    4. By.NAME、By.CLASS_NAME、By.TAG_NAME、By.XPATH
    5. By.LINK_TEXT、By.PARTIAL_LINK_TEXT、By.CSS_SELECTOR
3. 操作标签
    1. element.text：获取标签的文本内容；
    2. 对于输入框，输入内容：element.send_keys(&apos;abc&apos;)，输入中文：u&apos;中国&apos;
    3. 清空输入框：element.clear()
    4. 对于按钮，模拟点击：element.click() --&gt; 点击按钮也相当于发送一个请求
    driver.save_screenshot(&quot;a.png&quot;) --&gt; 查看当前的浏览器行为(最新的页面)；
    5. 通常在执行点击之后，会等待一段时间，待浏览器加载完成，再去执行其他操作。
4. 键盘操作：from selenium.webdriver.common.keys import Keys
    1. Ctrl+A/X全选/剪切输入框的内容：element.send_keys(Keys.CONTROL,&apos;a&apos;/&apos;x&apos;)
    2. 模拟Enter回车键：element.send_keys(Keys.RETURN)
5. 鼠标动作：from selenium.webdriver import ActionChains
    1. btn = driver.find_element_by_id(&quot;btn&quot;)
    2. ActionChains(driver).move_to_element(btn).perform()：鼠标移动到btn位置；
    3. ActionChains(driver).move_to_element(btn).click(btn).perform()：单击； 
    4. double_click(btn)：双击；    context_click(btn)：右击；
    5. click_and_hold(btn)：左键单击hold住；
    6. 将btn1拖拽到btn2的位置：
    ActionChains(driver).drag_and_drop(btn1, btn2).perform()
6. &lt;select&gt;下拉框：from selenium.webdriver.support.ui import Select
    1. select = Select(driver.find_element_by_name(&apos;status&apos;))：选取下拉框；
    2. select.select_by_index(1)：根据索引选取，索引从0开始；
    3. select.select_by_value(&quot;0&quot;)：根据&lt;option&gt;的value属性值选取；
    4. select.select_by_visible_text(u&quot;未审核&quot;)：根据&lt;option&gt;的字符串文本选取；
    5. select.deselect_all()：全部取消选择。
7. 页面弹窗：alert = driver.switch_to_alert()
8. 切换页面窗口：driver.switch_to.window(&quot;window name&quot;)
    for handle in driver.window_handles:
        driver.switch_to_window(handle) --&gt; 遍历每一个窗口的操作对象
9. 页面的前进和后退：driver.forward()、driver.back()
10. 操作Cookie
    1. driver.get_cookies()：获取当前页面的Cookie；
    for cookie in driver.get_cookies():    --&gt; 遍历页面的Cookie
        print &quot;%s: %s&quot; % (cookie[&apos;name&apos;], cookie[&apos;value&apos;])
    2. driver.delete_cookie(&quot;CookieName&quot;)：根据名称删除Cookie；
    3. driver.delete_all_cookies()：删除所有的Cookie；
11. 页面等待
    1. 采用AJAX技术的网页不确定何时加载完成，那么操作DOM就可能抛出空指针异常；
    2. Selenium提供了两种等待方式：显式等待、隐式等待；
    3. 隐式等待是等待特定的时间，显式等待是直到指定的某个条件成立时继续执行；
12. 显式等待：指定某个条件，并设置最长等待时间，如果仍没有找到某个元素，则抛异常；
    1. WebDriverWait：负责循环等待
    from selenium.webdriver.support.ui import WebDriverWait
    2. expected_conditions：负责条件触发
    from selenium.webdriver.support import expected_conditions as EC
    3. 执行等待：
    driver = webdriver.Chrome()
    driver.get(&quot;http://www.xxxxx.com/loading&quot;)
    try: --&gt; 页面一直循环，直到 id=&quot;uname&quot; 出现
        element = WebDriverWait(driver, 10).until(
            EC.presence_of_element_located((By.ID, &quot;uname&quot;)))
    finally:
        driver.quit()
    4. 如果不指定最长等待时间，程序默认会每隔0.5s查看一次元素是否已经生成；
    5. 内置的一些等待条件：title_is、title_contains、visibility_of ...
13. 隐式等待：设置一个等待时间，单位是秒，如果不设置，默认等待0s；
    driver = webdriver.Chrome()
    driver.implicitly_wait(10)    --&gt; 等待10s
    driver.get(&quot;http://www.xxxxx.com/loading&quot;)
    myDynamicElement = driver.find_element_by_id(&quot;uname&quot;)
</code></pre><h4 id="执行JS"><a href="#执行JS" class="headerlink" title="执行JS"></a>执行JS</h4><pre><code>1. JS修改标签样式：
   js = &apos;var q=document.getElementById(&quot;kw&quot;);q.style.border=&quot;2px solid red&quot;;&apos;
   driver.execute_script(js)
2. JS隐藏标签
    1. img = driver.find_element_by_xpath(&quot;//*[@id=&apos;lg&apos;]/img&quot;)
    2. driver.execute_script(&apos;$(arguments[0]).fadeOut()&apos;,img)
3. JS模拟滚动到底部
    1. js = &quot;document.body.scrollTop=10000&quot;
    2. driver.execute_script(js)
</code></pre><h2 id="测试模块"><a href="#测试模块" class="headerlink" title="测试模块"></a>测试模块</h2><pre><code>python的测试模块：import unittest
1. 定义测试类：class TestUnit(unittest.TestCase)
2. 测试模块的初始化方法：def setUp(self) --&gt; 固定名称
3. 定义具体的测试用例方法时，方法名必须以&apos;test&apos;开头，比如：def testDao(self)
4. 退出时的清理方法：def testDown(self) --&gt; 固定名称
5. 执行测试用例：
    if __name__ == &quot;__main__&quot;:
        unittest.main()
</code></pre><h2 id="Tesseract"><a href="#Tesseract" class="headerlink" title="Tesseract"></a>Tesseract</h2><pre><code>机器视觉：文字识别是其一个分支；
OCR：光学文字识别，将图像翻译成文字的技术，Tesseract就是一个OCR库；
1. Tesseract属于Google，是目前最优秀、最精确的开源OCR系统，同时具有很高的灵活性；
2. Tesseract可以通过训练识别出任何字体，也可以识别出任何Unicode字符；
3. linux系统的安装：sudo apt-get tesseract-ocr
    1. 要使用Tesseract的功能，必须设置环境变量$TESSDATA_PREFIX，让Tesseract知道训练
    的数据文件存储在哪里：export TESSDATA_PREFIX=/usr/local/share/Tesseract
    2. 还需要找一份tessdata数据文件，放到Tesseract目录下。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2017/10/05/爬虫基础-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/05/爬虫基础-2/" itemprop="url">爬虫基础-2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-05T00:00:00+08:00">
                2017-10-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="cookielib"><a href="#cookielib" class="headerlink" title="cookielib"></a>cookielib</h2><pre><code>cookielib是自动处理cookie的模块，对应urllib2的处理器：HTTPCookieProcessor
    1. cookielib：主要作用是提供用于存储cookie的对象；
    2. HTTPCookieProcessor：处理cookie对象，并构建Handler对象；
1. cookielib的主要对象：CookieJar、FileCookieJar、MozillaCookieJar、LWPCookieJar
    1. CookieJar：管理HTTP cookie值、存储HTTP请求生成的cookie、向发送的HTTP请求添加
    cookie的对象；整个cookie都存储在内存中，CookieJar实例被垃圾回收后，cookie也将丢失；
    2. FileCookieJar(filename, delayload=None, policy=None)：CookieJar的子类，
    检索cookie信息并存储到文件中，delayload为True时支持延迟访问文件，只有在需要时才读取
    文件或者在文件中存储数据；
    3. MozillaCookieJar(filename,delayload=None,policy=None)：FileCookieJar的子类，
    用于兼容Mozilla浏览器的FileCookieJar；
    4. LWPCookieJar(filename, delayload=None, policy=None)：FileCookieJar的子类，
    用于兼容libwww-perl标准Set-Cookie3文件格式的FileCookieJar。
2. HTTPCookieProcessor
    1. 构建能保存cookie的处理器和Opener：
        cookie = cookielib.CookieJar()
        handler = urllib2.HTTPCookieProcessor(cookie)
        opener = urllib2.build_opener(handler)
    2. 发送登录请求，保存生成的cookie：
        url = &apos;http://www.renren.com/PLogin.do&apos; --&gt; 老版人人网没有动态token验证
        data = {&apos;email&apos;: &apos;人人网用户名&apos;, &apos;password&apos;: &apos;人人网密码&apos;}
        request = urllib2.Request(url, data=urllib.urlencode(data), headers)
        response = opener.open(request) --&gt; 发送POST请求，如果登录成功，则保存Cookie
    3. 使用cookie访问个人主页
        pro_url = &apos;http://www.renren.com/966033501/profile&apos; --&gt; 人人网个人主页
        pro_request = urllib2.Request(profile_url, headers)
        res_pro = opener.open(pro_request) --&gt; 携带登录后的Cookie，再次发送请求
    4. 输出标准格式的Cookie：cookieStr = &quot;&quot;
        for item in cookie:
            cookieStr = cookieStr + item.name + &quot;=&quot; + item.value + &quot;;&quot;
        print cookieStr[:-1]
3. 对于FileCookieJar，发送请求之后，执行cookie.save()，才能保存Cookie到本地文件；
    1. cookie = cookielib.MozillaCookieJar()
    2. cookie.load(&apos;cookie.txt&apos;)：从文件中读取Cookie到内存中。
4. 模拟登录的注意点：
    1. 登录一般都会先有一个HTTP GET，拉取一些信息及获得Cookie，然后再HTTP POST登录；
    2. HTTP POST登录的链接有可能是动态的，从GET返回的信息中获取；
    3. password有些是明文发送，有些是加密后发送；有些网站甚至采用动态加密的，同时包括了
    很多其他数据的加密信息，只能通过查看JS源码获得加密算法，再去破解加密，非常困难；
    4. 大多数网站的登录整体流程是类似的，可能有些细节不一样，不能保证每个网站都能登录成功。
</code></pre><h2 id="URLError与HTTPError"><a href="#URLError与HTTPError" class="headerlink" title="URLError与HTTPError"></a>URLError与HTTPError</h2><pre><code>urlopen()/opener.open()发出请求时，如果urlopen()/opener.open()不能处理这个response，
就产生错误，常见的包括URLError、HTTPError
1. URLError产生的主要原因：没有网络连接、服务器连接失败、找不到指定的服务器；
    1. 在发送请求时，对urlopen()/opener.open()使用try-except捕获相应的异常；
    2. urlopen error [Errno 8]：未找到指定的服务器。
2. HTTPError是URLError的子类，服务器响应的response包含响应码，但urllib2会自动处理重定向
   的页面(3开头的响应码)，100-299表示成功，所以只能看到400-599的错误码；
3. try-except优先处理HTTPError，然后处理URLError：
    try:
        urllib2.urlopen(requset)
    except urllib2.HTTPError, err:
        print err.code
    except urllib2.URLError, err:
        print err
</code></pre><h2 id="requests"><a href="#requests" class="headerlink" title="requests"></a>requests</h2><pre><code>requests模块的底层是urllib3，继承了urllib2的所有特性，号称：HTTP for Humans
1. requests支持HTTP连接保持和连接池，支持使用cookie保持会话，支持文件上传；
2. 支持自动确定响应内容的编码，支持国际化的URL和POST数据自动编码；
3. requests能完全满足当前网络的需求，支持python2.6-3.x，而且能运行在PyPy环境；
4. 安装：pip install requests，easy_install requests
</code></pre><h3 id="GET和POST"><a href="#GET和POST" class="headerlink" title="GET和POST"></a>GET和POST</h3><pre><code>1. GET请求：
    1. response = requests.get(&quot;http://www.baidu.com/&quot;)
    2. response = requests.request(&quot;get&quot;, &quot;http://www.baidu.com/&quot;)
2. POST请求：response = requests.post(url, data={&apos;k1&apos;:&apos;v1&apos;}, heanders)
3. 添加请求头与请求参数
    1. requests.get(url, params={&apos;k1&apos;:&apos;v1&apos;}, headers={&apos;k1&apos;:&apos;v1&apos;})
    2. params：GET请求需要传递的参数；    headers：请求头；
    3. params和headers都会被自动国际化编码，不需要手动处理。
4. response.url：查看完整的URL；    response.status_code：查看响应码；
5. response.text：获取响应内容，一般为Unicode编码的数据；
    1. response.encoding：查看响应内容的字符编码；
    2. response.encoding=&apos;utf-8&apos;：修改响应数据的编码，response.text也会使用此编码；
    3. 在写入文件时，如果报编码错误：UnicodeEncodeError:&apos;ascii&apos; codec can&apos;t ...
    则使用&apos;utf-8&apos;编码，再写入：
    with open(&apos;res.txt&apos;, &apos;w&apos;) as f:
        f.write(response.text.encode(&apos;utf-8&apos;))
6. response.content：获取原始二进制字节流形式的响应内容，可用来保存图片等二进制文件；
7. response.json()：如果响应的是JSON数据，可以直接获取。
</code></pre><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><pre><code>1. 配置单个请求的代理：
    res = requests.get(url, proxies = {&apos;http&apos;:&apos;代理URL&apos;, &apos;https&apos;:&apos;代理URL&apos;})
2. 统一配置代理：在本地环境变量中配置HTTP_PROXY和HTTPS_PROXY
    export HTTP_PROXY=&quot;http://12.34.56.79:9527&quot;
    export HTTPS_PROXY=&quot;https://12.34.56.79:9527&quot;
3. 私密代理验证账号密码
    response = requests.get(url, proxies={ &quot;代理类型&quot;: &quot;用户名:密码@Ip:Port&quot; })
4. web客户端验证账号密码：response = requests.get(url, auth=(&quot;用户名&quot;, &quot;密码&quot;))
</code></pre><h3 id="Cookie与Sission"><a href="#Cookie与Sission" class="headerlink" title="Cookie与Sission"></a>Cookie与Sission</h3><pre><code>1. Cookie
    1. cookiejar = response.cookies：如果一个请求中包含Cookie，则获取到CookieJar对象；
    2. cookiedict = requests.utils.dict_from_cookiejar(cookiejar)：转为字典形式；
2. Sission
    1. 在requests中，Session对象是很常用的，它代表一次用户会话，Client连接Server开始，
    到Client断开连接；
    2. 会话能让Client在跨请求时保持某些参数，比如：在某一个Session实例发出的所有请求之间
    保持Cookie。
3. Session模拟Client登录
    ssion = requests.session() --&gt; 创建Session对象，保存Cookie；
    ssion.post(url, data={ 账号密码等参数 }, headers)
    response = ssion.get(url) --&gt; 登录成功后，ssion中已经保存了cookie，可以直接请求；
</code></pre><h3 id="HTTPS请求SSL证书"><a href="#HTTPS请求SSL证书" class="headerlink" title="HTTPS请求SSL证书"></a>HTTPS请求SSL证书</h3><pre><code>1. verify=True：表示发起HTTPS请求时，检查主机的SSL证书，默认为True；
    response = requests.get(&quot;https://www.baidu.com/&quot;, verify=True)
2. 如果SSL证书验证不通过/不信任Server的安全证书，如https://www.12306.cn，则报SSLError
    requests.get(&quot;https://www.12306.cn/mormhweb/&quot;, verify = False) --&gt; 跳过验证
</code></pre><h2 id="提取数据"><a href="#提取数据" class="headerlink" title="提取数据"></a>提取数据</h2><pre><code>爬取页面的内容一般分为两部分：非结构化数据和结构化数据；
1. 非结构化数据：先有数据，再有结构；
    1. 文本、电话号码、邮箱地址的处理方式：正则表达式；
    2. HTML文件：正则表达式、XPath、CSS选择器。
2. 结构化数据：先有结构，再有数据；
    1. JSON的处理方式：JSONPath、转化成Python类型进行操作(Json类)；
    2. XML：转化成Python类型(xmltodict)、XPath、CSS选择器、正则表达式。
3. 抓取速度：正则 &gt; XPath &gt; CSS选择器，但CSS选择器的使用时最简单的。
</code></pre><h3 id="XPath"><a href="#XPath" class="headerlink" title="XPath"></a>XPath</h3><pre><code>1. XPath：是一门在XML文档中查找信息的语言，可用来在XML文档中对元素和属性进行遍历；
    1. /div：从根节点开始匹配&lt;div&gt;；    //div：从任意节点开始匹配&lt;div&gt;；
    2. //div[@class=&quot;threadlist&quot;]：从任意目录开始、根据指定的属性进行匹配div节点；
    3. //div/a：从任意节点开始匹配div节点，然后匹配&lt;div&gt;的直接子节点&lt;a&gt;；
    4. //div//a：从任意节点开始匹配div节点，然后匹配&lt;div&gt;下任意层级的子节点&lt;a&gt;；
    5. //div//a[@class=&quot;thie&quot;]/@href：获取匹配&lt;a&gt;的href属性值；
    6. //div//@href：直接匹配&lt;div&gt;下的所有节点的href属性值；
    7. //div[@class=&quot;li_txt&quot;]/h3/text()：获取&lt;h3&gt;的文本内容
    8. .：选取当前节点；    ..：选取当前节点的父节点；    *：选取所有节点；    |：多选。
2. lxml：将HTML文档解析为HTML DOM模型，即把HTML转为XML；该模块需要手动安装；
    1. from lxml import etree
    2. html = urllib2.urlopen(request).read()
    3. xml = etree.HTML(html)
    4. content = xml.xpath(&apos;XPath的查找规则&apos;) --&gt; 返回一个列表，类似于正则findall()
3. content = xml.xpath(&apos;//div/a&apos;)
    1. content[0].tag：获取标签名；    content[0].text：获取标签内的字符串文本；
    2. content[0].get(&apos;href&apos;)：获取指定的属性值；
    3. content[0].xpath(&apos;./span&apos;)：对&apos;//div/a&apos;匹配的内容进一步匹配，//div/a/span
4. 不同的WebServer会针对不同的Client发送不同的数据，一般IE是标准格式，使用XPath解析时，
   通常使用IE的User-Agent作为请求头；
5. 如果当前层级查找不到，则继续向上取父节点，如爬取百度贴吧的帖子链接：
    1. 无效的XPath规则：
    //div[@class=&quot;threadlist_lz clearfix&quot;]/div/a[@class=&quot;j_th_tit&quot;]/@href
    //div[@class=&quot;threadlist_lz clearfix&quot;]//a[@class=&quot;j_th_tit&quot;]/@href
    2. 有效的XPath规则：//div[@class=&quot;t_con cleafix&quot;]/div/div/div/a/@href
6. 强大的模糊查询：
    //div[contains(@id, &quot;qiush_tag_&quot;)]，匹配id属性值中包含&quot;qiush&quot;的&lt;div&gt;
</code></pre><h3 id="BeautifulSoup4"><a href="#BeautifulSoup4" class="headerlink" title="BeautifulSoup4"></a>BeautifulSoup4</h3><pre><code>CSS选择器：BeautifulSoup4，也是一个HTML/XML的解析器，主要用于解析和提取HTML/XML数据；
    1. lxml只会局部遍历，而BeautifulSoup基于HTML DOM，会载入整个文档，解析整个DOM树，
    因此时间和内存开销都会大很多，所以性能要低于lxml；
    2. BeautifulSoup解析HTML比较简单，支持CSS选择器、Python标准库中的HTML解析器，
    也支持lxml的XML解析器；
    3. BS3目前已经停止开发，推荐使用BS4：pip install beautifulsoup4
1. from bs4 import BeautifulSoup
    1. soup = BeautifulSoup(html) --&gt; 由爬取的HTML创建BeautifulSoup对象
    2. BeautifulSoup(open(&apos;index.html&apos;)) --&gt; 打开本地HTML文件创建BeautifulSoup对象
    3. soup = BeautifulSoup(html, &apos;lxml&apos;)：指定解析器为lxml，如果没有显示指定，默认
    使用当前系统的最佳可用HTML解析器，不同的系统/虚拟环境中，使用不同的解析器造成行为不同；
    4. print soup.prettify() --&gt; 格式化输出soup对象的内容；
2. BeautifulSoup将复杂HTML文档转换成一个复杂的树形结构，每个节点都是Python对象，所有对象
   可以归纳为4种：BeautifulSoup、Tag、NavigableString、Comment
</code></pre><h4 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h4><pre><code>1. soup.element：根据标签名获取标签对象，且只返回第一个，对象类型为bs4.element.Tag
    1. soup.title：&lt;title&gt; ... &lt;/title&gt;
    2. soup.head：&lt;head&gt;&lt;title&gt; ... &lt;/title&gt;&lt;/head&gt;
    3. soup.element.get_text()：获取标签内的字符串文本。
2. 属性name
    1. BeautifulSoup表示的是一个文档的内容，它是一个特殊的Tag，soup.name：[document]
    2. soup.element.name：返回标签名，如soup.title.name：title
3. 属性attrs：获取标签的所有属性组成的字典，如果该标签没有使用属性，则返回空字典；
    1. 标签的class属性可以指定多个值，以列表的形式返回；
    2. soup.p.attrs：获取&lt;p&gt;的所有属性，{&apos;class&apos;: [&apos;cls1&apos;, &apos;cls2&apos;], &apos;name&apos;: &apos;p1&apos;}
4. soup.p[&apos;attr&apos;]/soup.p.get(&apos;attr&apos;)：根据标签的属性名获取属性值；
    1. soup.p.get(&apos;name&apos;)：获取&lt;p&gt;的name属性值；
    2. 如果标签属性有多个属性值，如class属性，则返回一个属性值列表。
5. soup.p[&apos;class&apos;] = &apos;cls3&apos;：修改&lt;p&gt;的class属性值；
6. del soup.p[&apos;class&apos;]：删除&lt;p&gt;的class属性。
</code></pre><h4 id="NavigableString"><a href="#NavigableString" class="headerlink" title="NavigableString"></a>NavigableString</h4><pre><code>&lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&apos;s story&lt;/b&gt;&lt;/p&gt;
    1. soup.p.string：获取&lt;p&gt;&lt;/p&gt;的文本内容，The Dormouse&apos;s story
    2. type(soup.p.string)：&lt;class &apos;bs4.element.NavigableString&apos;&gt;
&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;
    1. Comment是一个特殊NavigableString，其输出的内容不包括注释符号；
    2. soup.a.string：获取&lt;a&gt;&lt;/a&gt;的文本内容，Elsie
    3. type(soup.a.string)：&lt;class &apos;bs4.element.Comment&apos;&gt;
&lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;child1&lt;/b&gt;&lt;b&gt;child2&lt;/b&gt;&lt;/p&gt;
    soup.p.string：None，即当标签内只有一个直接子节点，或者没有子节点时，string才有效。
</code></pre><h4 id="遍历文档树"><a href="#遍历文档树" class="headerlink" title="遍历文档树"></a>遍历文档树</h4><pre><code>1. soup.element.contents：以列表的形式输出element的子节点的Tag对象，包括换行符\n等；
2. soup.element.children：返回一个列表迭代器listiterator，遍历获取所有子节点的Tag对象；
3. soup.element.descendants：content和children只遍历一次直接子节点，而descendants会
   递归遍历所有子节点，包括标签内的文本，返回一个生成器对象generator，遍历获取所有Tag对象；
</code></pre><h4 id="搜索文档树"><a href="#搜索文档树" class="headerlink" title="搜索文档树"></a>搜索文档树</h4><pre><code>soup.find(name, attrs, recursive, text, **kwargs)：返回第一个匹配标签的Tag对象；
soup.find_all(name, attrs, recursive, text, **kwargs)：返回一个列表；
1. 参数name：只针对标签，会自动过滤字符串文本；
    1. find_all(&apos;a&apos;)：返回所有&lt;a&gt;标签的Tag对象；
    2. find_all(re.compile(&apos;^b&apos;))：使用正则查找以&apos;b&apos;为开头的标签；
    3. find_all([&apos;a&apos;, &apos;b&apos;])：根据列表指定查找哪些标签。
2. 参数text：搜索标签内的字符串文本，返回匹配的字符串列表；
    1. text接受的参数与name相同：字符串、正则表达式、列表；
    2. find_all(text=re.compile(&apos;story&apos;))：匹配文档中包含&apos;story&apos;的字符串文本。
3. 参数attrs：根据标签的属性名和属性值进行查找，接收一个字典，多个键值表示条件与；
    1. find_all(attrs={&apos;id&apos;: &apos;uname&apos;})：查找id的属性值为&apos;uname&apos;的标签；
    2. find_all(attrs={&apos;class&apos;: &apos;con&apos;})：查找class的属性值中包含&apos;con&apos;的标签；
    3. find_all(attrs={&apos;name&apos;: &apos;uname&apos;, &apos;value&apos;: &apos;man&apos;})：查找name属性值为&apos;uname&apos;
    且value属性值为&apos;man&apos;的标签；
    4. find_all(&apos;h2&apos;, {&apos;class&apos;: &apos;ellip&apos;})：查找class的属性值包含&apos;ellip&apos;的&lt;h2&gt;
4. 参数kwargs：如果一个指定名字的参数不是搜索内置的参数名，则把该参数当作标签属性来搜索；
    1. find_all(id=&apos;login&apos;)：搜索id属性值为&apos;login&apos;的标签；
    2. find_all(href=re.compile(&quot;elsie&quot;))：搜索href属性值中匹配&apos;elsie&apos;的标签；
    3. find_all(id=True)：查找所有包含id属性的标签。
</code></pre><h4 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h4><pre><code>1. soup.select()：CSS选择器搜索文档树的方法，返回Tag列表，根据定义CSS名称的方式查找；
2. 标签选择器查找，即根据标签名查找：select(&apos;a&apos;)
3. 类选择器查找：select(&apos;.content&apos;)，匹配class属性值包含&apos;content&apos;的标签；
4. id选择器查找：select(&apos;#login&apos;)，匹配id为&apos;login&apos;的标签；
5. 利用层级选择器查找：select(&apos;.cont a&apos;)，使用了con选择器的标签下的&lt;a&gt;；
6. 只查找直接子节点：select(&apos;.cont &gt; a&apos;)，使用了con选择器的标签下的直接子节点&lt;a&gt;
</code></pre><h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><pre><code>1. python自带有json模块，import json，用于字符串和python数据类型间的转换；
2. json.loads(str)：把Json格式字符串解码转换为Python对象；
    object --&gt; dict，array --&gt; list，string --&gt; unicode str，null --&gt; None
    true/false --&gt; True/False
    1. 如果在loads()时出错，可能是因为Json字符串的编码不是UTF-8；
    2. 对于GBK编码的字符串：json.loads(jsonstr, encoding=&quot;GBK&quot;)
    3. 如果Json字符串指定了合适的编码，但是其中又包含其他编码的字符，则需要先转换为Unicode，
    然后再指定编码格式：
    unicodeStr = jsonStr.decode(&quot;GB2312&quot;); 
    data = json.loads(unicodeStr, encoding=&quot;GB2312&quot;);
    5. 任何平台的任何编码 都能和Unicode互相转换，对于UTF-8与GBK互相转换，先把UTF-8转换成
    Unicode(decode(&quot;UTF-8&quot;))，再从Unicode转换成GBK(encode(&quot;GBK&quot;))，反之同理；
    6. decode()：将其他编码的字符串转换成Unicode编码；
    7. encode()：将Unicode编码转换成其他编码的字符串。
3. json.dumps(obj)：把Python对象转为Json字符串，list/tuple --&gt; array
    1. dumps()转换时默认使用ASCII编码，dumps(obj, ensure_ascii=False)表示禁用ASCII，
    按UTF-8编码，但如果obj中是全英文的元素，仍使用ASCII编码；
    2. chardet：一个非常优秀的编码识别模块，可通过pip安装；
    3. chardet.detect(json.dumps(obj)) --&gt; {&apos;confidence&apos;:1.0,&apos;encoding&apos;:&apos;ascii&apos;}
4. json.dump(obj, open(&apos;f.json&apos;, &apos;w&apos;), ensure_ascii=False)：转为Json后写入文件；
5. json.load(open(&quot;f.json&quot;))：读取文件中Json，转为Python对象。
</code></pre><h4 id="JSONPath"><a href="#JSONPath" class="headerlink" title="JSONPath"></a>JSONPath</h4><pre><code>XPath用于匹配XML，JSONPath用于匹配Json，安装：pip install jsonpath
1. 语法对比
    1. $：根节点 --&gt; XPath的&apos;/&apos;；        @：当前节点 --&gt; XPath的&apos;.&apos;；
    2. .或[]：取子节点；    *：匹配所有节点；    [,]：多选操作 --&gt; XPath的&apos;|&apos;；
    3. ..：从任意节点开始查找 --&gt; XPath的&apos;//&apos;；    ?()：过滤操作 --&gt; XPath的&apos;[]&apos;；
    4. []：迭代器标示，可以做简单的迭代操作，如数组下标、根据内容选值等；
    5. XPath的[index]是从1开始，而JSONPath是从0开始，&apos;//book[3]&apos; &lt;--&gt; &apos;$..book[2]&apos;
2. import jsonpath
    1. city = json.loads(html)
    2. jsonpath.jsonpath(city, &apos;$..name&apos;)：从任意节点匹配name，返回一个name值的列表.
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2017/10/03/爬虫基础-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/03/爬虫基础-1/" itemprop="url">爬虫基础-1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-03T00:00:00+08:00">
                2017-10-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="爬虫概述"><a href="#爬虫概述" class="headerlink" title="爬虫概述"></a>爬虫概述</h2><pre><code>1. 网页的三大特征：
    1. 网页都有自己的唯一的URL进行定位；
    2. 网页都使用HTML来描述页面信息；
    3. 网页都使用HTTP/HTTPS协议传输HTML数据。
2. 爬虫的设计思路：
    1. 首先确定需要爬去的网页URL；
    2. 通过HTTP/HTTPS协议来获取对应的HTML页面；
    3. 提取HTML页面里有用的数据，如果页面中还有其他URL，则继续执行第二步。
</code></pre><h3 id="爬虫分类"><a href="#爬虫分类" class="headerlink" title="爬虫分类"></a>爬虫分类</h3><pre><code>1. 通用爬虫： 搜索引擎用的爬虫系统
    1. 目标：尽可能把互联网上的所有网页下载到本地服务器，形成备份，再对这些网页做相关
    处理(提取关键字、去广告)，最后提供一个用户检索接口；
    2. 抓取流程：选取一部分的种子URL，放到待爬取队列 --&gt; 从队列中取出这些URL，解析DNS
    得到主机IP --&gt; 到IP对应的服务器里下载HTML页面，保存到搜索引擎的本地服务器 --&gt;
    将这些URL放进已爬去队列 --&gt; 分析这些网页内容，找出网页里的其他URL，继续爬取，直至
    爬取条件结束。
    3. 搜索引擎获取一个新网站URL的方式：
        1. 主动向搜索引擎提交网址；
        2. 在其他网站设置外链，比如友情链接，搜索引擎在爬取时，会保存新的URL；
        3. 搜索引擎会和DNS服务商进行合作，可以快速收录新的网站。
    4. Robots协议：指明通用爬虫可以爬取网页的权限，一般只有大型搜索引擎的爬虫才会遵守；
    淘宝网的robots协议：https://www.taobao.com/robots.txt
    5. 工作流程：爬取网页 --&gt; 存储数据 --&gt; 内容处理 --&gt; 提供检索/排名服务
    6. 通用爬虫的缺点：
        1. 只能提供和文本相关的内容(HTML、Word、PDF...)，不能提供多媒体文件(音乐、图片、
        视频)和二进制文件(程序、脚本...)
        2. 提供的结果千篇一律，不能针对不同背景/领域的人提供不同的搜索结果；
        3. 不能理解人类的语义，只能提供关键字的检索。
2. 聚焦爬虫：爬虫程序员编写的针对某种内容的爬虫，弥补了通用爬虫的缺点。
    面向主题/需求爬虫，会针对某种特定的内容去爬取信息，而且会保证信息和需求尽可能相关。
</code></pre><h2 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h2><pre><code>1. HTTP协议：超文本传输协议，是一种发布与接收HTML页面的方法，默认端口号80；
2. HTTPS协议：HTTP的安全版，在HTTP下加入SSL层，默认端口号443；
    1. SSL：安全套接层，主要用于Web的安全传输协议，在传输层对网络连接进行加密；
    2. 浏览器的主要功能是向服务器发送请求，HTTP是一套计算机通过网络进行通信的规则；
    3. 网络爬虫抓取过程可以理解为：模拟浏览器操作的过程。
3. HTTP通信由两部分组成：客户端请求消息、服务器响应消息；
4. 浏览器分析Response中的HTML，发现其中还引用了其他文件，如图片、CSS文件、JS文件，
    浏览器会自动继续发送Request去获取这些资源文件。
5. URL：统一资源定位符，用于完整地描述Internet上网页和其他资源地址的一种标识方法；
    1. 格式：scheme://host[:port#]/path/.../[?query-string][#anchor]
    2. path：访问资源的路径；    query-string：参数，发送给HTTP服务器的数据；
    3. anchor：锚点，http://item.jd.com/11936.html#product-detail
    4. URL只是标识资源的位置，HTTP才是用来提交和获取资源。
</code></pre><h3 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h3><pre><code>请求消息的格式：请求行、请求头、空行、请求体
一个典型的HTTP请求：
    GET https://www.baidu.com/ HTTP/1.1
    Host: www.baidu.com
    Connection: keep-alive
    Upgrade-Insecure-Requests: 1
    User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit......
    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,......
    Referer: http://www.baidu.com/
    Accept-Encoding: gzip, deflate, sdch, br
    Accept-Language: zh-CN,zh;q=0.8,en;q=0.6
    Cookie: BAIDUID=04E4001F34EA74AD4601512DD3C41A7B:FG=1; BIDUPSID=......
1. 请求行：GET https://www.baidu.com/ HTTP/1.1
    1. GET：请求方法，常用GET和POST；
    2. https://www.baidu.com/：请求的URL；
    3. HTTP/1.1：HTTP协议和版本，0.9只有GET，1.0增加了POST和HEAD，1.1又新增了5种；
2. 请求头
    1. Host：指定请求资源的主机和端口号，通常属于URL的一部分；
    2. Connection：表示客户端与服务器链接的类型，HTTP1.1默认值为keep-alive
        1. 如果Server支持keep-alive，则回复一个包含Connection:keep-alive的响应，
        不关闭链接；否则回复一个包含Connection:close的响应，关闭链接；
        2. keep-alive在很多情况下能够重用连接，减少资源消耗，缩短响应时间。
    3. Upgrade-Insecure-Requests：升级不安全的请求，会在加载Http资源时自动替换成
        Https请求，让浏览器不再显示Https页面中的Http请求警报；
        HTTPS是以安全为目标的HTTP通道，所以在HTTPS承载的页面上不允许出现HTTP请求，
        一旦出现就会提示或报错。
    4. User-Agent：客户浏览器的名称，对爬虫而言，是最重要的参数，用于伪装请求者；
    5. Accept：client可以接受的MIME文件类型，Server根据它判断并返回适当的文件格式；
        1. Accept: */* --&gt; 表示什么都可以接收；
        2. Accept: image/gif --&gt; 客户端希望接受GIF图像格式的资源；
        3. Accept: text/html --&gt; 客户端希望接受html文本；
        4. Accept: text/html, application/xhtml+xml;q=0.9, image/*;q=0.8
        表示浏览器支持的MIME类型分别是html文本、xhtml和xml文档、所有的图像格式资源。
        5. q：权重系数，范围0-1，值越大，请求越倾向于获得其“;”之前的类型表示的内容。
        若没有指定q值，则默认为1，按从左到右排序顺序；若被赋值为0，则表示浏览器不接受
        此内容类型。
        6. text：用于标准化地表示的文本信息，文本消息可以是多种字符集/多种格式的；
        7. application：用于传输应用程序数据/二进制数据。
    6. Referer：表明产生请求的网页来自于哪个URL，它可以用来跟踪Web请求来自哪个页面、
        是从什么网站来的等等；
        有时候遇到下载某网站图片，需要对应的Referer，否则无法下载图片，是因为他们做了
        防盗链，原理就是根据Referer去判断是否是本网站的地址，如果不是，则拒绝。
    7. Accept-Encoding：文件的编解码格式，若不指定，Server不会压缩，仍响应原始数据；
        1. 编码方式不同于文件格式，它是为了压缩文件、以加速文件传输；
        2. 浏览器接收到Response后，先解码，再检查文件格式。
    8. Accept-Language：client支持的语言，en/en-us表示英语，zh/zh-cn表示中文；
    9. Accept-Charset：字符编码，如果不指定，则默认client支持所有字符集；
        1. ISO8859-1：通常叫做Latin-1，英文浏览器的默认值是ISO-8859-1
        2. gb2312：标准简体中文字符集；
        3. utf-8：可以解决多种语言文本显示问题，从而实现应用国际化和本地化。
    10. Content-Type：POST请求中的数据类型；
        1. Text/XML; charset=gb2312 --&gt; 请求体中包含的是纯文件的XML类型的数据，
        字符编码是gb2312；
        2. application/x-www-form-urlencoded --&gt; 表单数据会按照 n1=v1&amp;n2=v2
        的形式进行编码，存储在请求体中。
3. 请求体：与请求头隔一个空行，存储提交的数据/参数。
</code></pre><h3 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h3><pre><code>响应的格式：状态行、响应头、空行、响应体
    HTTP/1.1 200 OK
    Server: Tengine
    Connection: keep-alive
    Date: Wed, 30 Nov 2016 07:58:21 GMT
    Cache-Control: no-cache
    Content-Type: text/html;charset=UTF-8
    Keep-Alive: timeout=20
    Vary: Accept-Encoding
    Pragma: no-cache
    X-NWS-LOG-UUID: bd27210a-24e5-4740-8f6c-25dbafa9c395
    Content-Length: 180945

    &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; ....
1. Cache-Control: must-revalidate, no-cache, private
    1. Server不希望client缓存资源，在下次请求资源时，必须要重新请求Server，不能从
    缓存副本中获取资源；
    2. 当请求头中包含Cache-Control: max-age=0，明确表示不会缓存Server资源时，
    响应头中的Cache-Control通常为no-cache；
    3. 当请求头中没有Cache-Control时，Server往往会根据不同的资源执行不同的缓存策略，
    比如说oschina在缓存图片资源的策略就是Cache-Control：max-age=86400，即在86400s
    的时间内，client可以直接从缓存副本中读取资源，不需要再请求Server；
2. Connection: keep-alive --&gt; 告诉client，Server的TCP也是一个长链接；
3. Content-Encoding：响应资源所采用的编码格式，client应采用该编码进行解码；
4. Content-Type: text/html;charset=UTF-8 --&gt; 响应资源文件的类型及字符编码
    1. client通过utf-8对资源进行解码，然后对资源进行html解析；
    2. 如果网站乱码，往往是Server没有返回正确的编码。
5. Date：Server发送资源时的Server时间，GMT是格林尼治所在地的标准时间；
    HTTP协议的发送时间都是GMT，主要解决不同时区在互相请求资源时的时间混乱问题；
6. Expires: Sun, 1 Jan 2000 01:00:00 GMT --&gt; 也跟缓存有关，考虑到client和Server
    的时间不一定相同，Expires不如Cache-Control准确。
7. Pragma: no-cache --&gt; 与Cache-Control等同；
8. Server: Tengine/1.4.6 --&gt; 服务器和版本；
9. Transfer-Encoding: chunked --&gt; 告诉client，Server是分块发送资源的；
    1. 一般分块发送的资源都是Server动态生成的，再发送时还不确定资源的大小；
    2. 每一块都是独立的，都能标识自己的长度，当client读到长度为0的块时，则传输完毕。
10. Vary: Accept-Encoding --&gt; 告诉代理服务器缓存两种版本的资源：压缩和非压缩；
    因为现代浏览器都支持压缩，这个字段的用处并不大。
</code></pre><h4 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h4><pre><code>响应状态码：由3位数字组成，第一个数字表示响应的类别；
1. 100~199：Server成功接收部分请求，要求client继续提交其余请求才能完成整个处理过程；
2. 200~299：Server成功接收请求并已完成整个处理过程，常用200 OK 请求成功；
3. 300~399：为完成请求，client需要进一步细化请求，如：请求的资源已经移动一个新地址，
    常用302(所请求的页面已经临时转移至新的url)、307和304(使用缓存资源)；
4. 400~499：client的请求有错误；
    常用404(服务器找不到请求的页面)、403(服务器拒绝访问，权限不够)；
5. 500~599：Server出现错误，常用500(请求未完成，Server遇到不可预知的情况)。
</code></pre><h2 id="urllib2"><a href="#urllib2" class="headerlink" title="urllib2"></a>urllib2</h2><pre><code>urllib2是python2.7自带的模块，是很多网络爬虫的基础库，python3改名为urllib.request；
urllib2默认只支持HTTP/HTTPS的GET和POST；
1. 所谓的网页爬取，就是把URL地址中指定的网络资源从网络流中读取出来，保存到本地；
2. urllib2爬取百度首页
    1. res = urllib2.urlopen(&quot;http://www.baidu.com/&quot;)
    2. html = res.read() --&gt; 读取网络流中的资源；
    3. 如果中文乱码，可以使用html.decode(&apos;gbk&apos;)解码。
3. 对于缺省的请求头，urllib2会自动添加，但并不是模拟浏览器的header；
    1. 默认的User-Agent: Python-urllib/sys.version[0:3]
    2. import sys --&gt; sys.version[0:3] --&gt; 获取python的版本号
4. urllib2.Request()：构建请求头，模拟真实的client
    1. ua_headers = {&apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows......&apos;}
    2. request = urllib2.Request(&apos;http://www.baidu.com/&apos;, headers=ua_headers)
    3. res = urllib2.urlopen(request) --&gt; res.read()
    4. Request(url, data=None, headers={})：data是url提交的数据，如post的提交，
    同时HTTP请求将从GET改为POST。
    5. res.getcode() --&gt; HTTP响应码；
    6. res.geturl() --&gt; 实际响应数据的URL，防止重定向问题；
    7. res.info() --&gt; 响应的HTTP报文头。
5. User-Agent：用于决定用户的浏览器，为了获取更好的HTML页面效果；
    1. 除了Opera，其他浏览器都在间接或直接在Firefox的内核上披了一层外衣；
    2. Google:Chrome(like webkit) -&gt; Apple:Webkit(like KHTML) -&gt; Linux:KHTML
    (like Gecko) -&gt; Mozilla:Firefox(Gecko)，IE:Trident，Opera:Presto
    3. 构建一个User-Agent的列表，列表元素是浏览器真实的User-Agent信息：
    ua_list = [&apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) ...&apos;, ......]
    4. import random --&gt; ua = random.choice(ua_list) --&gt; 随机选择一个元素；
    5. request.add_header(&apos;User-Agent&apos;, ua) --&gt; 动态添加请求头User-Agent；
    6. request.get_header(&apos;User-agent&apos;)：获取指定的请求头(注：只有首字母大写)；
6. URL的中文编码：import urllib
    1. URL包含中文在时，浏览器发起请求时会自动编码，比如北京：%E5%8C%97%E4%BA%AC
    每3个作为一组，表示一个中文；空格会被编码成&quot;+&quot;；
    2. urllib.urlencode(dict) --&gt; 编码的结果：&quot;key1=value1&amp;key2=value2&quot;
    3. 解码：urllib.unquote(&quot;wd=%E5%8C%97%E4%BA%AC&quot;) --&gt; wd=北京
    4. 一般HTTP请求提交数据，需要编码成URL编码格式，然后作为url的一部分，或者作为
    参数传到Request对象中。
7. urllib、urllib2：都是接受URL请求的相关模块，最显著的不同在于：
    1. urllib只可以接受URL，不能创建设置了headers的Request的实例对象；
    2. urllib可以用于URL的编码与解码：urlencode(dict)，unquote(str)
</code></pre><h3 id="GET与POST"><a href="#GET与POST" class="headerlink" title="GET与POST"></a>GET与POST</h3><pre><code>1. GET请求的参数拼接在URL上，比如百度贴吧的必要参数：kw、pn
    1. page = int(raw_input(&apos;请输入页码: &apos;))，pn = str((page-1)*50)
    2. params = urllib.urlencode({&apos;kw&apos;:&apos;平顶山学院&apos;, &apos;pn&apos;:pn})
    3. url = &apos;http://tieba.baidu.com/f?&apos; + params
2. POST的请求参数在请求体中，参数必须与爬取网站提交的参数完全一致；
    1. data = urllib.urlencode({&apos;k1&apos;:&apos;v1&apos;, &apos;k2&apos;:&apos;v2&apos;})
    2. request = urllib2.Request(url, data=data, headers)
    3. url并不是浏览器地址栏显示的，而是通过抓包工具获取的、表单提交的URL。
3. 在headers中加入client保存的Cookie，可以模拟用户的登录，爬取登录后才展示的数据；
4. headers中不要添加Accept-Encoding: gzip，否则爬取的数据会显示乱码，因为Server
   传输的是压缩数据；
5. 有时候POST也能在URL内看到数据，是因为Form表单没有指定method=&apos;post&apos;，默认get。
</code></pre><h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><pre><code>1. AJAX是动态加载数据的，所以做爬虫最需要关注的不是页面显示的信息，而是信息的来源；
2. AJAX方式加载的页面，数据来源一定是JSON，爬取到JSON，也就得到了数据；
3. 通过抓包工具，获取动态数据的URL及其参数，对URL进行POST/GET获取数据。
</code></pre><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><pre><code>1. HTTPS请求需要通过SSL证书验证，如果网站的SSL证书是经过CA认证的，则能正常访问；
    1. 如果SSL证书验证不通过，浏览器会警告用户证书不受信任，如12306网站；
    2. urllib2在爬取&apos;https://www.12306.cn/mormhweb/&apos;时，会报出SSLError。
2. import ssl：SSL处理模块
    1. context = ssl._create_unverified_context() --&gt; 忽略未经允许的SSL证书
    2. response = urllib2.urlopen(request, context = context)
3. 除了电子交易等对安全要求比较高的网站必须使用HTTPS请求之外，一般支持HTTPS请求的URL，
   都支持HTTP请求，所以爬取的URL使用HTTP即可。
</code></pre><h2 id="Handler与Opener"><a href="#Handler与Opener" class="headerlink" title="Handler与Opener"></a>Handler与Opener</h2><pre><code>urllib2.urlopen()的实现过程：
    1. 默认创建的Handler处理器是HTTPSHandler，build_opener(handler)构建Opener实例；
    2. 由Opener的open()发送请求。
1. urllib2提供了很多Handler处理器，比如：使用HTTPHandler，自定义Opener
    handler = urllib2.HTTPHandler()
    opener = urllib2.build_opener(handler)
    request = urllib2.Request(&apos;http://www.baidu.com/&apos;)
    html = opener.open(request).read()
2. build_opener(handler1, handler2, ...)：可以同时添加多个处理器；
3. opener.addheaders = [(&apos;k1&apos;,&apos;v1&apos;), (&apos;k2&apos;,&apos;v2&apos;), ...]：也能为Opener添加请求头；
4. Handler支持调试：Handler(debuglevel=1)，会打印收包和发包的报头信息；
5. 提升自定义Opener为全局的：urllib2.install_opener(opener)，之后所有的urlopen()
   都将使用自定义Opener发送请求。
</code></pre><h3 id="ProxyHandler"><a href="#ProxyHandler" class="headerlink" title="ProxyHandler"></a>ProxyHandler</h3><pre><code>很多网站会检测某段时间内同一个IP的访问次数(流量统计、系统日志等)，禁止访问次数异常的IP；
所以，设置一些代理服务器，每隔一段时间换一个代理，即便IP被禁止，依然可以更换IP继续爬取。
1. ProxyHandler：代理处理器，使用代理IP，通常是最好用的爬虫/反爬虫机制；
2. ProxyHandler({&apos;代理类型&apos;: &apos;代理服务器的Ip:Port&apos;})：如果是空字典，表示不使用代理；
    1. http_proxy = ProxyHandler({&apos;http&apos;: &apos;124.88.67.54:80&apos;})
    2. 主机和代理服务器支持的编码可能不一致，而资源服务器是以代理服务器的编码为准，
    所以本机接收到代理服务器转发的数据之后，需要按照代理服务器的编码进行decode()解码。
3. 私密代理需要账号密码授权：ProxyHandler({&apos;代理类型&apos;: &apos;用户名:密码@Ip:Port&apos;})
    1. 用户名/密码错误，会报HTTP Error 407: Proxy Authentication Required
    2. 代理信息通常不会明文写在代码中，比如放在系统环境变量的配置文件中：
        proxyuser=&quot;用户名&quot;
        export proxyuser
        1. 执行命令：source 文件名 --&gt; 让新的配置信息生效
        2. import os --&gt; 用于操作系统相关的模块
        3. name = os.environ.get(&apos;proxyuser&apos;)
</code></pre><h3 id="授权验证处理器"><a href="#授权验证处理器" class="headerlink" title="授权验证处理器"></a>授权验证处理器</h3><pre><code>HTTPPasswordMgrWithDefaultRealm：密码管理对象，用于保存HTTP请求相关的用户名/密码；
主要应用：
    1. 私密代理授权验证的用户名和密码，对应处理器：ProxyBasicAuthHandler
    2. 验证Web Client的用户名和密码，对应处理器：HTTPBasicAuthHandler
1. ProxyBasicAuthHandler：可以处理代理身份验证的处理器，ProxyHandler的升级；
    1. 构建密码管理对象：mgr = urllib2.HTTPPasswordMgrWithDefaultRealm()
    2. 添加账户信息：mgr.add_password(None, &apos;代理服务器Ip:Port&apos;, &apos;用户名&apos;, &apos;密码&apos;)
    第一个参数是与远程服务器相关的域信息，一般为None；
    3. 构建处理身份验证的代理处理器：handler = urllib2.ProxyBasicAuthHandler(mgr)
    4. 因为这种方式比较复杂，通常还是直接使用ProxyHandler()实现私密验证。
2. HTTPBasicAuthHandler
    1. 有些WebServer访问时，需要进行用户身份验证，爬虫直接访问时会报HTTP 401
    2. 构建密码管理对象：mgr = urllib2.HTTPPasswordMgrWithDefaultRealm()
    3. 添加账户信息：mgr.add_password(None, &apos;服务器地址&apos;, &apos;用户名&apos;, &apos;密码&apos;)
    4. 构建WebClient授权验证的处理器：handler = urllib2.HTTPBasicAuthHandler(mgr)
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2017/10/01/Django/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/01/Django/" itemprop="url">Django</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-01T00:00:00+08:00">
                2017-10-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index">
                    <span itemprop="name">Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h2><pre><code>安装搭建虚拟环境的工具：pip install virtualenv，然后做一些必要的配置；
1. 创建/删除一个虚拟环境：mkvirtualenv/rmvirtualenv 虚拟环境名
2. 进入一个虚拟环境：workon 虚拟环境名
3. 退出当前的虚拟环境：deactivate
4. 查看当前虚拟环境中已经安装的包：pip list，pip freeze
</code></pre><h2 id="django"><a href="#django" class="headerlink" title="django"></a>django</h2><pre><code>安装django并指定版本：pip install django==1.8.2，会自动删除旧版本
1. 查看django版本：python shell --&gt; import django --&gt; django.get_version()
2. 创建项目：django-admin startproject 项目名
   默认生成一个与项目同名的应用，用于项目的配置：
    1. manage.py：一个命令行工具，可以用多种方式对Django项目进行交互；
    2. settings.py：项目的配置文件； urls.py：项目的URL声明；
    3. wsgi.py：项目与WSGI兼容的Web服务器入口；
    4. django默认使用SQLite数据库，同时支持mysql、oracle
3. 一个项目包含多个应用，创建应用：python manage.py startapp 应用名
    1. 在settings.py中注册模型：INSTALLED_APPS = ( ... , &apos;模型名&apos;)
    2. 在模型/models.py中创建model，用于生成数据库；
    3. 数据库的迁移：python manage.py makemigrations --&gt; ... migrate
    4. 进入测试环境：python manage.py shell
4. 开启服务器：python manage.py runserver ip:port
    1. ip默认localhost/127.0.0.1，port默认8000
    2. 这是一个纯Python编写的轻量级web服务器，仅在开发阶段使用；
    3. 修改文件不需要重启服务器，增删文件则需要重启服务器。
5. 站点管理
    1. 站点分为：内容发布和公共访问，内容发布的部分负责添加、修改、删除内容；
    2. 创建管理员用户：python manage.py craetesuperuser
    3. 启动服务器，访问站点：http://127.0.0.1:8000/admin
    4. 管理站点的应用：项目settings.py中的
    INSTALLED_APPS = (&apos;django.contrib.admin&apos;, ...)
6. 使用MySql数据库
    1. 在虚拟环境中安装MySql包：pip install mysql-python
    2. 登录MySql创建数据库：create database test2 charset=utf8;
    3. 在项目settings.py配置MySql：
    DATABASES = { &apos;default&apos;: { &apos;ENGINE&apos;: &apos;django.db.backends.mysql&apos;,
    &apos;NAME&apos;: &apos;test2&apos;, &apos;USER&apos;: &apos;用户名&apos;, &apos;PASSWORD&apos;: &apos;密码&apos;,
    &apos;HOST&apos;: &apos;数据库服务器ip，本地可用localhost&apos;, &apos;PORT&apos;: &apos;默认3306&apos; } }
7. settings.py修改测试模式为发布模式：
    1. DEBUG = False
    2. ALLOWED_HOSTS = [ &apos;*&apos;, ]：设置允许访问的主机，* 表示所有主机；
</code></pre><h2 id="状态保持"><a href="#状态保持" class="headerlink" title="状态保持"></a>状态保持</h2><pre><code>1. HTTP协议是无状态的，每一次请求都是新的，不会记录之前的通信状态；
2. 客户端与服务器端的一次通信，就是一次会话；
3. 实在状态保持的方式：在客户端/服务器端存储与会话有关的数据；
4. 存储方式：cookie、session，会话一般指session对象；
5. 状态保持的目的是在一段时间内跟踪请求者的状态，实现跨页面访问当前请求者的数据；
注意：但不同的请求者之间不会共享这个数据，该数据与请求者一一对应。
</code></pre><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><pre><code>session：服务器端记录客户端状态的一种机制，相应地会增加服务器端的存储压力；
1. session是cookie的一种，使用方式类似，都是键值对形式；
2. cookie保存在客户端浏览器，不能存储敏感信息，而session保存在服务器，数据更安全，
   所以使用session实现状态保持；
3. session依赖于cookie，每个session在存储时，都有一个session_id作为唯一标识，
   cookie中存储有session_id，用于区分不同请求者的session.
</code></pre><h3 id="django与session"><a href="#django与session" class="headerlink" title="django与session"></a>django与session</h3><pre><code>1. django默认启用session，在settings.py中：
    1. INSTALLED_APPS：django.contrib.sessions
    2. MIDDLEWARE_CLASSES：
    django.contrib.sessions.middleware.SessionMiddleware
    3. 删除这两个元素，即可禁止会话session，可节省一些性能；
    4. session默认两个星期之后过期。
2. django默认将session存储在数据库中，所以使用session之前必须做数据库的迁移；
3. 在settings.py中设置session的存储方式：
    1. 默认方式：SESSION_ENGINE=&apos;django.contrib.sessions.backends.db&apos;
    2. 基于缓存：存储在内存中，django.contrib.sessions.backends.cache
    3. 同时使用缓存和数据库：优先从本地缓存中读取
    SESSION_ENGINE=&apos;django.contrib.sessions.backends.cached_db&apos;
4. 会话还支持文件、纯cookie、Memcached、Redis等方式存储，以Redis为例：
    1. 在当前虚拟环境下安装Redis：pip install django-redis-sessions
    2. 配置settings.py：
        SESSION_ENGINE = &apos;redis_sessions.session&apos;
        SESSION_REDIS_HOST = &apos;localhost&apos;
        SESSION_REDIS_PORT = 6379
        SESSION_REDIS_DB = 0
        SESSION_REDIS_PASSWORD = &apos;&apos;
        SESSION_REDIS_PREFIX = &apos;session&apos;
    3. 启动Redis：sudo redis-server /etc/redis/redis.conf
</code></pre><h2 id="DTL"><a href="#DTL" class="headerlink" title="DTL"></a>DTL</h2><pre><code>1. DTL：Django模板语言，定义在django.template包中，在HTML中使用；
    1. 变量语法：{{ 变量 }}
    2. 执行Python代码：{% 代码块 %}
    3. 过滤器：{{ 变量|过滤器 }}
    4. {\# 单行注释 \#}，{% comment %} 多行注释 {% endcomment %}
2. HTML转义：视图在向HTML中传递包含HTML标签的字符串时，Django会对标签自动转义；
    1. HTML标签原样输出、而不解释执行，是为了防止可能存在的攻击代码，如JS脚本；
    2. &lt; 转换为 &amp;lt，&gt; 转换为 &amp;gt，&apos; --&gt; &amp;#39，&quot; --&gt; &amp;quot，&amp; --&gt; &amp;amp；
    3. 转义的过滤器：escape，{{ t1|escape }}，Django默认自动转义，默认省略；
    4. 关闭转义的过滤器：safe，{{ t1|safe }}
    5. 关闭代码块的转义：{% autoescape off %} {{ t1 }} {% endautoescape %}
    6. base模板中关闭自动转义，其child模板也是关闭的。
</code></pre><h2 id="反向解析"><a href="#反向解析" class="headerlink" title="反向解析"></a>反向解析</h2><pre><code>域名：http://127.0.0.1:9000
&lt;a&gt;的href、&lt;form&gt;的action、&lt;img/&gt;的src在引用同域名的URL时，如href=&apos;/a/b/&apos;，
其中，第一个&apos;/&apos;表示项目的根目录，即引用的地址是域名+&apos;/a/b/&apos;：
http://127.0.0.1:9000/a/b/
而href=&apos;a/b/&apos;则表示当前目录，即当前地址+&apos;a/b/&apos;，假设当前地址为：
http://127.0.0.1:9000/m/n/
则引用地址为：http://127.0.0.1:9000/m/n/a/b/

反向解析：解除这种硬编码的形式，通过include()的namespace和url()的name动态生成URL。
1. 配置应用的urls.py：url(r&apos;^&apos;, include(&apos;booktest.urls&apos;, namespace=&apos;booktest&apos;))
2. booktest应用的urls.py：url(&apos;^$&apos;, views.index, name=&apos;index&apos;)
3. 使用反向解析策略：&lt;a href=&quot;{% url 'booktest:index' %}&quot;&gt;
4. 反向解析避免了硬编码，不再受限于项目配置应用url(r&apos;^&apos;, ...)中的正则变更。
</code></pre><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><pre><code>CSRF：Cross Site Request Forgery，跨站请求伪造
1. 某些恶意网站上包含链接、表单或JS，它们利用登录过的用户在浏览器中的认证信息，试图在你的
   网站上完成某些操作，即跨站攻击；
2. django默认开启了CSRF防御，在配置应用的settings.py中，启用中间件：
    MIDDLEWARE_CLASSES = (&apos;django.middleware.csrf.CsrfViewMiddleware&apos;, )
3. 对于post请求的表单，必须加入CSRF验证，才能提交成功：
    &lt;form method=&apos;POST&apos;&gt; {% csrf_token %} ... &lt;/form&gt;
4. {% csrf_token %}其实是一个隐藏域：&lt;input type=&apos;hidden&apos; ... /&gt;
    在提交时，请求头中会携带一个cookie信息，用于验证身份；
5. 验证码也是有效防御CSRF的一种方式，原理：随机生成的验证码存储在session中，提交表单时，
   比较用户填写的验证码是否与session中的一致。
</code></pre><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><pre><code>中间件：一个轻量级、底层的插件系统，可以介入Django的请求/响应处理过程，修改输入/输出。
1. 项目配置应用的settings.py中，MIDDLEWARE_CLASSES元组中元素都是激活的中间件；
2. 中间件的技术思想是AOP，面向切面编程，Django处理一个网络请求的过程：
    接收请求--A--&gt;匹配URL--B--&gt;查找视图View--C--&gt;对应模板Template--D--&gt;响应
3. 对于某些特殊需求，可能需要干涉网络请求的过程，从而不得不修改Django的源代码，为了应对
   这种需求，Django提供了中间件，可以干涉A、B、C、D四个环节，从而避免开发者修改源代码；
4. 中间件的本质也就是一个Python类，可以定义的方法包括：
    1. _init_：无需任何参数，服务器响应第一个请求时响应一次，用于确定是否启用中间件；
    2. process_request(request)：对应A环节，返回None/HttpResponse对象；
    3. process_view(request, view_func, view_args, view_kwargs)：对应B环节，
    返回None/HttpResponse对象；
    4. process_template_response(request, response)：对应C环节，返回实现了
    render()的响应对象；
    5. process_response(request, response)：对应D环节，返回HttpResponse对象；
    6. process_exception(request, response, exception)：当视图抛出异常时调用，
    返回一个HttpResponse对象，然后响应给浏览器；404是匹配URL的错误，不会调用。
    7. 自定义的中间件(Python类)也必须在MIDDLEWARE_CLASSES中注册，才会启用。
5. 使用中间件，可以干扰整个处理过程，每次请求中都会执行中间件的方法。
</code></pre><h2 id="静态文件管理"><a href="#静态文件管理" class="headerlink" title="静态文件管理"></a>静态文件管理</h2><pre><code>项目中的CSS、JS、图片都是静态文件，静态文件的处理并不需要经过Django，可以直接请求。
1. 为了便于迁移，在项目根目录下创建static文件夹，用于存放静态文件；
2. 项目的配置应用settings.py中：
    1. STATIC_URL = &apos;/static/&apos; --&gt; 静态文件的逻辑地址，用于伪装静态文件的真实目录；
    2. STATICFILES_DIRS = [ os.path.join(BASE_DIR, &apos;static&apos;), ] --&gt; 物理地址；
3. 在模板中使用一个静态文件：/static/myapp/logo.jpg
    1. 这种硬编码的形式，一旦STATIC_URL修改了，该地址也要修改；
    2. static编码：{% load static from staticfiles %}
    &lt;img src=&quot;{ % static &apos;myapp/logo.jpg&apos; %}&quot; alt=&quot;My image&quot;/&gt;
4. 对于上传的静态文件，则在static目录下创建media文件夹，settings.py中配置：
    MEDIA_ROOT = os.path.join(BASE_DIR, &apos;static/media&apos;)
</code></pre><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><pre><code>Django自带一个健壮的缓存系统来保存动态页面，避免对于每次请求都重新计算；
Django可以控制缓存粒度：缓存特定视图的输出、仅仅缓存难以生产的部分数据、缓存整个网站；
1. 缓存配置
    1. 缓存可以设置在数据库中、文件系统、内存中；
    2. 项目的配置应用settings.py：
    CACHES = {
        &apos;default&apos;: {
            &apos;BACKEND&apos;: &apos;django.core.cache.backends.locmem.LocMemCache&apos;,
            &apos;TIMEOUT&apos;: 60,
        }
    }
    BACKEND：设置缓存的存储位置；
    TIMEOUT：缓存的默认过期时间(s)，默认是300秒；None表示永不过期，0表示立即失效。
2. 启用Redis缓存：
    1. 安装包：pip install django-redis-cache，默认使用编号为1的数据库；
    2. 配置：
    &apos;BACKEND&apos;: &apos;redis_cache.cache.RedisCache&apos;,
    &apos;LOCATION&apos;: &apos;localhost:6379&apos;,
3. 缓存单个视图View
    1. from django.views.decorators.cache import cache_page
    2. @cache_page(timeout)：timeout表示过期时间，单位是秒；
    @cache_page(60 * 15)
    def index(request):
        pass
    3. 15分钟内重复访问index视图，数据都是从缓存中获取的，不会重复执行index()；
    4. 如果多个URL指向同一个视图，每个URL会分别缓存该视图。
4. 模板片段缓存：缓存模板中一块数据
    1. {% load cache %}
    2. {% cache 300 hello %} 被缓存的数据 {% endcache %}
    3. 500表示缓存时间(s)，hello表示缓存片段的名称。
5. 缓存视图内的某些数据
    1. from django.core.cache import cache
    2. 设置/获取：cache.set(key, value, timeout)，cache.get(key)
    3. 删除/清空：cache.delete(key)，cache.clear()
</code></pre><h2 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h2><pre><code>视图view在操作数据库时，如果不满足某种条件，或者发生异常，希望回滚到指定的代码位置；
from django.db import transaction
@transaction.atomic()
def handle(request):
    tran_id = transaction.savepoint() --&gt; 埋点
    try:
        ......
    except Exception as e:
        transaction.savepoint_rollback(tran_id) --&gt; 回滚到埋点处
</code></pre><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><pre><code>处理三个方面：uwsgi、nginx、静态文件static
1. 配置服务器上的python虚拟环境，安装所需要的包，用ftp把项目上传到服务器的某个目录；
2. 更改项目的setting.py文件：
    1. DEBUG = False
    2. ALLOW_HOSTS=[&apos;*&apos;, ] --&gt; 表示允许任何Ip的终端访问服务器
3. python manage.py runserver：启动服务器，运行正常，但是静态文件无法加载。
</code></pre><h3 id="WSGI"><a href="#WSGI" class="headerlink" title="WSGI"></a>WSGI</h3><pre><code>WSGI：生产环境使用，Web服务器网关接口，Python Web Server Gateway Interface
1. python manage.py runserver：只是一个适合开发阶段使用的服务器，不适合生产环境；
2. WSGI是Python应用/框架与Web服务器之间的一种接口，Django项目默认遵守WSGI协议，
   只要是实现了WSGI的产品，就可以运行Python代码；
3. WSGI没有官方的实现，因为WSGI更像一个协议，只要遵守这些协议，WSGI应用就可以在任何
   服务器上运行。
4. django命令创建项目时会生成一个简单的wsgi.py文件，配置了项目的运行环境；
   wsgi.py确定了settings、application对象：
    1. 在Python模块中使用application对象与应用服务器交互；
    2. Django需要导入settings模块，它是定义应用的地方。
注：此处所指的服务器其实就是一个软件，可以监听网卡端口、遵从网络层传输协议、收发Http协议
    级别的数据。
</code></pre><h3 id="uWSGI"><a href="#uWSGI" class="headerlink" title="uWSGI"></a>uWSGI</h3><pre><code>1. uWSGI实现了WSGI的所有接口，是一个快速、自我修复、开发人员和系统管理员友好的服务器；
2. uWSGI代码完全用C编写，可以监听网卡的某个端口，获取请求报文，交给python代码处理；
3. 安装：pip install uwsgi，在项目的根目录下新建uwsgi.ini，用于配置uWSGI
    [uwsgi]
    socket=外网Ip:端口 --&gt; 使用nginx连接时，只能使用socket协议
    http=外网ip:端口 --&gt; 直接做web服务器，则使用Http协议，与socket二选一
    chdir=项目根目录，绝对路径
    wsgi-file=项目中wsgi.py文件的目录，相对于项目根目录
    processes=4 --&gt; 启用n个进程运行uWSGI服务器
    threads=2 --&gt; 每个进程启用n个线程运行uWSGI服务器，进程和线程的数量与硬件配置有关
    master=True --&gt; 作为主机运行
    pidfile=uwsgi.pid --&gt; 记录uWSGI服务的pid，便于关闭服务
    daemonize=uwsgi.log --&gt; 指定记录日志的文件
4. 启动：uwsgi --ini uwsgi.ini    停止/重启：uwsgi --stop/reload uwsgi.pid
5. 使用http协议查看网站运行情况，运行正常，但是静态文件无法加载。
</code></pre><h3 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h3><pre><code>1. nginx的作用：
    1. 负载均衡：多台服务器轮流处理请求；
    2. 反向代理：隐藏真实服务器。
2. 实现架构：客户端请求nginx --&gt; nginx请求uwsgi --&gt; 运行框架下的python代码；
3. 安装：sudo apt-get install nginx
    1. 主程序目录：/usr/sbin/nginx    配置文件目录：/etc/nginx
    2. 存放静态文件的目录：/usr/share/nginx    日志目录：/var/log/nginx
    3. sudo nginx：启动；    sudo nginx -v：查看版本；
    4. 停止/重启：sudo nginx -s stop/reload
4. 配置：/etc/nginx/nginx.conf --&gt; http节点：include /etc/nginx/sites-enabled/*
    1. sites-enabled目录下有文件default，可配置多个server节点，对应多个服务器；
    server {
        listen 192.168.233.128:80 default_server; --&gt; nginx监听的Ip和端口；
        location / {    --&gt; 配置转发的uwsgi
            include uwsgi_params; --&gt; 将所有的参数转给uwsgi
            uwsgi_pass 192.168.233.128:8989; --&gt; uwsgi.ini中配置的Ip和端口
        }
    }
    2. 配置uswgi.ini，禁用http：socket=192.168.233.128:8989
    3. 重启uwsgi、nginx，访问http://192.168.233.128/，80是http的默认端口。
</code></pre><h3 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h3><pre><code>对于静态文件，nginx可以直接返回给客户端，不需要再转到uwsgi；
1. 在server节点下配置静态文件路径：
    server {
        ...
        location /static {
            alias /var/www/项目名/static/;
        }
    }
2. 在服务器的/var/www目录下创建一个与项目同名的目录，如servtest
    1. 修改其权限：sudo chmod 777 /var/www/servtest
    2. 在servtest目录下创建static目录，用于存放静态文件；
    3. 配置项目的settings.py：STATIC_ROOT=&apos;/var/www/servtest/static/&apos;
    4. 收集所有静态文件到STATIC_ROOT指定的目录：python manage.py collectstatic
3. 重启uwsgi、nginx，即可访问到静态文件；
4. 同理，MEDIA_ROOT=&apos;/var/www/servtest/static/media&apos;
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">大麦田怪圈</p>
              <p class="site-description motion-element" itemprop="description">敢做就能赢！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">62</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大麦田怪圈</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
