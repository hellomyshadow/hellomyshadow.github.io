<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="敢做就能赢！">
<meta property="og:type" content="website">
<meta property="og:title" content="大麦田程序猿">
<meta property="og:url" content="http://hellomyshadow.github.io/index.html">
<meta property="og:site_name" content="大麦田程序猿">
<meta property="og:description" content="敢做就能赢！">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="大麦田程序猿">
<meta name="twitter:description" content="敢做就能赢！">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hellomyshadow.github.io/">





  <title>大麦田程序猿</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大麦田程序猿</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/09/08/TypeScript-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/08/TypeScript-2/" itemprop="url">TypeScript-2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-08T00:00:00+08:00">
                2018-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><pre><code>1. 装饰器：在尽可能不改变类结构的情况下，扩展其功能；
2. 装饰器是一种特殊类型的声明，可以被附加到类声明、属性、方法、参数、访问符上；
3. 启用装饰器：
    &quot;compilerOptions&quot;: {
        &quot;experimentalDecorators&quot;: true
    }
4. 装饰器函数
    1. 要在一个类/方法上使用装饰器，首先需要提供一个装饰器函数；
    2. 装饰器函数会在该装饰器被调用时调用；
5. 使用装饰器：在需要被装饰的类/方法前，通过 @装饰器名 来调用装饰器
    @f
    class Test { }
6. 装饰器可以累加，可以排在一行，也可以分为多行。
</code></pre><h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><pre><code>1. 类装饰器应用于构造函数，可以用来监视/修改/替换类的定义；
2. 类的构造函数会作为类装饰器函数的唯一一个参数
    function fn&lt;T extends {new(...args: any[]): {}}&gt;(constructor: T): T {
        class Ps extends constructor {
            age: number = 0;  ---&gt; 扩展一个类型为number的属性age
        }
        return Ps;
    }
    @fn
    class Person{ }  --&gt; 装饰之后的Person已经变成了Ps
3. 装饰器传参：闭包
    function fn(v: number) {
        return function&lt;T extends {new(...args: any[]): {}}&gt;(cst: T): T {
            class Ps extends cst {
                age: number = v;
            }
        }
    }
    @fn(10)
    class Person { }  ---&gt; age:number = 10
    @fn(20)
    class Cat { } ---&gt; age:number = 20
</code></pre><h3 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h3><pre><code>1. 方法装饰器对类的方法进行装饰，在调用时会传入3个参数：
    1. 对于静态成员，传入的是类的构造函数；对于实例成员，传入的是类的原型对象；
    2. 成员的名称；
    3. 成员属性描述符。
2. tsconfig.json
    1. 配置编译系统、编译保存、移除注释...
    &quot;compileOnSave&quot;: true, --&gt; 自动编译并保存
    &quot;compilerOptions&quot;: {
        &quot;moduleResolution&quot;: &quot;node&quot;, --&gt; 按node编译
        &quot;removeComments&quot;: true, ----&gt; 生成JS代码后，移除注释内容
        &quot;sourceMap&quot;: true, --&gt; 配合后期调试
        &quot;emitDecoratorMetadata&quot;: true,  --&gt; 支持元数据，装饰器需要使用
        &quot;typeRoots&quot;: [] --&gt; 为TS编译器指定检查类型的依据文件
    }
3. 
</code></pre><h3 id="访问器装饰器"><a href="#访问器装饰器" class="headerlink" title="访问器装饰器"></a>访问器装饰器</h3><pre><code>1. 访问器：get、set
2. 访问器装饰器在调用时传入的参数，与方法装饰器相同
3. 不允许同时装饰一个成员的get、set访问器；
4. 一个成员的所有装饰器必须应用在文档顺序的第一个访问器上；
</code></pre><h3 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h3><pre><code>1. 属性装饰器声明在一个属性声明之前
2. 被调用时传入2个参数：
    1. 对于静态成员，传入的是类的构造函数；对于实例成员，传入的是类的原型对象；
    2. 成员的名称。
</code></pre><h3 id="参数装饰器"><a href="#参数装饰器" class="headerlink" title="参数装饰器"></a>参数装饰器</h3><pre><code>1. 参数装饰器声明在一个参数声明之前；
2. 被调用时传入3个参数
    1. 对于静态成员，传入的是类的构造函数；对于实例成员，传入的是类的原型对象；
    2. 成员的名称；
    3. 参数在函数参数列表上的索引。
3. 参数装饰器只能用来监视一个方法的参数是否被传入；
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/09/05/TypeScript-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/05/TypeScript-1/" itemprop="url">TypeScript-1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-05T00:00:00+08:00">
                2018-09-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><pre><code>1. TypeScript是微软开发的，基于类的面向对象编程，其文件以 .ts 为后缀名；
2. TypeScript是JavaScript的超集，完全兼容JavaScript代码；
3. TypeScript只存活于编译阶段，编译为JavaScript之后，在浏览器/Node环境下才能运行；
4. 安装TS编译器：npm i typescript -g  ===&gt; tsc ts文件名 [编译后输出目录及文件]
    1. 默认情况下，编译生成的js文件输出到当前目录下；
    2. tsc t1.ts --outDir ./dist：编译后的t1.js文件输出到dist目录下。
</code></pre><h2 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h2><pre><code>1. tsconfig.json：用于配置 tsc 的编译配置选项，如js文件的输出目录
2. 当 tsc 不指定要编译的ts文件时，编译器会从当前目录开始逐级向上查找tsconfig.json
3. 当指定了编译的ts文件时，tsconfig.json会被忽略；
4. --project(-p)：指定一个包含 tsconfig.json 的目录来进行编译；
</code></pre><h3 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h3><pre><code>1. compilerOptions：编译选项的配置，在tsconfig.json的第一层
    { 
        &quot;compilerOptions&quot;: { }
    }
2. 配置输出目录
    &quot;compilerOptions&quot;: {
        &quot;outDir&quot;: &quot;./dist&quot;  ---&gt; 指定输出目录：tsconfig.json所在目录/dist
    }
    1. 执行 tsc 命令，但不指定任何ts文件，会自动把ts文件编译输出到dist目录。
3. 合并输出到一个文件，合并的文件顺序为加载和依赖顺序
    &quot;compilerOptions&quot;: {
        &quot;outFile&quot;: &quot;./bundle.js&quot;  ---&gt; 把ts文件合并编译输出到bundle.js中
    }
4. target：指定编译后的js对应的ECMAScript版本，es3、es5、es6、es2015、es2016 ...
5. module：编译后的js所使用的模块化系统，none、commonjs、es2015、amd、esnext ...
</code></pre><h3 id="指定编译文件"><a href="#指定编译文件" class="headerlink" title="指定编译文件"></a>指定编译文件</h3><pre><code>1. 执行 tsc 命令，但不指定任何ts文件时，默认会编译当前项目中的所有ts文件；
2. include：指定要编译的ts文件目录
    &quot;include&quot;: [ &quot;./src/&quot; ] ---&gt; 编译tsconfig.json所在目录/src目录下的ts文件
    1. 使用glob模式，类似于正则表达式，**/ 递归匹配任意子目录；
    2. * 匹配0或多个字符，? 匹配一个任意字符，但都不包括目录分隔符；
    3. &quot;./src/*&quot;：只编译src目录下的ts文件，不包括src的子目录；
    4. &quot;./src/**/*&quot;：递归编译src目录下的ts文件，包括子目录；
3. exclude：指定不编译的ts文件目录，默认已经排除了 node_modules 和 &lt;outDir&gt; 目录
</code></pre><h2 id="ts-node"><a href="#ts-node" class="headerlink" title="ts-node"></a>ts-node</h2><pre><code>1. npm i ts-node -D/-g：与 tsc 命令不同的是，它会编译并执行ts文件；
2. ts-node 命令也会读取 tsconfig.json
</code></pre><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><pre><code>1. 语法：let 变量: 类型
    1. let input: HTMLInputElement = document.querySelector(&apos;uname&apos;);
    2. let value: number = Number(input.value) + 10;
    3. let a: string;  a = 1; --&gt; 报错
2. TS的类型：数字、字符串、布尔型、null、undefined、数组、元组、枚举、void、any、Never
3. 基本类型与包装类型
    1. 基本类型：string、number、boolean
    2. 包装类型：String、Number、Boolean
    3. 基本类型可以直接赋值给对应的包装类型，但反之不行。
    let s: String = &apos;nodejs&apos;;
4. 数组
    1. 基本语法：let list: number[];  --&gt; 一个number类型的数组，只能存储number
    2. 泛型方式：let list: Array&lt;number&gt;;
5. 元组：与数组类似，但可以存储不同类型的元素
    1. let tup: [number, string, boolean];  --&gt; 定义一个存储三种类型的元组
    2. 元组的元素顺序必须与定义的类型一一对应，tup[0]=1; tup[1]=&apos;a&apos;; tup[2]=true;
    3. 对于越界部分的元素，则采用联合类型(三种类型中的任意一种)：tup[3]=&apos;b&apos;;
    4. 定义联合类型的元组：let tup: string|number; --&gt; 元素类型属于这两种之一即可
    5. 交叉类型的元组：let tup: string&amp;number; --&gt; 此元组必须包含这两种类型的元素
6. 枚举：为一组数据赋予友好的名字
    1. enum Color {Red, Green, Blue};  --&gt;Color.Red，Color.Green，Color.Blue
    2. 默认情况下，元素的编号从 0 开始，也可以手动指定编号，enum Color {Red=1, ...};
7. 更多其他类型：null、undefined、void、any、never
    1. null和undefined的值分别只有null、undefined，所以用处不大；
    2. let a: undefined = undefined; 不能再赋其他值，只能赋值undefined
    3. 默认情况下，null和undefined是所以类型的子类型，可以赋值给其他类型；
    4. 如果采用严格模式，则不允许把null和undefined赋值给其他类型；
    5. 启用严格模式：tsconfig.json的 compilerOptions 下增加 strictNullChecks
    &quot;compilerOptions&quot;: {
        &quot;strictNullChecks&quot;: true
    }
    let div1 = document.querySelector(&apos;#div1&apos;);
    div1.style.color = &apos;red&apos;;  --&gt; ts报错，因为div1可能为null，需要判断不为null
    6. never：表示那些永不存在的值的类型；
    7. any：任意类型，在不确定返回类型的情况下使用；
    8. void：与 any 相反，表示没有任何类型，常见于没有返回值的函数。
8. 类型推导
    1. 有时候不一定强制使用类型声明，TS会根据语境进行类型推导；
    2. TS的变量初始化推导
    let a;  a=1; --&gt; 变量a 是number类型，不允许再赋予其他类型的值；
    3. TS的上下文推导
    btn.onclick = function(e) {} --&gt; e: MouseEvent
    btn.onkeydown = function(e) {} --&gt; e: KeyboardEvent
    4. TS会根据当前绑定的事件，推导出回调函数的第一个参数类型MouseEvent/KeyboardEvent
</code></pre><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><pre><code>1. 函数声明：function fn(x: Type, y: Type): Type { ... }
    function fn(x: number, y: number): number { --&gt; 参数为number，返回值为number
        return x+y;
    }
    let fn = function(x: number, y: number): number { return x+y; }
2. 函数表达式：let fn:(x:Type, y:Type) =&gt; Type = function(x:Type, y:Type){ ... }
    let fn: (x: number, y: number) =&gt; number = function(x, y) {
        return x+y;
    }
    1. 函数体function的参数类型可以省略，ts会进行类型推导
3. 类型约束：函数参数、函数返回值、无返回值的类型为void
4. 可选参数：通过 ? 定义，默认值为undefined(与ES6保持一致)，必须在必传参数之后
    function fn(x: number, y?: number): void { ... }
    fn(10); --&gt; 参数y 为可选参数
5. 默认值：如果手动指定了可选参数的默认值，则不能再使用 ? ，也可以不明确类型
    function fn(x: number, y=1)
6. 剩余参数：必须是数组类型
    function fn(...args: any[]) { ... } --&gt; any表示剩余参数可以是任意类型
7. 函数重载
    1. 重载形式
    function fn(x: number, y: number): number;
    function fn(x: string, y: string): string;
    2. 函数实现
    function fn(x: any, y: any): any { ... } ---&gt; 实现时的类型必须是 any
    3. 参数x、y 的类型必须同时为number或者string; fn(1, 2);  fn(&apos;a&apos;, &apos;b&apos;);
8. 函数的this
    1. ts的函数中，this默认指向 any，ts不能对any类型提示任何属性和方法；
    2. 在tsconfig.json中，取消 this 默认指向 any 的设置：
    &quot;compilerOptions&quot;: {
        &quot;noImplicitThis&quot;: true
    }
    3. 对于某些情况，如DOM事件，回调函数的this默认指向DOM对象，TS自动推导。
</code></pre><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><pre><code>1. TS的类与ES2015(es6)中的 class 类似，同时新增了一些实用特性；
2. 成员属性和成员方法：与ES6不同，与Java类似
    class Person {
        username: string = &apos;&apos;;  ---&gt; 提前声明成员属性
        constructor(name: string) {
            this.username = name;  --&gt; 使用成员属性
        }
    }
    let p1 = new Person(&apos;Mack&apos;); --&gt;TS自动推导出p1的类型为Person
3. 修饰符：public、protected、private、readonly，控制对成员属性/方法的访问
    1. public：成员属性和方法的默认修饰符，可以公开访问；
    2. protected：只能在类中、及其子类中访问；
    3. private：只能在类的内部直接访问，但可以定义 setter/getter，让外部对象访问；
    4. readonly：只读，对象只能获取，不能重新赋值。
    5. 在构造函数的参数上使用修饰符，表示同时在类中创建该属性，该属性不能在类中预定义；
    constructor(public age: number){ --&gt;为Person创建属性age：public age: number;
        this.age = age;
    }
4. 存取器：setter/getter的简写形式
    private _age: number = 10;
    get age(): number {  ------&gt; 访问：p1.age;
        return this._age;
    }
    set age(age: number) {  ---&gt; 访问：p1.age = 20;
        this._age = age;
    }
5. 静态成员：static修饰的属性和方法
    1. 单例模式
    class MySql {
        private constructor(){}  ---&gt; 私有化构造函数
        public static instance;  ---&gt; 静态属性
        public static getInstance() {  -----&gt; 静态方法
            if(!MySql.instance) {
                MySql.instance = new MySql();
            }
            return MySql.instance;
        }
    }
6. 继承：extends实现继承机制，且是单继承
    1. 与JS相同，如果子类重写了构造函数，必须先调用 super(); 初始化父类的构造函数；
    class Student extends Person {
        constructor(name: string) {
            super(name);
        }
    }
7. 抽象类：abstract修饰的类
    1. 抽象方法：abstract修饰的方法，且没有方法体，只能定义在抽象类中；
    abstract class Person {
        abstract study(): void;
    }
    2. 不允许通过 new 创建抽象类的对象；
    3. 抽象类的子类必须实现所有抽象方法，否则该子类也必须声明为抽象类。
</code></pre><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><pre><code>1. 接口用于定义规则，TS的数据检测就是一种规则
    1. 接口的规则只有抽象描述，属性不能有具体的值，方法不能有具体的实现；
    interface Options {
        width: number, height: number
    }
    2. 使用规则：width和height都是必须的属性
    function fn(opts: Options){ ... }
    fn({ width:100, height:200 });
    3. TS类型检测器只会检查接口所定义的规则属性是否存在，并不会检查属性的顺序。
    fn({ height:200, width:100 });
2. 可选的接口规则：通过 ? 声明
    interface Options {
        width: number, height: number,
        color?: string  ---&gt; 属性color是可选的
    }
3. 只读的接口规则：readonly修饰，readonly height?: number
4. 绕开类型检测
    1. 断言：as
    fn({ width: 100 } as Options);  ---&gt; 虽然少了规则，但TS不会报错
    2. 如果有多余的规则，TS也不允许，则先赋值给一个变量，再作为参数传入规则
    fn({ width:100, height:200, a:1 });  ---&gt; TS报错
    let opt = { width:100, height:200, a:1 };
    fn(opt); --&gt; TS允许
5. 索引签名：定义一组key-value的数据，这组数据的个数是不确定的，其中key具有某种特性
    interface Options {
        [attr: number]: any,  ---&gt; 一组k-v数据：key为number类型，value为任意类型
        length: number  -----&gt; 非索引属性
    }
    fn({
        0: 100, 1: 200, 2: 300,  ---&gt; 也可以绕开TS的类型检测
        length: 1
    });
    1. 索引 key 的类型只能是string和number
    2. 在TS的类中，不允许对象直接扩展属性/方法
    class Person { }
    let p: Person = new Person();
    p.fly = function() { }  -------&gt; TS报错，Person类中不存在fly
    3. 以全局对象 window 为例，通过接口去扩展属性/方法
    interface Window{  ------&gt; window对象实现了 Window 接口
        abc: number
    }
    window.abc = 1; -----&gt; 通过TS检查
    4. 由此可见，可以通过接口去扩展Person的属性/方法
    interface Person {
        [attr: string]: any
    }
    p.fly = function() { }  -------&gt; 通过TS检查
5. 函数类型的接口规则
    1. 只包含成员类型为函数的接口，并不是函数类型的接口
    interface Options {
        fn: Function
    }
    let opt: Options = { fn: function(){} }
    2. 函数类型的接口描述的是一个函数结构
    interface IFn {
        (x: number, y: number): number  --&gt; 两个number类型的参数，返回值为number
    }
    let fn: IFn = function(x: number, y: number): number { return x+y; }
    3. 定义一个MouseEvent类型参数的函数结构
    interface MouseEback {
        (e: MouseEvent): any
    }
    let fn: MouseEback = function(ex: MouseEvent){}
    document.onclick = fn; ---&gt; 符合DOM点击事件的回调函数，通过TS的类型检查
6. 接口的实现：implements，从而让一个类符合某种规则
    1. 类是单继承的，接口可以多实现，接口之间通过 extends 实现继承；
    2. 实现接口时，必须实现接口中的定义属性和方法
    interface ISuper {
        fly(): void;
    }
    class SuperMan implements ISuper {
        fly() { }
    }
</code></pre><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><pre><code>1. 泛型：把类型变成一个变量，提高复用性；此变量一般使用单个大写字母；
2. 函数的泛型
    function fn&lt;T&gt;(x: T): number {
        return Number(x) * 10;
    }
    fn&lt;number&gt;(4);
    1. 在调用函数的时候再决定类型，从而根据指定的类型去检测；
    2. 泛型也可以指定多个：
    function fn&lt;T, S&gt;(a:T, b:S): [T, S] {}
    3. 数组形式的泛型：
    function fn&lt;T&gt;(a: T[]): T[] {}
    function fn&lt;T&gt;(a: Array&lt;T&gt;): Array&lt;T&gt; {}
3. 类的泛型
    class Cat &lt;T&gt; {
        private _data: T[] = [];
        public push(v: T): number {}
    }
    let cat: Cat&lt;string&gt; = new Cat();
4. 泛型作为一种类型
    let fn: &lt;T&gt;(x: T, y: T) =&gt; number = function(x, y) {
        return Number(x) + Number(y);
    }
5. 泛型接口
    interface IFn &lt;T&gt; {
        (x: T, y: T): number
    }
    let fn: IFn&lt;string&gt; = function(x, y) {
        return Number(x) + Number(y);
    }
6. 泛型约束：约束泛型的类型范围，extends
    1. 约束泛型为HTML节点
    function fn&lt;T extends HTMLElement&gt; (ele: T) { }
    2. 配合接口使用
    interface Len {
        length: number
    }
    function fn&lt;T extends Len&gt; (e: T) { }
    fn(1);  ---&gt; TS报错：number类型没有实现 Len 接口，也不具备 length 属性
    fn(&apos;2&apos;); --&gt; string类型实现了 Len 接口
7. 类类型
    1. 如何让一个外部函数成为创建对象的工厂
    function getArray(constructor: Array) {
        return new constructor();
    }
    let arr = getArray(Array);  --&gt; TS报错
    2. 形参constructor表示Array类型的对象，而不是一个Array的构造函数，所以无法创建对象
    3. {new()}：表示构造函数类型
    function getInstance(constructor: {new()}) {
        return new constructor();
    }
    let arr = getInstance(Array);  --&gt; 通过TS检查，创建一个数组对象
    4. 限制构造函数的类型：
    function getInstance(ct: {new(): Array&lt;string&gt;}) {
        return new ct();   --&gt; 只能创建Array&lt;string&gt;类型的对象
    }
    function getInstance&lt;T&gt;(ct: {new(): T}) { --&gt; 泛型
        return new ct();
    }
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/09/01/Electron/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/01/Electron/" itemprop="url">Electron</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-01T00:00:00+08:00">
                2018-09-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="node-GUI"><a href="#node-GUI" class="headerlink" title="node GUI"></a>node GUI</h2><pre><code>1. NW.js和Electron都是基于NodeJs的GUI框架，使用HTML、CSS、JS来构建UI，处理与用户的交互
2. NW.js和Electron专注于开发桌面跨平台应用，而不是web服务器
3. NW.js的原称为Node-Webkit，目前由因特尔公司维护，而Electron由Github维护；
4. NW.js和Electron都使用了开源浏览器Chromium，并使用NodeJs访问系统、文件、网络...
</code></pre><h3 id="Electron"><a href="#Electron" class="headerlink" title="Electron"></a>Electron</h3><pre><code>1. Electron的原理：将Chromium和Node.js整合到一个运行时环境中，且可以跨平台打包；
    1. Chromium是一个谷歌开源浏览器，可以调用所有前端相关的API，且不需要考虑兼容性问题；
    2. 浏览器并不能访问原生的资源，但Node.Js的API支持在页面中和操作系统进行交互。
2. npm install -g electron：全局安装Electron
    1. 可以在Github上下载Electron的demo：electron-quick-start
    2. 进入demo目录，执行 cnpm install 安装依赖，执行 npm start 运行demo
3. electron-forge：相当于Electron的脚手架，可以快速创建、运行、打包项目；
    1. npm install -g electron-forge：全局安装
    2. electron-forge init myDemo：创建项目，默认使用 npm i 安装依赖；
    3. 如果执行失败，可以删除项目中的node_modules，执行 cnpm i，手动安装依赖；
4. 手动搭建项目：创建目录，在目录中创建main.js和index.html，执行cnpm init；
    1. main.js就是主进程，项目运行的入口文件；
    2. 一个应用只有一个主进程，但可以有多个渲染进程，一个窗口就表示一个渲染进程；
    3. electron .：运行项目。
5. 拖放打开文件
    &lt;textarea id=&quot;container&quot;&gt;&lt;/textarea&gt;
    1. 调用H5的拖动API，获取拖放文件的路径
    let box = document.querySelector(&apos;#container&apos;)
    box.ondragenter=box.ondragover=box.ondragleave = (e) =&gt; {
        return false; --&gt; 组织默认行为
    }
    box.ondrop=(e) =&gt; {
        e.preventDefault(); --&gt; 阻止默认行为
        let path = e.dataTransfer.files[0].path; --&gt; 获取文件的路径
    }
    2. 使用Node.js的fs模块读取文件，赋值给box.value：let fs = require(&apos;fs&apos;)
6. 相关模块
    1. Electron中的模块分为：主进程模块，渲染进程模块，公用模块；
    2. app：主进程模块，控制应用的生命周期，写法比较固定，注册固定的几个事件；
    3. BrowserWindow：主进程模块，窗口相关的模块；
    let win = BrowserWindow.getFocusedWindow();  --&gt;获取当前窗口的对象
    win.center();  --&gt;把窗口移动到屏幕中央
    4. remote：渲染进程的模块，用于间接调用部分主进程的模块，如BrowserWindow
    5. Menu：主进程的菜单模块，包括顶部菜单、右键菜单、系统托盘的右键菜单。
7. Menu菜单功能必须在窗口加载完成之后才能执行；
    app.on(&apos;ready&apos;, {
        ...... //创建窗口BrowserWindow
        require(&apos;./main/menu.js&apos;) //加载创建菜单的js模块
    })
    1. 虽然渲染进程也能通过remote模块调用Menu模块，实现自定义的顶部菜单，但可能会闪现默认
    的顶部菜单，所以还是建议在主进程中实现顶部菜单。
</code></pre><h2 id="进程间通信IPC"><a href="#进程间通信IPC" class="headerlink" title="进程间通信IPC"></a>进程间通信IPC</h2><pre><code>1. 被Electron直接运行的脚本(package.json中指定的main节点)称为主进程，有且只有一个；
2. 用于展示的web界面都运行在一个独立的进程中，称为渲染进程；
3. 进程间通信的相关模块：ipcMain(主进程)、ipcRenderer(渲染进程)
</code></pre><h3 id="主进程与渲染进程"><a href="#主进程与渲染进程" class="headerlink" title="主进程与渲染进程"></a>主进程与渲染进程</h3><pre><code>1. 渲染进程向主进程发送异步消息：ipcRenderer.send(&apos;事件名1&apos;, 消息内容)
    1. 主进程中监听消息：ipcMain.on(&apos;事件名1&apos;, (event, arg) =&gt; { ... })
    2. 主进程给渲染进程回复消息：event.sender.send(&apos;事件名2&apos;, 消息内容)
    3. 渲染进程监听回复的消息：ipcRenderer.on(&apos;事件名2&apos;, (event, arg) =&gt; {})
2. 渲染进程向主进程发送同步消息：
    1. let msg = ipcRenderer.sendSync(&apos;事件名1&apos;, 消息内容)
    2. 与异步消息不同，主进程收到同步消息，必须回复，否则渲染进程会阻塞；
    ipcMain.on(&apos;事件名1&apos;, (event, arg) =&gt; {
        event.returnValue = &apos;sync reply&apos; ---&gt; 回复给渲染进程
    }) ----&gt; sendSync()的返回值就是主进程回复的消息内容
3. 主进程把数据挂载到node的全局对象global上，渲染进程通过 getGlobal() 获取数据
    1. 主进程：global.username = &apos;abc&apos;;
    2. 渲染进程：remote.getGlobal(&apos;username&apos;);
    3. 这种方式污染了全局对象global，并不建议使用。
</code></pre><h3 id="渲染进程与渲染进程"><a href="#渲染进程与渲染进程" class="headerlink" title="渲染进程与渲染进程"></a>渲染进程与渲染进程</h3><pre><code>1. 渲染进程无法直接通信，最简单的方式是通过localStorage实现；
2. 通过BrowserWindow和webContents模块实现：
    1. webContents是一个事件发出者，负责渲染并控制网页，也是BrowserWindow的属性；
3. 渲染进程1向主进程发送消息，主进程创建渲染进程2，再向渲染进程2发送消息；
    ipcMain.on(&apos;事件名1&apos;, (event, arg) =&gt; { --&gt; 主进程监听消息事件
        win = new BrowserWindow({width:400, height:300})
        win.loadURL(path.join(&apos;file:&apos;, __dirname, &apos;../news.html&apos;))
        win.webContents.on(&apos;did-finish-load&apos;, () =&gt; { --&gt; 窗口加载完毕
            win.webContents.send(&apos;事件名2&apos;, arg) --&gt; 向渲染进程2发送事件
        }) ---&gt; 新的渲染进程中注册&apos;事件名2&apos;
    })
4. 渲染进程2向渲染进程1回复消息，则需要把渲染进程1的Id也发送给渲染进程2
    ipcMain.on(&apos;事件名1&apos;, (event, arg) =&gt; {
        //必须在新窗口加载之前获取当前窗口的Id，否则获取的新窗口的Id
        let winId = BrowserWindow.getFocusedWindow().id
        win = new BrowserWindow({width:400, height:300})
        win.loadURL(path.join(&apos;file:&apos;, __dirname, &apos;../news.html&apos;))
        win.webContents.on(&apos;did-finish-load&apos;, () =&gt; {
            win.webContents.send(&apos;事件名2&apos;, arg, winId)
        })
    })
5. 在新窗口中注册事件，向渲染进程1回复消息，在渲染进程1中监听回复事件
    ipcRenderer.on(&apos;事件名2&apos;, (event, arg, winId) =&gt; {
        let win = BrowserWindow.fromId(winId) --&gt;获取渲染进程1的窗口对象
        win.webContents.send(&apos;事件名3&apos;, &apos;reply the msg&apos;) --&gt;回复消息
    })
</code></pre><h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><pre><code>1. shell模块可以操作用户的默认浏览器，调用资源管理器；
2. 调用用户的默认浏览器，打开指定网址：shell.openExternal(&apos;https://...&apos;)
3. shell.showItemInFolder()/openItem()：资源管理器的相关操作；
4. &lt;webview&gt;：与HTML的&lt;iframe&gt;相似，但webview与应用程序不在同一个进程；
    1. webview没有渲染进程的权限，并且与应用之间的交互都是异步的，保证应用的安全性不受嵌入
    内容的影响；
    2. &lt;webview src=&quot;https://www.baidu.com&quot;&gt;&lt;/webview&gt;
</code></pre><h3 id="dialog"><a href="#dialog" class="headerlink" title="dialog"></a>dialog</h3><pre><code>1. dialog模块：不仅可以弹出信息提示框，也可以实现本地文件的打开与保存；
2. 信息提示框
    1. dialog.showErrorBox(&apos;title&apos;, &apos;content&apos;)：错误信息提示框；
    2. dialog.showMessageBox({}, (index)=&gt;{...})：信息提示框；
    3. 异步变同步：let index = dialog.showMessageBox({})
3. 打开文件/目录：dialog.showOpenDialog({}, (path) =&gt; {...})
    1. 打开功能只是回调文件/目录的路径，并不能获取文件/目录的内容；
    2. 操作文件/目录的功能，需要通过nodejs实现。
4. 保存文件：dialog.showSaveDialog({}, (path) =&gt; {...})
    1. showSaveDialog()只回调保存路径，并不是真的保存，不会在本地生成任何文件；
    2. 保存功能需要借助nodejs实现，通过fs模块把内容写入本地。
5. 打印当前窗口：BrowserWindow.getFocusedWindow().webContents.print()
6. app.quit()：退出应用，Electron使用的是单例模式，此时不必考虑性能问题。
</code></pre><h3 id="系统托盘"><a href="#系统托盘" class="headerlink" title="系统托盘"></a>系统托盘</h3><pre><code>1. Tray模块：主进程的系统托盘模块；
2. 实现系统托盘：let tray = new Tray(path.join(__dirname, &apos;icon.png&apos;))
3. 设置托盘名称：tray.setToolTip(&apos;title&apos;)，鼠标悬停在托盘图标上弹出；
4. 创建托盘的右键菜单
    1. Menu模块创建菜单：let menu = Menu.buildFromTemplate([{...}, {...}])
    2. 设置托盘的右键菜单：tray.setContextMenu(menu)
5. 关闭窗口，则隐藏到系统托盘；双击系统托盘，则重新打开窗口
    1. 关闭窗口
    let win = BrowserWindow.getFocusedWindow() --&gt; 获取当前的窗口对象
    win.on(&apos;close&apos;, (e) =&gt; { --&gt; 监听关闭按钮的事件
        if(win.isFocused()) { --&gt;点击托盘右键菜单上的&apos;退出&apos;，则关闭窗口
            win = null
        } else {
            e.preventDefault() --&gt; 阻止默认的关闭事件
            win.hide() --&gt; 隐藏窗口到系统托盘
        }
    })
    2. app.quit()会回调&apos;close&apos;事件，所以需要判断当前关闭的窗口是否拥有焦点；
    3. 如果当前窗口拥有焦点，则隐藏窗口；如果没有焦点，表示窗口已经处于隐藏状态，则关闭窗口
    4. 打开窗口
    tray.on(&apos;double-click&apos;, () =&gt; { --&gt; 监听系统托盘的双击事件
        win.show()
    })
6. 托盘图标的闪烁：设置定时器setInterval()，每隔一段时间就重新设置一次图标。
</code></pre><h3 id="消息通知"><a href="#消息通知" class="headerlink" title="消息通知"></a>消息通知</h3><pre><code>1. Electron的消息通知是通过H5的API实现的，右下方弹出通知框的效果；
    let option = {
        title: &apos;通知标题&apos;, body: &apos;通知内容&apos;, icon: &apos;通知图标的路径&apos;
    }
    let notification = new window.Notification(option.title, option)
    notification.onclick = ()=&gt;{...} --&gt; 通知框的点击事件
2. 监听网络变化：也是通过H5实现
    1. 网络正常：window.addEventListener(&apos;online&apos;, () =&gt; { ... })
    2. 网络断开：window.addEventListener(&apos;offline&apos;, () =&gt; { ... })
</code></pre><h3 id="其他模块"><a href="#其他模块" class="headerlink" title="其他模块"></a>其他模块</h3><pre><code>1. globalShortcut模块：主进程模块，注册全局快捷键，在窗口创建之前注册；
    app.on(&apos;ready&apos;, () =&gt; {
        ... //注册全局快捷键 ---&gt; ... //创建窗口 ---&gt; ... //设置菜单
    })
    1. 注册全局快捷键：globalShortcut.register(&apos;ctrl+e&apos;, () =&gt; { ... })
    2. 判断是否注册成功：globalShortcut.isRegistered(&apos;ctrl+e&apos;)
    3. 窗口关闭时要取消全局快捷键：globalShortcut.unregister(&apos;ctrl+e&apos;)
    app.on(&apos;will-quit&apos;, () =&gt; { globalShortcut.unregister(&apos;ctrl+e&apos;) })
2. clipboard模块：公用模块，剪切板事件
    1. 复制操作：clipboard.writeText(&apos;复制内容&apos;)，系统的Ctrl+C
    2. 手动获取复制的内容：let text = clipboard.readText()，系统的Ctrl+V
    3. 除了读取文本，剪切板还能读取HTML、Image、RTF...
3. nativeImage模块：公用模块，用于读取、传递图片
    1. nativeImage.createEmpty()：创建一个空的nativeImage对象；
    2. nativeImage.createFromPath(&apos;路径&apos;)：根据图片路径，创建nativeImage对象
4. 剪切板无法直接读取图片，需要借助nativeImage模块；
    let image = nativeImage.createFromPath(&apos;static/back.jpg&apos;)
    clipboard.writeImage(image) --&gt; 复制图片
    let data = clipboard.readImage() --&gt; 读取复制的图片，返回nativeImage对象
    let src = data.toDataURL() --&gt; 转为图片的Base64编码
    1. 创建一个&lt;img /&gt;：let img = new Image()
    2. 设置src属性：img.src = src
    3. 插入到HTML中：document.body.appendChild(img)
</code></pre><h2 id="Electron-Vue"><a href="#Electron-Vue" class="headerlink" title="Electron-Vue"></a>Electron-Vue</h2><pre><code>1. Electron-Vue：Electron结合Vue开发单页面桌面应用；
    1. 安装环境：cnpm install electron -g、cnpm install vue-cli -g
    2. 创建项目：vue init simulatedgreg/electron-vue my-project
    3. 下载依赖：cd my-project ---&gt; cnpm install
    4. 运行项目：npm run dev
2. 在main.js中默认引入了electron，在Vue组件中通过this.$electron能直接使用；
    1. 主进程模块：src/main/index.js
    2. 渲染进程模块：src/renderer目录下的所有Vue组件
3. 在Vue组件中使用Node.js的模块：const path = require(&apos;path&apos;);
4. 打包后的electron应用无法找到图片
    1. 对于static目录下的图片：&lt;img :src=&quot;&apos;./static/img/a.png&apos;&quot; /&gt;
    2. 对于电脑本地的图片，直接使用图片的绝对路径，另外还要关闭窗口的安全模式
    new BrowserWindow({ webPreferences: { webSecurity: false } });
</code></pre><h3 id="窗口操作"><a href="#窗口操作" class="headerlink" title="窗口操作"></a>窗口操作</h3><pre><code>1. frame:false：无边框化，去除顶部菜单、最小化、最大化和关闭；
    let win = new BrowserWindow({..., useContentSize:true, frame:false})
    1. 无边框化之后，窗口的可拖拽区也随之消失，需要手动设置拖拽区，鼠标可以拖动窗口；
    2. 设置拖拽区的CSS属性：-webkit-app-region: drag
    body{ -webkit-app-region: drag } --&gt; 设置整个窗口为拖拽区
    3. 拖拽区内的按钮必须标记为no-draggable，否则将不可点击；
    button{ -webkit-app-region: no-drag; }
2. win.setMenu(null)：只隐藏顶部菜单；
3. 最大化、最小化、隐藏、关闭窗口
    1. win.hide()：隐藏窗口； win.isVisible()：窗口是否可见； win.close()：关闭窗口
    2. win.maximize()：最大化窗口，如果窗口尚未显示，这也将会显示，但不会有焦点；
    3. win.unmaximize()：取消窗口最大化；  win.isMaximized()：判断窗口是否最大化；
    5. win.minimize()：最小化窗口；  win.isMinimized()：判断窗口是否最小化；
    6. win.restore()：将窗口从最小化状态恢复到以前的状态。
</code></pre><h3 id="NeDB"><a href="#NeDB" class="headerlink" title="NeDB"></a>NeDB</h3><pre><code>1. NeDB：Nodejs实现的一个NoSQL嵌入式数据库；
    1. 与Android上的Sqlite类似，都是嵌入式数据库，一般用于本地数据的持久化；
    2. 不同的是，Sqlite是MySql类型的，使用SQL语句操作，而NeDB的操作类似于MongoDB；
    3. 可以充当内存数据库，也可以用来实现本地存储，甚至可以在浏览器中使用。
2. 使用方式：
    1. 安装操作模块：cnpm install nedb --save
    2. 在src/renderer目录下创建datastore.js，import Datastore from &apos;nedb&apos;
    import path from &apos;path&apos;  import {remote} from &apos;electron&apos;
    export default new Datasotre({
        autoload: true,
        filename: path.join(remote.app.getPath(&apos;userData&apos;), &apos;/data.db&apos;)
    })
    3. 设置NeDB保存在userData目录中，该目录空间专门为应用程序所保留，不会被篡改；
    4. 在main.js中，把数据库操作对象绑定到原型上：
    import db from &apos;./datastore&apos;  --&gt; Vue.prototype.$db = db
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/08/17/Koa-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/17/Koa-2/" itemprop="url">Koa-2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-17T00:00:00+08:00">
                2018-08-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Koa脚手架"><a href="#Koa脚手架" class="headerlink" title="Koa脚手架"></a>Koa脚手架</h2><pre><code>1. 全局安装脚手架：npm install koa-generator -g
2. 创建项目：koa demo01  --&gt; cd demo01  --&gt; npm install
3. 运行项目：npm start
4. 脚手架创建的项目已经实现了路由的模块化，即项目的模块化。
</code></pre><h2 id="路由模块化"><a href="#路由模块化" class="headerlink" title="路由模块化"></a>路由模块化</h2><pre><code>1. 与Express的路由模块化类似，把不同功能的路由拆分到不同的js文件中，然后再暴露路由对象；
2. 假设项目包含首页(index)、后台管理(admin)，配置模板引擎art-template的目录为views
    1. 在根目录下创建routes目录，用于存放路由模块，项目入口为app.js
    2. 创建routes/index.js，routes/admin.js
3. 在index.js中配置index模块的路由，index是根路由的模块
    let router = require(&apos;koa-router&apos;)();
    router.use(async(ctx, next)=&gt;{ ----&gt; index模块的应用级中间件，在index路由之前匹配
        ......
        await next(); ----&gt; 继续向下匹配index路由
        ......
    })
    router.get(&apos;/&apos;, async(ctx)=&gt;{
        await ctx.render(&apos;index&apos;); --&gt;渲染模板：views/index.html
    })
    router.get(&apos;case&apos;, async(ctx)=&gt;{  ------&gt; 对于根路由的模块，其子路由不能再加&apos;/&apos;
        await ctx.render(&apos;index/case&apos;); --&gt;渲染模板：views/index/case.html
    })
    module.exports = router; ---&gt; 暴露index模块的路由对象
    1. 注意：与Express不同，Koa的根目录匹配已经默认加了&apos;/&apos;，其子路由的开头不能再加&apos;/&apos;
4. 在admin.js中配置admin模块的路由
    let router = require(&apos;koa-router&apos;)();
    router.use(async(ctx, next)=&gt;{ ----&gt; admin模块的应用级中间件，在admin路由之前匹配
        ......
        await next(); ----&gt; 继续向下匹配admin路由
        ......
    })
    router.get(&apos;/&apos;, async(ctx)=&gt;{
        await ctx.render(&apos;admin&apos;);
    })
    router.get(&apos;/user&apos;, async(ctx)=&gt;{
        await ctx.render(admin/user&apos;);
    })
    module.exports = router;
5. 在app.js中启用index模块和admin模块的路由
    let router = require(&apos;koa-router&apos;)();
    let index = require(&apos;./routes/index&apos;);
    let admin = require(&apos;./routes/admin&apos;);
    router.use(&apos;/&apos;, index.routes());  -----&gt; 启用根路由的index模块
    router.use(&apos;/admin&apos;, admin.routes()); ---&gt; admin模块的路由
    app.use(router.routes()).use(router.allowedMethods);
6. 子路由：在admin路由中继续启用子路由
    1. 创建routes/admin/user.js，配置路由
    let router = require(&apos;koa-router&apos;)();
    router.get(&apos;/&apos;, async(ctx)=&gt;{
        await ctx.render(&apos;admin/user&apos;); --&gt;渲染模板：views/admin/user.html
    })
    router.get(&apos;/add&apos;, async(ctx)=&gt;{
        await ctx.render(&apos;admin/user/add&apos;); -&gt;渲染模板：views/admin/user/add.html
    })
    module.exports = router;
    2. 在admin.js中引入user.js，并启用user路由
    let user = require(&apos;./admin/user&apos;);
    router.use(&apos;/user&apos;, user.routes());
7. router路由的写法不止一种，比如把路由写在对应的路由文件中
    1. app.js：router.use(admin.routes());
    2. admin.js：let Router = require(&apos;koa-router&apos;);
    let router = new Router({ prefix: &apos;/admin&apos; })
</code></pre><h2 id="更多补充"><a href="#更多补充" class="headerlink" title="更多补充"></a>更多补充</h2><pre><code>1. nodeJs生成验证码：svgCaptcha，支持express和koa
2. 页面自动刷新/跳转
    1. 页面3s后自动刷新：&lt;meta http-equiv=&quot;refresh&quot; content=&quot;3&quot; /&gt;
    2. 3s后页面自动转到指定网址
    &lt;meta http-equiv=&quot;refresh&quot; content=&quot;3; url=http://www.baidu.com/&quot; /&gt;
    3. 登录失败之后，加载错误页面error.html，5s后自动转回登录页
    router.use(async(ctx, next)=&gt;{
        ctx.state.HOST = &apos;http://&apos;+ctx.request.header.host;  --&gt;设置域名的全局变量
        await next();
    })
    router.post(&apos;doLogin&apos;, async(ctx)=&gt;{
        if(登录失败){
            await ctx.render(&apos;login/error&apos;, { url: ctx.state.HOST+&apos;/login&apos; })
        }
    })
    error.html：&lt;meta http-equiv=&quot;refresh&quot; content=&quot;5; url={{url}}&quot; /&gt;
3. art-template自定义日期管道/过滤器
    1. 格式化日期的插件：npm install silly-datetime --save
    2. let sd = require(&apos;silly-datetime&apos;);
    render(app, {
        root: path.join(__dirname, &apos;views&apos;),
        extname: &apos;.html&apos;,
        debug: process.env.NODE_ENV !== &apos;production&apos;,
        dateFormat: dateFormat=function(value){ -----&gt; 扩展模板里的方法
            return sd.format(new Date(value), &apos;YYYY-MM-DD HH:mm&apos;);
        }
    })
    3. 在art模板中使用过滤器，格式化传递的变量time：&lt;div&gt;{{time | dateFormat}}&lt;/div&gt;
4. koa-jsonp：ajax请求返回JSON的中间件，npm install koa-jsonp --save
    1. let jsonp = require(&apos;koa-jsonp&apos;);  ---&gt; 同时支持处理JSON和jsonp
    2. 配置jsonp中间件：app.use(jsonp());
    3. 一个简单的JSON数据接口：
    router.get(&apos;/getMsg&apos;, async (ctx) =&gt; {
        ctx.body = { message: &quot;请求的数据信息&quot;, success: true }
    })
    4. 使用浏览器测试接口：
    http://localhost:3000/getMsg  ---&gt; 如果返回JSON格式的数据，则表示此接口支持JSON
    http://localhost:3000/getMsg?callback=xxx  ---&gt; 测试接口是否支持jsonp
5. ctx.request.headers[&apos;referer&apos;]：获取上一页的地址
    1. 用全局变量记录上一页的地址
    ctx.state.prevPage = ctx.request.headers[&apos;referer&apos;];
    2. 返回上一页：ctx.redirect(ctx.state.prevPage);
</code></pre><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><pre><code>&lt;form action=&quot;{{HOST}}/doUpload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
    &lt;input type=&quot;file&quot; id=&quot;pic&quot; name=&quot;pic&quot; /&gt;
&lt;/form&gt;
1. koa-multer：用于处理 multipart/form-data 类型的表单数据，主要用于上传文件；
2. koa-multer基于 multer 模块：npm i koa-multer --save
    let multer = require(&apos;koa-multer&apos;);
    let storage = multer.diskStorage({
        destination: function(req, file, cb) {
            cb(null, &apos;upload/pic&apos;); ---&gt; 配置上传文件的目录：当前目录下的upload/pic
        },
        filename: function(req, file, cb) {
            let extname = (file.originalname).split(&apos;.&apos;);  --&gt;从文件名中切割出后缀名
            cb(null, Date.now()+&apos;.&apos;+extname[extname.length-1]); --&gt;对文件重命名
        }
    });
    let upload = multer({storage: storage});
3. 处理上传文件
    router.post(&apos;/doUpload&apos;, upload.single(&apos;pic&apos;), async (ctx)=&gt;{
        let filename = ctx.req.file.filename;  ---&gt; 上传的文件名
        let form = ctx.req.body; ---&gt; form表单的其他数据
    })
4. upload.single(&apos;pic&apos;)：pic与&lt;input type=&quot;file&quot; name=&quot;pic&quot; /&gt;的name保持一致；
5. koa-multer也支持多个文件上传，在github上的multer模块中有更多配置信息；
6. koa-body：用于取代 koa-bodyparser 和 koa-multer
</code></pre><h3 id="路由鉴权"><a href="#路由鉴权" class="headerlink" title="路由鉴权"></a>路由鉴权</h3><pre><code>1. koa-jwt：用于路由鉴权、token验证
</code></pre><h3 id="富文本编辑器"><a href="#富文本编辑器" class="headerlink" title="富文本编辑器"></a>富文本编辑器</h3><pre><code>1. ueditor：百度的轻量级、可定制富文本web编辑器，开源基于MIT协议，允许自由使用和修改代码
2. ueditor官方虽然没有提供NodeJs版本，但官方推荐的第三方插件里有nodeJs版本；
    1. 第三方插件直接支持express，不支持koa2
    2. 支持koa2的ueditor插件：npm i koa2-ueditor --save
3. ueditor的基本配置
    1. 在github下载koa2-ueditor的demo，拷贝public/ueditor，粘贴到自己项目的public目录
    2. 在模板中的&lt;head&gt;标签中引入ueditor目录下的静态文件
    &lt;script type=&quot;text/javascript&quot; src=&quot;/ueditor/ueditor.config.js&quot;&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;/ueditor/ueditor.all.min.js&quot;&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;/ueditor/lang/zh-cn/zh-ch.js&quot;&gt;
    3. 使用ueditor，取代&lt;textarea&gt;的位置
    &lt;script id=&quot;editor1&quot; type=&quot;text/plain&quot; style=&quot;width:800px;height:300px;&quot;&gt;
    4. 在&lt;body&gt;标签之后实例化富文本编辑器：
    &lt;script type=&quot;text/javascript&quot;&gt;
        let ue = UE.getEditor(&apos;editor1&apos;);
    &lt;/script&gt;
    5. 富文本编辑器中的内容最终生成的是带有style样式的html标签，是一个html字符串。
    &lt;form ...&gt;
        &lt;script type=&quot;text/plain&quot; id=&quot;editor1&quot; name=&quot;content&quot; style=&quot;...&quot;&gt;
    &lt;/form&gt;
    router.post(&apos;/doUpload&apos;, upload.single(&apos;pic&apos;), async (ctx)=&gt;{
        let content = ctx.req.body.content; ---&gt; form表单的富文本编辑框中的数据
    })
4. 配置ueditor的图片上传
    const ueditor = require(&apos;koa2-ueditor&apos;);
    router.all(&apos;/editor/controller&apos;, ueditor([&apos;public&apos;, {
        imageAllowFiles: [&apos;.png&apos;, &apos;.jpg&apos;, &apos;.jpeg&apos;],
        imagePathFormat: &apos;/upload/ueditor/image/{yyyy}{mm}{dd}/{filename}&apos;
    }]));
    1. &apos;/editor/controller&apos;：统一上传的地址，对应ueditor/ueditor.config.js中的配置
    serverUrl: &quot;/editor/controller&quot;  ---&gt; 根据router.all()的实际路由进行修改
    http://localhost:3000/editor/controller  --&gt; 完整的上传地址URI
    2. &apos;public&apos;：上传图片的保存目录，根目录/public/upload/ueditor/image/当前日期/图片名
5. 自定义ueditor编辑框：修改配置文件ueditor/ueditor.config.js
    1. 配置自动增长高度：autoHeightEnabled: false  --&gt; 编辑框的内容过长时自动出现滚动条
    2. 自定义工具栏：修改toolbars节点
6. 为编辑框设置默认内容
    &lt;script type=&quot;text/javascript&quot;&gt;
        let ue = UE.getEditor(&apos;editor1&apos;);
        ue.addListener(&apos;ready&apos;, ()=&gt;{  ----&gt; 监听ueditor准备完成
            ue.setContent(`{{@list.content}}`);  --&gt; art-template模板接收参数的方式
        })  ---&gt; list.content是上一次富文本编辑框中的内容，保存在数据库中
    &lt;/script&gt;
</code></pre><h2 id="SEO优化"><a href="#SEO优化" class="headerlink" title="SEO优化"></a>SEO优化</h2><pre><code>1. SEO优化：也称为搜索引擎优化，目的是让搜索引擎优先搜索到自家网站，并展示给用户；
2. 设置网站的必要信息：标题、关键字、描述
    1. 网站标题：&lt;title&gt;标题内容&lt;/title&gt;，网站标题变化不能过于频繁，否则百度会认为是作弊；
    2. 网站关键字：&lt;meta name=&quot;Keywords&quot; content=&quot;关键字内容&quot; /&gt;
    3. 网站描述：&lt;meta name=&quot;Description&quot; content=&quot;描述内容&quot; /&gt;
3. 图片&lt;img&gt;必须使用 alt 属性
4. html标签的合理使用，语义化，符合W3C标准
    1. 尤其是 h 系列标签的合理使用，其中，&lt;h1&gt;标签的权重最高，一个页面建议只出现一次；
    2. &lt;h1&gt;标签的内容建议和&lt;title&gt;的内容相同。
5. 内链、外链的合理使用，如友情链接就属于外链，因为搜索引擎会根据内链和外链继续搜索网站；
6. 网站的内容尽量都是原创的；
7. 合理使用长尾关键词：比如，相对与&quot;koa2教程&quot;，&quot;koa2视频教程&quot;就属于长尾关键词.
</code></pre><h2 id="API接口"><a href="#API接口" class="headerlink" title="API接口"></a>API接口</h2><pre><code>1. NodeJs的异步环境特性，让它最适合写API接口，非常善于处理大数据、高并发；
2. 比如一个返回JSON数据的简单接口
    let jsonp = require(&apos;koa-jsonp&apos;);
    app.use(jsonp());
    router.get(&apos;/getList&apos;, async (ctx)=&gt;{
        let result = await (从数据库中获取数据);
        ctx.body = { data: result }
    })
</code></pre><h3 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h3><pre><code>1. 在AJAX请求后台接口数据时，浏览器的同源策略会引起跨域安全问题；
    1. 接口的协议、域名、端口号必须与当前Web应用所处的协议、域名、端口号保持一致；
    2. 比如，访问当前网页的地址为 http://localhost:3000/index，那么，网页中的AJAX请求的
    接口地址必须是http://localhost:3000/xxxx
    3. 协议、域名、端口号三者有任何一个出现不一致，就会导致跨域问题。
2. JSONP的原理：利用&lt;script&gt;可以跨域的特性
    1. 在本地写一个回调函数，在远程执行这个函数，并把远程数据传到本地
    http://localhost:3000/api/getList?callback=xxx ---&gt; xxx被当作远程执行的函数
    2. JSONP跨域请求的前提：服务器必须支持JSONP；第三方koa-jsonp模块同时支持JSONP请求。
3. 除了JSONP实现跨域请求，还可以让后台设置允许跨域：npm i koa2-cors --save
    1. NodeJs后台设置允许跨域请求
    let cors = require(&apos;koa2-cors&apos;);
    app.use(cors());
    2. AJAX可以直接跨域请求接口，但由此导致的安全性问题，则通过token验证解决。
</code></pre><h3 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h3><pre><code>1. 当前Web应用的趋势就是前后端分离，为了让前端设备与后端更好地通信，出现了很多API结构；
2. RESTful API是目前比较成熟的一套互联网应用程序的API设计理念；
3. 一个优秀的RESTful API所考虑的方面：
    1. 协议：建议使用更安全的https协议
    2. 域名：尽量部署在专属域名下面，如https://a.bcd.com，https://api.bcd.com
    3. 考虑到接口的升级，应该将API的版本号放在URI中
    https://a.bcd.com/api1/list，https://a.bcd.com/api2/list
    https://a1.bcd.com，https://a2.bcd.com
    4. 路径：在RESTful架构中，每个URI代表一种资源，所以URI中使用与数据库表名相对应的名词
    5. 使用合理的HTTP请求方法
4. HTTP的7种请求方法：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS，常用的只有前4种
    1. GET：select，从服务器取出一项或多项资源
    2. POST：create，在服务器新建一个资源
    3. PUT：update，在服务器更新/修改资源
    router.put(&apos;/edit&apos;, async (ctx)=&gt;{  ---&gt; koa2可以直接识别不同的请求方法
        //修改数据、并返回修改后的完整数据
    })
    4. DELETE：从服务器删除资源
    router.delete(&apos;/del&apos;, async (ctx)=&gt;{ ---&gt; 响应 delete 方式的请求
        //删除数据
    })
5. 以vueJs的axios为例，axios提供了7种不同的HTTP请求方法。
</code></pre><h2 id="发布线上"><a href="#发布线上" class="headerlink" title="发布线上"></a>发布线上</h2><pre><code>1. 购买域名和服务器：万网(阿里收购)、西部数码...
2. 域名备案：新购买的域名不能直接被解析到服务器，需要在管理局登记域名信息(20个工作日左右)
    1. 每个出售域名的网站上，会有域名备案的流程说明和入口；
    2. 当然，还可以出钱到就近的外包公司备案。
3. 域名解析：让域名和服务器IP地址相关联，在购买域名的网站上配置即可；
    1. DNS服务器：负责域名解析的服务器，返回真实的服务器IP地址；
    2. ping 域名：查看当前域名所指向的真实服务器IP，如果ping失败，可能此域名设置了拒绝。
    ping www.baidu.com
4. nginx：负责转发与负载均衡，从而可以在一台服务器上运行N个nodeJs应用程序。
</code></pre><h3 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h3><pre><code>1. 在当前服务器上有2个nodeJs应用程序，端口号分别为8001、8002
2. 下载nginx应用包，解压，改名为nginx
3. 配置nginx/conf/nginx.conf
    1. 配置http节点：转发规则
    http {
        upstream backaa {
            server 127.0.0.1:8001; ---&gt; 服务器上的nodeJs应用程序的端口号
        }
        upstream backbb {
            server 127.0.0.1:8002;
        }
    }
    2. 配置http节点下的server节点：反向代理/负载均衡
    server {
        listen       80;
        server_name  aa.v123.com;  ---&gt; 域名

        #location / {
        #    root   html;
        #    index  index.html index.htm;
        #}

        location / {
            # 设置主机头和客户端的真实地址，以便服务器获取客户端的真实IP
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            #禁用缓存
            proxy_buffering off;
            #反向代理的地址
            proxy_pass http://backaa;  ---&gt; 与upstream相对应
        }
        ......
    }
    server {
        listen       8080;
        server_name  bb.v123.com;  ---&gt; 域名

        #location / {
        #    root   html;
        #    index  index.html index.htm;
        #}

        location / {
            # 设置主机头和客户端的真实地址，以便服务器获取客户端的真实IP
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            #禁用缓存
            proxy_buffering off;
            #反向代理的地址
            proxy_pass http://backbb;  ---&gt; 与upstream相对应
        }
        ......
    }
5. 启动nginx(windows系统)：双击运行nginx/nginx.exe
6. 启动nodeJs应用程序
7. 访问：http://aa.v123.com，http://bb.v123.com
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/08/15/Koa-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/15/Koa-1/" itemprop="url">Koa-1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-15T00:00:00+08:00">
                2018-08-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Koa2-x"><a href="#Koa2-x" class="headerlink" title="Koa2.x"></a>Koa2.x</h2><pre><code>1. Koa是基于Node.js的下一代web开发框架，也是由Express团队开发的；
    1. Node.js是一个异步的世界，官方API支持的都是callback形式的异步编程模型；
    2. Koa的开发思路与Express差不多，最大的特点就是，可以避免异步嵌套(回调地狱)；
    3. Koa不在内核方法中绑定任何中间件，仅仅提供一个轻量优雅的函数库，所以体积更小，更健壮
    4. 阿里是业界最早一批使用Node.js做线上大流量应用的公司，并基于koa开发了egg.js
2. 环境搭建：koa2.0开始才算是稳定版，npm install koa --save
    1. koa2.x要求Node.js的版本大于v7.6，因为node7.6开始完全支持async/await
    2. 简单使用：const Koa = require(&apos;koa&apos;);  const app = new Koa();
    app.use( async (ctx)=&gt;{ -----&gt; 配置中间件
        ctx.body = &apos;hello koa2&apos;;
    })
    app.listen(3000, &apos;Ip&apos;) ---&gt; 默认Ip为127.0.0.1
3. koa的工作内容
    1. 接收请求(request) --&gt; 处理数据，生成数据(middleware) --&gt; 发送数据(response)
    2. koa已经处理request和response，开发者只需要专心处理数据即可；
    3. 通过 use() 注册中间件，处理数据、生成数据。
4. 热重载工具：npm i supervisor -g，启动：supervisor app.js
</code></pre><h2 id="四大对象"><a href="#四大对象" class="headerlink" title="四大对象"></a>四大对象</h2><pre><code>1. koa的四大对象：Application -&gt; Context -&gt; Request、Response
2. Application：当前应用程序对象，由 new Koa() 创建的实例对象，Context是其子类；
    let app = new Koa();
    1. app.listen()：启用监听；
    2. app.use(callback)：启用中间件的方法，callback(ctx, next)
    3. ctx 就是 Context对象，next 是迭代器，实现手动控制执行过程；
    4. 异步中间件：use(async(ctx, next) =&gt; { ... });
    5. 监听错误：app.on(&apos;error&apos;, (err, ctx) =&gt; { ...//统计错误处理 });
    app.use((ctx, next) =&gt; {
        throw new Error(); ---&gt; 把错误抛给error事件去处理
    })
3. Context：每次请求都会包装成一个Context对象，它进一步封装了node的request和response
    1. koa把Context传入到中间件函数的第一个参数ctx中；
    2. ctx.req、ctx.res：分别是Node的request对象和response对象(太原始，并不推荐使用)
    3. ctx.request、ctx.response：分别是Koa的request对象和response对象，包含更多信息
    4. ctx.state：用户数据存储空间，ctx.username会污染Context对象，所以用ctx.state
    app.use((ctx, next) =&gt; {
        ctx.state.username = &apos;abc&apos;;
        next();
    }); 
    app.use((ctx, next) =&gt; { --&gt; 同一个请求的Context对象也都是同一个
        console.log(ctx.state.username);
    });
    5. ctx.app：当前应用程序的Application对象
    6. ctx.throw()：抛出错误时不建议使用 throw new Error(); 它属于JS，而throw()带有
    http的错误信息，如抛出404错误：ctx.throw(404, &apos;错误信息&apos;, {附带参数});
4. Request、Response
    1. ctx.request、ctx.response分别获取本次请求的Request对象和Response对象；
    2. Request和Response可以获取/设置本次请求和响应的各种信息；
    3. Request和Response的很多方法会被映射到 Context 上，通过 ctx 直接调用；
    4. 重定向：ctx.redirect(&apos;/login&apos;); --&gt;ctx.response.redirect(&apos;/login&apos;);
    5. 设置下载文件头：ctx.attachment(filename); --&gt;ctx.response.attachment();
    6. ctx.query 同 ctx.request.query，ctx.url 同 ctx.request.url ...
</code></pre><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><pre><code>1. 安装路由模块：cnpm install koa-router --save
2. 使用方式：let Router = require(&apos;koa-router&apos;);
    let router = new Router();  ---&gt; 等效于：let router = Router();
    router.get(&apos;/&apos;, async(ctx, next) =&gt; {
        ctx.body = &apos;Index&apos;; ---------&gt; 相当于 res.writeHead();  res.end();
    })
    router.get(&apos;/news&apos;, async(ctx, next) =&gt; {
        ctx.body = &apos;News&apos;;
    }) -----------------------&gt; 可以使用链式调用：router.get().get().get();
    app.use(router.routes());
    app.use(router.allowedMethods());  ----&gt;可以用链式调用，app.use().use();
    1. app.use(router.routes())：启用路由；
    2. app.use(router.allowedMethods())：不是必须，但官方推荐，写在所有路由后面；
    3. allowedMethods() 的作用是会根据 ctx.status 设置response的响应头。
3. router.redict()：路由重定向
    1. router.redict(&apos;/admin&apos;, &apos;/user&apos;, 301);
    2. 访问 /admin 时，会被重定向到 /user
4. URL生成器：Router.url();
    1. Router.url(&apos;/list&apos;, {page: 1}, {query: {order:&apos;desc&apos;}});
    2. 生成路由：/list/1?order=desc
</code></pre><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><pre><code>1. get传值
    router.get(&apos;/news&apos;, async(ctx, next) =&gt; {
        ctx.body = &apos;News&apos;;
    }) --&gt; http://localhost:3000/news?aid=123&amp;uname=Jack
    1. 接收get传值的方式有两种：query(格式化的参数对象)和querystring(请求字符串)
    2. ctx.query：获取的是参数对象，{ aid:&apos;123&apos;, uname:&apos;Jack&apos; }
    3. ctx.querystring：请求字符串的形式，aid=123&amp;uname=Jack
    4. ctx.url：请求的路由地址，/news?aid=123&amp;uname=Jack
2. 动态路由
    router.get(&apos;/news/:aid&apos;, async(ctx, next) =&gt; {
        ctx.body = &apos;News&apos;;
    }) --&gt; http://localhost:3000/news/123
    1. ctx.params：获取动态路由的参数对象，{ aid: &apos;123&apos; }
    2. /news/:aid/:uname：多个占位符，http://localhost:3000/news/123/Mack
</code></pre><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><pre><code>1. 在express中，中间件必须写在所有路由之前，而在koa中不管写在哪个位置，都会优先匹配；
2. 应用级中间件
    app.use(async (ctx)=&gt;{
        ctx.body = &apos;应用级中间件&apos;
    })
    1. 用于匹配所有路由，一旦匹配成功，将不再自动向下匹配；
    2. 手动让路由继续向下匹配
    app.use(async (ctx, next)=&gt;{
        ...
        await next();  ---&gt; 继续向下匹配
    })
3. 路由中间件
    router.get(&apos;/news&apos;, async(ctx, next) =&gt; {
        console.log(&apos;首次匹配news&apos;)
        await next(); ---&gt; 继续向下匹配
    })
    router.get(&apos;/news&apos;, async(ctx, next) =&gt; {
        ctx.body = &apos;News&apos;;
    })
4. 错误处理中间件
    app.use(async (ctx, next)=&gt;{
        console.log(&apos;1&apos;, &apos;中间件&apos;)
        await next(); -----------------&gt;去匹配路由，不会再继续向下执行，等待匹配结果
        console.log(&apos;2&apos;, ctx.url)
        if(ctx.status == 404) { ---&gt; 路由不存在，匹配失败，进行错误处理
            console.log(&apos;3&apos;, &apos;404&apos;)
            ctx.body = &apos;404页面&apos;
        } else { ---------------------&gt; 匹配成功
            console.log(&apos;4&apos;, ctx.url)
        }
    })
    router.get(&apos;/news&apos;, async(ctx, next) =&gt; {
        console.log(&apos;5&apos;, &apos;news&apos;)
        ctx.body = &apos;News&apos;
    })
    1. 访问http://localhost:3000/xxx --&gt; 1 --&gt; 不存在此路由，匹配失败 --&gt; 2 --&gt; 3
    2. 访问http://localhost:3000/news --&gt; 1 --&gt; 5 --&gt; 2 --&gt; 4
5. koa的洋葱模型
    1. koa的匹配过程(request--&gt;response)类似于一个洋葱
</code></pre><p><img src="https://i.imgur.com/XY2Jw5b.png" alt></p>
<pre><code>2. 由外而内，再由内而外：
中间件-1 --&gt; 中间件2 --&gt; 匹配路由，返回匹配结果 --&gt; 中间件2 --&gt; 中间件1
app.use(async(ctx, next)=&gt;{ ----------&gt; 中间件-1
    console.log(&apos;1-1&apos;)
    await next();
    console.log(&apos;1-2&apos;)
})
app.use(async(ctx, next)=&gt;{ ----------&gt; 中间件-2
    console.log(&apos;2-1&apos;)
    await next();
    console.log(&apos;2-2&apos;)
})
router.get(&apos;/news&apos;, async(ctx, next) =&gt; {
    console.log(&apos;news&apos;)
    ctx.body = &apos;News&apos;
})
3. 匹配过程：1-1 ==&gt; 2-1 ==&gt; news ==&gt; 2-2 ==&gt; 1-2
</code></pre><h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><pre><code>1. 原生NodeJs获取POST提交的数据：&lt;input type=&quot;text&quot; name=&quot;uname&quot; /&gt;
    function parserPost(ctx) {
        return new Promise((resolve, reject) =&gt; {
            try{
                let postData = &quot;&quot;;
                ctx.req.on(&apos;data&apos;, (chunk)=&gt;{
                    postData += chunk.toString();
                });
                ctx.req.on(&apos;end&apos;, ()=&gt;{ ---&gt; 数据传输完成
                    resolve(postData);
                });
            } catch(error) {
                reject(error);
            }
        });
    }
    router.post(&apos;/dologin&apos;, async(ctx) =&gt; {
        let data = await parserPost(ctx);
        ctx.body = &apos;登录成功！&apos;
    })
2. 中间件处理POST提交的数据：npm i koa-bodyparser --save
    1. 配置中间件：let parser = require(&apos;koa-bodyparser&apos;);
    app.use(parser());
    2. 获取post提交的数据
    router.post(&apos;/dologin&apos;, async (ctx)=&gt;{
        let postData = ctx.request.body;
    });
3. 在url中，? 后的内容称为querystring
    1. querystring是url的一部分，与提交方式(无论是post还是get)没有任何关系；
    2. url的长度有限，所以在数据量较大时，不推荐使用querystring的方式传输，跟get没关系；
    3. post请求也可以在url上使用querystring，在后台也可以获取此参数；
    4. 不同的是，get方式不能操作正文，而post可以把参数写入正文(请求体)
</code></pre><h2 id="静态服务"><a href="#静态服务" class="headerlink" title="静态服务"></a>静态服务</h2><pre><code>1. 静态资源中间件：npm install koa-static --save
2. 配置中间件：const static = require(&apos;koa-static&apos;);
    1. app.use(static(&apos;static&apos;)); ----&gt; 托管 根目录/static 下的资源文件
    2. 在模板中访问static/css/base.css：
    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/base.css&quot; /&gt; ---&gt; href=&quot;/css/base.css&quot;
3. koa静态资源的目录也可以配置多个：
    app.use(static(&apos;static&apos;)); ---&gt; 根目录/static
    app.use(static(path(__dirname, &apos;public&apos;))); ---&gt; 根目录/public
    1. 在匹配资源时，会先在static目录下查找，如果查找失败，再去public目录下查找；
    2. app.use(static(&apos;.&apos;)); --&gt;表示去根目录下去查找
    &lt;img src=&quot;public/img/a.png&quot; /&gt; --&gt; 根目录/public/img/a.png
4. app.use(static(&apos;.&apos;))是不安全的，它能访问根目录下的所有资源，如app.js、package.json
</code></pre><h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><pre><code>适用于koa的模板引擎有很多，如ejs、jade、nunjucks、art-template...
</code></pre><h3 id="koa与ejs"><a href="#koa与ejs" class="headerlink" title="koa与ejs"></a>koa与ejs</h3><pre><code>1. 安装ejs之后，安装koa-views：npm install koa-views --save
2. 多种方式配置koa-views中间件，const views = require(&apos;koa-views&apos;);
    1. app.use(views(&apos;views&apos;, { map:{ html:&apos;ejs&apos; } })); --&gt;模板的后缀名为html
    2. app.use(views(&apos;views&apos;, { extension:&apos;ejs&apos; })); --&gt;模板的后缀名为ejs
    3. views()的第一个参数表示ejs模板存放的目录，&apos;views&apos;表示在根目录/views
3. 在根目录/views中创建index.ejs
    router.get(&apos;/&apos;, async(ctx) =&gt; {
        await ctx.render(&apos;index&apos;, {key: value}) ---&gt;渲染index.ejs
    })
4. 公共数据(全局变量)
    1. 在koa中，通过 ctx.state 管理公共数据，在所有模板中都能访问；
    2. 在中间件中设置公共数据
    app.use(async(ctx, next) =&gt; {
        ctx.state = { uname: &apos;Mack&apos;, age: 20 } ----&gt; 设置公共数据uname和age
        await next();
    })
    3. 在模板中使用：&lt;h2&gt;&lt;%= uname %&gt;&lt;/h2&gt;
</code></pre><h3 id="art-template"><a href="#art-template" class="headerlink" title="art-template"></a>art-template</h3><pre><code>1. art-template是一个简约、超快的模板引擎，它采用作用域预声明的技术来优化模板渲染速度；
    1. art-template的模板渲染速度接近JavaScript极限地运行性能，且同时支持NodeJs和浏览器
    2. art-template支持ejs语法，也可以用类似angular数据绑定地语法
    3. 由腾讯开发的，同时支持Express、Koa
2. 渲染速度：art-template(15-25ms) &gt; jade(51ms) &gt; ejs(141ms)
3. 安装：npm install art-template --save，npm install koa-art-template --save
    const render = require(&apos;koa-art-template&apos;);
    render(app, {
        root: path.join(__dirname, &apos;views&apos;), ---&gt; 配置模板的位置：根目录/view
        extname: &apos;.art&apos;, ---&gt; 模板的扩展名，也可以设置为&apos;.html&apos;
        debug: process.env.NODE_ENV !== &apos;production&apos; --&gt; 开发环境下开启调试模式
    })
    app.use(async (ctx)=&gt;{
        await ctx.render(&apos;index&apos;, {key: value}); --&gt; 根目录/views/index.art
    })
4. art-template支持类似ejs的语法(原始语法)，也支持类似angular的语法(标准语法)
    1. 原始语法：&lt;%= value %&gt;，&lt;%= a?b:c %&gt; ，&lt;%= a+b %&gt;，&lt;%- value %&gt; ...
    2. 引入子模板的方式与ejs不同：&lt;% include(&apos;./public/header.art&apos;) %&gt;
    &lt;% include(&apos;./public/header.art&apos;, data) %&gt;
5. 标准语法：{{value}}，{{a?b:c}}，{{a+b}}，{{@value}}，{{if a}} ... {{/if}}
    1. {{@value}}：表示原样输出value，如value=&quot;&lt;p&gt;123&lt;/p&gt;&quot;，原样输出的结果就是&lt;p&gt;标签
    2. 循环数据：{{each a}}  {{$index}} {{$value}}  {{/each}}
    3. 引入子模板：{{include './header.art'}}，{{include './header.art', data}}
    4. 引入不在同一目录下的子模板时，不能使用相对路径，而是直接相对于模板的根目录；
    {{include 'admin/public/header.html'}}  ---&gt;views/admin/public/header.html
6. 在标签内直接使用模板语言
    &lt;input type=&quot;checkbox&quot; {{if list.check==1}} checked {{/if}} /&gt;
</code></pre><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><pre><code>1. Koa可以直接操作cookie：ctx.cookies.set(name, value, [options])
    router.get(&apos;/&apos;, async (ctx)=&gt;{
        ctx.cookies.set(&apos;uname&apos;, &apos;Jack&apos;, {
            maxAge: 60*1000*60 ---&gt; 60s后过期
        })
    })
    1. 获取cookie：ctx.cookies.get(&apos;uname&apos;)
2. options的可选参数：maxAge、expires、path、domain、secure、httpOnly、overwrite
    1. httpOnly：是否只允许服务器访问cookie，默认为true，不允许浏览器端的JS访问cookie
    2. secure：安全的cookie，默认为false，设置为true表示只允许https可以访问；
    3. overwrite：是否覆盖以前设置的同名cookie，默认为false
    ctx.cookies.set(&apos;uname&apos;, &apos;Jack&apos;, {
        path: &apos;/news&apos;,  ---&gt; 只允许 /news 路由页面可以访问此cookie
        domain: &apos;.baidu.com&apos;  --&gt;设置允许访问cookie的域名，默认当前域名下的所有路由页面
    }) -------------------------&gt; 都可以访问，所以正常情况下不会设置
3. 在koa中无法直接设置中文的cookie，如ctx.cookies.set(&apos;uname&apos;, &apos;李蕾&apos;);
    1. 可以把中文转为base64编码：new Buffer(&apos;李蕾&apos;).toString(&apos;base64&apos;);
    2. 解码：new Buffer(&apos;base64编码数据&apos;, &apos;base64&apos;).toString();
</code></pre><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><pre><code>1. 安装中间件：npm i koa-session --save
2. 配置session中间件
    1. const session = require(&apos;koa-session&apos;);
    2. app.keys = [&apos;some secret&apos;]; ---&gt; cookie的签名/加密，可以是任意字符串
    2. app.use(session(CONFIG, app));
3. CONFIG表示session的配置
    const CONFIG = {
        key: &apos;koa:sess&apos;,  ---&gt; 也类似于cookie的key，使用默认配置即可
        maxAge: 86400000, ---&gt; cookie的过期时间
        overwrite: true,
        httpOnly: false,  ---&gt; 默认为true，表示只允许服务器端访问cookie
        signed: true, ----&gt; 启用签名
        rolling: false,
        renew: false
    }
    1. rolling:true --&gt; 浏览器每次访问都强制设置cookie，每次都会重置过期时间
    2. renew:true --&gt; 每次访问时会检查cookie的过期时间，在将要过期时才会重置过期时间
4. 设置/获取：ctx.session.uname=&apos;Mack&apos;;  let uname=ctx.session.uname;
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/08/01/Express/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/01/Express/" itemprop="url">Express</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-01T00:00:00+08:00">
                2018-08-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h2><pre><code>1. Express是一个基于NodeJs平台的后台开发框架；
    1. 极简、开放、灵活的web应用开发框架，帮助开发各种Web和移动设备应用；
    2. Express不对NodeJs已有的特性进行二次抽象，只是在它之上扩展了Web应用所需的功能；
    3. Express提供了丰富的HTTP快捷方法和任意排列组合的Connect中间件。
2. Express的使用：npm install express --save
    1. 引入：const express = require(&apos;express&apos;)，let app = new express()
    2. 配置get请求的路由
    app.get(&apos;/&apos;, (req, res) =&gt; {  ------&gt; 配置路由
        res.send(&apos;Hello Express&apos;) ----&gt; 响应内容
    })
    3. 配置post请求的路由
    app.post(&apos;/dologin&apos;, (req, res) =&gt; { ... })
    4. 设置监听的Ip和端口号：app.listen(3000, &apos;ip&apos;)，默认Ip是127.0.0.1
    5. node命令运行该js文件，它也就是项目的入口文件。
3. 传递参数
    1. 配置动态路由
    app.get(&apos;/news/:id&apos;, (req, res) =&gt; {
        let {id} = req.params ---&gt; 获取id参数
    }) --&gt; 访问http://localhost:3000/news/123
    2. get传值
    app.get(&apos;/news&apos;, (req, res) =&gt; {
        let {id} = req.query ---&gt; 获取id参数
    }) --&gt; 访问http://localhost:3000/news?id=123
4. 其他API
    1. 重定向：res.redirect(&apos;/index&apos;) --&gt;重定向到路由&apos;/index&apos;
    2. 获取访问的路由：req.url ---&gt; 如&apos;/login&apos;
    3. 响应一段JS代码，弹出alert()，并重定向页面路由：
    res.send(&quot;&lt;script&gt;alert(&apos;登录失败！&apos;);location.href=&apos;/login&apos;&lt;/script&gt;&quot;)
</code></pre><h2 id="express与ejs"><a href="#express与ejs" class="headerlink" title="express与ejs"></a>express与ejs</h2><pre><code>1. Express中引入ejs模板引擎：app.set(&apos;view engine&apos;, &apos;ejs&apos;)
2. 使用ejs模板：res.render(&apos;模板名&apos;, { key:value })
    1. 模板名不需要指定路径，默认使用的路径：项目根目录/views/模板名.ejs
    app.get(&apos;/news&apos;, (req, res) =&gt; {
        res.render(&apos;index&apos;, {newsId: 123}) --&gt;默认使用的模板：views/index.ejs
    })
    2. 指定模板的目录：app.set(&apos;views&apos;, __dirname + &apos;/static&apos;)，修改为static目录；
    3. 使用path模块拼接路径：require(&apos;path&apos;).join(__dirname, &apos;static&apos;)
3. 全局变量
    1. 如果多个模板都需要接收同一变量，每个模板对应的路由都必须传递该参数，而全局变量只需要
    设置一次即可，所有模板都可以接收全局变量；
    2. 设置全局变量：app.locals[&apos;全局变量名&apos;] = &apos;123&apos;
    3. 在第一个需要接收全局变量的模板被渲染之前，设置全局变量uname的值：
    app.post(&apos;/dologin&apos;, (req, res) =&gt; {
        app.locals[&apos;uname&apos;] = &apos;123&apos; --&gt;在任何模板中都可以接收变量uname：&lt;%= uname %&gt;
        ......
    })
    4. app.locals[&apos;变量名&apos;]是真正的全局，req.app.locals[&apos;变量名&apos;]表示请求的全局。
</code></pre><h2 id="静态服务"><a href="#静态服务" class="headerlink" title="静态服务"></a>静态服务</h2><pre><code>1. 静态服务/静态路由：用于提供静态资源服务，包括css文件、js文件、图片、供下载的文件...
2. 以css文件为例，在模板中直接使用&lt;link /&gt;引入是无效的
    app.get(&apos;/login&apos;, (req, res) =&gt; {
        res.render(&apos;login&apos;) ----&gt; views/login.ejs
    })
    1. login.ejs中引入css文件：&lt;link rel=&quot;stylesheet&quot; href=&quot;css/login.css&quot; /&gt;
    2. css文件的真实获取方式：http://localhost:3000/css/login.css
    3. 很明显，&quot;/css/login.css&quot;的路由是不存在，所以获取css文件失败。
2. 在express中，利用 express.static 中间件托管静态文件
    1. app.use(express.static(&apos;public&apos;)) --&gt; 给public目录下的文件提供静态web服务
    2. 在public目录下创建有效的css/login.css
    http://localhost:3000/css/login.css --&gt; 查找路径：public/css/login.css
    3. 同理，login.ejs中的&lt;img /&gt;加载的图片资源也必须提供静态服务
    &lt;img src=&quot;img/a.png&quot; /&gt; =&gt;http://localhost:3000/img/a.png =&gt;public/img/a.png
3. 注意：href=&quot;css/login.css&quot; 与 href=&quot;/css/login.css&quot; 并不完全相同
    1. &apos;/&apos;、&apos;/login&apos;、&apos;/user&apos;都属于一级路由，而&apos;/index/login&apos;属于二级路由；
    2. 在一级路由中渲染的ejs模板中，&quot;css/login.css&quot; 与 &quot;/css/login.css&quot; 是相同的
    http://localhost:3000/css/login.css ==&gt; public/css/login.css
    3. 对于二级路由，&quot;css/login.css&quot; 与 &quot;/css/login.css&quot;的参考路由不同，也就导致了资源
    路径出错，从而无法加载资源；
    4. 在二级路由 &apos;/index/login&apos; 中渲染login.ejs模板时：
    href=&quot;css/login.css&quot; -----&gt; http://localhost:3000/index/css/login.css ------
    --&gt; public/index/css/login.css --&gt; public目录下不存在 index目录，所以访问失败
    href=&quot;/css/login.css&quot; --&gt; http://localhost:3000/css/login.css --&gt; 访问成功
    5. 原因：href=&quot;css/login.css&quot;相对于当前路由，而href=&quot;/css/login.css&quot;相对于根路由。
5. 设置虚拟目录，映射真实的资源路径：app.use(&apos;/static&apos;, express.static(&apos;public&apos;))
    1. app.use(express.static(&apos;public&apos;)) --&gt;匹配的是根路由，而所有路由又都开始于根路由
    2. app.use(&apos;/static&apos;, express.static(&apos;public&apos;)) 匹配的路由是 &apos;/static&apos;
    3. href=&quot;/css/login.css&quot; 不能在访问了，需要使用 href=&quot;/static/css/login.css&quot;
    http://localhost:3000/static/css/login.css ==&gt; public/css/login.css
6. 如果静态资源存在多个目录，可以配置多个 express.static 中间件
    app.use(express.static(&apos;public&apos;)) ---&gt; public目录
    app.use(express.static(&apos;static&apos;)) ---&gt; static目录
    app.use(&apos;/static&apos;, express.static(&apos;public&apos;)) --&gt; 虚拟路径
    1. 访问静态资源时，express会依次匹配静态资源目录，如果都找不到，才会抛出404
7. href和src都是可以跨域的，可以直接指定静态资源的完整地址，包括域名和路径。
</code></pre><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><pre><code>1. Express本身非常简洁，它完全是由路由和中间件构成的web开发框架，其应用就是在调用各种中间件
2. 简单来说，中间件就是在匹配路由之前和之后所做的一系列操作；
3. 类型：应用级中间件、路由级中间件、错误处理中间件、内置中间件、第三方中间件
1. 应用级中间件：匹配任何路由
    app.use((req, res, next) =&gt; { ... })
    1. 路由默认只匹配一次，一旦匹配成功，则不再继续向下匹配；
    2. 调用 next()，让路由继续向下匹配，直到匹配正确的路由。
    http://localhost:3000/news
    app.use((req, res, next) =&gt; { ---&gt; 可用作权限判断
        ......
        next();  --&gt; 继续向下匹配
    })
    app.get(&apos;/news&apos;, (req, res) =&gt; { ---&gt; 匹配成功
        res.send(&apos;匹配news路由&apos;)
    })
    4. 默认匹配所有路由，也可以指定只匹配某个路由
    app.use(&apos;/news&apos;, (req, res, next) =&gt; {  --&gt; 只匹配 /news
        ......
        next();
    })
    5. 中间件和路由的排列顺序不能颠倒，否则一旦匹配成功，将不再继续执行。
2. 路由级中间件：匹配多个路由
    http://localhost:3000/news
    app.get(&apos;/news&apos;, (req, res, next) =&gt; {
        console.log(&apos;路由中间件news&apos;)
        next(); ---&gt; 不执行 res.send() 返回数据，让路由继续向下执行
    })
    app.get(&apos;/news&apos;, (req, res) =&gt; {
        res.send(&apos;匹配news路由&apos;)
    })
3. 错误处理中间件
    1. 写在所有路由的后面，当上面的所有路由都不匹配时，则返回404
    app.use((req, res) =&gt; {  ---&gt; 匹配所有路由
        res.status(404).send(&apos;404页面&apos;)
    })
4. 内置中间件：如 express.static()，用于托管静态资源
    app.use(&apos;/static&apos;, express.static(&apos;./static&apos;))
</code></pre><h3 id="第三方中间件"><a href="#第三方中间件" class="headerlink" title="第三方中间件"></a>第三方中间件</h3><pre><code>1. body-parser：用于获取POST提交的数据，npm install body-parser --save
    1. let parser = require(&apos;body-parser&apos;)
    2. 配置 body-parser 中间件
    //parse application/x-www-form-urlcoded
    app.use(parser.urlencoded({extended:false}))
    app.use(parser.json()) ---&gt; parse application/json
    app.post(&apos;/login&apos;, (req, res) =&gt; {
        let body = req.body  ---&gt; 获取post提交的数据
    })
2. 但是，如果表单中涉及文件上传，body-parser模块就无法处理了，需要使用multiparty模块
    1. npm install multiparty --save
    2. multiparty可以设置上传文件的保存路径、限制文件的大小...
    3. 对于涉及文件上传的表单，必须设置&lt;form enctype=&quot;multipart/form-data&quot;&gt;
    let multiparty = require(&apos;multiparty&apos;)
    let form = new multiparty.Form()
    form.uploadDir = &apos;upload&apos; ----&gt; 设置上传文件的保存目录，项目根目录/upload
    form.parse(req, (err, fields, files) =&gt; { ---&gt; 处理 req 中提交的表单数据
        // --&gt;fields是处理后的表单数据，files是文件上传成功后返回的信息
    })
    4. 使用虚拟目录为 upload 目录配置静态服务：
    app.use(&apos;/upload&apos;, express.static(&apos;upload&apos;))
    5. 访问 upload 目录中上传的图片文件：http://localhost:3000/upload/a.jpg
3. multiparty模块的问题
    1. 如果表单中没有选择上传的图片，即&lt;input type=&quot;file&quot; /&gt;是空的，multiparty模块仍会在
    上传目录中生成一个临时文件；
    2. 上传成功后，files中的originalFilename属性表示上传文件的原始名称，path属性表示上传
    文件在服务器端存储的路径，为了防止文件名重复，文件的名称已经被重新编码了；
    3. 如果表&lt;input type=&quot;file&quot; /&gt;是空的，那么 files.originalFilename=&apos;&apos;，由此判断文件
    是否上传，如果没有上传，则根据 files.path 删除临时文件。
</code></pre><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><pre><code>1. NodeJs操作Cookie的中间件：npm install cookie-parser --save
2. 配置 Cookie 中间件
    let cookieParser = require(&apos;cookie-parser&apos;)
    app.use(cookieParser())
3. 设置cookie
    app.get(&apos;/set&apos;, (req, res) =&gt; {
        res.cookie(&apos;username&apos;, &apos;Mack&apos;, { maxAge:90000, httpOnly:true })
        res.send(&apos;set Cookie&apos;)
    })
    1. 参数1和参数2分别是cookie的键-值，参数3是对cookie的配置；
    2. maxAge：表示过期时间(s)，最大失效时间
    3. httpOnly：默认为false，表示不允许客户端的脚本访问，只能在nodeJs服务的操作
    4. 获取cookie：一旦访问过 /set 路由，就可以在其他路由中获取 cookie
    app.get(&apos;/news&apos;, (req, res) =&gt; {
        let username = req.cookies.username; --&gt;{ username: &apos;Mack&apos; }
        res.send(`get Cookie: ${username}`);
    })
4. Cookie的更多设置
res.cookie(&apos;uname&apos;, &apos;Node&apos;, {expires:new Date(Date.now()+9000), httpOnly:true})
    1. expires：也是设置Cookie的过期时间，表示从当前时间开始，到 expires 设置的时间过期
res.cookie(&apos;uname&apos;, &apos;Node&apos;, {domain:&apos;.exa.com&apos;, path: &apos;/admin&apos;, secure: true})
    1. secure：设置为true，表示cookie在 HTTP 中是无效的，仅在 HTTPS 中才有效；
    2. path：指定cookie匹配的路由，如果访问的路由不匹配，浏览器不会发送cookie
    3. domain：域名，让所有子域名/二级域名共享同一个cookie信息，如domain:&apos;.exa.com&apos;的
    子域名www.exa.com、aaa.exa.com ...
5. cookie的签名/加密
    app.use(cookieParser(&apos;sign&apos;)) --&gt; 传入一个随机字符串，用于cookie的加密
    res.cookie(&apos;uname&apos;, [1,2,3], {maxAge:60000, signed:true})
    1. cookie默认是明文存储的，signed用于签名cookie，设置为true 会对cookie签名/加密；
    2. res.signedCookies：获取签名后的cookie
    3. 被篡改的签名cookie会被服务器拒绝，且cookie会被重置为初始值。
</code></pre><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><pre><code>1. session是另一种记录客户端状态的机制，与cookie不同的是，session保存在服务器端；
    1. 当客户端第一次访问服务器时，session可以保存客户端的登录状态，当客户访问其他路由时，
    判断客户的登录状态，作出响应提示；
    2. 工作机制：客户端第一次向服务器发送请求 --&gt; 服务器创建一个类似键-值的session对象，
    然后将key设置在cookie中，返回给客户端 --&gt; 客户端下次访问时会携带cookie，根据cookie中
    的key找到对应的session
2. 与cookie不同，session没有过期时间，浏览器一旦关闭，session就失效了；
3. session还可以和Redis等数据库结合，实现持久化，就算服务器宕机，也不会丢失用户状态；
4. express-session：nodeJs操作session的中间件
    1. npm install express-session --save
    2. 配置中间件
    const session = require(&apos;express-session&apos;)
    app.use(session({ 
        secret:&apos;anything&apos;,  --&gt; 服务器生成session的签名，可以是任意字符串，用于加密
        //name: &apos;&apos; --------&gt; 返回给客户端的cookie名称，默认为connect.sid
        resave: false, --&gt; 强制保存session，即使没有变化，默认值为true
        saveUninitialized:true, --&gt;强制将未初始化的session存储，默认为true
        cookie:{ secure:false } --&gt;设置cookie，maxAge、path、domain...
    }))  --&gt; 一旦关闭浏览器，session就失效了，相关的cookie也会失效
    2. 设置/获取session
    app.get(&apos;/&apos;, (req, res) =&gt; {
        if(req.session.userInfo) {  ---&gt; 获取session
            res.send(&apos;welcome back: &apos;, req.session.userInfo)
        } else {
            res.send(&apos;logout&apos;)
        }
    })
    app.get(&apos;/login&apos;, (req, res) =&gt; {
        req.session.userInfo = {uname:&apos;Mack&apos;, pwd:&apos;123&apos;}  ---&gt; 设置session
        res.send(&apos;login success&apos;)
    })
    3. 销毁session，如切换登陆、退出登录时，要主动销毁session
    req.session.cookie.maxAge=0  --&gt; 方式1：把cookie的过期时间设置为0ms后，立即过期
    req.session.destroy(err =&gt; {}) ---&gt; 方式2：调用session的销毁方法
5. 负载均衡配置Session
    1. 负载均衡：后台配置多个服务器，执行同一套node代码，通过Nginx服务器动态地把不同地区的
    用户请求转发给不同的服务器处理，或者把用户请求转发给同一地区压力比较小的服务器；
    2. session默认保存在服务器的缓存文件中，而后台配置了负载均衡之后，同一用户访问的服务器
    就可能发生变化，那么原本的session信息也就不存在了，但多个服务器会共享数据库，所以需要把
    session保存到数据库中；
    3. 把session保存在MongoDB数据库中：express-session和connect-mongo两大模块
    let session = require(&apos;express-session&apos;)
    const MongoStore = require(&apos;connect-mongo&apos;)(session)
    4. 配置中间件
    app.use(session({secret:&apos;1234&apos;, resave:false, saveUninitialized:true,
        cookie: { maxAge:1000*60*30 }, --&gt; 在浏览器未关闭的情况下，30min后过期
        rooling:true, --&gt;默认false，每次请求时强行设置cookie，这将会重置cookie过期时间
        store:new MongoStore({
            url: &apos;mongodb://127.0.0.1:27017/student&apos;, ---&gt;数据库地址
            touchAfter: 24*3600 --&gt; 不管多少次请求，24小时内只更新一次session，除非在
        }) ------------------------------------------&gt; session数据上更改了某些内容
    }))
    5. db.sessions.find(); --&gt; 查询MongoDB中保存的session
</code></pre><h2 id="express模块化"><a href="#express模块化" class="headerlink" title="express模块化"></a>express模块化</h2><pre><code>1. express.Router：路由模块化，进而实现项目的模块化，便于协作开发与维护；
2. 创建入口文件app.js：
    const express = require(&apos;express&apos;);  let app = express();
    1. 引入路由模块的文件
    let index = require(&apos;./routes/index&apos;)
    let user = require(&apos;./routes/user&apos;)
    2. 应用路由模块
    app.use(&apos;/&apos;, index) ---&gt;当访问 http://localhost:3000 时，进入index.js去匹配路由
    app.use(&apos;/user&apos;, user) --&gt; http://localhost:3000/user --&gt; user.js
    app.listen(3000)
2. 以index.js为例：const express = require(&apos;express&apos;);
    1. 创建路由对象：let router = express.Router();
    2. 引入index模块的子路由模块login.js、home.js
    let login = require(&apos;./index/login&apos;);  let home = require(&apos;./index/home&apos;)
    3. 配置匹配的路由
    router.use(&apos;/&apos;, login) --&gt; http://localhost:3000 --&gt; 进入login.js去匹配
    router.use(&apos;/home&apos;, home) --&gt; http://localhost:3000/home --&gt; home.js
    4. 暴露模块的路由对象：module.exports = router
3. 以home.js为例
    const express = require(&apos;express&apos;);  let router = express.Router();
    1. 响应处理请求
    router.get(&apos;/&apos;, (req, res) =&gt; { --&gt;处理响应http://localhost:3000/home
        res.send(&apos;index--&gt;home&apos;)
    })
    router.get(&apos;/item&apos;, (req, res) =&gt; { --&gt;响应http://localhost:3000/home/item
        res.send(&apos;index--&gt;home--&gt;item&apos;)
    })
    2. 暴露子模块的路由对象：module.exports = router
4. 使用ejs模板
    1. 在入口文件app.js中配置ejs引擎和静态服务：
    app.set(&apos;view engine&apos;, &apos;ejs&apos;);  app.use(express.static(&apos;public&apos;));
    2. 在login.js中使用
    router.get(&apos;/&apos;, (req, res) =&gt; {
        res.render(&apos;login&apos;) ---&gt; 默认使用的模板为views/login.ejs
    })
5. express脚手架：express-generator
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/07/09/NodeJs-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/09/NodeJs-3/" itemprop="url">NodeJs-3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-09T00:00:00+08:00">
                2018-07-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="路由与模板引擎"><a href="#路由与模板引擎" class="headerlink" title="路由与模板引擎"></a>路由与模板引擎</h2><pre><code>1. 路由：简单来说就是，根据不同请求的URL，处理不同的业务逻辑；
2. ESJ模板引擎：是一种后台模板，可以把数据库/文件的读取内容显示到HTML页面上；
    1. 安装：npm/cnpm install ejs --save
    2. 创建ejs文件，取代HTML文件，但ejs文件的代码格式仍是HTML；
    let ejs = require(&apos;ejs&apos;)
    http.createServer((req, res) =&gt; {
        res.writeHead(200, {&quot;Content-Type&quot;:&quot;text/html;charset=&apos;utf-8&apos;&quot;})
        ejs.renderFile(&apos;view/login.ejs&apos;, {}, (err, data) =&gt; {
            res.end(data) --&gt; 把ejs模板引擎的渲染的数据，响应给浏览器
        })
    }).listen(8000)
3. EJS模板语言
    1. 向模板中传递变量：ejs.renderFile()的第二个参数，如{name: &apos;Mack&apos;}
    2. 模板中接收变量：&lt;h2&gt;&lt;%= name %&gt;&lt;/h2&gt;
    3. 在模板中使用JS语句：
    &lt;% if(name) { %&gt;
        &lt;h2&gt;&lt;%= name %&gt;&lt;/h2&gt;
    &lt;% } %&gt;
    4. 引入公共的模板：&lt;%- include header.ejs %&gt;
    5. 接收HTML数据：&lt;%- html %&gt;
4. 隐藏表单域传值
    1. 模板中需要使用参数id，那么就在渲染模板时传递参数id，在模板中使用隐藏表单域接收此参数
    ejs.renderFile(&apos;view/login.ejs&apos;, { id: 12 });
    &lt;input type=&quot;hidden&quot; id=&quot;keyId&quot; value=&quot;&lt;%= id %&gt;&quot; /&gt;
    2. 在模板的&lt;script&gt;中操作DOM，获取隐藏表单域的value值，也就获取了参数id
    let keyId = document.getElementById(&apos;keyId&apos;);
    let id = keyId.value
</code></pre><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><pre><code>1. NoSQL最早在20世纪80年代被提出，属于非关系型数据库，以key-value形式存储；
2. 在如今的大数据时代，NoSQL更多地是强调协助解决大数据等相关问题；
3. 建议使用NoSQL的情况：
    1. 对数据库高并发读写、高可扩展性和高可用性的需求，对海量数据的高效率存储和访问的需求。
</code></pre><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><pre><code>1. 启动MongoDB
    1. 启动服务器端(windows)：mongod --dbpath F:\mongodb
    2. --dbpath F:\mongodb 表示指定mongodb服务器端的工作目录，保存数据库文件
    3. 启动客户端：mongo ip:27017 ---&gt; 默认ip为127.0.0.1，默认端口号27017
2. NodeJs操作MongoDB：cnpm install mongodb --save
    1. mongodb模块是MongoDB官方为nodeJs提供的驱动，用于nodeJs原生操作MongoDB
    2. const MongoClient = require(&apos;mongodb&apos;).MongoClient
    3. 数据库的地址：在命令行执行 mongo，会显示地址，如 mongodb://127.0.0.1:27017
3. NodeJs连接数据库：MongoDB4.0与4.0之前的版本是不同的
    1. 主要因为MongoDB官方为nodeJs提供的MongoDB驱动更新了，Driver3.x与2.x是不同的
    2. Driver2.x操作数据库：const url = &apos;mongodb://127.0.0.1:27017/test&apos;
    MongoClient.connect(url, (err, db) =&gt; { --&gt; db表示数据库test的对象
        if(err) return;
        db.connect(&apos;user&apos;).insertOne({name: &apos;Jack&apos;}, callback) --&gt;插入一条数据
    })  ---&gt;在callback中关闭数据库：db.close()
    3. Driver3.x操作数据库：const url = &apos;mongodb://127.0.0.1:27017&apos;
    MongoClient.connect(url, (err, client) =&gt; { --&gt;client表示数据库对象
        if(err) return;
        let db = client.db(&apos;test&apos;) --&gt; 连接数据库test
        db.collection(&apos;user&apos;).insert({name: &apos;Jack&apos;}, callback) --&gt;插入一条数据
    }) ---&gt; client.close() 关闭数据库
    4. 查询MongoDB官网文档可知，MongoDB NodeJs Driver3.x查询数据
    MongoClient.connect(url, (err, client) =&gt; {
        if(err) return;
        let db = client.db(&apos;user&apos;) ---&gt; 连接数据库user
        let cursor = db.collection(&apos;user&apos;).find() ---&gt; 查询出user中的所有数据
        let userlist = []
        cursor.forEach(doc =&gt; {
            userlist.push(doc) ---&gt; 把数据保存到一个数组中
        }, error =&gt; {
            if(error) { console.log(error) }
            client.close() ---&gt; 查询结束，关闭数据库
        })
    })
    5. 另一种获取cursor中的数据、并转为数组的方式：
    cursor.toArray((err, result) =&gt; {
        if(!err) {
            console.log(&apos;result: &apos;, result)  ---&gt; result已经是一个数组了
        }
        client.close()
    })
4. ObjectID：MongoDB数据库的id是封装后的，不能直接使用，需要借助mongodb模块的ObjectID
    1. let { ObjectID } = require(&apos;mongodb&apos;)
    2. 根据id查询数据：find({ _id: new ObjectID(&apos;id值&apos;) })
5. 用户的登录密码需要md5加密之后再存入数据库，md5模块：cnpm install md5-node --save
6. MongoDB Compass Community：MongoDB官方提供的可视化管理工具，最新的MongoDB自带此工具
7. mongoose：NodeJs操作MongoDB的第三方模块，它是一种便捷操作的对象模型工具。
</code></pre><h3 id="导入与导出"><a href="#导入与导出" class="headerlink" title="导入与导出"></a>导入与导出</h3><pre><code>1. 导出：mongodump -h dbhost -d dbname -o dbdirectory
    1. 导出时需要连接数据库，所以MongoDB服务器端必须运行；
    mongodump -h 127.0.0.1 -d koastu -o D:\users\test
    2. 把127.0.0.1上的MongoDB数据库koastu，导出到D:\users\test目录；
    3. 在D:\users\test下会生成一个数据库文件目录koastu
2. 导入：mongorestore -h dbhost -d dbname &lt;path&gt;
    1. 导入时不需要运行MongoDB服务器
    mongorestore -h 127.0.0.1 -d koademo D:\users\test\koastu
    2. 把D:\users\test\koastu中的数据库文件，导入到127.0.0.1上的MongoDB数据库koademo
    3. 如果指定的数据库koademo不存在，MongoDB会自动创建
</code></pre><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><pre><code>1. 插入/删除/更新/查询的操作其实是很快的，而连接数据库的操作却会耗费很长时间；
2. 性能优化的关键点：保持数据库的长连接，即保存第一次成功连接后的数据库对象
3. 创建一个单例模式的类：
    class DB {
        static getInstance() {  ---&gt; 静态方法
            if(!DB.instance) {
                DB.instance = new DB();
            }
            return DB.instance;
        }
        constructor() {
            this.dbClient = null;  ---&gt; 用于保存数据库对象
        }
    }
</code></pre><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><pre><code>1. mysql2：第三方MySQL驱动引擎，npm i mysql2 --save
2. 连接数据库：const mysql = require(&apos;mysql2/promise&apos;);
    let conn = await mysql.createConnection({ 数据库参数 });
</code></pre><h3 id="Sequelize"><a href="#Sequelize" class="headerlink" title="Sequelize"></a>Sequelize</h3><pre><code>1. ORM映射：避免直接写SQL语句，而是用对象模型去操作数据库；
2. Sequelize：ORM映射模型，支持多种数据库，对于MySQL的操作，底层使用的是mysql2
    npm i mysql2 --save
    npm i sequelize --save
    1. 连接数据库：const Sequelize = require(&apos;sequelize&apos;);
    const conn = new Sequelize(&apos;数据库名&apos;, &apos;用户名&apos;, &apos;密码&apos;, { 数据库参数 });
    2. 数据库参数可以配置域名host、数据库类型dialect，时区timezone
    { host: &apos;117.78.51.252&apos;, dialect:&apos;mysql&apos;, timezone:&apos;+08:00&apos; }
    3. 测试是否连接成功：conn.authenticate();
1. 定义要操作的表的对象模型
    const User = conn.define(&apos;模型名&apos;, { 字段参数配置 }, { 可选配置 });
    1. 字段参数配置与数据库表的字段要一一对应，建立映射关系；
    2. 默认情况下，模型名+&apos;s&apos;为表名，在可选配置中指定表名
    { freezeTableName:true, tableName:&apos;user&apos;, timestamps:false }
    3. freezeTableName：设置为true，表示允许通过tableName自定义表名；
    4. 如果没有tableName自定义表名，则取模型名为表名；
    5. timestamps：设置为false，关闭自动向模型中添加时间戳字段createAt和updatedAt
2. 访问数据库的所有数据：User.findAll().then(res =&gt; { ... });
3. 查询并修改
    User.findById(10).then(res =&gt; {
        res.set(&apos;字段名&apos;, &apos;字段值&apos;);  --&gt; 设置新的字段值
        res.save();  --&gt; 保存到数据库中
    });
4. 插入数据
    let zhgsan = User.build({字段名: 字段值, ...});
    zhgsan.set(key, value);  --&gt; 重新设置新的值
    zhgsan.save();  --&gt; 插入到数据库表中
</code></pre><h3 id="sequelize-cli"><a href="#sequelize-cli" class="headerlink" title="sequelize-cli"></a>sequelize-cli</h3><pre><code>1. sequelize-cli：sequelize的命令行工具，npm i -D sequelize-cli
2. 初始化：sequelize init，在当前目录下会生成4个目录；
    1. config：配置目录，
    2. migrations：迁移文件目录(数据库表结构)
    3. seeders：种子文件目录(生成测试数据)
    4. models：模型文件目录，主要供程序使用
3. config/config.json中包含三大节点：development(开发)、test(测试)、production(生产)
    1. 配置时区：&quot;timezone&quot;: &quot;+08:00&quot;
4. 创建数据库：在config目录中配置数据库信息，执行 sequelize db:create 生成数据库；
5. 构建数据迁移结构：sequelize migration:create --name [迁移文件的名称]
    1. 在migrations目录中生成相应的JS文件，一个迁移文件对应一个表；
    2. 在迁移文件中配置表结构，再执行生成表的命令；
    3. 第三方日期时间格式化模块：momentjs
6. 生成表：sequelize db:migrate
7. 把种子文件的数据导入表中：sequelize db:seed:all
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/07/08/NodeJs-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/08/NodeJs-2/" itemprop="url">NodeJs-2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-08T00:00:00+08:00">
                2018-07-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="path模块"><a href="#path模块" class="headerlink" title="path模块"></a>path模块</h2><pre><code>1. path模块：用于处理文件路径，var path = require(&apos;path&apos;)
2. path.extname(&apos;index.html&apos;)：获取文件的后缀名&apos;.html&apos;
3. path.basename(&apos;./conf/img/a.png&apos;)：获取文件名 a.png
4. path.join(path1, path2, ...)：连接路径；
    1. 主要用途：它会正确地使用当前系统的路径分隔符，Unix系统是&quot;/&quot;，Windows系统是&quot;\&quot;
    2. path.join(__dirname, &apos;user/config&apos;)：项目根目录/user/config
5. path.parse(pathStr)：返回路径字符串的对象；
6. path.resolve(from, to)：将相对路径转为绝对路径。
</code></pre><h2 id="url模块"><a href="#url模块" class="headerlink" title="url模块"></a>url模块</h2><pre><code>var url = require(&apos;url&apos;)
1. 解析一个域名：var result = url.parse(&apos;http://www.baidu.com/&apos;)
2. result是一个对象，如获取协议名：result.protocol --&gt; &apos;http&apos;
3. url.parse(&apos;http://www.a.com/news?n=pfy&amp;a=10&apos;, true)：把GET请求的参数封装成一个对象
    query: { n: &apos;pfy&apos;, a: &apos;10&apos; }
4. url.format()：url.parse()的逆向操作
5. url.resolve(from, to)：拼接URL
    1. url.resolve(&apos;http://abc.com&apos;, &apos;one&apos;) --&gt; http://abc.com/one
    2. url.resolve(&apos;http://abc.com/news&apos;, &apos;one&apos;) --&gt; http://abc.com/one
</code></pre><h2 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h2><pre><code>1. http模块：提供了网络请求(客户端)和网络服务(服务端)的实现，let http=require(&apos;http&apos;)
2. http服务端：http.Server 继承自 net.Server
    const server = new http.Server(); / http.createServer();
    1. 启动监听：server.listen(8000, &apos;127.0.0.1&apos;, ()=&gt;{ //启动成功的回调 });
    2. 接收请求的事件
    server.on(&apos;request&apos;, (req, res) =&gt; { --&gt; request, response
        let url = req.url; --&gt;请求地址，对应服务端的路由
    });
    3. req 本质是net.Socket + (http协议增加的内容)，req.socket获取客户端的socket对象
    4. 设置响应头：res.writeHead(状态码, 状态描述, 响应头);
    res.writeHead(200, &apos;ok&apos;, {
        &apos;Content-Type&apos;: &apos;text/html;charset=utf8&apos;
    });
    res.writeHead(301, http.STATUS_CODES[301], { ---&gt;重定向
        &apos;Content-Type&apos;: &apos;text/html;charset=utf8&apos;,
        &apos;Location&apos;: &apos;/&apos;  ----&gt; 告诉浏览器重定向的地址
    });
    5. res.setHeader(key, val); 也是设置响应头，会与 writeHead() 设置的响应头合并，
    且 writeHead() 设置的响应头优先；响应头的设置必须在响应数据之前；
    6. 设置响应数据：res.write(&apos;hello client&apos;);
    7. 数据传输完成，结束本次响应：res.end();  --&gt;如果传递参数，内部会调用 write();
    res.end(&apos;hello client&apos;);
3. Http服务的简写形式：
    http.createServer((req, res) =&gt; {
        ...
    }).listen(8000);
4. http客户端：http.request();
    1. 发起一个http请求
    let client = http.request({
        host: &apos;127.0.0.1&apos;,
        port: 8000,  ------&gt; IP和端口号是TCP所必须的，其他的参数是http所需要的
        protocol: &apos;http:&apos;,
        method: &apos;get&apos;,
        path: &apos;/abc&apos;  -------&gt; get请求的完整地址：http://127.0.0.1:8000/abc
    }, res =&gt; {  --&gt;处理服务器的响应数据
        res.on(&apos;data&apos;, data =&gt; {
            ...//处理接收的数据，数据量比较大时，socket会分包发送，data事件多次触发
        });
        res.on(&apos;end&apos;, () =&gt; {
            //数据传输完成
        });
    });
    2. 发送的数据：client.write(&apos;hello server&apos;); --&gt;比如post请求的参数
    3. 通知服务器发送完成：client.end();
</code></pre><h3 id="作为客户端"><a href="#作为客户端" class="headerlink" title="作为客户端"></a>作为客户端</h3><pre><code>1. 发送POST请求，接收响应的ZIP数据流
    let params = {}
    let options = {
        hostname: &apos;117.78.51.252&apos;, port: 8030, method: &quot;POST&quot;, --&gt; POST请求
        path: &apos;/Ae/Resources/Download&apos;, ---&gt;接口
        headers: { } --&gt; 如果需要，可以手动设置请求头
    }
    let streamlist = [];
    let req = http.request(options, res =&gt; {
        //res.setEncoding(&apos;utf8&apos;) --&gt; 当请求的是流数据时，一定不能设置响应数据的编码
        res.on(&apos;data&apos;, chunk =&gt; { --&gt; 接收数据
            streamlist.push(chunk); --&gt; 大数据流会分多次传输，所以先用数组保存
        });
        res.on(&apos;end&apos;, () =&gt; {
            let data = Buffer.concat(streamlist); --&gt;把一个buffer数组转为一个buffer
            fs.writeFile(&apos;./config.zip&apos;, data, err=&gt;{}) --&gt;把Buffer写入到文件中
        });
    });
    req.on(&apos;error&apos;, e =&gt; { console.error(`请求遇到问题: ${e.message}`); });
    // 把参数转化后，写入请求主体，两种转化方式，根据后台的获取方式进行选择
    let postData = require(&apos;querystring&apos;).stringify(params) --&gt;id=1&amp;name=Mack
    let postData = JSON.stringify(params) ---&gt; {&quot;id&quot;:1,&quot;name&quot;:&quot;Mack&quot;}
    req.write(postData);
    req.end(); ---&gt; 告诉服务器，结束请求
2. POST请求上传文件
    let boundaryKey = &quot;----&quot; + new Date().getTime();  --&gt;HTTP协议
    let options = {
        hostname: &apos;117.78.51.252&apos;, port: 8030, method: &quot;POST&quot;,
        path: &apos;/Ae/Project/Upload&apos;,
        headers: {  ---&gt; 设置数据的类型：multipart/form-data表示是上传文件
            &quot;Content-Type&quot;: &quot;multipart/form-data; boundary=&quot; + boundaryKey,
            &apos;Connection&apos;: &quot;keep-alive&quot;
        }
    };
    let req = http.request(options, function(res) {
        res.setEncoding(&quot;utf8&quot;);  --&gt;设置响应数据的编码格式
        res.on(&quot;data&quot;, chunk =&gt; { ---&gt; chunk其实是一个Buffer
            console.log(chunk.toString()) ---&gt;假设响应数据是简短的JSON字符串
        });
        res.on(&quot;end&quot;, () =&gt; { console.log(&quot;res end.&quot;); });
    });
    req.on(&apos;error&apos;, e =&gt; { console.log(&apos;req error: &apos;, e) });
    //开始上传：参数1表示提交的内容信息，参数2表示上传的文件列表，参数3表示请求对象
    this.postFile([], [{
        urlKey:&quot;file1&quot;,  --&gt; 文件名
        urlValue: &apos;./config.zip&apos; ---&gt; 文件的路径
    }], req);
    ----------------------------------------------------------------------
    postFile(fileInfo, fileData, req) {
        const path = require(&apos;path&apos;);  const fs = require(&apos;fs&apos;);
        let boundaryKey = Math.random().toString(16);
        let enddata = &apos;\r\n----&apos; + boundaryKey + &apos;--&apos;;
        let dataLength = 0;
        let dataArr = new Array();
        for (let i = 0; i &lt; fileInfo.length; i++) {
            let dataInfo = &quot;\r\n----&quot; + boundaryKey + &quot;\r\n&quot; + 
                &quot;Content-Disposition: form-data; name=\&quot;&quot; + 
                fileInfo[i].urlKey + &quot;\&quot;\r\n\r\n&quot; + fileInfo[i].urlValue;
            let dataBinary = new Buffer(dataInfo, &quot;utf-8&quot;);
            dataLength += dataBinary.length;
            dataArr.push({ dataInfo: dataInfo });
        }
        let files = new Array();
        for (let i = 0; i &lt; fileData.length; i++) {
            let content = &quot;\r\n----&quot; + boundaryKey + &quot;\r\n&quot; + 
                &quot;Content-Type: application/octet-stream\r\n&quot; + 
                &quot;Content-Disposition: form-data; name=\&quot;&quot; + 
                fileData[i].urlKey + &quot;\&quot;; filename=\&quot;&quot; + 
                path.basename(fileData[i].urlValue) + &quot;\&quot;\r\n&quot; + 
                &quot;Content-Transfer-Encoding: binary\r\n\r\n&quot;;
            //编码为ascii时，中文会乱码
            let contentBinary = new Buffer(content, &apos;utf-8&apos;);
            files.push({ contentBinary: contentBinary, 
                filePath: fileData[i].urlValue });
        }
        let contentLength = 0;
        for (let i = 0; i &lt; files.length; i++) {
            let filePath = files[i].filePath;
            if (fs.existsSync(filePath)) {
                let stat = fs.statSync(filePath);
                contentLength += stat.size;
            } else {
                contentLength += new Buffer(&quot;\r\n&quot;, &apos;utf-8&apos;).length;
            }
            contentLength += files[i].contentBinary.length;
        }
        req.setHeader(&apos;Content-Type&apos;, 
            &apos;multipart/form-data; boundary=--&apos; + boundaryKey);
        req.setHeader(&apos;Content-Length&apos;, 
            dataLength + contentLength + Buffer.byteLength(enddata));
        for (let i = 0; i &lt; dataArr.length; i++) { --&gt; 将参数发出
            req.write(dataArr[i].dataInfo)
        }
        let fileindex = 0;
        let doOneFile = function () {
            req.write(files[fileindex].contentBinary);
            let currentFilePath = files[fileindex].filePath;
            if (fs.existsSync(currentFilePath)) {
                let fileStream = fs.createReadStream(currentFilePath, 
                    { bufferSize: 4 * 1024 });
                fileStream.pipe(req, { end: false });
                fileStream.on(&apos;end&apos;, function () {
                    fileindex++;
                    if (fileindex == files.length) {
                        req.end(enddata);
                    } else {
                        doOneFile();
                    }
                });
            } else {
                req.write(&quot;\r\n&quot;);
                fileindex++;
                if (fileindex == files.length) {
                    req.end(enddata);
                } else {
                    doOneFile();
                }
            }
        };
        if(fileindex == files.length) {
            req.end(enddata);
        } else {
            doOneFile();
        }
    }
3. request模块是对http模块的GET、POST等请求的进一步封装。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/07/05/NodeJs-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/05/NodeJs-1/" itemprop="url">NodeJs-1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-05T00:00:00+08:00">
                2018-07-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h2><pre><code>1. NodeJs是单线程、非阻塞I/O的事件驱动；
    1. 不同于Java/PHP/.net等服务器语言，NodeJs不会为每个Client连接创建新线程；
    2. 当有新的Client请求连接时会触发内部事件，通过非阻塞I/O、事件驱动机制，让Node应用程序
    在宏观上是并行的；
    3. 使用Node.js，一个8G的服务器可以同时处理超过4w的Client连接。
2. 处理异步的两种常用方式：回调函数、事件的订阅/发布
3. 事件是整个Node的核心，Node中大部分模块都使用/继承events模块，类似WebAPI的EventTarget
</code></pre><h3 id="events模块"><a href="#events模块" class="headerlink" title="events模块"></a>events模块</h3><pre><code>1. const EventEmitter = require(&apos;events&apos;);
    class MyEmitter extends EventEmitter {}
    const emitter = new MyEmitter();
2. 通过EventEmitter实例来绑定和监听事件，以广播(订阅/发布)的形式处理异步；
    1. 订阅事件的方式
    emitter.on(&apos;toparent&apos;, (data) =&gt; { --&gt; 方式一：订阅事件&apos;toparent&apos;
        console.log(data) --&gt; 处理广播数据data
    })
    emitter.addListener(&apos;toparent&apos;, (data) =&gt; { --&gt; 方式二
        console.log(data);
    })
    2. 发布事件：emitter.emit(&apos;toparent&apos;, &apos;广播数据&apos;)
3. emitter.setMaxListeners(2); --&gt;设置最大的订阅个数
</code></pre><h2 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h2><pre><code>1. process对象是一个全局变量，提供了当前Node程序与系统的有关信息，还可以控制当前的Node进程
2. process.argv：获取运行node程序的命令，是一个数组
    node app.js -i  --&gt; [&apos;node命令的路径&apos;, &apos;app.js的路径&apos;, &apos;-i&apos;]
3. process.evn：环境变量相关，比如通过配置环境变量控制开发模式与生产模式的切换
    1. 在当前系统上新建一个环境变量：mode=&apos;dev&apos;
    2. 判断当前是否处于开发模式：process.env.mode == &apos;dev&apos;
4. process.exit()：结束当前进程
5. process.stdout/stdin：标准输入输出流
    1. 将数据输出到终端：process.stdout.write(&apos;hello&apos;); --&gt; console.log的底层原理
    2. 监听用户的输入：
    process.stdin.on(&apos;data&apos;, e=&gt;{ ---&gt; 可用于实现交互式的命令行，比如Vue.js的脚手架
        process.stdout.write(&apos;用户输入: &apos;, e.toString());
    })
    3. 在命令行输入内容后，还要点击 Enter键作为输入完成的信号，process.stdin才能监听到，
    所以接收到的数据其实是以回车符号结尾的；
    4. 去除Windows系统的回车符：e.toString().replace(&apos;\r\n&apos;, &apos;&apos;);
6. 移动光标的位置：process.stdout.cursorTo(x, y);
</code></pre><h2 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h2><pre><code>1. 流是一种在Node中处理流式数据的抽象接口，fs、net、http、https等模块都提供了流的实现；
2. stream约定了一些基本特性(但并没有实现)，所有实现流操作的对象都具备这些共同的特性；
2. 流的基本类型
    1. Writable：可写入数据的流，如fs.createWriteStream()
    2. Readable：可读取数据流，如fs.createReadStream()
    3. Duplex：可读又可写的流，又称为双工数据流
    4. Transform：可修改的双工数据流，在读写过程中可修改/转换
3. Writable：write()、end()、setDefaultEncoding()
4. Readable：setEncoding()、read()、pipe()、pause()、resume()
</code></pre><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><pre><code>1. Buffer：缓冲区，类似于数组，长度固定，专门用于操作二进制数据
2. v8是JS引擎，内存有限，32位操作系统约0.7G，64位约为1.4G，Node使用的也是v8引擎
3. 虽然v8有内存限制，但Buffer实际上是对底层内存的直接操作，它的大小不计入v8的内存开销；
4. let buf = new Buffer(10); --&gt; 10个字节的Buffer，但Buffer的所有构造函数已废弃
    1. 虽然Buffer存储的是二进制数据，但显示时都是以十六进制的形式(二进制太长了)；
    2. Buffer操作的是底层内存，大小一旦确定，就会分配一段连续的内存空间，不允许修改大小；
    buf[0]=88; --&gt; 十进制转为十六进制：58，也可以直接赋值十六进制
    buf[11]=255; --&gt; 角标越界不会报错，但不会有变化
    3. Buffer中每个元素的范围：00-ff，即十进制的0-255，二进制的一个字节；
    buf[2]=556; --&gt; 超过一个字节的最大数值255，会舍弃高位，只存储低8位：2c
    4. 控制台默认打印的数字都是十进制，buf[0].toString(16)表示以十六进制输出；
    5. buf.tostring()：将Buffer中的二进制数据转为字符串。
5. Buffer.alloc(size[, fill, encoding])：创建size个字节的Buffer对象
    1. fill和encoding都是可选参数，encoding默认为utf8
    2. 不指定fill时，新创建的Buffer默认用 0 填充。
6. Buffer.allocUnsafe(size)：不安全的Buffer，Buffer中可能含有敏感数据；
    1. Buffer.alloc()的默认值都是00，也即分配内存时会清空该内存中的原数据；
    2. Buffer.allocUnsafe()在分配内存时不会清空内存中原数据，所以默认值可能不是00；
7. Buffer.from(str|array|buffer)：将字符串/数组/buffer数据转化为一个新的Buffer
    1. var str=&quot;Hello&quot;; --&gt; str.length：字符串长度
    2. var buf = Buffer.from(str); --&gt; buf.length：占用内存的字节大小
    3. 英文字符串的每个字符占一个字节，所以str.length==buf.length
    4. 查看字符串的字节长度：Buffer.byteLength(&apos;你好&apos;);
8. Buffer.concat(array)：合并array中的Buffer，再转为一个新的Buffer
9. 比较两个Buffer的值是否完全相等：buf1.equals(buf2);
</code></pre><h2 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h2><pre><code>1. fs：文件系统，node的核心模块，var fs = require(&quot;fs&quot;);
    1. fs模块中的所有操作都可以选择同步/异步，同步会阻塞程序的执行，而异步则不会；
    2. 在fs中，带有Sync的都是同步方法，不带的都是异步方法，且异步方法带有回调函数。
2. open()/openSync()：打开文件，返回一个文件的描述符，通过该描述符进行文件操作；
    1. fs.openSync(path, flags, mode);  fs.open(path, flags, mode, callback);
    2. path：文件路径； flags：操作类型r/w； mode：设置文件的操作权限，一般不传；
    3. callback回调2个参数arguments：function(err, fd){ ... }
    4. err：错误对象，没有错误则为null； fd：文件描述符；
    5. Node的设计就是错误优先，所以回调函数的第一个参数是错误对象。
3. write()/writeSync()：向文件中写入内容；
    1. fs.writeSync(fd, string, position, encoding);
    2. fd：文件描述符； string：写入的内容，如果不是字符串，则被强制转为字符串；
    3. position：写入指针的位置，默认为0； encoding：写入的编码，默认为utf-8；
    1. fs.writeSync(fd, string, position, encoding, callback);
    2. callback回调3个参数：function(err, written, string){ ... }
    3. written：传入的字符串被写入的字节数； string：被写入的内容；
4. close(fd, callback)/closeSync(fd)：关闭文件操作；
    1. fd：文件描述符，表示要关闭的文件操作；
    2. callback只回调一个参数：function(err){ ... }
5. fs的写入过程：数据--&gt;Buffer--&gt;stream，为了提高效率，数据先写入缓冲区，再一次性写入文件
6. 异步的错误在回调函数中，而同步的错误只能用 try-catch 捕获
</code></pre><h3 id="简单读写"><a href="#简单读写" class="headerlink" title="简单读写"></a>简单读写</h3><pre><code>1. 简单文件写入：fs.writeFile()/fs.writeFileSync()
    1. writeFile(file, data, options, callback)
    2. file：操作的文件路径； data：待写入的数据； options：可选，设置写入动作；
    3. callback回调一个参数：function(err) {}，而且不用手动关闭操作流；
    4. options：对象，包括encoding(默认utf-8)，mode(默认0o66)，flag(默认w)
    fs.writeFile(file, data, { flag: &apos;a&apos; }, callback); --&gt; 表示向文件中追加写入
    5. data可以是字符串或Buffer，如果data是一个buffer，options中的encoding是无效的；
    6. 如果文件的路径使用绝对路径：
    fs.writeFile(&quot;C:/workplace/test.txt&quot;, ...);
    fs.writeFile(&quot;C:\\workplace\\test.txt&quot;, ...); ==&gt; 两者等效；
    7. 简单文件写入的原理：仍是使用write()/writeSync()
2. 流式文件写入：用于写入大文件，可以分多次写入文件
    1. 同步/异步/简单文件写入都不适合大文件的写入，性能较差，容易导致内存溢出；
    2. var ws = fs.createWriteStream(path, options); --&gt;创建一个写入流；
    3. ws.write(str); --&gt;写入数据
    4. ws.end(); --&gt;等待写入完成再关闭流，不能用ws.close()，会造成流中的数据丢失；
    5. ws.on(&quot;事件名&quot;, function)：绑定一个长期有效的事件；
    6. ws.once(&quot;事件名&quot;, function)：绑定一个一次性的事件，触发一次之后自动失效；
    ws.once(&quot;open&quot;, function(){ --&gt; 监听写入流的打开事件
        console.log(&quot;流打开了...&quot;)
    });
    ws.once(&quot;close&quot;, function(){ --&gt; 监听写入流的关闭事件
        console.log(&quot;流关闭了...&quot;)
    });
3. 简单文件读取：fs.readFile()/fs.readFileSync()
    1. fs.readFile(path, options, callback)
    2. callback：function(err, data)，data表示读取到的内容，是一个Buffer对象；
    3. data之所以是一个Buffer对象，是因为读取的可能是二进制文件，如图片、音频；
    4. data.toString()的方式只适用于字符串，对二进制数据会乱码。
    fs.readFile(&quot;an.jpg&quot;, function(err, data){
        if(!err) {
            fs.writeFile(&quot;pn.jpg&quot;, data, function(err){ ... });
        }
    });
4. 流式文件读取：用于读取大文件，可以分多次读取文件
    1. var rs = fs.createReadStream(path, options); --&gt;创建一个读取流；
    2. 读取一个可读流中的数据，必须为可读流绑定一个data事件，绑定后会自动开始读取；
    rs.on(&quot;data&quot;, function(data){ --&gt; 读取过程不是一次性事件
        //data也是一个Buffer对象
    });
    3. 管道：rs.pipe(ws); --&gt; 可读流rs自动将数据传递给写入流ws，不需要绑定事件
</code></pre><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><pre><code>1. fs.exists(path, callback)/existsSync(path)：文件/目录是否存在
    1. fs.exists()：已废弃，被fs.stat()/fs.access()替代；
2. fs.stat(path, callback)/statSync(path)：获取文件信息，类似文件/目录的属性信息
    1. callback：function(err, stats) --&gt; stats对象中保存了文件的状态信息
    2. stats.size：获取文件的大小；
    3. stats.isFile()/isDirectory()：是否是一个文件/文件夹。
3. fs.unlink(path, callback)/unlinkSync(path)：删除文件；
4. fs.readdir(path, options, callback)/readdirSync(path, options)
    1. 读取一个目录的结构，获取指定目录下的所有文件/文件夹；
    2. callback：function(err, files) --&gt; files是一个数组，文件/文件夹的名称
5. fs.truncate(path, len, callback)/truncateSync(path, len)
    1. 截断文件，将文件修改为指定的大小，len表示字节大小，将文件大小设置为len
6. fs.mkdir(path, mode, callback)/mkdirSync(path, mode)：创建目录，但不会递归创建
7. fs.rmdir(path, callback)/rmdirSync(path)：删除目录，但不能删除非空目录
8. fs.rename(old, new, callback)：重命名/剪切
9. fs.watchFile(filename, options, listener)：监视文件的修改
    1. 内部原理是一个定时机制，定时检查文件中的内容；
    2. options：{ persistent: true, interval: 5007 }，默认5s检查一次；
    fs.watchFile(&quot;test.txt&quot;, {interval:1000}, function(curr, prev) {
        //curr是修改后的状态，prev是修改前的状态，它们都是stats对象
    });
10. fs.watch()：可以监听目录的状态变化
</code></pre><h3 id="fs-Promise"><a href="#fs-Promise" class="headerlink" title="fs Promise"></a>fs Promise</h3><pre><code>1. 在node10.0之后，fs模块中引入了Promise，文件操作不再区分异步和同步，而是返回Promise对象
2. const fsPromises = require(&apos;fs&apos;).promises;
</code></pre><h2 id="UDP之dgram"><a href="#UDP之dgram" class="headerlink" title="UDP之dgram"></a>UDP之dgram</h2><pre><code>1. dgram模块：提供UDP数据包socket的实现，const dgram = require(&apos;dgram&apos;);
2. 服务端
    1. 创建socket对象
    const server = dgram.createSocket(); --&gt; 静态方法创建socket对象
    const server = new dgram.Socket(type[, callback]);
    2. type：udp4 =&gt;IPV4、udp6 =&gt;IPV6;  callback：接收到数据的回调;
    3. 绑定IP和端口号
    server.bind(3000, &apos;127.0.0.1&apos;);
    4. 监听事件：close(关闭)、error(发生错误)、listening(启动监听)、message(收到消息)
    server.on(&apos;listening&apos;, ()=&gt;{ console.log(&apos;启动成功...&apos;); });
    server.on(&apos;message&apos;, (data) =&gt; {
        //网络传输的数据是二进制的，在node上是一个buffer对象
    });
    5. 关闭socket：server.close(callback);
3. 客户端
    1. let client = dgram.createSocket(&apos;udp4&apos;);
    2. 发送数据：client.send(&apos;Hello Server&apos;, 3000, &apos;127.0.0.1&apos;);
</code></pre><h2 id="TCP之net"><a href="#TCP之net" class="headerlink" title="TCP之net"></a>TCP之net</h2><pre><code>1. net模块：提供了创建基于流的 TCP/IPC 服务器和客户端的异步网络API
2. const net = require(&apos;net&apos;);
3. 服务端
    let server = new net.Server(); / net.createServer();
    1. 启动监听：server.listen(3000, &apos;127.0.0.1&apos;); --&gt; IP默认为0.0.0.0
    2. server.listen(3000, &apos;0.0.0.0&apos;); --&gt; 监听当前设备上的所有IP收到的3000端口消息
    4. 一台电脑可能有多个网卡(对应多个IP)，但端口号是唯一的，0.0.0.0 类似于通配符 *
    2. 连接事件、发送数据
    server.on(&apos;connect&apos;, (socket) =&gt; { --&gt; 回调的socket表示当前客户端的socket对象
        console.log(&apos;有客户端连接...&apos;);
        socket.write(&apos;hello client&apos;); --&gt; 向客户端写(发送)数据
        socket.on(&apos;data&apos;, (data) =&gt; { --&gt; 监听客户端发来的数据
            ...
        });
    });
    3. 获取客户端的IP和端口号：socket.remoteAddress，socket.remotePort
4. 客户端
    1. 创建客户端：new net.Socket(); / net.createConnection();
    let client = net.createConnection(3000, &apos;127.0.0.1&apos;);
    2. 监听服务器发来的数据
    client.on(&apos;data&apos;, data =&gt; {
        ...
    });
    3. 向服务器端发送数据：client.write(&apos;hello server&apos;);
5. socket数据的分包
    1. 当一个数据包很大时，并不会一次性传输，而是分多次，也就是说，data事件会被触发多次；
    2. 服务端告诉客户端数据传输完成：socket.end();
    server.on(&apos;connect&apos;, (socket) =&gt; {
        let data = fs.readFileSync(&apos;./a.mp4&apos;); --&gt; 读取一个大文件
        socket.write(data); --&gt; 开始传输，socket内部会分包传输
        socket.end(); --&gt; 通知客户端传输完成
    })
    3. socket.end(); 一旦执行，本次连接也会终止，客户端断开连接；
    4. 客户端收到数据传输完成的事件：client.on(&apos;end&apos;, () =&gt; { ... });
    5. 客户端需要把每次收到的数据(buffer)，拼接成一个buffer对象，才是一个完整的数据包。
    let list = [];
    client.on(&apos;data&apos;, chunk =&gt; {
        list.push(chunk);
    });
    client.on(&apos;end&apos;, () =&gt; { --&gt; 数据传输完成，连接已断开
        let data = Buffer.concat(list); --&gt; 把多个buffer对象合并为一个buffer
        fs.writeFile(&apos;./b.mp4&apos;, data, err=&gt;{});
    });
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/07/02/EventLoop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/02/EventLoop/" itemprop="url">EventLoop</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-02T00:00:00+08:00">
                2018-07-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><pre><code>1. EventLoop：事件循环，node单线程、异步编程的核心
2. process.nextTick
3. setTimeout()/clearTimeout()
4. setInterval()/clearInterval()
5. setImmediate()/clearImmediate()
</code></pre><h3 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h3><pre><code>1. node代码都会进入执行栈，主线程不断地轮询执行栈中的任务；
</code></pre><p><img src="https://i.imgur.com/dGWpPY2.jpg" alt></p>
<pre><code>2. 解析器会区别对待执行栈中的同步任务和异步任务，并做不同处理；
3. 同步任务会直接进入主线程进行执行，而异步任务会被推入事件表中；
4. 异步任务执行完之后，其回调函数会进入事件队列中，主线程执行完同步任务、空闲下来之后，会去
   轮询事件队列，把其中的回调函数放入主线程进行执行。
</code></pre><h3 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h3><pre><code>1. 主线程空闲之后，开始查看异步任务队列，如果没有异步任务，则程序结束；
2. 如果有异步任务，主线程会进入事件循环，执行完所有的异步任务之后，程序结束。
</code></pre><p><img src="https://i.imgur.com/YY1tawg.jpg" alt></p>
<pre><code>1. 异步任务也分很多种，不同的异步任务执行的次序也是不同的；
2. 异步任务之Timer
    1. Timer阶段用于处理所有 setTimeout和setInterval 的回调函数；
    2. setTimeout的延迟时间不一定准确，如果主线程有耗时的同步任务，如alter()、for循环...
    会延迟异步回调的执行；
    3. 如果多个不同类型的异步任务同时执行完成，Timer的优先级是最高的，优先执行其回调函数。
3. 异步任务之IO
    1. Pending I/O 阶段：执行I/O回调，包括文件操作、网络操作...
    2. Idle，Prepare 阶段：内部使用
    3. Poll 阶段：轮询I/O操作，如等待AJAX是否完成，如果没有则阻塞，但会有超时和基本检测，
    不会一直阻塞；
    4. 如果Poll阶段轮询到了I/O回调，则重新进入Pending I/O阶段，执行I/O回调；
    5. 如果Poll阶段阻塞超时或者没有I/O操作，则进入Check阶段。
4. 异步任务之Check
    1. 只处理 setImmediate 的回调函数；
    2. setImmediate 是IE10的新增特性，标准的浏览器是不支持的，但NodeJs支持。
5. 异步任务之Close Callback
    1. 专门处理一些 close 类型的回调，如关闭网络连接、关闭数据库连接...
    2. Close Callback 是最后一个阶段，然后主线程会去检查是否还有异步任务，如果有，则继续
    重新轮询，否则程序结束。
</code></pre><h2 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h2><pre><code>1. 不管同步任务还是异步任务，进入主线程执行的任务又可分为宏任务和微任务，优先执行宏任务
</code></pre><p><img src="https://i.imgur.com/5Z10bBQ.jpg" alt></p>
<pre><code>1. 宏任务：主体script脚本，setTimeout，setInterval
2. 微任务：Promise，process.nextTick
3. Promise并不是属于异步任务，不会被推入事件轮询表中
    console.log(&apos;start&apos;); ---&gt; 宏任务
    setTimeout(() =&gt; { ------&gt; 异步任务EventLoop
        console.log(&apos;set timeout&apos;); ---&gt; 宏任务
    }, 0);
    new Promise(resolve =&gt; {
        console.log(111); ---&gt; 属于宏任务
        resolve();
    }).then(() =&gt; {
        console.log(222); ---&gt; 属于微任务
    }).then(() =&gt; {
        console.log(333); ---&gt; 属于微任务
    });
    console.log(&apos;end&apos;); ---&gt; 宏任务
4. 执行过程：同步代码 =&gt;宏任务 --&gt; 微任务 ==&gt; Event Loop(异步任务) =&gt;宏任务 --&gt; 微任务
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">大麦田怪圈</p>
              <p class="site-description motion-element" itemprop="description">敢做就能赢！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">62</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">36</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大麦田怪圈</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
