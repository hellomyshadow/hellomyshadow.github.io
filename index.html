<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="敢做就能赢！">
<meta property="og:type" content="website">
<meta property="og:title" content="大麦田程序猿">
<meta property="og:url" content="http://hellomyshadow.github.io/index.html">
<meta property="og:site_name" content="大麦田程序猿">
<meta property="og:description" content="敢做就能赢！">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="大麦田程序猿">
<meta name="twitter:description" content="敢做就能赢！">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hellomyshadow.github.io/">





  <title>大麦田程序猿</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大麦田程序猿</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/08/17/Koa-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/17/Koa-2/" itemprop="url">Koa-2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-17T00:00:00+08:00">
                2018-08-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Koa脚手架"><a href="#Koa脚手架" class="headerlink" title="Koa脚手架"></a>Koa脚手架</h2><pre><code>1. 全局安装脚手架：npm install koa-generator -g
2. 创建项目：koa demo01  --&gt; cd demo01  --&gt; npm install
3. 运行项目：npm start
4. 脚手架创建的项目已经实现了路由的模块化，即项目的模块化。
</code></pre><h2 id="路由模块化"><a href="#路由模块化" class="headerlink" title="路由模块化"></a>路由模块化</h2><pre><code>1. 与Express的路由模块化类似，把不同功能的路由拆分到不同的js文件中，然后再暴露路由对象；
2. 假设项目包含首页(index)、后台管理(admin)，配置模板引擎art-template的目录为views
    1. 在根目录下创建routes目录，用于存放路由模块，项目入口为app.js
    2. 创建routes/index.js，routes/admin.js
3. 在index.js中配置index模块的路由，index是根路由的模块
    let router = require(&apos;koa-router&apos;)();
    router.use(async(ctx, next)=&gt;{ ----&gt; index模块的应用级中间件，在index路由之前匹配
        ......
        await next(); ----&gt; 继续向下匹配index路由
        ......
    })
    router.get(&apos;/&apos;, async(ctx)=&gt;{
        await ctx.render(&apos;index&apos;); --&gt;渲染模板：views/index.html
    })
    router.get(&apos;case&apos;, async(ctx)=&gt;{  ------&gt; 对于根路由的模块，其子路由不能再加&apos;/&apos;
        await ctx.render(&apos;index/case&apos;); --&gt;渲染模板：views/index/case.html
    })
    module.exports = router; ---&gt; 暴露index模块的路由对象
    1. 注意：与Express不同，Koa的根目录匹配已经默认加了&apos;/&apos;，其子路由的开头不能再加&apos;/&apos;
4. 在admin.js中配置admin模块的路由
    let router = require(&apos;koa-router&apos;)();
    router.use(async(ctx, next)=&gt;{ ----&gt; admin模块的应用级中间件，在admin路由之前匹配
        ......
        await next(); ----&gt; 继续向下匹配admin路由
        ......
    })
    router.get(&apos;/&apos;, async(ctx)=&gt;{
        await ctx.render(&apos;admin&apos;);
    })
    router.get(&apos;/user&apos;, async(ctx)=&gt;{
        await ctx.render(admin/user&apos;);
    })
    module.exports = router;
5. 在app.js中启用index模块和admin模块的路由
    let router = require(&apos;koa-router&apos;)();
    let index = require(&apos;./routes/index&apos;);
    let admin = require(&apos;./routes/admin&apos;);
    router.use(&apos;/&apos;, index.routes());  -----&gt; 启用根路由的index模块
    router.use(&apos;/admin&apos;, admin.routes()); ---&gt; admin模块的路由
    app.use(router.routes()).use(router.allowedMethods);
6. 子路由：在admin路由中继续启用子路由
    1. 创建routes/admin/user.js，配置路由
    let router = require(&apos;koa-router&apos;)();
    router.get(&apos;/&apos;, async(ctx)=&gt;{
        await ctx.render(&apos;admin/user&apos;); --&gt;渲染模板：views/admin/user.html
    })
    router.get(&apos;/add&apos;, async(ctx)=&gt;{
        await ctx.render(&apos;admin/user/add&apos;); -&gt;渲染模板：views/admin/user/add.html
    })
    module.exports = router;
    2. 在admin.js中引入user.js，并启用user路由
    let user = require(&apos;./admin/user&apos;);
    router.use(&apos;/user&apos;, user.routes());
7. router路由的写法不止一种，比如把路由写在对应的路由文件中
    1. app.js：router.use(admin.routes());
    2. admin.js：let Router = require(&apos;koa-router&apos;);
    let router = new Router({ prefix: &apos;/admin&apos; })
</code></pre><h2 id="更多补充"><a href="#更多补充" class="headerlink" title="更多补充"></a>更多补充</h2><pre><code>1. nodeJs生成验证码：svgCaptcha，支持express和koa
2. 页面自动刷新/跳转
    1. 页面3s后自动刷新：&lt;meta http-equiv=&quot;refresh&quot; content=&quot;3&quot; /&gt;
    2. 3s后页面自动转到指定网址
    &lt;meta http-equiv=&quot;refresh&quot; content=&quot;3; url=http://www.baidu.com/&quot; /&gt;
    3. 登录失败之后，加载错误页面error.html，5s后自动转回登录页
    router.use(async(ctx, next)=&gt;{
        ctx.state.HOST = &apos;http://&apos;+ctx.request.header.host;  --&gt;设置域名的全局变量
        await next();
    })
    router.post(&apos;doLogin&apos;, async(ctx)=&gt;{
        if(登录失败){
            await ctx.render(&apos;login/error&apos;, { url: ctx.state.HOST+&apos;/login&apos; })
        }
    })
    error.html：&lt;meta http-equiv=&quot;refresh&quot; content=&quot;5; url={{url}}&quot; /&gt;
3. art-template自定义日期管道/过滤器
    1. 格式化日期的插件：npm install silly-datetime --save
    2. let sd = require(&apos;silly-datetime&apos;);
    render(app, {
        root: path.join(__dirname, &apos;views&apos;),
        extname: &apos;.html&apos;,
        debug: process.env.NODE_ENV !== &apos;production&apos;,
        dateFormat: dateFormat=function(value){ -----&gt; 扩展模板里的方法
            return sd.format(new Date(value), &apos;YYYY-MM-DD HH:mm&apos;);
        }
    })
    3. 在art模板中使用过滤器，格式化传递的变量time：&lt;div&gt;{{time | dateFormat}}&lt;/div&gt;
4. koa-jsonp：ajax请求返回JSON的中间件，npm install koa-jsonp --save
    1. let jsonp = require(&apos;koa-jsonp&apos;);  ---&gt; 同时支持处理JSON和jsonp
    2. 配置jsonp中间件：app.use(jsonp());
    3. 一个简单的JSON数据接口：
    router.get(&apos;/getMsg&apos;, async (ctx) =&gt; {
        ctx.body = { message: &quot;请求的数据信息&quot;, success: true }
    })
    4. 使用浏览器测试接口：
    http://localhost:3000/getMsg  ---&gt; 如果返回JSON格式的数据，则表示此接口支持JSON
    http://localhost:3000/getMsg?callback=xxx  ---&gt; 测试接口是否支持jsonp
5. ctx.request.headers[&apos;referer&apos;]：获取上一页的地址
    1. 用全局变量记录上一页的地址
    ctx.state.prevPage = ctx.request.headers[&apos;referer&apos;];
    2. 返回上一页：ctx.redirect(ctx.state.prevPage);
</code></pre><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><pre><code>&lt;form action=&quot;{{HOST}}/doUpload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
    &lt;input type=&quot;file&quot; id=&quot;pic&quot; name=&quot;pic&quot; /&gt;
&lt;/form&gt;
1. koa-multer：用于处理 multipart/form-data 类型的表单数据，主要用于上传文件；
2. koa-multer基于 multer 模块：npm i koa-multer --save
    let multer = require(&apos;koa-multer&apos;);
    let storage = multer.diskStorage({
        destination: function(req, file, cb) {
            cb(null, &apos;upload/pic&apos;); ---&gt; 配置上传文件的目录：当前目录下的upload/pic
        },
        filename: function(req, file, cb) {
            let extname = (file.originalname).split(&apos;.&apos;);  --&gt;从文件名中切割出后缀名
            cb(null, Date.now()+&apos;.&apos;+extname[extname.length-1]); --&gt;对文件重命名
        }
    });
    let upload = multer({storage: storage});
3. 处理上传文件
    router.post(&apos;/doUpload&apos;, upload.single(&apos;pic&apos;), async (ctx)=&gt;{
        let filename = ctx.req.file.filename;  ---&gt; 上传的文件名
        let form = ctx.req.body; ---&gt; form表单的其他数据
    })
4. upload.single(&apos;pic&apos;)：pic与&lt;input type=&quot;file&quot; name=&quot;pic&quot; /&gt;的name保持一致；
5. koa-multer也支持多个文件上传，在github上的multer模块中有更多配置信息；
6. koa-body：用于取代 koa-bodyparser 和 koa-multer
</code></pre><h3 id="路由鉴权"><a href="#路由鉴权" class="headerlink" title="路由鉴权"></a>路由鉴权</h3><pre><code>1. koa-jwt：用于路由鉴权、token验证
</code></pre><h3 id="富文本编辑器"><a href="#富文本编辑器" class="headerlink" title="富文本编辑器"></a>富文本编辑器</h3><pre><code>1. ueditor：百度的轻量级、可定制富文本web编辑器，开源基于MIT协议，允许自由使用和修改代码
2. ueditor官方虽然没有提供NodeJs版本，但官方推荐的第三方插件里有nodeJs版本；
    1. 第三方插件直接支持express，不支持koa2
    2. 支持koa2的ueditor插件：npm i koa2-ueditor --save
3. ueditor的基本配置
    1. 在github下载koa2-ueditor的demo，拷贝public/ueditor，粘贴到自己项目的public目录
    2. 在模板中的&lt;head&gt;标签中引入ueditor目录下的静态文件
    &lt;script type=&quot;text/javascript&quot; src=&quot;/ueditor/ueditor.config.js&quot;&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;/ueditor/ueditor.all.min.js&quot;&gt;
    &lt;script type=&quot;text/javascript&quot; src=&quot;/ueditor/lang/zh-cn/zh-ch.js&quot;&gt;
    3. 使用ueditor，取代&lt;textarea&gt;的位置
    &lt;script id=&quot;editor1&quot; type=&quot;text/plain&quot; style=&quot;width:800px;height:300px;&quot;&gt;
    4. 在&lt;body&gt;标签之后实例化富文本编辑器：
    &lt;script type=&quot;text/javascript&quot;&gt;
        let ue = UE.getEditor(&apos;editor1&apos;);
    &lt;/script&gt;
    5. 富文本编辑器中的内容最终生成的是带有style样式的html标签，是一个html字符串。
    &lt;form ...&gt;
        &lt;script type=&quot;text/plain&quot; id=&quot;editor1&quot; name=&quot;content&quot; style=&quot;...&quot;&gt;
    &lt;/form&gt;
    router.post(&apos;/doUpload&apos;, upload.single(&apos;pic&apos;), async (ctx)=&gt;{
        let content = ctx.req.body.content; ---&gt; form表单的富文本编辑框中的数据
    })
4. 配置ueditor的图片上传
    const ueditor = require(&apos;koa2-ueditor&apos;);
    router.all(&apos;/editor/controller&apos;, ueditor([&apos;public&apos;, {
        imageAllowFiles: [&apos;.png&apos;, &apos;.jpg&apos;, &apos;.jpeg&apos;],
        imagePathFormat: &apos;/upload/ueditor/image/{yyyy}{mm}{dd}/{filename}&apos;
    }]));
    1. &apos;/editor/controller&apos;：统一上传的地址，对应ueditor/ueditor.config.js中的配置
    serverUrl: &quot;/editor/controller&quot;  ---&gt; 根据router.all()的实际路由进行修改
    http://localhost:3000/editor/controller  --&gt; 完整的上传地址URI
    2. &apos;public&apos;：上传图片的保存目录，根目录/public/upload/ueditor/image/当前日期/图片名
5. 自定义ueditor编辑框：修改配置文件ueditor/ueditor.config.js
    1. 配置自动增长高度：autoHeightEnabled: false  --&gt; 编辑框的内容过长时自动出现滚动条
    2. 自定义工具栏：修改toolbars节点
6. 为编辑框设置默认内容
    &lt;script type=&quot;text/javascript&quot;&gt;
        let ue = UE.getEditor(&apos;editor1&apos;);
        ue.addListener(&apos;ready&apos;, ()=&gt;{  ----&gt; 监听ueditor准备完成
            ue.setContent(`{{@list.content}}`);  --&gt; art-template模板接收参数的方式
        })  ---&gt; list.content是上一次富文本编辑框中的内容，保存在数据库中
    &lt;/script&gt;
</code></pre><h2 id="SEO优化"><a href="#SEO优化" class="headerlink" title="SEO优化"></a>SEO优化</h2><pre><code>1. SEO优化：也称为搜索引擎优化，目的是让搜索引擎优先搜索到自家网站，并展示给用户；
2. 设置网站的必要信息：标题、关键字、描述
    1. 网站标题：&lt;title&gt;标题内容&lt;/title&gt;，网站标题变化不能过于频繁，否则百度会认为是作弊；
    2. 网站关键字：&lt;meta name=&quot;Keywords&quot; content=&quot;关键字内容&quot; /&gt;
    3. 网站描述：&lt;meta name=&quot;Description&quot; content=&quot;描述内容&quot; /&gt;
3. 图片&lt;img&gt;必须使用 alt 属性
4. html标签的合理使用，语义化，符合W3C标准
    1. 尤其是 h 系列标签的合理使用，其中，&lt;h1&gt;标签的权重最高，一个页面建议只出现一次；
    2. &lt;h1&gt;标签的内容建议和&lt;title&gt;的内容相同。
5. 内链、外链的合理使用，如友情链接就属于外链，因为搜索引擎会根据内链和外链继续搜索网站；
6. 网站的内容尽量都是原创的；
7. 合理使用长尾关键词：比如，相对与&quot;koa2教程&quot;，&quot;koa2视频教程&quot;就属于长尾关键词.
</code></pre><h2 id="API接口"><a href="#API接口" class="headerlink" title="API接口"></a>API接口</h2><pre><code>1. NodeJs的异步环境特性，让它最适合写API接口，非常善于处理大数据、高并发；
2. 比如一个返回JSON数据的简单接口
    let jsonp = require(&apos;koa-jsonp&apos;);
    app.use(jsonp());
    router.get(&apos;/getList&apos;, async (ctx)=&gt;{
        let result = await (从数据库中获取数据);
        ctx.body = { data: result }
    })
</code></pre><h3 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h3><pre><code>1. 在AJAX请求后台接口数据时，浏览器的同源策略会引起跨域安全问题；
    1. 接口的协议、域名、端口号必须与当前Web应用所处的协议、域名、端口号保持一致；
    2. 比如，访问当前网页的地址为 http://localhost:3000/index，那么，网页中的AJAX请求的
    接口地址必须是http://localhost:3000/xxxx
    3. 协议、域名、端口号三者有任何一个出现不一致，就会导致跨域问题。
2. JSONP的原理：利用&lt;script&gt;可以跨域的特性
    1. 在本地写一个回调函数，在远程执行这个函数，并把远程数据传到本地
    http://localhost:3000/api/getList?callback=xxx ---&gt; xxx被当作远程执行的函数
    2. JSONP跨域请求的前提：服务器必须支持JSONP；第三方koa-jsonp模块同时支持JSONP请求。
3. 除了JSONP实现跨域请求，还可以让后台设置允许跨域：npm i koa2-cors --save
    1. NodeJs后台设置允许跨域请求
    let cors = require(&apos;koa2-cors&apos;);
    app.use(cors());
    2. AJAX可以直接跨域请求接口，但由此导致的安全性问题，则通过token验证解决。
</code></pre><h3 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h3><pre><code>1. 当前Web应用的趋势就是前后端分离，为了让前端设备与后端更好地通信，出现了很多API结构；
2. RESTful API是目前比较成熟的一套互联网应用程序的API设计理念；
3. 一个优秀的RESTful API所考虑的方面：
    1. 协议：建议使用更安全的https协议
    2. 域名：尽量部署在专属域名下面，如https://a.bcd.com，https://api.bcd.com
    3. 考虑到接口的升级，应该将API的版本号放在URI中
    https://a.bcd.com/api1/list，https://a.bcd.com/api2/list
    https://a1.bcd.com，https://a2.bcd.com
    4. 路径：在RESTful架构中，每个URI代表一种资源，所以URI中使用与数据库表名相对应的名词
    5. 使用合理的HTTP请求方法
4. HTTP的7种请求方法：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS，常用的只有前4种
    1. GET：select，从服务器取出一项或多项资源
    2. POST：create，在服务器新建一个资源
    3. PUT：update，在服务器更新/修改资源
    router.put(&apos;/edit&apos;, async (ctx)=&gt;{  ---&gt; koa2可以直接识别不同的请求方法
        //修改数据、并返回修改后的完整数据
    })
    4. DELETE：从服务器删除资源
    router.delete(&apos;/del&apos;, async (ctx)=&gt;{ ---&gt; 响应 delete 方式的请求
        //删除数据
    })
5. 以vueJs的axios为例，axios提供了7种不同的HTTP请求方法。
</code></pre><h2 id="发布线上"><a href="#发布线上" class="headerlink" title="发布线上"></a>发布线上</h2><pre><code>1. 购买域名和服务器：万网(阿里收购)、西部数码...
2. 域名备案：新购买的域名不能直接被解析到服务器，需要在管理局登记域名信息(20个工作日左右)
    1. 每个出售域名的网站上，会有域名备案的流程说明和入口；
    2. 当然，还可以出钱到就近的外包公司备案。
3. 域名解析：让域名和服务器IP地址相关联，在购买域名的网站上配置即可；
    1. DNS服务器：负责域名解析的服务器，返回真实的服务器IP地址；
    2. ping 域名：查看当前域名所指向的真实服务器IP，如果ping失败，可能此域名设置了拒绝。
    ping www.baidu.com
4. nginx：负责转发与负载均衡，从而可以在一台服务器上运行N个nodeJs应用程序。
</code></pre><h3 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h3><pre><code>1. 在当前服务器上有2个nodeJs应用程序，端口号分别为8001、8002
2. 下载nginx应用包，解压，改名为nginx
3. 配置nginx/conf/nginx.conf
    1. 配置http节点：转发规则
    http {
        upstream backaa {
            server 127.0.0.1:8001; ---&gt; 服务器上的nodeJs应用程序的端口号
        }
        upstream backbb {
            server 127.0.0.1:8002;
        }
    }
    2. 配置http节点下的server节点：反向代理/负载均衡
    server {
        listen       80;
        server_name  aa.v123.com;  ---&gt; 域名

        #location / {
        #    root   html;
        #    index  index.html index.htm;
        #}

        location / {
            # 设置主机头和客户端的真实地址，以便服务器获取客户端的真实IP
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            #禁用缓存
            proxy_buffering off;
            #反向代理的地址
            proxy_pass http://backaa;  ---&gt; 与upstream相对应
        }
        ......
    }
    server {
        listen       8080;
        server_name  bb.v123.com;  ---&gt; 域名

        #location / {
        #    root   html;
        #    index  index.html index.htm;
        #}

        location / {
            # 设置主机头和客户端的真实地址，以便服务器获取客户端的真实IP
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            #禁用缓存
            proxy_buffering off;
            #反向代理的地址
            proxy_pass http://backbb;  ---&gt; 与upstream相对应
        }
        ......
    }
5. 启动nginx(windows系统)：双击运行nginx/nginx.exe
6. 启动nodeJs应用程序
7. 访问：http://aa.v123.com，http://bb.v123.com
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/08/15/Koa-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/15/Koa-1/" itemprop="url">Koa-1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-15T00:00:00+08:00">
                2018-08-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Koa2-x"><a href="#Koa2-x" class="headerlink" title="Koa2.x"></a>Koa2.x</h2><pre><code>1. Koa是基于Node.js的下一代web开发框架，也是由Express团队开发的；
    1. Node.js是一个异步的世界，官方API支持的都是callback形式的异步编程模型；
    2. Koa的开发思路与Express差不多，最大的特点就是，可以避免异步嵌套(回调地狱)；
    3. Koa不在内核方法中绑定任何中间件，仅仅提供一个轻量优雅的函数库，所以体积更小，更健壮
    4. 阿里是业界最早一批使用Node.js做线上大流量应用的公司，并基于koa开发了egg.js
2. 环境搭建：koa2.0开始才算是稳定版，npm install koa --save
    1. koa2.x要求Node.js的版本大于v7.6，因为node7.6开始完全支持async/await
    2. 简单使用：const Koa = require(&apos;koa&apos;);  const app = new Koa();
    app.use( async (ctx)=&gt;{ -----&gt; 配置中间件
        ctx.body = &apos;hello koa2&apos;;
    })
    app.listen(3000, &apos;Ip&apos;) ---&gt; 默认Ip为127.0.0.1
3. koa的工作内容
    1. 接收请求(request) --&gt; 处理数据，生成数据(middleware) --&gt; 发送数据(response)
    2. koa已经处理request和response，开发者只需要专心处理数据即可；
    3. 通过 use() 注册中间件，处理数据、生成数据。
4. 热重载工具：npm i supervisor -g，启动：supervisor app.js
</code></pre><h2 id="四大对象"><a href="#四大对象" class="headerlink" title="四大对象"></a>四大对象</h2><pre><code>1. koa的四大对象：Application -&gt; Context -&gt; Request、Response
2. Application：当前应用程序对象，由 new Koa() 创建的实例对象，Context是其子类；
    let app = new Koa();
    1. app.listen()：启用监听；
    2. app.use(callback)：启用中间件的方法，callback(ctx, next)
    3. ctx 就是 Context对象，next 是迭代器，实现手动控制执行过程；
    4. 异步中间件：use(async(ctx, next) =&gt; { ... });
    5. 监听错误：app.on(&apos;error&apos;, (err, ctx) =&gt; { ...//统计错误处理 });
    app.use((ctx, next) =&gt; {
        throw new Error(); ---&gt; 把错误抛给error事件去处理
    })
3. Context：每次请求都会包装成一个Context对象，它进一步封装了node的request和response
    1. koa把Context传入到中间件函数的第一个参数ctx中；
    2. ctx.req、ctx.res：分别是Node的request对象和response对象(太原始，并不推荐使用)
    3. ctx.request、ctx.response：分别是Koa的request对象和response对象，包含更多信息
    4. ctx.state：用户数据存储空间，ctx.username会污染Context对象，所以用ctx.state
    app.use((ctx, next) =&gt; {
        ctx.state.username = &apos;abc&apos;;
        next();
    }); 
    app.use((ctx, next) =&gt; { --&gt; 同一个请求的Context对象也都是同一个
        console.log(ctx.state.username);
    });
    5. ctx.app：当前应用程序的Application对象
    6. ctx.throw()：抛出错误时不建议使用 throw new Error(); 它属于JS，而throw()带有
    http的错误信息，如抛出404错误：ctx.throw(404, &apos;错误信息&apos;, {附带参数});
4. Request、Response
    1. ctx.request、ctx.response分别获取本次请求的Request对象和Response对象；
    2. Request和Response可以获取/设置本次请求和响应的各种信息；
    3. Request和Response的很多方法会被映射到 Context 上，通过 ctx 直接调用；
    4. 重定向：ctx.redirect(&apos;/login&apos;); --&gt;ctx.response.redirect(&apos;/login&apos;);
    5. 设置下载文件头：ctx.attachment(filename); --&gt;ctx.response.attachment();
    6. ctx.query 同 ctx.request.query，ctx.url 同 ctx.request.url ...
</code></pre><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><pre><code>1. 安装路由模块：cnpm install koa-router --save
2. 使用方式：let Router = require(&apos;koa-router&apos;);
    let router = new Router();  ---&gt; 等效于：let router = Router();
    router.get(&apos;/&apos;, async(ctx, next) =&gt; {
        ctx.body = &apos;Index&apos;; ---------&gt; 相当于 res.writeHead();  res.end();
    })
    router.get(&apos;/news&apos;, async(ctx, next) =&gt; {
        ctx.body = &apos;News&apos;;
    }) -----------------------&gt; 可以使用链式调用：router.get().get().get();
    app.use(router.routes());
    app.use(router.allowedMethods());  ----&gt;可以用链式调用，app.use().use();
    1. app.use(router.routes())：启用路由；
    2. app.use(router.allowedMethods())：不是必须，但官方推荐，写在所有路由后面；
    3. allowedMethods() 的作用是会根据 ctx.status 设置response的响应头。
3. router.redict()：路由重定向
    1. router.redict(&apos;/admin&apos;, &apos;/user&apos;, 301);
    2. 访问 /admin 时，会被重定向到 /user
4. URL生成器：Router.url();
    1. Router.url(&apos;/list&apos;, {page: 1}, {query: {order:&apos;desc&apos;}});
    2. 生成路由：/list/1?order=desc
</code></pre><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><pre><code>1. get传值
    router.get(&apos;/news&apos;, async(ctx, next) =&gt; {
        ctx.body = &apos;News&apos;;
    }) --&gt; http://localhost:3000/news?aid=123&amp;uname=Jack
    1. 接收get传值的方式有两种：query(格式化的参数对象)和querystring(请求字符串)
    2. ctx.query：获取的是参数对象，{ aid:&apos;123&apos;, uname:&apos;Jack&apos; }
    3. ctx.querystring：请求字符串的形式，aid=123&amp;uname=Jack
    4. ctx.url：请求的路由地址，/news?aid=123&amp;uname=Jack
2. 动态路由
    router.get(&apos;/news/:aid&apos;, async(ctx, next) =&gt; {
        ctx.body = &apos;News&apos;;
    }) --&gt; http://localhost:3000/news/123
    1. ctx.params：获取动态路由的参数对象，{ aid: &apos;123&apos; }
    2. /news/:aid/:uname：多个占位符，http://localhost:3000/news/123/Mack
</code></pre><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><pre><code>1. 在express中，中间件必须写在所有路由之前，而在koa中不管写在哪个位置，都会优先匹配；
2. 应用级中间件
    app.use(async (ctx)=&gt;{
        ctx.body = &apos;应用级中间件&apos;
    })
    1. 用于匹配所有路由，一旦匹配成功，将不再自动向下匹配；
    2. 手动让路由继续向下匹配
    app.use(async (ctx, next)=&gt;{
        ...
        await next();  ---&gt; 继续向下匹配
    })
3. 路由中间件
    router.get(&apos;/news&apos;, async(ctx, next) =&gt; {
        console.log(&apos;首次匹配news&apos;)
        await next(); ---&gt; 继续向下匹配
    })
    router.get(&apos;/news&apos;, async(ctx, next) =&gt; {
        ctx.body = &apos;News&apos;;
    })
4. 错误处理中间件
    app.use(async (ctx, next)=&gt;{
        console.log(&apos;1&apos;, &apos;中间件&apos;)
        await next(); -----------------&gt;去匹配路由，不会再继续向下执行，等待匹配结果
        console.log(&apos;2&apos;, ctx.url)
        if(ctx.status == 404) { ---&gt; 路由不存在，匹配失败，进行错误处理
            console.log(&apos;3&apos;, &apos;404&apos;)
            ctx.body = &apos;404页面&apos;
        } else { ---------------------&gt; 匹配成功
            console.log(&apos;4&apos;, ctx.url)
        }
    })
    router.get(&apos;/news&apos;, async(ctx, next) =&gt; {
        console.log(&apos;5&apos;, &apos;news&apos;)
        ctx.body = &apos;News&apos;
    })
    1. 访问http://localhost:3000/xxx --&gt; 1 --&gt; 不存在此路由，匹配失败 --&gt; 2 --&gt; 3
    2. 访问http://localhost:3000/news --&gt; 1 --&gt; 5 --&gt; 2 --&gt; 4
5. koa的洋葱模型
    1. koa的匹配过程(request--&gt;response)类似于一个洋葱
</code></pre><p><img src="https://i.imgur.com/XY2Jw5b.png" alt></p>
<pre><code>2. 由外而内，再由内而外：
中间件-1 --&gt; 中间件2 --&gt; 匹配路由，返回匹配结果 --&gt; 中间件2 --&gt; 中间件1
app.use(async(ctx, next)=&gt;{ ----------&gt; 中间件-1
    console.log(&apos;1-1&apos;)
    await next();
    console.log(&apos;1-2&apos;)
})
app.use(async(ctx, next)=&gt;{ ----------&gt; 中间件-2
    console.log(&apos;2-1&apos;)
    await next();
    console.log(&apos;2-2&apos;)
})
router.get(&apos;/news&apos;, async(ctx, next) =&gt; {
    console.log(&apos;news&apos;)
    ctx.body = &apos;News&apos;
})
3. 匹配过程：1-1 ==&gt; 2-1 ==&gt; news ==&gt; 2-2 ==&gt; 1-2
</code></pre><h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><pre><code>1. 原生NodeJs获取POST提交的数据：&lt;input type=&quot;text&quot; name=&quot;uname&quot; /&gt;
    function parserPost(ctx) {
        return new Promise((resolve, reject) =&gt; {
            try{
                let postData = &quot;&quot;;
                ctx.req.on(&apos;data&apos;, (chunk)=&gt;{
                    postData += chunk.toString();
                });
                ctx.req.on(&apos;end&apos;, ()=&gt;{ ---&gt; 数据传输完成
                    resolve(postData);
                });
            } catch(error) {
                reject(error);
            }
        });
    }
    router.post(&apos;/dologin&apos;, async(ctx) =&gt; {
        let data = await parserPost(ctx);
        ctx.body = &apos;登录成功！&apos;
    })
2. 中间件处理POST提交的数据：npm i koa-bodyparser --save
    1. 配置中间件：let parser = require(&apos;koa-bodyparser&apos;);
    app.use(parser());
    2. 获取post提交的数据
    router.post(&apos;/dologin&apos;, async (ctx)=&gt;{
        let postData = ctx.request.body;
    });
3. 在url中，? 后的内容称为querystring
    1. querystring是url的一部分，与提交方式(无论是post还是get)没有任何关系；
    2. url的长度有限，所以在数据量较大时，不推荐使用querystring的方式传输，跟get没关系；
    3. post请求也可以在url上使用querystring，在后台也可以获取此参数；
    4. 不同的是，get方式不能操作正文，而post可以把参数写入正文(请求体)
</code></pre><h2 id="静态服务"><a href="#静态服务" class="headerlink" title="静态服务"></a>静态服务</h2><pre><code>1. 静态资源中间件：npm install koa-static --save
2. 配置中间件：const static = require(&apos;koa-static&apos;);
    1. app.use(static(&apos;static&apos;)); ----&gt; 托管 根目录/static 下的资源文件
    2. 在模板中访问static/css/base.css：
    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/base.css&quot; /&gt; ---&gt; href=&quot;/css/base.css&quot;
3. koa静态资源的目录也可以配置多个：
    app.use(static(&apos;static&apos;)); ---&gt; 根目录/static
    app.use(static(path(__dirname, &apos;public&apos;))); ---&gt; 根目录/public
    1. 在匹配资源时，会先在static目录下查找，如果查找失败，再去public目录下查找；
    2. app.use(static(&apos;.&apos;)); --&gt;表示去根目录下去查找
    &lt;img src=&quot;public/img/a.png&quot; /&gt; --&gt; 根目录/public/img/a.png
4. app.use(static(&apos;.&apos;))是不安全的，它能访问根目录下的所有资源，如app.js、package.json
</code></pre><h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><pre><code>适用于koa的模板引擎有很多，如ejs、jade、nunjucks、art-template...
</code></pre><h3 id="koa与ejs"><a href="#koa与ejs" class="headerlink" title="koa与ejs"></a>koa与ejs</h3><pre><code>1. 安装ejs之后，安装koa-views：npm install koa-views --save
2. 多种方式配置koa-views中间件，const views = require(&apos;koa-views&apos;);
    1. app.use(views(&apos;views&apos;, { map:{ html:&apos;ejs&apos; } })); --&gt;模板的后缀名为html
    2. app.use(views(&apos;views&apos;, { extension:&apos;ejs&apos; })); --&gt;模板的后缀名为ejs
    3. views()的第一个参数表示ejs模板存放的目录，&apos;views&apos;表示在根目录/views
3. 在根目录/views中创建index.ejs
    router.get(&apos;/&apos;, async(ctx) =&gt; {
        await ctx.render(&apos;index&apos;, {key: value}) ---&gt;渲染index.ejs
    })
4. 公共数据(全局变量)
    1. 在koa中，通过 ctx.state 管理公共数据，在所有模板中都能访问；
    2. 在中间件中设置公共数据
    app.use(async(ctx, next) =&gt; {
        ctx.state = { uname: &apos;Mack&apos;, age: 20 } ----&gt; 设置公共数据uname和age
        await next();
    })
    3. 在模板中使用：&lt;h2&gt;&lt;%= uname %&gt;&lt;/h2&gt;
</code></pre><h3 id="art-template"><a href="#art-template" class="headerlink" title="art-template"></a>art-template</h3><pre><code>1. art-template是一个简约、超快的模板引擎，它采用作用域预声明的技术来优化模板渲染速度；
    1. art-template的模板渲染速度接近JavaScript极限地运行性能，且同时支持NodeJs和浏览器
    2. art-template支持ejs语法，也可以用类似angular数据绑定地语法
    3. 由腾讯开发的，同时支持Express、Koa
2. 渲染速度：art-template(15-25ms) &gt; jade(51ms) &gt; ejs(141ms)
3. 安装：npm install art-template --save，npm install koa-art-template --save
    const render = require(&apos;koa-art-template&apos;);
    render(app, {
        root: path.join(__dirname, &apos;views&apos;), ---&gt; 配置模板的位置：根目录/view
        extname: &apos;.art&apos;, ---&gt; 模板的扩展名，也可以设置为&apos;.html&apos;
        debug: process.env.NODE_ENV !== &apos;production&apos; --&gt; 开发环境下开启调试模式
    })
    app.use(async (ctx)=&gt;{
        await ctx.render(&apos;index&apos;, {key: value}); --&gt; 根目录/views/index.art
    })
4. art-template支持类似ejs的语法(原始语法)，也支持类似angular的语法(标准语法)
    1. 原始语法：&lt;%= value %&gt;，&lt;%= a?b:c %&gt; ，&lt;%= a+b %&gt;，&lt;%- value %&gt; ...
    2. 引入子模板的方式与ejs不同：&lt;% include(&apos;./public/header.art&apos;) %&gt;
    &lt;% include(&apos;./public/header.art&apos;, data) %&gt;
5. 标准语法：{{value}}，{{a?b:c}}，{{a+b}}，{{@value}}，{{if a}} ... {{/if}}
    1. {{@value}}：表示原样输出value，如value=&quot;&lt;p&gt;123&lt;/p&gt;&quot;，原样输出的结果就是&lt;p&gt;标签
    2. 循环数据：{{each a}}  {{$index}} {{$value}}  {{/each}}
    3. 引入子模板：{{include './header.art'}}，{{include './header.art', data}}
    4. 引入不在同一目录下的子模板时，不能使用相对路径，而是直接相对于模板的根目录；
    {{include 'admin/public/header.html'}}  ---&gt;views/admin/public/header.html
6. 在标签内直接使用模板语言
    &lt;input type=&quot;checkbox&quot; {{if list.check==1}} checked {{/if}} /&gt;
</code></pre><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><pre><code>1. Koa可以直接操作cookie：ctx.cookies.set(name, value, [options])
    router.get(&apos;/&apos;, async (ctx)=&gt;{
        ctx.cookies.set(&apos;uname&apos;, &apos;Jack&apos;, {
            maxAge: 60*1000*60 ---&gt; 60s后过期
        })
    })
    1. 获取cookie：ctx.cookies.get(&apos;uname&apos;)
2. options的可选参数：maxAge、expires、path、domain、secure、httpOnly、overwrite
    1. httpOnly：是否只允许服务器访问cookie，默认为true，不允许浏览器端的JS访问cookie
    2. secure：安全的cookie，默认为false，设置为true表示只允许https可以访问；
    3. overwrite：是否覆盖以前设置的同名cookie，默认为false
    ctx.cookies.set(&apos;uname&apos;, &apos;Jack&apos;, {
        path: &apos;/news&apos;,  ---&gt; 只允许 /news 路由页面可以访问此cookie
        domain: &apos;.baidu.com&apos;  --&gt;设置允许访问cookie的域名，默认当前域名下的所有路由页面
    }) -------------------------&gt; 都可以访问，所以正常情况下不会设置
3. 在koa中无法直接设置中文的cookie，如ctx.cookies.set(&apos;uname&apos;, &apos;李蕾&apos;);
    1. 可以把中文转为base64编码：new Buffer(&apos;李蕾&apos;).toString(&apos;base64&apos;);
    2. 解码：new Buffer(&apos;base64编码数据&apos;, &apos;base64&apos;).toString();
</code></pre><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><pre><code>1. 安装中间件：npm i koa-session --save
2. 配置session中间件
    1. const session = require(&apos;koa-session&apos;);
    2. app.keys = [&apos;some secret&apos;]; ---&gt; cookie的签名/加密，可以是任意字符串
    2. app.use(session(CONFIG, app));
3. CONFIG表示session的配置
    const CONFIG = {
        key: &apos;koa:sess&apos;,  ---&gt; 也类似于cookie的key，使用默认配置即可
        maxAge: 86400000, ---&gt; cookie的过期时间
        overwrite: true,
        httpOnly: false,  ---&gt; 默认为true，表示只允许服务器端访问cookie
        signed: true, ----&gt; 启用签名
        rolling: false,
        renew: false
    }
    1. rolling:true --&gt; 浏览器每次访问都强制设置cookie，每次都会重置过期时间
    2. renew:true --&gt; 每次访问时会检查cookie的过期时间，在将要过期时才会重置过期时间
4. 设置/获取：ctx.session.uname=&apos;Mack&apos;;  let uname=ctx.session.uname;
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/08/01/Express/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/01/Express/" itemprop="url">Express</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-01T00:00:00+08:00">
                2018-08-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h2><pre><code>1. Express是一个基于NodeJs平台的后台开发框架；
    1. 极简、开放、灵活的web应用开发框架，帮助开发各种Web和移动设备应用；
    2. Express不对NodeJs已有的特性进行二次抽象，只是在它之上扩展了Web应用所需的功能；
    3. Express提供了丰富的HTTP快捷方法和任意排列组合的Connect中间件。
2. Express的使用：npm install express --save
    1. 引入：const express = require(&apos;express&apos;)，let app = new express()
    2. 配置get请求的路由
    app.get(&apos;/&apos;, (req, res) =&gt; {  ------&gt; 配置路由
        res.send(&apos;Hello Express&apos;) ----&gt; 响应内容
    })
    3. 配置post请求的路由
    app.post(&apos;/dologin&apos;, (req, res) =&gt; { ... })
    4. 设置监听的Ip和端口号：app.listen(3000, &apos;ip&apos;)，默认Ip是127.0.0.1
    5. node命令运行该js文件，它也就是项目的入口文件。
3. 传递参数
    1. 配置动态路由
    app.get(&apos;/news/:id&apos;, (req, res) =&gt; {
        let {id} = req.params ---&gt; 获取id参数
    }) --&gt; 访问http://localhost:3000/news/123
    2. get传值
    app.get(&apos;/news&apos;, (req, res) =&gt; {
        let {id} = req.query ---&gt; 获取id参数
    }) --&gt; 访问http://localhost:3000/news?id=123
4. 其他API
    1. 重定向：res.redirect(&apos;/index&apos;) --&gt;重定向到路由&apos;/index&apos;
    2. 获取访问的路由：req.url ---&gt; 如&apos;/login&apos;
    3. 响应一段JS代码，弹出alert()，并重定向页面路由：
    res.send(&quot;&lt;script&gt;alert(&apos;登录失败！&apos;);location.href=&apos;/login&apos;&lt;/script&gt;&quot;)
</code></pre><h2 id="express与ejs"><a href="#express与ejs" class="headerlink" title="express与ejs"></a>express与ejs</h2><pre><code>1. Express中引入ejs模板引擎：app.set(&apos;view engine&apos;, &apos;ejs&apos;)
2. 使用ejs模板：res.render(&apos;模板名&apos;, { key:value })
    1. 模板名不需要指定路径，默认使用的路径：项目根目录/views/模板名.ejs
    app.get(&apos;/news&apos;, (req, res) =&gt; {
        res.render(&apos;index&apos;, {newsId: 123}) --&gt;默认使用的模板：views/index.ejs
    })
    2. 指定模板的目录：app.set(&apos;views&apos;, __dirname + &apos;/static&apos;)，修改为static目录；
    3. 使用path模块拼接路径：require(&apos;path&apos;).join(__dirname, &apos;static&apos;)
3. 全局变量
    1. 如果多个模板都需要接收同一变量，每个模板对应的路由都必须传递该参数，而全局变量只需要
    设置一次即可，所有模板都可以接收全局变量；
    2. 设置全局变量：app.locals[&apos;全局变量名&apos;] = &apos;123&apos;
    3. 在第一个需要接收全局变量的模板被渲染之前，设置全局变量uname的值：
    app.post(&apos;/dologin&apos;, (req, res) =&gt; {
        app.locals[&apos;uname&apos;] = &apos;123&apos; --&gt;在任何模板中都可以接收变量uname：&lt;%= uname %&gt;
        ......
    })
    4. app.locals[&apos;变量名&apos;]是真正的全局，req.app.locals[&apos;变量名&apos;]表示请求的全局。
</code></pre><h2 id="静态服务"><a href="#静态服务" class="headerlink" title="静态服务"></a>静态服务</h2><pre><code>1. 静态服务/静态路由：用于提供静态资源服务，包括css文件、js文件、图片、供下载的文件...
2. 以css文件为例，在模板中直接使用&lt;link /&gt;引入是无效的
    app.get(&apos;/login&apos;, (req, res) =&gt; {
        res.render(&apos;login&apos;) ----&gt; views/login.ejs
    })
    1. login.ejs中引入css文件：&lt;link rel=&quot;stylesheet&quot; href=&quot;css/login.css&quot; /&gt;
    2. css文件的真实获取方式：http://localhost:3000/css/login.css
    3. 很明显，&quot;/css/login.css&quot;的路由是不存在，所以获取css文件失败。
2. 在express中，利用 express.static 中间件托管静态文件
    1. app.use(express.static(&apos;public&apos;)) --&gt; 给public目录下的文件提供静态web服务
    2. 在public目录下创建有效的css/login.css
    http://localhost:3000/css/login.css --&gt; 查找路径：public/css/login.css
    3. 同理，login.ejs中的&lt;img /&gt;加载的图片资源也必须提供静态服务
    &lt;img src=&quot;img/a.png&quot; /&gt; =&gt;http://localhost:3000/img/a.png =&gt;public/img/a.png
3. 注意：href=&quot;css/login.css&quot; 与 href=&quot;/css/login.css&quot; 并不完全相同
    1. &apos;/&apos;、&apos;/login&apos;、&apos;/user&apos;都属于一级路由，而&apos;/index/login&apos;属于二级路由；
    2. 在一级路由中渲染的ejs模板中，&quot;css/login.css&quot; 与 &quot;/css/login.css&quot; 是相同的
    http://localhost:3000/css/login.css ==&gt; public/css/login.css
    3. 对于二级路由，&quot;css/login.css&quot; 与 &quot;/css/login.css&quot;的参考路由不同，也就导致了资源
    路径出错，从而无法加载资源；
    4. 在二级路由 &apos;/index/login&apos; 中渲染login.ejs模板时：
    href=&quot;css/login.css&quot; -----&gt; http://localhost:3000/index/css/login.css ------
    --&gt; public/index/css/login.css --&gt; public目录下不存在 index目录，所以访问失败
    href=&quot;/css/login.css&quot; --&gt; http://localhost:3000/css/login.css --&gt; 访问成功
    5. 原因：href=&quot;css/login.css&quot;相对于当前路由，而href=&quot;/css/login.css&quot;相对于根路由。
5. 设置虚拟目录，映射真实的资源路径：app.use(&apos;/static&apos;, express.static(&apos;public&apos;))
    1. app.use(express.static(&apos;public&apos;)) --&gt;匹配的是根路由，而所有路由又都开始于根路由
    2. app.use(&apos;/static&apos;, express.static(&apos;public&apos;)) 匹配的路由是 &apos;/static&apos;
    3. href=&quot;/css/login.css&quot; 不能在访问了，需要使用 href=&quot;/static/css/login.css&quot;
    http://localhost:3000/static/css/login.css ==&gt; public/css/login.css
6. 如果静态资源存在多个目录，可以配置多个 express.static 中间件
    app.use(express.static(&apos;public&apos;)) ---&gt; public目录
    app.use(express.static(&apos;static&apos;)) ---&gt; static目录
    app.use(&apos;/static&apos;, express.static(&apos;public&apos;)) --&gt; 虚拟路径
    1. 访问静态资源时，express会依次匹配静态资源目录，如果都找不到，才会抛出404
7. href和src都是可以跨域的，可以直接指定静态资源的完整地址，包括域名和路径。
</code></pre><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><pre><code>1. Express本身非常简洁，它完全是由路由和中间件构成的web开发框架，其应用就是在调用各种中间件
2. 简单来说，中间件就是在匹配路由之前和之后所做的一系列操作；
3. 类型：应用级中间件、路由级中间件、错误处理中间件、内置中间件、第三方中间件
1. 应用级中间件：匹配任何路由
    app.use((req, res, next) =&gt; { ... })
    1. 路由默认只匹配一次，一旦匹配成功，则不再继续向下匹配；
    2. 调用 next()，让路由继续向下匹配，直到匹配正确的路由。
    http://localhost:3000/news
    app.use((req, res, next) =&gt; { ---&gt; 可用作权限判断
        ......
        next();  --&gt; 继续向下匹配
    })
    app.get(&apos;/news&apos;, (req, res) =&gt; { ---&gt; 匹配成功
        res.send(&apos;匹配news路由&apos;)
    })
    4. 默认匹配所有路由，也可以指定只匹配某个路由
    app.use(&apos;/news&apos;, (req, res, next) =&gt; {  --&gt; 只匹配 /news
        ......
        next();
    })
    5. 中间件和路由的排列顺序不能颠倒，否则一旦匹配成功，将不再继续执行。
2. 路由级中间件：匹配多个路由
    http://localhost:3000/news
    app.get(&apos;/news&apos;, (req, res, next) =&gt; {
        console.log(&apos;路由中间件news&apos;)
        next(); ---&gt; 不执行 res.send() 返回数据，让路由继续向下执行
    })
    app.get(&apos;/news&apos;, (req, res) =&gt; {
        res.send(&apos;匹配news路由&apos;)
    })
3. 错误处理中间件
    1. 写在所有路由的后面，当上面的所有路由都不匹配时，则返回404
    app.use((req, res) =&gt; {  ---&gt; 匹配所有路由
        res.status(404).send(&apos;404页面&apos;)
    })
4. 内置中间件：如 express.static()，用于托管静态资源
    app.use(&apos;/static&apos;, express.static(&apos;./static&apos;))
</code></pre><h3 id="第三方中间件"><a href="#第三方中间件" class="headerlink" title="第三方中间件"></a>第三方中间件</h3><pre><code>1. body-parser：用于获取POST提交的数据，npm install body-parser --save
    1. let parser = require(&apos;body-parser&apos;)
    2. 配置 body-parser 中间件
    //parse application/x-www-form-urlcoded
    app.use(parser.urlencoded({extended:false}))
    app.use(parser.json()) ---&gt; parse application/json
    app.post(&apos;/login&apos;, (req, res) =&gt; {
        let body = req.body  ---&gt; 获取post提交的数据
    })
2. 但是，如果表单中涉及文件上传，body-parser模块就无法处理了，需要使用multiparty模块
    1. npm install multiparty --save
    2. multiparty可以设置上传文件的保存路径、限制文件的大小...
    3. 对于涉及文件上传的表单，必须设置&lt;form enctype=&quot;multipart/form-data&quot;&gt;
    let multiparty = require(&apos;multiparty&apos;)
    let form = new multiparty.Form()
    form.uploadDir = &apos;upload&apos; ----&gt; 设置上传文件的保存目录，项目根目录/upload
    form.parse(req, (err, fields, files) =&gt; { ---&gt; 处理 req 中提交的表单数据
        // --&gt;fields是处理后的表单数据，files是文件上传成功后返回的信息
    })
    4. 使用虚拟目录为 upload 目录配置静态服务：
    app.use(&apos;/upload&apos;, express.static(&apos;upload&apos;))
    5. 访问 upload 目录中上传的图片文件：http://localhost:3000/upload/a.jpg
3. multiparty模块的问题
    1. 如果表单中没有选择上传的图片，即&lt;input type=&quot;file&quot; /&gt;是空的，multiparty模块仍会在
    上传目录中生成一个临时文件；
    2. 上传成功后，files中的originalFilename属性表示上传文件的原始名称，path属性表示上传
    文件在服务器端存储的路径，为了防止文件名重复，文件的名称已经被重新编码了；
    3. 如果表&lt;input type=&quot;file&quot; /&gt;是空的，那么 files.originalFilename=&apos;&apos;，由此判断文件
    是否上传，如果没有上传，则根据 files.path 删除临时文件。
</code></pre><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><pre><code>1. NodeJs操作Cookie的中间件：npm install cookie-parser --save
2. 配置 Cookie 中间件
    let cookieParser = require(&apos;cookie-parser&apos;)
    app.use(cookieParser())
3. 设置cookie
    app.get(&apos;/set&apos;, (req, res) =&gt; {
        res.cookie(&apos;username&apos;, &apos;Mack&apos;, { maxAge:90000, httpOnly:true })
        res.send(&apos;set Cookie&apos;)
    })
    1. 参数1和参数2分别是cookie的键-值，参数3是对cookie的配置；
    2. maxAge：表示过期时间(s)，最大失效时间
    3. httpOnly：默认为false，表示不允许客户端的脚本访问，只能在nodeJs服务的操作
    4. 获取cookie：一旦访问过 /set 路由，就可以在其他路由中获取 cookie
    app.get(&apos;/news&apos;, (req, res) =&gt; {
        let username = req.cookies.username; --&gt;{ username: &apos;Mack&apos; }
        res.send(`get Cookie: ${username}`);
    })
4. Cookie的更多设置
res.cookie(&apos;uname&apos;, &apos;Node&apos;, {expires:new Date(Date.now()+9000), httpOnly:true})
    1. expires：也是设置Cookie的过期时间，表示从当前时间开始，到 expires 设置的时间过期
res.cookie(&apos;uname&apos;, &apos;Node&apos;, {domain:&apos;.exa.com&apos;, path: &apos;/admin&apos;, secure: true})
    1. secure：设置为true，表示cookie在 HTTP 中是无效的，仅在 HTTPS 中才有效；
    2. path：指定cookie匹配的路由，如果访问的路由不匹配，浏览器不会发送cookie
    3. domain：域名，让所有子域名/二级域名共享同一个cookie信息，如domain:&apos;.exa.com&apos;的
    子域名www.exa.com、aaa.exa.com ...
5. cookie的签名/加密
    app.use(cookieParser(&apos;sign&apos;)) --&gt; 传入一个随机字符串，用于cookie的加密
    res.cookie(&apos;uname&apos;, [1,2,3], {maxAge:60000, signed:true})
    1. cookie默认是明文存储的，signed用于签名cookie，设置为true 会对cookie签名/加密；
    2. res.signedCookies：获取签名后的cookie
    3. 被篡改的签名cookie会被服务器拒绝，且cookie会被重置为初始值。
</code></pre><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><pre><code>1. session是另一种记录客户端状态的机制，与cookie不同的是，session保存在服务器端；
    1. 当客户端第一次访问服务器时，session可以保存客户端的登录状态，当客户访问其他路由时，
    判断客户的登录状态，作出响应提示；
    2. 工作机制：客户端第一次向服务器发送请求 --&gt; 服务器创建一个类似键-值的session对象，
    然后将key设置在cookie中，返回给客户端 --&gt; 客户端下次访问时会携带cookie，根据cookie中
    的key找到对应的session
2. 与cookie不同，session没有过期时间，浏览器一旦关闭，session就失效了；
3. session还可以和Redis等数据库结合，实现持久化，就算服务器宕机，也不会丢失用户状态；
4. express-session：nodeJs操作session的中间件
    1. npm install express-session --save
    2. 配置中间件
    const session = require(&apos;express-session&apos;)
    app.use(session({ 
        secret:&apos;anything&apos;,  --&gt; 服务器生成session的签名，可以是任意字符串，用于加密
        //name: &apos;&apos; --------&gt; 返回给客户端的cookie名称，默认为connect.sid
        resave: false, --&gt; 强制保存session，即使没有变化，默认值为true
        saveUninitialized:true, --&gt;强制将未初始化的session存储，默认为true
        cookie:{ secure:false } --&gt;设置cookie，maxAge、path、domain...
    }))  --&gt; 一旦关闭浏览器，session就失效了，相关的cookie也会失效
    2. 设置/获取session
    app.get(&apos;/&apos;, (req, res) =&gt; {
        if(req.session.userInfo) {  ---&gt; 获取session
            res.send(&apos;welcome back: &apos;, req.session.userInfo)
        } else {
            res.send(&apos;logout&apos;)
        }
    })
    app.get(&apos;/login&apos;, (req, res) =&gt; {
        req.session.userInfo = {uname:&apos;Mack&apos;, pwd:&apos;123&apos;}  ---&gt; 设置session
        res.send(&apos;login success&apos;)
    })
    3. 销毁session，如切换登陆、退出登录时，要主动销毁session
    req.session.cookie.maxAge=0  --&gt; 方式1：把cookie的过期时间设置为0ms后，立即过期
    req.session.destroy(err =&gt; {}) ---&gt; 方式2：调用session的销毁方法
5. 负载均衡配置Session
    1. 负载均衡：后台配置多个服务器，执行同一套node代码，通过Nginx服务器动态地把不同地区的
    用户请求转发给不同的服务器处理，或者把用户请求转发给同一地区压力比较小的服务器；
    2. session默认保存在服务器的缓存文件中，而后台配置了负载均衡之后，同一用户访问的服务器
    就可能发生变化，那么原本的session信息也就不存在了，但多个服务器会共享数据库，所以需要把
    session保存到数据库中；
    3. 把session保存在MongoDB数据库中：express-session和connect-mongo两大模块
    let session = require(&apos;express-session&apos;)
    const MongoStore = require(&apos;connect-mongo&apos;)(session)
    4. 配置中间件
    app.use(session({secret:&apos;1234&apos;, resave:false, saveUninitialized:true,
        cookie: { maxAge:1000*60*30 }, --&gt; 在浏览器未关闭的情况下，30min后过期
        rooling:true, --&gt;默认false，每次请求时强行设置cookie，这将会重置cookie过期时间
        store:new MongoStore({
            url: &apos;mongodb://127.0.0.1:27017/student&apos;, ---&gt;数据库地址
            touchAfter: 24*3600 --&gt; 不管多少次请求，24小时内只更新一次session，除非在
        }) ------------------------------------------&gt; session数据上更改了某些内容
    }))
    5. db.sessions.find(); --&gt; 查询MongoDB中保存的session
</code></pre><h2 id="express模块化"><a href="#express模块化" class="headerlink" title="express模块化"></a>express模块化</h2><pre><code>1. express.Router：路由模块化，进而实现项目的模块化，便于协作开发与维护；
2. 创建入口文件app.js：
    const express = require(&apos;express&apos;);  let app = express();
    1. 引入路由模块的文件
    let index = require(&apos;./routes/index&apos;)
    let user = require(&apos;./routes/user&apos;)
    2. 应用路由模块
    app.use(&apos;/&apos;, index) ---&gt;当访问 http://localhost:3000 时，进入index.js去匹配路由
    app.use(&apos;/user&apos;, user) --&gt; http://localhost:3000/user --&gt; user.js
    app.listen(3000)
2. 以index.js为例：const express = require(&apos;express&apos;);
    1. 创建路由对象：let router = express.Router();
    2. 引入index模块的子路由模块login.js、home.js
    let login = require(&apos;./index/login&apos;);  let home = require(&apos;./index/home&apos;)
    3. 配置匹配的路由
    router.use(&apos;/&apos;, login) --&gt; http://localhost:3000 --&gt; 进入login.js去匹配
    router.use(&apos;/home&apos;, home) --&gt; http://localhost:3000/home --&gt; home.js
    4. 暴露模块的路由对象：module.exports = router
3. 以home.js为例
    const express = require(&apos;express&apos;);  let router = express.Router();
    1. 响应处理请求
    router.get(&apos;/&apos;, (req, res) =&gt; { --&gt;处理响应http://localhost:3000/home
        res.send(&apos;index--&gt;home&apos;)
    })
    router.get(&apos;/item&apos;, (req, res) =&gt; { --&gt;响应http://localhost:3000/home/item
        res.send(&apos;index--&gt;home--&gt;item&apos;)
    })
    2. 暴露子模块的路由对象：module.exports = router
4. 使用ejs模板
    1. 在入口文件app.js中配置ejs引擎和静态服务：
    app.set(&apos;view engine&apos;, &apos;ejs&apos;);  app.use(express.static(&apos;public&apos;));
    2. 在login.js中使用
    router.get(&apos;/&apos;, (req, res) =&gt; {
        res.render(&apos;login&apos;) ---&gt; 默认使用的模板为views/login.ejs
    })
5. express脚手架：express-generator
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/07/09/NodeJs-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/09/NodeJs-3/" itemprop="url">NodeJs-3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-09T00:00:00+08:00">
                2018-07-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="路由与模板引擎"><a href="#路由与模板引擎" class="headerlink" title="路由与模板引擎"></a>路由与模板引擎</h2><pre><code>1. 路由：简单来说就是，根据不同请求的URL，处理不同的业务逻辑；
2. ESJ模板引擎：是一种后台模板，可以把数据库/文件的读取内容显示到HTML页面上；
    1. 安装：npm/cnpm install ejs --save
    2. 创建ejs文件，取代HTML文件，但ejs文件的代码格式仍是HTML；
    let ejs = require(&apos;ejs&apos;)
    http.createServer((req, res) =&gt; {
        res.writeHead(200, {&quot;Content-Type&quot;:&quot;text/html;charset=&apos;utf-8&apos;&quot;})
        ejs.renderFile(&apos;view/login.ejs&apos;, {}, (err, data) =&gt; {
            res.end(data) --&gt; 把ejs模板引擎的渲染的数据，响应给浏览器
        })
    }).listen(8000)
3. EJS模板语言
    1. 向模板中传递变量：ejs.renderFile()的第二个参数，如{name: &apos;Mack&apos;}
    2. 模板中接收变量：&lt;h2&gt;&lt;%= name %&gt;&lt;/h2&gt;
    3. 在模板中使用JS语句：
    &lt;% if(name) { %&gt;
        &lt;h2&gt;&lt;%= name %&gt;&lt;/h2&gt;
    &lt;% } %&gt;
    4. 引入公共的模板：&lt;%- include header.ejs %&gt;
    5. 接收HTML数据：&lt;%- html %&gt;
4. 隐藏表单域传值
    1. 模板中需要使用参数id，那么就在渲染模板时传递参数id，在模板中使用隐藏表单域接收此参数
    ejs.renderFile(&apos;view/login.ejs&apos;, { id: 12 });
    &lt;input type=&quot;hidden&quot; id=&quot;keyId&quot; value=&quot;&lt;%= id %&gt;&quot; /&gt;
    2. 在模板的&lt;script&gt;中操作DOM，获取隐藏表单域的value值，也就获取了参数id
    let keyId = document.getElementById(&apos;keyId&apos;);
    let id = keyId.value
</code></pre><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><pre><code>1. NoSQL最早在20世纪80年代被提出，属于非关系型数据库，以key-value形式存储；
2. 在如今的大数据时代，NoSQL更多地是强调协助解决大数据等相关问题；
3. 建议使用NoSQL的情况：
    1. 对数据库高并发读写、高可扩展性和高可用性的需求，对海量数据的高效率存储和访问的需求。
</code></pre><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><pre><code>1. 启动MongoDB
    1. 启动服务器端(windows)：mongod --dbpath F:\mongodb
    2. --dbpath F:\mongodb 表示指定mongodb服务器端的工作目录，保存数据库文件
    3. 启动客户端：mongo ip:27017 ---&gt; 默认ip为127.0.0.1，默认端口号27017
2. NodeJs操作MongoDB：cnpm install mongodb --save
    1. mongodb模块是MongoDB官方为nodeJs提供的驱动，用于nodeJs原生操作MongoDB
    2. const MongoClient = require(&apos;mongodb&apos;).MongoClient
    3. 数据库的地址：在命令行执行 mongo，会显示地址，如 mongodb://127.0.0.1:27017
3. NodeJs连接数据库：MongoDB4.0与4.0之前的版本是不同的
    1. 主要因为MongoDB官方为nodeJs提供的MongoDB驱动更新了，Driver3.x与2.x是不同的
    2. Driver2.x操作数据库：const url = &apos;mongodb://127.0.0.1:27017/test&apos;
    MongoClient.connect(url, (err, db) =&gt; { --&gt; db表示数据库test的对象
        if(err) return;
        db.connect(&apos;user&apos;).insertOne({name: &apos;Jack&apos;}, callback) --&gt;插入一条数据
    })  ---&gt;在callback中关闭数据库：db.close()
    3. Driver3.x操作数据库：const url = &apos;mongodb://127.0.0.1:27017&apos;
    MongoClient.connect(url, (err, client) =&gt; { --&gt;client表示数据库对象
        if(err) return;
        let db = client.db(&apos;test&apos;) --&gt; 连接数据库test
        db.collection(&apos;user&apos;).insert({name: &apos;Jack&apos;}, callback) --&gt;插入一条数据
    }) ---&gt; client.close() 关闭数据库
    4. 查询MongoDB官网文档可知，MongoDB NodeJs Driver3.x查询数据
    MongoClient.connect(url, (err, client) =&gt; {
        if(err) return;
        let db = client.db(&apos;user&apos;) ---&gt; 连接数据库user
        let cursor = db.collection(&apos;user&apos;).find() ---&gt; 查询出user中的所有数据
        let userlist = []
        cursor.forEach(doc =&gt; {
            userlist.push(doc) ---&gt; 把数据保存到一个数组中
        }, error =&gt; {
            if(error) { console.log(error) }
            client.close() ---&gt; 查询结束，关闭数据库
        })
    })
    5. 另一种获取cursor中的数据、并转为数组的方式：
    cursor.toArray((err, result) =&gt; {
        if(!err) {
            console.log(&apos;result: &apos;, result)  ---&gt; result已经是一个数组了
        }
        client.close()
    })
4. ObjectID：MongoDB数据库的id是封装后的，不能直接使用，需要借助mongodb模块的ObjectID
    1. let { ObjectID } = require(&apos;mongodb&apos;)
    2. 根据id查询数据：find({ _id: new ObjectID(&apos;id值&apos;) })
5. 用户的登录密码需要md5加密之后再存入数据库，md5模块：cnpm install md5-node --save
6. MongoDB Compass Community：MongoDB官方提供的可视化管理工具，最新的MongoDB自带此工具
7. mongoose：NodeJs操作MongoDB的第三方模块，它是一种便捷操作的对象模型工具。
</code></pre><h3 id="导入与导出"><a href="#导入与导出" class="headerlink" title="导入与导出"></a>导入与导出</h3><pre><code>1. 导出：mongodump -h dbhost -d dbname -o dbdirectory
    1. 导出时需要连接数据库，所以MongoDB服务器端必须运行；
    mongodump -h 127.0.0.1 -d koastu -o D:\users\test
    2. 把127.0.0.1上的MongoDB数据库koastu，导出到D:\users\test目录；
    3. 在D:\users\test下会生成一个数据库文件目录koastu
2. 导入：mongorestore -h dbhost -d dbname &lt;path&gt;
    1. 导入时不需要运行MongoDB服务器
    mongorestore -h 127.0.0.1 -d koademo D:\users\test\koastu
    2. 把D:\users\test\koastu中的数据库文件，导入到127.0.0.1上的MongoDB数据库koademo
    3. 如果指定的数据库koademo不存在，MongoDB会自动创建
</code></pre><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><pre><code>1. 插入/删除/更新/查询的操作其实是很快的，而连接数据库的操作却会耗费很长时间；
2. 性能优化的关键点：保持数据库的长连接，即保存第一次成功连接后的数据库对象
3. 创建一个单例模式的类：
    class DB {
        static getInstance() {  ---&gt; 静态方法
            if(!DB.instance) {
                DB.instance = new DB();
            }
            return DB.instance;
        }
        constructor() {
            this.dbClient = null;  ---&gt; 用于保存数据库对象
        }
    }
</code></pre><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><pre><code>1. mysql2：第三方MySQL驱动引擎，npm i mysql2 --save
2. 连接数据库：const mysql = require(&apos;mysql2/promise&apos;);
    let conn = await mysql.createConnection({ 数据库参数 });
</code></pre><h3 id="Sequelize"><a href="#Sequelize" class="headerlink" title="Sequelize"></a>Sequelize</h3><pre><code>1. ORM映射：避免直接写SQL语句，而是用对象模型去操作数据库；
2. Sequelize：ORM映射模型，支持多种数据库，对于MySQL的操作，底层使用的是mysql2
    npm i mysql2 --save
    npm i sequelize --save
    1. 连接数据库：const Sequelize = require(&apos;sequelize&apos;);
    const conn = new Sequelize(&apos;数据库名&apos;, &apos;用户名&apos;, &apos;密码&apos;, { 数据库参数 });
    2. 数据库参数可以配置域名host、数据库类型dialect，时区timezone
    { host: &apos;117.78.51.252&apos;, dialect:&apos;mysql&apos;, timezone:&apos;+08:00&apos; }
    3. 测试是否连接成功：conn.authenticate();
1. 定义要操作的表的对象模型
    const User = conn.define(&apos;模型名&apos;, { 字段参数配置 }, { 可选配置 });
    1. 字段参数配置与数据库表的字段要一一对应，建立映射关系；
    2. 默认情况下，模型名+&apos;s&apos;为表名，在可选配置中指定表名
    { freezeTableName:true, tableName:&apos;user&apos;, timestamps:false }
    3. freezeTableName：设置为true，表示允许通过tableName自定义表名；
    4. 如果没有tableName自定义表名，则取模型名为表名；
    5. timestamps：设置为false，关闭自动向模型中添加时间戳字段createAt和updatedAt
2. 访问数据库的所有数据：User.findAll().then(res =&gt; { ... });
3. 查询并修改
    User.findById(10).then(res =&gt; {
        res.set(&apos;字段名&apos;, &apos;字段值&apos;);  --&gt; 设置新的字段值
        res.save();  --&gt; 保存到数据库中
    });
4. 插入数据
    let zhgsan = User.build({字段名: 字段值, ...});
    zhgsan.set(key, value);  --&gt; 重新设置新的值
    zhgsan.save();  --&gt; 插入到数据库表中
</code></pre><h3 id="sequelize-cli"><a href="#sequelize-cli" class="headerlink" title="sequelize-cli"></a>sequelize-cli</h3><pre><code>1. sequelize-cli：sequelize的命令行工具，npm i -D sequelize-cli
2. 初始化：sequelize init，在当前目录下会生成4个目录；
    1. config：配置目录，
    2. migrations：迁移文件目录(数据库表结构)
    3. seeders：种子文件目录(生成测试数据)
    4. models：模型文件目录，主要供程序使用
3. config/config.json中包含三大节点：development(开发)、test(测试)、production(生产)
    1. 配置时区：&quot;timezone&quot;: &quot;+08:00&quot;
4. 创建数据库：在config目录中配置数据库信息，执行 sequelize db:create 生成数据库；
5. 构建数据迁移结构：sequelize migration:create --name [迁移文件的名称]
    1. 在migrations目录中生成相应的JS文件，一个迁移文件对应一个表；
    2. 在迁移文件中配置表结构，再执行生成表的命令；
    3. 第三方日期时间格式化模块：momentjs
6. 生成表：sequelize db:migrate
7. 把种子文件的数据导入表中：sequelize db:seed:all
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/07/08/NodeJs-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/08/NodeJs-2/" itemprop="url">NodeJs-2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-08T00:00:00+08:00">
                2018-07-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="path模块"><a href="#path模块" class="headerlink" title="path模块"></a>path模块</h2><pre><code>1. path模块：用于处理文件路径，var path = require(&apos;path&apos;)
2. path.extname(&apos;index.html&apos;)：获取文件的后缀名&apos;.html&apos;
3. path.basename(&apos;./conf/img/a.png&apos;)：获取文件名 a.png
4. path.join(path1, path2, ...)：连接路径；
    1. 主要用途：它会正确地使用当前系统的路径分隔符，Unix系统是&quot;/&quot;，Windows系统是&quot;\&quot;
    2. path.join(__dirname, &apos;user/config&apos;)：项目根目录/user/config
5. path.parse(pathStr)：返回路径字符串的对象；
6. path.resolve(from, to)：将相对路径转为绝对路径。
</code></pre><h2 id="url模块"><a href="#url模块" class="headerlink" title="url模块"></a>url模块</h2><pre><code>var url = require(&apos;url&apos;)
1. 解析一个域名：var result = url.parse(&apos;http://www.baidu.com/&apos;)
2. result是一个对象，如获取协议名：result.protocol --&gt; &apos;http&apos;
3. url.parse(&apos;http://www.a.com/news?n=pfy&amp;a=10&apos;, true)：把GET请求的参数封装成一个对象
    query: { n: &apos;pfy&apos;, a: &apos;10&apos; }
4. url.format()：url.parse()的逆向操作
5. url.resolve(from, to)：拼接URL
    1. url.resolve(&apos;http://abc.com&apos;, &apos;one&apos;) --&gt; http://abc.com/one
    2. url.resolve(&apos;http://abc.com/news&apos;, &apos;one&apos;) --&gt; http://abc.com/one
</code></pre><h2 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h2><pre><code>1. http模块：提供了网络请求(客户端)和网络服务(服务端)的实现，let http=require(&apos;http&apos;)
2. http服务端：http.Server 继承自 net.Server
    const server = new http.Server(); / http.createServer();
    1. 启动监听：server.listen(8000, &apos;127.0.0.1&apos;, ()=&gt;{ //启动成功的回调 });
    2. 接收请求的事件
    server.on(&apos;request&apos;, (req, res) =&gt; { --&gt; request, response
        let url = req.url; --&gt;请求地址，对应服务端的路由
    });
    3. req 本质是net.Socket + (http协议增加的内容)，req.socket获取客户端的socket对象
    4. 设置响应头：res.writeHead(状态码, 状态描述, 响应头);
    res.writeHead(200, &apos;ok&apos;, {
        &apos;Content-Type&apos;: &apos;text/html;charset=utf8&apos;
    });
    res.writeHead(301, http.STATUS_CODES[301], { ---&gt;重定向
        &apos;Content-Type&apos;: &apos;text/html;charset=utf8&apos;,
        &apos;Location&apos;: &apos;/&apos;  ----&gt; 告诉浏览器重定向的地址
    });
    5. res.setHeader(key, val); 也是设置响应头，会与 writeHead() 设置的响应头合并，
    且 writeHead() 设置的响应头优先；响应头的设置必须在响应数据之前；
    6. 设置响应数据：res.write(&apos;hello client&apos;);
    7. 数据传输完成，结束本次响应：res.end();  --&gt;如果传递参数，内部会调用 write();
    res.end(&apos;hello client&apos;);
3. Http服务的简写形式：
    http.createServer((req, res) =&gt; {
        ...
    }).listen(8000);
4. http客户端：http.request();
    1. 发起一个http请求
    let client = http.request({
        host: &apos;127.0.0.1&apos;,
        port: 8000,  ------&gt; IP和端口号是TCP所必须的，其他的参数是http所需要的
        protocol: &apos;http:&apos;,
        method: &apos;get&apos;,
        path: &apos;/abc&apos;  -------&gt; get请求的完整地址：http://127.0.0.1:8000/abc
    }, res =&gt; {  --&gt;处理服务器的响应数据
        res.on(&apos;data&apos;, data =&gt; {
            ...//处理接收的数据，数据量比较大时，socket会分包发送，data事件多次触发
        });
        res.on(&apos;end&apos;, () =&gt; {
            //数据传输完成
        });
    });
    2. 发送的数据：client.write(&apos;hello server&apos;); --&gt;比如post请求的参数
    3. 通知服务器发送完成：client.end();
</code></pre><h3 id="作为客户端"><a href="#作为客户端" class="headerlink" title="作为客户端"></a>作为客户端</h3><pre><code>1. 发送POST请求，接收响应的ZIP数据流
    let params = {}
    let options = {
        hostname: &apos;117.78.51.252&apos;, port: 8030, method: &quot;POST&quot;, --&gt; POST请求
        path: &apos;/Ae/Resources/Download&apos;, ---&gt;接口
        headers: { } --&gt; 如果需要，可以手动设置请求头
    }
    let streamlist = [];
    let req = http.request(options, res =&gt; {
        //res.setEncoding(&apos;utf8&apos;) --&gt; 当请求的是流数据时，一定不能设置响应数据的编码
        res.on(&apos;data&apos;, chunk =&gt; { --&gt; 接收数据
            streamlist.push(chunk); --&gt; 大数据流会分多次传输，所以先用数组保存
        });
        res.on(&apos;end&apos;, () =&gt; {
            let data = Buffer.concat(streamlist); --&gt;把一个buffer数组转为一个buffer
            fs.writeFile(&apos;./config.zip&apos;, data, err=&gt;{}) --&gt;把Buffer写入到文件中
        });
    });
    req.on(&apos;error&apos;, e =&gt; { console.error(`请求遇到问题: ${e.message}`); });
    // 把参数转化后，写入请求主体，两种转化方式，根据后台的获取方式进行选择
    let postData = require(&apos;querystring&apos;).stringify(params) --&gt;id=1&amp;name=Mack
    let postData = JSON.stringify(params) ---&gt; {&quot;id&quot;:1,&quot;name&quot;:&quot;Mack&quot;}
    req.write(postData);
    req.end(); ---&gt; 告诉服务器，结束请求
2. POST请求上传文件
    let boundaryKey = &quot;----&quot; + new Date().getTime();  --&gt;HTTP协议
    let options = {
        hostname: &apos;117.78.51.252&apos;, port: 8030, method: &quot;POST&quot;,
        path: &apos;/Ae/Project/Upload&apos;,
        headers: {  ---&gt; 设置数据的类型：multipart/form-data表示是上传文件
            &quot;Content-Type&quot;: &quot;multipart/form-data; boundary=&quot; + boundaryKey,
            &apos;Connection&apos;: &quot;keep-alive&quot;
        }
    };
    let req = http.request(options, function(res) {
        res.setEncoding(&quot;utf8&quot;);  --&gt;设置响应数据的编码格式
        res.on(&quot;data&quot;, chunk =&gt; { ---&gt; chunk其实是一个Buffer
            console.log(chunk.toString()) ---&gt;假设响应数据是简短的JSON字符串
        });
        res.on(&quot;end&quot;, () =&gt; { console.log(&quot;res end.&quot;); });
    });
    req.on(&apos;error&apos;, e =&gt; { console.log(&apos;req error: &apos;, e) });
    //开始上传：参数1表示提交的内容信息，参数2表示上传的文件列表，参数3表示请求对象
    this.postFile([], [{
        urlKey:&quot;file1&quot;,  --&gt; 文件名
        urlValue: &apos;./config.zip&apos; ---&gt; 文件的路径
    }], req);
    ----------------------------------------------------------------------
    postFile(fileInfo, fileData, req) {
        const path = require(&apos;path&apos;);  const fs = require(&apos;fs&apos;);
        let boundaryKey = Math.random().toString(16);
        let enddata = &apos;\r\n----&apos; + boundaryKey + &apos;--&apos;;
        let dataLength = 0;
        let dataArr = new Array();
        for (let i = 0; i &lt; fileInfo.length; i++) {
            let dataInfo = &quot;\r\n----&quot; + boundaryKey + &quot;\r\n&quot; + 
                &quot;Content-Disposition: form-data; name=\&quot;&quot; + 
                fileInfo[i].urlKey + &quot;\&quot;\r\n\r\n&quot; + fileInfo[i].urlValue;
            let dataBinary = new Buffer(dataInfo, &quot;utf-8&quot;);
            dataLength += dataBinary.length;
            dataArr.push({ dataInfo: dataInfo });
        }
        let files = new Array();
        for (let i = 0; i &lt; fileData.length; i++) {
            let content = &quot;\r\n----&quot; + boundaryKey + &quot;\r\n&quot; + 
                &quot;Content-Type: application/octet-stream\r\n&quot; + 
                &quot;Content-Disposition: form-data; name=\&quot;&quot; + 
                fileData[i].urlKey + &quot;\&quot;; filename=\&quot;&quot; + 
                path.basename(fileData[i].urlValue) + &quot;\&quot;\r\n&quot; + 
                &quot;Content-Transfer-Encoding: binary\r\n\r\n&quot;;
            //编码为ascii时，中文会乱码
            let contentBinary = new Buffer(content, &apos;utf-8&apos;);
            files.push({ contentBinary: contentBinary, 
                filePath: fileData[i].urlValue });
        }
        let contentLength = 0;
        for (let i = 0; i &lt; files.length; i++) {
            let filePath = files[i].filePath;
            if (fs.existsSync(filePath)) {
                let stat = fs.statSync(filePath);
                contentLength += stat.size;
            } else {
                contentLength += new Buffer(&quot;\r\n&quot;, &apos;utf-8&apos;).length;
            }
            contentLength += files[i].contentBinary.length;
        }
        req.setHeader(&apos;Content-Type&apos;, 
            &apos;multipart/form-data; boundary=--&apos; + boundaryKey);
        req.setHeader(&apos;Content-Length&apos;, 
            dataLength + contentLength + Buffer.byteLength(enddata));
        for (let i = 0; i &lt; dataArr.length; i++) { --&gt; 将参数发出
            req.write(dataArr[i].dataInfo)
        }
        let fileindex = 0;
        let doOneFile = function () {
            req.write(files[fileindex].contentBinary);
            let currentFilePath = files[fileindex].filePath;
            if (fs.existsSync(currentFilePath)) {
                let fileStream = fs.createReadStream(currentFilePath, 
                    { bufferSize: 4 * 1024 });
                fileStream.pipe(req, { end: false });
                fileStream.on(&apos;end&apos;, function () {
                    fileindex++;
                    if (fileindex == files.length) {
                        req.end(enddata);
                    } else {
                        doOneFile();
                    }
                });
            } else {
                req.write(&quot;\r\n&quot;);
                fileindex++;
                if (fileindex == files.length) {
                    req.end(enddata);
                } else {
                    doOneFile();
                }
            }
        };
        if(fileindex == files.length) {
            req.end(enddata);
        } else {
            doOneFile();
        }
    }
3. request模块是对http模块的GET、POST等请求的进一步封装。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/07/05/NodeJs-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/05/NodeJs-1/" itemprop="url">NodeJs-1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-05T00:00:00+08:00">
                2018-07-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h2><pre><code>1. NodeJs是单线程、非阻塞I/O的事件驱动；
    1. 不同于Java/PHP/.net等服务器语言，NodeJs不会为每个Client连接创建新线程；
    2. 当有新的Client请求连接时会触发内部事件，通过非阻塞I/O、事件驱动机制，让Node应用程序
    在宏观上是并行的；
    3. 使用Node.js，一个8G的服务器可以同时处理超过4w的Client连接。
2. 处理异步的两种常用方式：回调函数、事件的订阅/发布
3. 事件是整个Node的核心，Node中大部分模块都使用/继承events模块，类似WebAPI的EventTarget
</code></pre><h3 id="events模块"><a href="#events模块" class="headerlink" title="events模块"></a>events模块</h3><pre><code>1. const EventEmitter = require(&apos;events&apos;);
    class MyEmitter extends EventEmitter {}
    const emitter = new MyEmitter();
2. 通过EventEmitter实例来绑定和监听事件，以广播(订阅/发布)的形式处理异步；
    1. 订阅事件的方式
    emitter.on(&apos;toparent&apos;, (data) =&gt; { --&gt; 方式一：订阅事件&apos;toparent&apos;
        console.log(data) --&gt; 处理广播数据data
    })
    emitter.addListener(&apos;toparent&apos;, (data) =&gt; { --&gt; 方式二
        console.log(data);
    })
    2. 发布事件：emitter.emit(&apos;toparent&apos;, &apos;广播数据&apos;)
3. emitter.setMaxListeners(2); --&gt;设置最大的订阅个数
</code></pre><h2 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h2><pre><code>1. process对象是一个全局变量，提供了当前Node程序与系统的有关信息，还可以控制当前的Node进程
2. process.argv：获取运行node程序的命令，是一个数组
    node app.js -i  --&gt; [&apos;node命令的路径&apos;, &apos;app.js的路径&apos;, &apos;-i&apos;]
3. process.evn：环境变量相关，比如通过配置环境变量控制开发模式与生产模式的切换
    1. 在当前系统上新建一个环境变量：mode=&apos;dev&apos;
    2. 判断当前是否处于开发模式：process.env.mode == &apos;dev&apos;
4. process.exit()：结束当前进程
5. process.stdout/stdin：标准输入输出流
    1. 将数据输出到终端：process.stdout.write(&apos;hello&apos;); --&gt; console.log的底层原理
    2. 监听用户的输入：
    process.stdin.on(&apos;data&apos;, e=&gt;{ ---&gt; 可用于实现交互式的命令行，比如Vue.js的脚手架
        process.stdout.write(&apos;用户输入: &apos;, e.toString());
    })
    3. 在命令行输入内容后，还要点击 Enter键作为输入完成的信号，process.stdin才能监听到，
    所以接收到的数据其实是以回车符号结尾的；
    4. 去除Windows系统的回车符：e.toString().replace(&apos;\r\n&apos;, &apos;&apos;);
6. 移动光标的位置：process.stdout.cursorTo(x, y);
</code></pre><h2 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h2><pre><code>1. 流是一种在Node中处理流式数据的抽象接口，fs、net、http、https等模块都提供了流的实现；
2. stream约定了一些基本特性(但并没有实现)，所有实现流操作的对象都具备这些共同的特性；
2. 流的基本类型
    1. Writable：可写入数据的流，如fs.createWriteStream()
    2. Readable：可读取数据流，如fs.createReadStream()
    3. Duplex：可读又可写的流，又称为双工数据流
    4. Transform：可修改的双工数据流，在读写过程中可修改/转换
3. Writable：write()、end()、setDefaultEncoding()
4. Readable：setEncoding()、read()、pipe()、pause()、resume()
</code></pre><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><pre><code>1. Buffer：缓冲区，类似于数组，长度固定，专门用于操作二进制数据
2. v8是JS引擎，内存有限，32位操作系统约0.7G，64位约为1.4G，Node使用的也是v8引擎
3. 虽然v8有内存限制，但Buffer实际上是对底层内存的直接操作，它的大小不计入v8的内存开销；
4. let buf = new Buffer(10); --&gt; 10个字节的Buffer，但Buffer的所有构造函数已废弃
    1. 虽然Buffer存储的是二进制数据，但显示时都是以十六进制的形式(二进制太长了)；
    2. Buffer操作的是底层内存，大小一旦确定，就会分配一段连续的内存空间，不允许修改大小；
    buf[0]=88; --&gt; 十进制转为十六进制：58，也可以直接赋值十六进制
    buf[11]=255; --&gt; 角标越界不会报错，但不会有变化
    3. Buffer中每个元素的范围：00-ff，即十进制的0-255，二进制的一个字节；
    buf[2]=556; --&gt; 超过一个字节的最大数值255，会舍弃高位，只存储低8位：2c
    4. 控制台默认打印的数字都是十进制，buf[0].toString(16)表示以十六进制输出；
    5. buf.tostring()：将Buffer中的二进制数据转为字符串。
5. Buffer.alloc(size[, fill, encoding])：创建size个字节的Buffer对象
    1. fill和encoding都是可选参数，encoding默认为utf8
    2. 不指定fill时，新创建的Buffer默认用 0 填充。
6. Buffer.allocUnsafe(size)：不安全的Buffer，Buffer中可能含有敏感数据；
    1. Buffer.alloc()的默认值都是00，也即分配内存时会清空该内存中的原数据；
    2. Buffer.allocUnsafe()在分配内存时不会清空内存中原数据，所以默认值可能不是00；
7. Buffer.from(str|array|buffer)：将字符串/数组/buffer数据转化为一个新的Buffer
    1. var str=&quot;Hello&quot;; --&gt; str.length：字符串长度
    2. var buf = Buffer.from(str); --&gt; buf.length：占用内存的字节大小
    3. 英文字符串的每个字符占一个字节，所以str.length==buf.length
    4. 查看字符串的字节长度：Buffer.byteLength(&apos;你好&apos;);
8. Buffer.concat(array)：合并array中的Buffer，再转为一个新的Buffer
9. 比较两个Buffer的值是否完全相等：buf1.equals(buf2);
</code></pre><h2 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h2><pre><code>1. fs：文件系统，node的核心模块，var fs = require(&quot;fs&quot;);
    1. fs模块中的所有操作都可以选择同步/异步，同步会阻塞程序的执行，而异步则不会；
    2. 在fs中，带有Sync的都是同步方法，不带的都是异步方法，且异步方法带有回调函数。
2. open()/openSync()：打开文件，返回一个文件的描述符，通过该描述符进行文件操作；
    1. fs.openSync(path, flags, mode);  fs.open(path, flags, mode, callback);
    2. path：文件路径； flags：操作类型r/w； mode：设置文件的操作权限，一般不传；
    3. callback回调2个参数arguments：function(err, fd){ ... }
    4. err：错误对象，没有错误则为null； fd：文件描述符；
    5. Node的设计就是错误优先，所以回调函数的第一个参数是错误对象。
3. write()/writeSync()：向文件中写入内容；
    1. fs.writeSync(fd, string, position, encoding);
    2. fd：文件描述符； string：写入的内容，如果不是字符串，则被强制转为字符串；
    3. position：写入指针的位置，默认为0； encoding：写入的编码，默认为utf-8；
    1. fs.writeSync(fd, string, position, encoding, callback);
    2. callback回调3个参数：function(err, written, string){ ... }
    3. written：传入的字符串被写入的字节数； string：被写入的内容；
4. close(fd, callback)/closeSync(fd)：关闭文件操作；
    1. fd：文件描述符，表示要关闭的文件操作；
    2. callback只回调一个参数：function(err){ ... }
5. fs的写入过程：数据--&gt;Buffer--&gt;stream，为了提高效率，数据先写入缓冲区，再一次性写入文件
6. 异步的错误在回调函数中，而同步的错误只能用 try-catch 捕获
</code></pre><h3 id="简单读写"><a href="#简单读写" class="headerlink" title="简单读写"></a>简单读写</h3><pre><code>1. 简单文件写入：fs.writeFile()/fs.writeFileSync()
    1. writeFile(file, data, options, callback)
    2. file：操作的文件路径； data：待写入的数据； options：可选，设置写入动作；
    3. callback回调一个参数：function(err) {}，而且不用手动关闭操作流；
    4. options：对象，包括encoding(默认utf-8)，mode(默认0o66)，flag(默认w)
    fs.writeFile(file, data, { flag: &apos;a&apos; }, callback); --&gt; 表示向文件中追加写入
    5. data可以是字符串或Buffer，如果data是一个buffer，options中的encoding是无效的；
    6. 如果文件的路径使用绝对路径：
    fs.writeFile(&quot;C:/workplace/test.txt&quot;, ...);
    fs.writeFile(&quot;C:\\workplace\\test.txt&quot;, ...); ==&gt; 两者等效；
    7. 简单文件写入的原理：仍是使用write()/writeSync()
2. 流式文件写入：用于写入大文件，可以分多次写入文件
    1. 同步/异步/简单文件写入都不适合大文件的写入，性能较差，容易导致内存溢出；
    2. var ws = fs.createWriteStream(path, options); --&gt;创建一个写入流；
    3. ws.write(str); --&gt;写入数据
    4. ws.end(); --&gt;等待写入完成再关闭流，不能用ws.close()，会造成流中的数据丢失；
    5. ws.on(&quot;事件名&quot;, function)：绑定一个长期有效的事件；
    6. ws.once(&quot;事件名&quot;, function)：绑定一个一次性的事件，触发一次之后自动失效；
    ws.once(&quot;open&quot;, function(){ --&gt; 监听写入流的打开事件
        console.log(&quot;流打开了...&quot;)
    });
    ws.once(&quot;close&quot;, function(){ --&gt; 监听写入流的关闭事件
        console.log(&quot;流关闭了...&quot;)
    });
3. 简单文件读取：fs.readFile()/fs.readFileSync()
    1. fs.readFile(path, options, callback)
    2. callback：function(err, data)，data表示读取到的内容，是一个Buffer对象；
    3. data之所以是一个Buffer对象，是因为读取的可能是二进制文件，如图片、音频；
    4. data.toString()的方式只适用于字符串，对二进制数据会乱码。
    fs.readFile(&quot;an.jpg&quot;, function(err, data){
        if(!err) {
            fs.writeFile(&quot;pn.jpg&quot;, data, function(err){ ... });
        }
    });
4. 流式文件读取：用于读取大文件，可以分多次读取文件
    1. var rs = fs.createReadStream(path, options); --&gt;创建一个读取流；
    2. 读取一个可读流中的数据，必须为可读流绑定一个data事件，绑定后会自动开始读取；
    rs.on(&quot;data&quot;, function(data){ --&gt; 读取过程不是一次性事件
        //data也是一个Buffer对象
    });
    3. 管道：rs.pipe(ws); --&gt; 可读流rs自动将数据传递给写入流ws，不需要绑定事件
</code></pre><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><pre><code>1. fs.exists(path, callback)/existsSync(path)：文件/目录是否存在
    1. fs.exists()：已废弃，被fs.stat()/fs.access()替代；
2. fs.stat(path, callback)/statSync(path)：获取文件信息，类似文件/目录的属性信息
    1. callback：function(err, stats) --&gt; stats对象中保存了文件的状态信息
    2. stats.size：获取文件的大小；
    3. stats.isFile()/isDirectory()：是否是一个文件/文件夹。
3. fs.unlink(path, callback)/unlinkSync(path)：删除文件；
4. fs.readdir(path, options, callback)/readdirSync(path, options)
    1. 读取一个目录的结构，获取指定目录下的所有文件/文件夹；
    2. callback：function(err, files) --&gt; files是一个数组，文件/文件夹的名称
5. fs.truncate(path, len, callback)/truncateSync(path, len)
    1. 截断文件，将文件修改为指定的大小，len表示字节大小，将文件大小设置为len
6. fs.mkdir(path, mode, callback)/mkdirSync(path, mode)：创建目录，但不会递归创建
7. fs.rmdir(path, callback)/rmdirSync(path)：删除目录，但不能删除非空目录
8. fs.rename(old, new, callback)：重命名/剪切
9. fs.watchFile(filename, options, listener)：监视文件的修改
    1. 内部原理是一个定时机制，定时检查文件中的内容；
    2. options：{ persistent: true, interval: 5007 }，默认5s检查一次；
    fs.watchFile(&quot;test.txt&quot;, {interval:1000}, function(curr, prev) {
        //curr是修改后的状态，prev是修改前的状态，它们都是stats对象
    });
10. fs.watch()：可以监听目录的状态变化
</code></pre><h3 id="fs-Promise"><a href="#fs-Promise" class="headerlink" title="fs Promise"></a>fs Promise</h3><pre><code>1. 在node10.0之后，fs模块中引入了Promise，文件操作不再区分异步和同步，而是返回Promise对象
2. const fsPromises = require(&apos;fs&apos;).promises;
</code></pre><h2 id="UDP之dgram"><a href="#UDP之dgram" class="headerlink" title="UDP之dgram"></a>UDP之dgram</h2><pre><code>1. dgram模块：提供UDP数据包socket的实现，const dgram = require(&apos;dgram&apos;);
2. 服务端
    1. 创建socket对象
    const server = dgram.createSocket(); --&gt; 静态方法创建socket对象
    const server = new dgram.Socket(type[, callback]);
    2. type：udp4 =&gt;IPV4、udp6 =&gt;IPV6;  callback：接收到数据的回调;
    3. 绑定IP和端口号
    server.bind(3000, &apos;127.0.0.1&apos;);
    4. 监听事件：close(关闭)、error(发生错误)、listening(启动监听)、message(收到消息)
    server.on(&apos;listening&apos;, ()=&gt;{ console.log(&apos;启动成功...&apos;); });
    server.on(&apos;message&apos;, (data) =&gt; {
        //网络传输的数据是二进制的，在node上是一个buffer对象
    });
    5. 关闭socket：server.close(callback);
3. 客户端
    1. let client = dgram.createSocket(&apos;udp4&apos;);
    2. 发送数据：client.send(&apos;Hello Server&apos;, 3000, &apos;127.0.0.1&apos;);
</code></pre><h2 id="TCP之net"><a href="#TCP之net" class="headerlink" title="TCP之net"></a>TCP之net</h2><pre><code>1. net模块：提供了创建基于流的 TCP/IPC 服务器和客户端的异步网络API
2. const net = require(&apos;net&apos;);
3. 服务端
    let server = new net.Server(); / net.createServer();
    1. 启动监听：server.listen(3000, &apos;127.0.0.1&apos;); --&gt; IP默认为0.0.0.0
    2. server.listen(3000, &apos;0.0.0.0&apos;); --&gt; 监听当前设备上的所有IP收到的3000端口消息
    4. 一台电脑可能有多个网卡(对应多个IP)，但端口号是唯一的，0.0.0.0 类似于通配符 *
    2. 连接事件、发送数据
    server.on(&apos;connect&apos;, (socket) =&gt; { --&gt; 回调的socket表示当前客户端的socket对象
        console.log(&apos;有客户端连接...&apos;);
        socket.write(&apos;hello client&apos;); --&gt; 向客户端写(发送)数据
        socket.on(&apos;data&apos;, (data) =&gt; { --&gt; 监听客户端发来的数据
            ...
        });
    });
    3. 获取客户端的IP和端口号：socket.remoteAddress，socket.remotePort
4. 客户端
    1. 创建客户端：new net.Socket(); / net.createConnection();
    let client = net.createConnection(3000, &apos;127.0.0.1&apos;);
    2. 监听服务器发来的数据
    client.on(&apos;data&apos;, data =&gt; {
        ...
    });
    3. 向服务器端发送数据：client.write(&apos;hello server&apos;);
5. socket数据的分包
    1. 当一个数据包很大时，并不会一次性传输，而是分多次，也就是说，data事件会被触发多次；
    2. 服务端告诉客户端数据传输完成：socket.end();
    server.on(&apos;connect&apos;, (socket) =&gt; {
        let data = fs.readFileSync(&apos;./a.mp4&apos;); --&gt; 读取一个大文件
        socket.write(data); --&gt; 开始传输，socket内部会分包传输
        socket.end(); --&gt; 通知客户端传输完成
    })
    3. socket.end(); 一旦执行，本次连接也会终止，客户端断开连接；
    4. 客户端收到数据传输完成的事件：client.on(&apos;end&apos;, () =&gt; { ... });
    5. 客户端需要把每次收到的数据(buffer)，拼接成一个buffer对象，才是一个完整的数据包。
    let list = [];
    client.on(&apos;data&apos;, chunk =&gt; {
        list.push(chunk);
    });
    client.on(&apos;end&apos;, () =&gt; { --&gt; 数据传输完成，连接已断开
        let data = Buffer.concat(list); --&gt; 把多个buffer对象合并为一个buffer
        fs.writeFile(&apos;./b.mp4&apos;, data, err=&gt;{});
    });
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/07/02/EventLoop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/02/EventLoop/" itemprop="url">EventLoop</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-02T00:00:00+08:00">
                2018-07-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><pre><code>1. EventLoop：事件循环，node单线程、异步编程的核心
2. process.nextTick
3. setTimeout()/clearTimeout()
4. setInterval()/clearInterval()
5. setImmediate()/clearImmediate()
</code></pre><h3 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h3><pre><code>1. node代码都会进入执行栈，主线程不断地轮询执行栈中的任务；
</code></pre><p><img src="https://i.imgur.com/dGWpPY2.jpg" alt></p>
<pre><code>2. 解析器会区别对待执行栈中的同步任务和异步任务，并做不同处理；
3. 同步任务会直接进入主线程进行执行，而异步任务会被推入事件表中；
4. 异步任务执行完之后，其回调函数会进入事件队列中，主线程执行完同步任务、空闲下来之后，会去
   轮询事件队列，把其中的回调函数放入主线程进行执行。
</code></pre><h3 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h3><pre><code>1. 主线程空闲之后，开始查看异步任务队列，如果没有异步任务，则程序结束；
2. 如果有异步任务，主线程会进入事件循环，执行完所有的异步任务之后，程序结束。
</code></pre><p><img src="https://i.imgur.com/YY1tawg.jpg" alt></p>
<pre><code>1. 异步任务也分很多种，不同的异步任务执行的次序也是不同的；
2. 异步任务之Timer
    1. Timer阶段用于处理所有 setTimeout和setInterval 的回调函数；
    2. setTimeout的延迟时间不一定准确，如果主线程有耗时的同步任务，如alter()、for循环...
    会延迟异步回调的执行；
    3. 如果多个不同类型的异步任务同时执行完成，Timer的优先级是最高的，优先执行其回调函数。
3. 异步任务之IO
    1. Pending I/O 阶段：执行I/O回调，包括文件操作、网络操作...
    2. Idle，Prepare 阶段：内部使用
    3. Poll 阶段：轮询I/O操作，如等待AJAX是否完成，如果没有则阻塞，但会有超时和基本检测，
    不会一直阻塞；
    4. 如果Poll阶段轮询到了I/O回调，则重新进入Pending I/O阶段，执行I/O回调；
    5. 如果Poll阶段阻塞超时或者没有I/O操作，则进入Check阶段。
4. 异步任务之Check
    1. 只处理 setImmediate 的回调函数；
    2. setImmediate 是IE10的新增特性，标准的浏览器是不支持的，但NodeJs支持。
5. 异步任务之Close Callback
    1. 专门处理一些 close 类型的回调，如关闭网络连接、关闭数据库连接...
    2. Close Callback 是最后一个阶段，然后主线程会去检查是否还有异步任务，如果有，则继续
    重新轮询，否则程序结束。
</code></pre><h2 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h2><pre><code>1. 不管同步任务还是异步任务，进入主线程执行的任务又可分为宏任务和微任务，优先执行宏任务
</code></pre><p><img src="https://i.imgur.com/5Z10bBQ.jpg" alt></p>
<pre><code>1. 宏任务：主体script脚本，setTimeout，setInterval
2. 微任务：Promise，process.nextTick
3. Promise并不是属于异步任务，不会被推入事件轮询表中
    console.log(&apos;start&apos;); ---&gt; 宏任务
    setTimeout(() =&gt; { ------&gt; 异步任务EventLoop
        console.log(&apos;set timeout&apos;); ---&gt; 宏任务
    }, 0);
    new Promise(resolve =&gt; {
        console.log(111); ---&gt; 属于宏任务
        resolve();
    }).then(() =&gt; {
        console.log(222); ---&gt; 属于微任务
    }).then(() =&gt; {
        console.log(333); ---&gt; 属于微任务
    });
    console.log(&apos;end&apos;); ---&gt; 宏任务
4. 执行过程：同步代码 =&gt;宏任务 --&gt; 微任务 ==&gt; Event Loop(异步任务) =&gt;宏任务 --&gt; 微任务
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/07/01/nodejs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/01/nodejs/" itemprop="url">nodejs</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-01T00:00:00+08:00">
                2018-07-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="NodeJs"><a href="#NodeJs" class="headerlink" title="NodeJs"></a>NodeJs</h2><pre><code>Node.js：一个能够在服务器端运行JavaScript的开源代码、跨平台JavaScript运行环境；
    1. 采用Google开发的V8引擎运行JS代码，使用事件驱动、非阻塞、异步I/O模型等技术提高性能，
    可优化应用程序的传输量和规模；
    2. Node大部分基本模块都是采用JS编写的，由一个高性能的Web服务器形成一个Node生态环境。
1. Node的服务器是单线程的
    1. Node处理请求时是单线程，但在后台拥有一个I/O线程池；
    2. Node有专门处理请求的线程，还有专门处理I/O的线程。
2. JS没有模块的概念，而Node遵循CommonJS规范，将模块划分为：核心模块、文件模块
    1. 核心模块：node引擎提供的模块，可以直接引用，不用指定模块路径；
    2. 文件模块：第三方模块，文件模块的标识就是文件的路径；
    3. require()：引入外部模块的函数，返回值就是引入模块的对象；
    4. 如果是相对路径，必须以&quot;./&quot;或&quot;../&quot;开头，如require(&quot;./req.js&quot;)，后缀名&apos;.js&apos;可省略
3. 模块的作用域：在Node中，每一个JS文件中的JS代码都独立运行在一个函数中，而不是全局作用域
    1. 模块之间不能直接共享数据，即require()返回的对象无法访问模块内的变量/方法；
    2. 在执行的模块中使用：console.log(arguments.callee + &quot;&quot;);
    会发现，当前正在执行的模块代码被node放在了一个函数中：
    function (exports, require, module, __filename, __dirname) {
        //模块的JS代码
    }
    1. exports：用于将变量/函数暴露到外部的对象，每个模块文件中都有一个exports对象；
    2. require：用来引入外部模块的函数，只要是作为exports的属性/方法，该函数返回的对象都可
    以直接访问：req.js：exports.x = &quot;Hello&quot;; exports.fn = function(){}
    3. 其他模块中引用req.js模块：
    var r = require(&quot;./req&quot;); ==&gt; r: {x: &apos;Hello&apos;, fn: [Function]}
    r.fn(); ==&gt;执行模块中的方法，r.x; ==&gt;获取模块中的变量
    4. module：每个模块都有一个内置的对象属性module，包含了当前模块所拥有的一些信息；
    5. module的属性信息：id(模块的唯一标识)、filename(文件的路径名)、loaded、children、
    paths、exports、parent、require() --&gt; require()也来自module对象
    6. exports是module的属性，即module也可以用于导出：module.exports.x = &quot;Hello&quot;;
    7. __filename：当前模块的绝对路径； __dirname：当前模块所在目录的绝对路径。
4. exports与module.exports的区别：
    1. exports只是一个指向module.exports的引用，module.exports才是一个对象；
    exports.a=10;  ---&gt; 等同于：module.exports.a=10;
    2. 真正具有向外暴露能力的是module.exports，而不是exports，比如exports={ a: 10 }
    --&gt;exports指向了一个新的对象，不再指向module.exports，也就失去了可以向外暴露的能力
    3. exports只能通过 exports.x 的方式向外暴露，而module.exports={ a: 10 }可以暴露
    4. require()得到的其实也是module.exports对象的引用。
5. 在浏览器端的JS中，全局变量/函数都作为window对象的属性/方法保存的；在node中，也有类似于
   window作用的全局对象：global
    1. 所谓node环境，也就是ECMAScript，global是ECMAScript标准提供的；
    2. 本质上，浏览器端的window其实就是扩展自ECMAScript中的global
6. 包：package，由包结构和包描述文件组成，其实就是一个压缩文件，解压还原为目录；
    1. 包结构：用于组织包中的各种文件；
    2. 包描述文件：描述包的相关信息，以供外部读取分析；
    3. 目录文件包括：描述文件(package.json)、可执行二进制文件(bin)、js代码(lib)
    doc(文档)、test(单元测试)，其中package.json是必需的；
    4. package.json是一个JSON格式的文件，不能有任何注释，它是配置文件。
</code></pre><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><pre><code>npm：Node Package Manager，node的包管理器，用于node的第三方模块的发布、安装、依赖等；
1. 借助npm，Node与第三方模块之间形成了一个很好的生态系统；
2. npm search 包名：搜索模块包；
3. npm install/i 包名：在当前目录安装模块包；
    1. 执行：npm init --&gt; 当前目录会生成一个package.json
    2. 安装依赖包，如npm install math：math包会在安装到当前目录下；
    3. 在当前目录下会生成一个node_modules目录，存放安装的模块，使用这些模块时，不需要指定
    模块路径：var math = require(&quot;math&quot;);
    4. npm i 包名 --save：在项目或模块包的 package.json 中会生成相关模块的依赖信息；
    npm i math --save ===&gt; package.json -&gt; &quot;dependencies&quot;: { &quot;math&quot;: &quot;0.0.3&quot; }
    5. 依赖信息的作用：将当前目录(即项目)上传到开源站时，并不会上传node_modules目录，因为
    会影响上传/下载的速度，而且不能保证依赖的模块包一定是最新版本；那么下载并使用该项目后，
    也就不能直接运行，需要先在该项目的根目录下执行：npm install =&gt;安装依赖
4. npm install/i 包名 -g：全局模式安装模块包，一般都是一些工具；
    1. npm root -g：查看全局安装的根目录；
    2. npm list：查看当前目录下已安装的node包；
    3. npm info 包名：查看包的所有版本；--&gt; npm i jquery@1.8.2：指定版本安装。
5. npm update：升级依赖包
6. npm remove/r 包名：删除模块包，同理，--save也会删除package.json中的依赖信息；
7. 镜像服务器：npm服务器不在国内，所以npm下载时可能会很慢，镜像服务器的作用就是把npm服务器
   的数据拷贝一份，通过国内的镜像服务器下载模块包，就会很快；
    1. 淘宝NPM镜像：同步npm服务器数据的频率为10分钟，定制的cnpm代替默认的npm命令；
    2. npm install -g cnpm --registry=https://registry.npm.taobao.org
    3. cnpm与npm的命令一模一样，但下载的模块目录结构可能不同，也是为了避免相互覆盖。
8. require(&quot;math&quot;)的查找路径：当前目录的node_modules--&gt;上一级目录的node_modules
    --&gt; 再上一级目录的node_modules --&gt; ... --&gt; 磁盘根目录 --&gt; 仍没有则报错
</code></pre><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><pre><code>1. package.json中的一些节点
    1. name：包名
    2. version：版本，x.x.x
    3. main：包的入口主文件
    4. scripts：自定义脚本，通过 npm run 脚本名 执行脚本定义的命令
    5. dependencies：生产环境下必需的依赖包
    6. devDependencies：只在开发环境下使用的依赖包
2. dependencies 与 devDependencies 中的依赖包版本：
    1. ^2.3.4：表示在执行 npm install 时，第一位版本号不变，后两位取最新的；
    2. ~2.3.4：前两位不变，最后一位取最新；
    3. *2.3.4：表示全部取最新的。
</code></pre><h2 id="开发方向"><a href="#开发方向" class="headerlink" title="开发方向"></a>开发方向</h2><pre><code>1. GUI：Graphical User Interface，图形用户界面，如office、vscode、浏览器、播放器...
2. CLI：Command Line Interface，命令行界面，也称为CUI(字符用户界面)
    1. 相比于GUI，CLI更节省计算机资源，一般用于服务器环境，如babel、vue-cli、webpack...
    2. Node第三方命令行框架：commander、chalk、inquirer
    3. commander：命令行开发工具
    4. chalk：命令行样式风格控制器
    5. inquirer：交互式命令行工具
3. Server：提供服务，如Web Server、IM...
</code></pre><h2 id="JS模块化"><a href="#JS模块化" class="headerlink" title="JS模块化"></a>JS模块化</h2><pre><code>模块化规范：CommonJs、AMD、CMD、ES6
1. CommonJs规范
    1. 在服务器端：模块的加载是运行时同步加载的；
    2. 在浏览器端：模块需要提前编译打包处理，因为浏览器不识别 require() 的引入模块方式；
    3. 暴露模块的两种方式：module.exports = value，exports.xxx = value
    4. 引入模块：let xxx = require(&apos;xxx&apos;);
    5. 服务器端的实现：Node.js
    6. 浏览器端的实现：Browserify，用于对js模块的提前打包处理，&lt;script&gt;引入处理后的js
2. AMD规范：专门用于浏览器端，模块的加载是异步的
    1. CommonJs最初是基于服务器端的Js模块化规范，AMD针对浏览器端出了一套JS模块化规范之后，
    CommonJs才有了基于浏览器端的实现；
    2. 暴露模块--&gt;定义没有依赖的模块：define(function(){ return 模块 })
    3. 暴露模块--&gt;定义有依赖的模块：
    define([&apos;module1&apos;, &apos;module2&apos;], function(m1, m2){ --&gt;回调的形参与依赖的模块相对应
        return 模块
    })
    4. 浏览器端的实现：RequireJs，使用时，&lt;script&gt;引入require.js，并指定主模块入口
    &lt;script data-main=&quot;js/main.js&quot; src=&quot;js/libs/require.js&quot;&gt;&lt;/script&gt;
    5. 在主模块中声明要引入的其他模块，这样只用一个&lt;script&gt;就能引入所有需要的模块
3. CMD规范：CMD是阿里的JS规范，也是专门用于浏览器端，后来出售给了国外，很少用；
    1. CMD规范其实就是把CommonJs和AMD进行结合，定义模块使用AMD，暴露模块使用CommonJS；
    2. 浏览器端的实现：SeaJs，使用时，一个&lt;script&gt;引入sea.js，一个&lt;script&gt;引入主模块；
    &lt;script type=&quot;text/javascript&quot; src=&quot;js/libs/sea.js&quot;&gt;&lt;/script&gt;
    &lt;script type=&quot;text/javascript&quot;&gt; seajs.use(&apos;./js/modules/main&apos;) &lt;/script&gt;
4. ES6规范：依赖模块需要编译打包处理
    1. 导出模块：export，引入模块：import，Vue.js2.0就是基于ES6规范
    2. 浏览器端的实现：Babel、Browserify
    3. Babel：有的浏览器不支持ES6的语法，Babel可以将ES6编译为ES5
    4. Browserify：用于编译打包JS
    5. 常规暴露：export { fun1, fun2 }，引入：import {fun1, fun2} from &apos;./module&apos;
    6. 默认暴露：可以暴露任意数据类型，而且暴露的数据与引入的数据是一致的；
    export default () =&gt; { ... } ---&gt; 暴露一个方法
    引入： import fun from &apos;./module&apos; ---&gt; fun就是module.js中默认暴露的方法
5. 自动化打包工具：webpack、Grunt、Gulp，用于简化编译打包JS/Sass/Less、压缩、合并等过程
</code></pre><h2 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs"></a>CommonJs</h2><pre><code>1. CommonJs规范主要是为了弥补JS没有标准的缺陷，终极目标是提供一个类似Python、Ruby和Java的
   标准库，而不只是停留在小脚本程序的阶段；
2. CommonJs就是模块化的标准，nodeJs就是CommonJs的一种实现；
3. NodeJs中的模块分为两类：
    1. NodeJs本身提供的核心模块，如http、url、fs，可以直接引入使用；
    2. 自定义模块：依照CommonJs中的规定，实现的第三方模块。
</code></pre><h3 id="自定义模块的规定"><a href="#自定义模块的规定" class="headerlink" title="自定义模块的规定"></a>自定义模块的规定</h3><pre><code>1. 一个JS文件作为一个模块，通过 exports 或者 module.exports 暴露属性/方法；
2. 自定义模块的查找过程：
    1. 如果当前目录下没有，则去当前目录下的node_modules目录中查找；
    var foo=require(&apos;foo&apos;) --&gt; ./node_modules/foo.js
    2. 如果node_modules目录中没有foo.js，但有foo文件夹，且foo.js在foo目录中；
    var foo=require(&apos;foo/foo.js&apos;) --&gt; ./node_modules/foo/foo.js
3. 如果希望 require(&apos;foo&apos;) 能直接引用 ./node_modules/foo/foo.js
    1. 在foo目录下执行 npm init --yes，生成package.json文件，--yes表示强制生成；
    2. require(&apos;foo&apos;)在node_modules中查找到foo目录，那么就查找foo/package.json，
    如果不存在，则提示没有foo.js模块；
    3. 如果package.json存在，则查找main节点，此时的foo目录被视为一个模块，main节点表示
    模块的入口，也就是真正暴露的模块；
    4. 如果main节点指向 foo.js，则查找foo/foo.js，如果指向 index.js，则require(&apos;foo&apos;)
    实际引用的是foo/index.js
4. 通过 npm 下载第三方模块时，也会自动下载到node_modules目录中，下载的其实也是目录；
    1. npm i md5-node --save 与 --save-dev：都会把md5-node写入package.json中；
    2. --save：同-S，写入到package.json中的 &quot;dependencies&quot; 中；
    3. --save-dev：同-D，写入到package.json中的 &quot;devDependencies&quot; 中；
5. &quot;dependencies&quot; 与 &quot;devDependencies&quot; 的区别：
    1. 正常执行 cnpm install 时，dependencies和devDependencies中的模块都会下载；
    2. --save：运行时依赖，如vue、react等，没有这些依赖，打包的项目无法运行；
    3. --save-dev：开发时依赖，即开发环境所需的依赖，如构建工具，测试工具等等，打包发布时
    不需要这些工具，如less-loader、webpack、babel
</code></pre><h3 id="模块的加载机制"><a href="#模块的加载机制" class="headerlink" title="模块的加载机制"></a>模块的加载机制</h3><pre><code>1. 模块的分类：文件模块、文件夹模块、核心模块
    1. 文件模块其实就是一个JS文件，通过 module.exports 暴露模块的功能；
    2. 文件夹模块可分为 node_modules Folders 和 global Folders
    3. global folders 是全局模块，由node的环境变量NODE_PATH控制所在路径。
2. 路径加载模式：require(&apos;./m3&apos;)引入模块时，以 ./、../、/ 开头，表示路径模块加载模式
3. 非路径加载模式：require(&apos;m3&apos;)在引入时不指定模块的路径
    1. module.paths是一个数组，保存的是查找此模块的路径列表；
    2. 核心模块是node的内置模块，require()引用时也不需要指定路径；
    3. 但是，如果自定义的模块名与核心模块名相冲突，则默认加载核心模块。
4. 模块文件的后缀名处理机制：require(&apos;./m3&apos;) --&gt; m3 -&gt; m3.js -&gt; m3.json -&gt; m3.node
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/06/09/JS-ES6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/09/JS-ES6/" itemprop="url">JS-ES6</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-09T00:00:00+08:00">
                2018-06-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><pre><code>1. 声明变量：let、const
    1. let：块级作用域，不能重复声明，不会预处理，不存在变量提升；
    2. const：与let类似，但它定义的是常量，不能修改；
2. 变量的结构解析(解构赋值)：从对象/数组中提取数据，并赋值给一个/多个变量；
    1. 对象：let obj = { name: &apos;Mack&apos;, age: 12 }
    let {name, age} = obj; --&gt;变量名必须与对象中的属性名保持一致，位置可以任意排列
    console.log(name, age); --&gt; name=&apos;Mack&apos;, age=12
    let {name} = obj; --&gt; 需要哪些属性，就获取哪些属性
    2. 数组：let arr = [ 1, 3, 5, false, &apos;hello&apos; ]
    let [ a, b ] = arr; --&gt; 变量值与位置有关，与数组的下标对应
    let [,,, a, b] = arr; --&gt; a=false, b=&apos;hello&apos;
3. 模板字符串：``和${xxx}
    1. `` 是模板字符串的标识，${xxx} 是变化的部分，简化字符串的拼接
    2. let str = `My name is ${obj.name}`  --&gt; &apos;My name is Mack&apos;
4. 对象属性/方法的简写方式：let name = &apos;Mack&apos;
    let obj = { name,  ---&gt; 等同于 name: name，同名属性可以省略
        getName() { ... }, --&gt; 等同于 getName: function() { ... }
    }
5. 形参默认值：function test(x=1, y=2, z) { ... }
</code></pre><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><pre><code>1. 箭头函数：(arg1, arg2,) =&gt; { ... }，类似于lambda表达式
    1. 无参数：let fun = () =&gt; console.log(&apos;Hello JS&apos;);
    fun(); --&gt; fun指向箭头函数，fun()调用箭头函数
    2. &quot;=&gt;&quot;后是单条语句时，可省略&quot;{}&quot;，且该语句执行的结果会作为函数的返回值；
    3. 一个参数：let fun = a =&gt; console.log(a);
    4. 多个参数：let fun = (a, b) =&gt; console.log(a, b);
    5. 多条语句时，&quot;{}&quot;不能省略，函数的返回值仍默认为undefined
    let fun = () =&gt; {
        return &apos;Hello World&apos;;  --&gt; 手动指定返回值
    }
2. 箭头函数的this：
    1. 箭头函数没有自己的this，它的this不是调用时决定的，而是在定义时所处的环境决定的；
    2. 如果箭头函数直接定义在一个对象/函数中，那么箭头函数的this就是该对象/函数的this，
    否则，箭头函数的this指向window；
    3. 也就是说，箭头函数的this取决于箭头函数所定义的外层空间；
    element.onclick = function() { ...// this就是element对象 }
    element.onclick = () =&gt; {
        // 箭头函数定义在全局作用域，也即定义在window中，那么this指向window
    }
3. 可变参数：...rest，用于取代arguments
    1. arguments只是类似于数组，但并不具备数组的方法，如forEach()
    2. ...rest只接收多余的实参，而且是一个数组；
    function(a, b, ...rest) { --&gt; 必须放在参数的最后位置
        rest.forEach((item, index) =&gt; { ... }) --&gt; 遍历多余参数
    }
    3. 扩展应用-三点运算符：let arr = [2, 3, 4];
    let arr2 = [1, ...arr, 5] --&gt; [1, 2, 3, 4, 5]
    console.log(...arr2) --&gt; 1 2 3 4 5，三点运算符会自动遍历数组元素
    4. 三点运算符还可以浅拷贝复制数组和对象
    let copyArr = [...arr]
    let obj = { name:&apos;Mack&apos; } ---&gt; let copyObj = { ...obj }
</code></pre><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><pre><code>1. Promise对象：表示未来某个将要发生的事件，通常是一个异步操作；
2. Promise可以将异步操作以同步的方式表达出来，避免了层层嵌套的回调(回调地狱)；
3. 使用Promise：Promise是ES6的一个构造函数
    1. 创建Promise对象：
    let promise = new Promise((resolve, reject) =&gt; {
        //Promise为初始化状态：pending
        ...... //执行异步操作
        if(异步操作成功) { resolve(value); } --&gt;修改Promise为成功状态：fullfilled
        else { reject(errMsg); } --&gt; 修改Promise为失败状态：rejected
    });
    2. 调用Promise的then()
    promise.then(result =&gt; { --&gt;执行resolve()，则回调then()的第一个函数
            console.log(result);
        }, errMsg =&gt; {  --&gt; 执行reject()，则回调then()的第二个函数
            console.log(errMsg);
        }
    ) --&gt; 回调参数result、errMsg分别是resolve()、reject()传递的value、errMsg
    3. 封装AJAX请求：
    fuction getNews(url) {
        let promise = new Promise((resolve, reject) =&gt; {
            let http = new XMLHttpResponse();
            http.onreadystatechange = function() {
                if(http.readyState!==4) return;
                if(http.status == 200) {
                    resolve(http.responseText); --&gt;请求成功，修改状态
                } else {
                    reject(&apos;暂时没有数据&apos;); ---&gt;请求失败，修改状态
                }
            };
            http.open(&apos;GET&apos;, url);  http.send(); --&gt;发送请求
        })；
        return promise;
    }
    getNews(&apos;http://&apos;).then(res =&gt; { ······
            return getNews(res.url); --&gt;发送第二次AJAX请求，必须返回一个
        }, error =&gt; { ······ }   --------&gt; Promise对象，then()可以链式回调;
    ).then(res =&gt; {  ----&gt; 回调第二次AJAX的结果
        ······
    }, error =&gt; { ······ });
</code></pre><h2 id="Symbol属性"><a href="#Symbol属性" class="headerlink" title="Symbol属性"></a>Symbol属性</h2><pre><code>1. ES5中对象的属性名都是字符串，容易重名，污染环境；
2. Symbol是ES6新增的一种数据类型，它对应的值是唯一的；
3. 不能与其他数据计算，包括字符串拼接，for-in/for-of不会遍历Symbol属性；
    let sym = Symbol();  --&gt; Symbol不是构造函数，不用new创建
    let obj = { name: &apos;Mack&apos; }
    obj[sym] = &apos;Hello&apos;; --&gt; 为对象添加Symbol属性，其属性值为&apos;Hello&apos;
4. 创建Symbol时还可以传递参数，作为Symbol的标识；
    let sym = Symbol(&apos;Hello&apos;)
    const SYM = Symbol(&apos;key&apos;) ---&gt; 定义为常量
5. ES6还提供了11个内置的Symbol值，指向内部使用方法，如Symbol.iterator
</code></pre><h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><pre><code>1. Iterator：一种接口机制，为各种不同的数据结构提供统一的访问机制；
2. ES6提供了一种新的遍历方式：for-of，Iterator主要供for-of消费；
3. 模拟Iterator的原理：let arr = [1, 4, 27, &apos;abc&apos;]
    function myIterator(arr) {
        let index = 0;  ---&gt; 记录指针的位置
        return {  -----&gt; 遍历器对象
            next: function() {
                return index &lt; arr.length ? {value:arr[index++], done:false}
                 : { value: undefined, done: true }
            }
        }
    }
    let iter = myIterator(arr);
    console.log(iter.next()); --&gt; { value: 1, done: false }
    ......
    console.log(iter.next()); --&gt; { value: &apos;abc&apos;, done: false }
    console.log(iter.next()); --&gt; { value: undefined, done: true }
4. 将Iterator接口部署到指定的数据类型上，则可以用for-of遍历；
    1. JS的原生数据类型中具备Iterator接口的有：String、Array、arguments、Set、Map
    2. for(let i of [1,2,3]) { ...//i就是每次循环的元素 }
5. Symbol.iterator
    1. String、Array、arguments等对象具备Iterator接口，但普通对象并没有Iterator接口，
    所以不能使用for-of遍历；
    2. 为普通对象添加Symbol.iterator属性，指向其默认遍历器方法，for-of就能遍历该对象；
    3. Symbol.iterator属性添加给对象，就等同于为该对象部署了Iterator接口；
    let data = {
        [Symbol.iterator]: function() {
            let index = 0; ---&gt; 记录指针的位置
            return { ... } ---&gt; 遍历器对象
        }
    }
    4. 三点运算符和解构赋值，默认调用的就是Iterator接口。
</code></pre><h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><pre><code>1. Generator函数：ES6提供的解决异步编程的方案之一；
    function* test() {
        yield &apos;test1&apos;
        yield &apos;test2&apos;
    }
2. 调用Generator函数，返回一个指针对象，由该对象调用next()，遇到yield返回；
    let gen = test();
    console.log(gen.next());  --&gt; {value: &quot;test1&quot;, done: false}
    console.log(gen.next());  --&gt; {value: &quot;test2&quot;, done: false}
    console.log(gen.next());  --&gt; {value: undefined, done: true}
3. 为普通对象添加Symbol.iterator属性，指向一个Generator函数；
    let obj = { name: &apos;Mack&apos; }
    obj[Symbol.iterator] = function* gen() { --&gt;为对象部署Iterator接口
        yield 1
        yield 2
    }
    for(let i of obj) {  ---&gt; 具备Iterator接口的对象，for-of都可以遍历
        console.log(i)  --&gt; 1 2
    }
4. let result = yield &apos;test1&apos;  --&gt; yield的返回值默认是undefined
5. next(arg)：参数arg会先赋值给当前指针所在的yield，再向下移动；
    function getNews(url) {
        $.get(url, function(data) { --&gt; jQuery-GET请求成功的回调
            HTTP.next(data.url);  ---&gt; 获取新的URL，发送第二次请求
        });
    }
    function* sendHttp() {
        let url = yield getNews(&apos;http://...&apos;) --&gt; 第一次next()
        yield getNews(url)  --&gt; 第二次next()，需要传递参数
    }
    let HTTP = sendHttp(); ---&gt; 获取遍历器对象
    HTTP.next();  --&gt; 发送第一次GET请求
</code></pre><h2 id="async"><a href="#async" class="headerlink" title="async"></a>async</h2><pre><code>1. async函数：真正意义上解决回调地狱的问题，同步的方式表达异步操作；
2. async函数的本质是Generator的语法糖，源自ES2016(ES7)；
    1. async函数返回的总是Promise对象，用then()进行下一步操作；
    async function test() {  ---&gt; 函数test变成一个异步函数
        return &apos;hello async&apos;;
    }
    test().then(res=&gt;{
        console.log(res); --&gt;hello async
    })
    2. async取代Generator函数的&quot;*&quot;，await取代Generator函数的yield；
    async function test() {
        await 异步操作; --------&gt; 该异步操作总是返回一个Promise对象
        await 异步操作;
    }
    3. async函数不需要像Generator函数那样去调用next()，遇到await就会等待，当前的异步操作
    完成后，则继续向下执行。
3. async的使用方式
    1. 基本使用
    async function test() { return &apos;hello async&apos;; }
    async function exec() {
        let t = await test(); --&gt; 阻塞程序，等待异步方法test() 执行完成
        console.log(t)
    }
    2. async函数返回一个Pormise对象，await总是配合Promise使用，返回值由resolve()决定
    async function test() {
        let res = await new Promise((resolve, reject) =&gt; {
                setTimeout(() =&gt; { resolve(&apos;Mack&apos;); }, 2000);
            })
        console.log(res); --&gt; 2000ms之后打印 Mack
    }
    3. await语句默认返回undefined，resolve()可以为awiat传递参数，reject()表示异步任务
    失败，会终止继续向下执行。
4. 发送AJAX请求：
    function getNews(url) {
        return new Promise((resolve, reject) =&gt; {
            $.ajax({ method: &apos;GET&apos;, url,
                success: data =&gt; resolve(data), --&gt; GET请求成功
                error: error =&gt; resolve(error) --&gt; 请求失败不使用reject()
            }) ------&gt; 那么await会继续向下执行，由此判断成功还是失败
        })
    }
    async function sendHttp() {
        let res = await getNews(&apos;http://...&apos;)
        if(res) { --&gt; 判断res的状态
            res = await getNews(res.url) --&gt; 继续执行异步任务
        } else { alert(&apos;请求失败&apos;) --&gt; 请求失败，则提示给用户 }
    }
    sendHttp();
</code></pre><h2 id="其他新增"><a href="#其他新增" class="headerlink" title="其他新增"></a>其他新增</h2><pre><code>1. class：可以定义类、实现类的继承，通过类中的constructor定义构造方法；
    1. new 创建类的实例对象，extends实现类的继承，super调用父类的构造方法；
    class Person {
        constructor(name, age) {  ---&gt; 构造函数
            this.name = name;  this.age = age; --&gt; 定义属性
        }
        showName() {   -------------&gt; 类的方法必须是简写形式
            console.log(this.name);
        }
        static run() {  -----------------&gt; 静态方法
            console.log(&apos;static method&apos;);
        }
    }
    2. 创建实例对象：let p = new Person(&apos;Mack&apos;, 18)
    3. 静态方法可以直接通过类名调用：Person.run();
    4. extends：类的继承
    class Stu extends Person {
        constructor(name, age, job) {
            super(name, age);  ------&gt; 必须先初始化父类的构造方法
            this.job = job;
        }
        showName() {  ...... } ---&gt; 重写父类的方法
    }
2. 字符串的扩展
    1. includes(str)：判断是否包含某个字符串；
    2. startsWidth(str)/endsWidth(str)：判断是否以某个字符串开头/结尾；
    3. repeat(count)：把当前字符串拼接count次，并返回；
3. number的扩展
    1. 二进制与八进制的数值表示：0b、0o
    2. Number.isFinite(num)：判断num是否是一个有限大的是数字；
    3. Number.isNaN(num)/isInteger(num)：判断num是否是NaN/整数；
    4. Number.parseInt(str)：把字符串转为数值；
    5. Math.trunc(num)：取整，去除小数部分。
4. Array的扩展
    1. Array.from(v)：将伪数组/可遍历对象转为真实的数组，包括Set、Map、字符串
    低于ES6的版本：Array.prototype.slice.call(v)
    2. Array.of(v1, v2, v3)：将一系列的值转为一个数组[v1, v2, v3]
    3. find/findIndex((value, index, arr) =&gt; { return true })
    查找第一个满足条件返回true的元素/元素下标：let arr = [2, 3, 5, 7, 1]
    let res = arr.find(function(v, i) { return v &gt; 4 }) --&gt; 5
5. 对象方法的扩展
    1. Object.is(v1, v2)：判断2个数据是否完全相等；，Object.is(NaN, NaN) --&gt;true
    Object.is(0, -0) --&gt; false，其实该方法是按照字符串的标准比较的
    2. Object.assign(target, s1,s2,...)：将源对象s1、s2...的属性复制给目标对象target
    let s1 = { name:&apos;Mack&apos;, job:&apos;Teacher&apos; };  let s2 = { name:&apos;JJJ&apos;, age:20 };
    let target1 = {}
    let target2 = Object.assign(target, s1,s2); ---&gt; s2的name属性会覆盖s1的name属性
    --&gt; target1和target2：{ name:&apos;JJJ&apos;, age:20, job:&apos;Teacher&apos; }
    3. 直接操作隐式原型__proto__，ES6之前不能访问隐式原型。
6. 深度克隆
    1. 浅拷贝：拷贝的是引用，修改拷贝后的数据，会影响原数据；
    2. 深拷贝对象/数组：JSON.parse(JSON.stringify(data))
    3. 三点运算符、Object.assign(target, s1,s2) 都是浅拷贝
</code></pre><h2 id="Set、Map"><a href="#Set、Map" class="headerlink" title="Set、Map"></a>Set、Map</h2><pre><code>1. Set：无序、不可重复的、多个value的集合体；
    1. let set = new Set(); --&gt; set.size：value的个数
    2. let set = new Set(array); --&gt;会去除array中的重复数据；
    3. 添加、删除、清空：add(value)、delete(value)、clear()
    4. has(value)：判断value是否存在。
2. Map：无序的、key不重复的、多个key-value的集合体；
    1. let map = new Map(); --&gt; set.size：key的个数
    2. new Map([[1], [4,5], [7,8,9]]) --&gt;{ 1=&gt;undefined, 4=&gt;5, 7=&gt;8 }
    3. 添加/修改、获取value、删除：set(key, value)、get(key)、delete(key)
    4. has(key)：判断key是否存在；  clear()：清空。
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/06/07/JS-新特性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/07/JS-新特性/" itemprop="url">JS-新特性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-07T00:00:00+08:00">
                2018-06-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ES"><a href="#ES" class="headerlink" title="ES"></a>ES</h2><pre><code>JS包含三个部分：ECMAScript(核心)、扩展浏览器端、扩展服务器端
1. ECMAScript：2009年发布ES5，2015年发布ES6，2016年发布ES7
2. 扩展浏览器端：BOM(浏览器对象模型)、DOM(文档对象模型)
3. 扩展服务器端：Node.js
</code></pre><h3 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h3><pre><code>1. 严格模式：除了正常运行模型(混杂模型)，ES5增加了严格模式(strict mode)
    1. 消除JS语法的一些不合理、不严谨、不安全之处，减少一些怪异行为；
    2. 使用：在全局/函数的首行定义&apos;use strict&apos;; 即使不支持，也没有任何副作用；
2. 严格模式的语法和行为：
    1. 变量必须用var声明，混杂模式下，如果不使用，则升级为全局变量，即添加给window
    2. 禁止自定义函数中的this指向window
    function Person(name) { this.name = name; }
    Person(&apos;Mack&apos;) --&gt; 直接调用构造函数，则this指向window，严格模式不允许
    new Person(&apos;Mack&apos;) --&gt; 创建实例对象，则this指向当前的实例对象
    3. 创建eval作用域：var str = &apos;Mack&apos;;
    eval(&apos;var str = &quot;Any&quot;; alert(str);&apos;); --&gt; var str = &quot;Any&quot;; alert(str);
    alert(str); --&gt; 非严格模式下，str=&apos;Any&apos;，那么就可以借助eval()攻击
    4. 对象不能有重名的属性。
3. 为Object扩展一些静态方法，如create()、defineProperties()、defineProperty()
    var obj = { name: &apos;Mack&apos;, age: 30 }
    1. create(prototype, [descriptors])：以指定对象为原型，创建新的对象；
    var obj2 = {};  var obj4 = {};
    obj2 = Object.create(obj); --&gt; obj2仍是空的，但其隐式原型指向obj
    obj4 = Object.create(obj, {
        sex: {  --------------&gt; 扩展属性
            value: &apos;Male&apos;, ---&gt; 属性值
            writale: true, ---&gt; 当前属性值是否可修改，默认为false
            configurable: true, ---&gt; 当前属性是否能被删除，默认为false
            enumerable: true ------&gt; 当前属性能否被for-in遍历，默认为false
        }
    })
    2. defineProperties(object, props)：为指定对象定义扩展属性。
    Object.defineProperties(obj, {
        job: { ---&gt; 扩展新的属性
            get: function() {  --&gt; 访问扩展属性时回调，计算当前属性值
                return this.name + &apos;:&apos; + this.age;
            },
            set: function(data) { --&gt; 修改属性时回调，用于监视属性的变化
                var n = data.split(&apos;:&apos;)
                this.name = n[0];  this.age = n[1]
            },
        }
    })
    console.log(obj.job) --&gt; 回调get()：&apos;Mack:30&apos;
    obj.job = &apos;Any:16&apos; --&gt; 回调set()：name=&apos;Any&apos;，age=16
    2. getter和setter都是惰性执行的，只有在访问/修改属性时才会调用，直接打印obj并不会
    直接显示job的属性值。
    3. 对象本身也有getter和setter，其实defineProperties()中调用的也是它们；
    var obj = { name: &apos;Mack&apos;, age: 30,
        get job() {
            return this.name + &apos;:&apos; + this.age;
        },
        set job(data) {
            var n = data.split(&apos;:&apos;)
            this.name = n[0];  this.age = n[1]
        }
    }
    4. defineProperty(obj, prop, descriptor)：参数3为将被定义或修改的属性描述符
4. 数组Array扩展的方法
    1. indexOf(value)/lastIndexOf(value)：返回元素的索引；
    2. forEach(function(item, index){ ... })：遍历数组；
    3. map(callback)：计算每一个数组元素，并不会影响原数组，而是返回一个新的数组；
    4. reduce(function(arg1, arg2){ ... })：两两计算，返回最终结果；
    5. filter(callback)：过滤数组的元素，返回一个新的数组。
5. 函数扩展的方法：call()，apply()，bind()
    1. call/apply/bind()都能修改函数中的this指向；
    2. bind(obj)：让函数内的this指向obj，但不会执行函数，而是将函数返回；
    3. bind()传递参数的方式与call()相同，通常用于修改回调函数中的this指向。
</code></pre><h2 id="ES7"><a href="#ES7" class="headerlink" title="ES7"></a>ES7</h2><pre><code>1. 指数运算符：3**3 = 27
2. Array.prototype.includes(value)：判断数组中是否包含value
</code></pre><hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">大麦田怪圈</p>
              <p class="site-description motion-element" itemprop="description">敢做就能赢！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">56</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大麦田怪圈</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
