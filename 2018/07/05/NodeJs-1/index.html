<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="NodeJs,">










<meta name="description" content="事件驱动1. NodeJs是单线程、非阻塞I/O的事件驱动；     1. 不同于Java/PHP/.net等服务器语言，NodeJs不会为每个Client连接创建新线程；     2. 当有新的Client请求连接时会触发内部事件，通过非阻塞I/O、事件驱动机制，让Node应用程序     在宏观上是并行的；     3. 使用Node.js，一个8G的服务器可以同时处理超过4w的Client连">
<meta name="keywords" content="NodeJs">
<meta property="og:type" content="article">
<meta property="og:title" content="NodeJs-1">
<meta property="og:url" content="http://hellomyshadow.github.io/2018/07/05/NodeJs-1/index.html">
<meta property="og:site_name" content="大麦田程序猿">
<meta property="og:description" content="事件驱动1. NodeJs是单线程、非阻塞I/O的事件驱动；     1. 不同于Java/PHP/.net等服务器语言，NodeJs不会为每个Client连接创建新线程；     2. 当有新的Client请求连接时会触发内部事件，通过非阻塞I/O、事件驱动机制，让Node应用程序     在宏观上是并行的；     3. 使用Node.js，一个8G的服务器可以同时处理超过4w的Client连">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-01-12T15:14:49.167Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="NodeJs-1">
<meta name="twitter:description" content="事件驱动1. NodeJs是单线程、非阻塞I/O的事件驱动；     1. 不同于Java/PHP/.net等服务器语言，NodeJs不会为每个Client连接创建新线程；     2. 当有新的Client请求连接时会触发内部事件，通过非阻塞I/O、事件驱动机制，让Node应用程序     在宏观上是并行的；     3. 使用Node.js，一个8G的服务器可以同时处理超过4w的Client连">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hellomyshadow.github.io/2018/07/05/NodeJs-1/">





  <title>NodeJs-1 | 大麦田程序猿</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大麦田程序猿</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2018/07/05/NodeJs-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">NodeJs-1</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-05T00:00:00+08:00">
                2018-07-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h2><pre><code>1. NodeJs是单线程、非阻塞I/O的事件驱动；
    1. 不同于Java/PHP/.net等服务器语言，NodeJs不会为每个Client连接创建新线程；
    2. 当有新的Client请求连接时会触发内部事件，通过非阻塞I/O、事件驱动机制，让Node应用程序
    在宏观上是并行的；
    3. 使用Node.js，一个8G的服务器可以同时处理超过4w的Client连接。
2. 处理异步的两种常用方式：回调函数、事件的订阅/发布
3. 事件是整个Node的核心，Node中大部分模块都使用/继承events模块，类似WebAPI的EventTarget
</code></pre><h3 id="events模块"><a href="#events模块" class="headerlink" title="events模块"></a>events模块</h3><pre><code>1. const EventEmitter = require(&apos;events&apos;);
    class MyEmitter extends EventEmitter {}
    const emitter = new MyEmitter();
2. 通过EventEmitter实例来绑定和监听事件，以广播(订阅/发布)的形式处理异步；
    1. 订阅事件的方式
    emitter.on(&apos;toparent&apos;, (data) =&gt; { --&gt; 方式一：订阅事件&apos;toparent&apos;
        console.log(data) --&gt; 处理广播数据data
    })
    emitter.addListener(&apos;toparent&apos;, (data) =&gt; { --&gt; 方式二
        console.log(data);
    })
    2. 发布事件：emitter.emit(&apos;toparent&apos;, &apos;广播数据&apos;)
3. emitter.setMaxListeners(2); --&gt;设置最大的订阅个数
</code></pre><h2 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h2><pre><code>1. process对象是一个全局变量，提供了当前Node程序与系统的有关信息，还可以控制当前的Node进程
2. process.argv：获取运行node程序的命令，是一个数组
    node app.js -i  --&gt; [&apos;node命令的路径&apos;, &apos;app.js的路径&apos;, &apos;-i&apos;]
3. process.evn：环境变量相关，比如通过配置环境变量控制开发模式与生产模式的切换
    1. 在当前系统上新建一个环境变量：mode=&apos;dev&apos;
    2. 判断当前是否处于开发模式：process.env.mode == &apos;dev&apos;
4. process.exit()：结束当前进程
5. process.stdout/stdin：标准输入输出流
    1. 将数据输出到终端：process.stdout.write(&apos;hello&apos;); --&gt; console.log的底层原理
    2. 监听用户的输入：
    process.stdin.on(&apos;data&apos;, e=&gt;{ ---&gt; 可用于实现交互式的命令行，比如Vue.js的脚手架
        process.stdout.write(&apos;用户输入: &apos;, e.toString());
    })
    3. 在命令行输入内容后，还要点击 Enter键作为输入完成的信号，process.stdin才能监听到，
    所以接收到的数据其实是以回车符号结尾的；
    4. 去除Windows系统的回车符：e.toString().replace(&apos;\r\n&apos;, &apos;&apos;);
6. 移动光标的位置：process.stdout.cursorTo(x, y);
</code></pre><h2 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h2><pre><code>1. 流是一种在Node中处理流式数据的抽象接口，fs、net、http、https等模块都提供了流的实现；
2. stream约定了一些基本特性(但并没有实现)，所有实现流操作的对象都具备这些共同的特性；
2. 流的基本类型
    1. Writable：可写入数据的流，如fs.createWriteStream()
    2. Readable：可读取数据流，如fs.createReadStream()
    3. Duplex：可读又可写的流，又称为双工数据流
    4. Transform：可修改的双工数据流，在读写过程中可修改/转换
3. Writable：write()、end()、setDefaultEncoding()
4. Readable：setEncoding()、read()、pipe()、pause()、resume()
</code></pre><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><pre><code>1. Buffer：缓冲区，类似于数组，长度固定，专门用于操作二进制数据
2. v8是JS引擎，内存有限，32位操作系统约0.7G，64位约为1.4G，Node使用的也是v8引擎
3. 虽然v8有内存限制，但Buffer实际上是对底层内存的直接操作，它的大小不计入v8的内存开销；
4. let buf = new Buffer(10); --&gt; 10个字节的Buffer，但Buffer的所有构造函数已废弃
    1. 虽然Buffer存储的是二进制数据，但显示时都是以十六进制的形式(二进制太长了)；
    2. Buffer操作的是底层内存，大小一旦确定，就会分配一段连续的内存空间，不允许修改大小；
    buf[0]=88; --&gt; 十进制转为十六进制：58，也可以直接赋值十六进制
    buf[11]=255; --&gt; 角标越界不会报错，但不会有变化
    3. Buffer中每个元素的范围：00-ff，即十进制的0-255，二进制的一个字节；
    buf[2]=556; --&gt; 超过一个字节的最大数值255，会舍弃高位，只存储低8位：2c
    4. 控制台默认打印的数字都是十进制，buf[0].toString(16)表示以十六进制输出；
    5. buf.tostring()：将Buffer中的二进制数据转为字符串。
5. Buffer.alloc(size[, fill, encoding])：创建size个字节的Buffer对象
    1. fill和encoding都是可选参数，encoding默认为utf8
    2. 不指定fill时，新创建的Buffer默认用 0 填充。
6. Buffer.allocUnsafe(size)：不安全的Buffer，Buffer中可能含有敏感数据；
    1. Buffer.alloc()的默认值都是00，也即分配内存时会清空该内存中的原数据；
    2. Buffer.allocUnsafe()在分配内存时不会清空内存中原数据，所以默认值可能不是00；
7. Buffer.from(str|array|buffer)：将字符串/数组/buffer数据转化为一个新的Buffer
    1. var str=&quot;Hello&quot;; --&gt; str.length：字符串长度
    2. var buf = Buffer.from(str); --&gt; buf.length：占用内存的字节大小
    3. 英文字符串的每个字符占一个字节，所以str.length==buf.length
    4. 查看字符串的字节长度：Buffer.byteLength(&apos;你好&apos;);
8. Buffer.concat(array)：合并array中的Buffer，再转为一个新的Buffer
9. 比较两个Buffer的值是否完全相等：buf1.equals(buf2);
</code></pre><h2 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h2><pre><code>1. fs：文件系统，node的核心模块，var fs = require(&quot;fs&quot;);
    1. fs模块中的所有操作都可以选择同步/异步，同步会阻塞程序的执行，而异步则不会；
    2. 在fs中，带有Sync的都是同步方法，不带的都是异步方法，且异步方法带有回调函数。
2. open()/openSync()：打开文件，返回一个文件的描述符，通过该描述符进行文件操作；
    1. fs.openSync(path, flags, mode);  fs.open(path, flags, mode, callback);
    2. path：文件路径； flags：操作类型r/w； mode：设置文件的操作权限，一般不传；
    3. callback回调2个参数arguments：function(err, fd){ ... }
    4. err：错误对象，没有错误则为null； fd：文件描述符；
    5. Node的设计就是错误优先，所以回调函数的第一个参数是错误对象。
3. write()/writeSync()：向文件中写入内容；
    1. fs.writeSync(fd, string, position, encoding);
    2. fd：文件描述符； string：写入的内容，如果不是字符串，则被强制转为字符串；
    3. position：写入指针的位置，默认为0； encoding：写入的编码，默认为utf-8；
    1. fs.writeSync(fd, string, position, encoding, callback);
    2. callback回调3个参数：function(err, written, string){ ... }
    3. written：传入的字符串被写入的字节数； string：被写入的内容；
4. close(fd, callback)/closeSync(fd)：关闭文件操作；
    1. fd：文件描述符，表示要关闭的文件操作；
    2. callback只回调一个参数：function(err){ ... }
5. fs的写入过程：数据--&gt;Buffer--&gt;stream，为了提高效率，数据先写入缓冲区，再一次性写入文件
6. 异步的错误在回调函数中，而同步的错误只能用 try-catch 捕获
</code></pre><h3 id="简单读写"><a href="#简单读写" class="headerlink" title="简单读写"></a>简单读写</h3><pre><code>1. 简单文件写入：fs.writeFile()/fs.writeFileSync()
    1. writeFile(file, data, options, callback)
    2. file：操作的文件路径； data：待写入的数据； options：可选，设置写入动作；
    3. callback回调一个参数：function(err) {}，而且不用手动关闭操作流；
    4. options：对象，包括encoding(默认utf-8)，mode(默认0o66)，flag(默认w)
    fs.writeFile(file, data, { flag: &apos;a&apos; }, callback); --&gt; 表示向文件中追加写入
    5. data可以是字符串或Buffer，如果data是一个buffer，options中的encoding是无效的；
    6. 如果文件的路径使用绝对路径：
    fs.writeFile(&quot;C:/workplace/test.txt&quot;, ...);
    fs.writeFile(&quot;C:\\workplace\\test.txt&quot;, ...); ==&gt; 两者等效；
    7. 简单文件写入的原理：仍是使用write()/writeSync()
2. 流式文件写入：用于写入大文件，可以分多次写入文件
    1. 同步/异步/简单文件写入都不适合大文件的写入，性能较差，容易导致内存溢出；
    2. var ws = fs.createWriteStream(path, options); --&gt;创建一个写入流；
    3. ws.write(str); --&gt;写入数据
    4. ws.end(); --&gt;等待写入完成再关闭流，不能用ws.close()，会造成流中的数据丢失；
    5. ws.on(&quot;事件名&quot;, function)：绑定一个长期有效的事件；
    6. ws.once(&quot;事件名&quot;, function)：绑定一个一次性的事件，触发一次之后自动失效；
    ws.once(&quot;open&quot;, function(){ --&gt; 监听写入流的打开事件
        console.log(&quot;流打开了...&quot;)
    });
    ws.once(&quot;close&quot;, function(){ --&gt; 监听写入流的关闭事件
        console.log(&quot;流关闭了...&quot;)
    });
3. 简单文件读取：fs.readFile()/fs.readFileSync()
    1. fs.readFile(path, options, callback)
    2. callback：function(err, data)，data表示读取到的内容，是一个Buffer对象；
    3. data之所以是一个Buffer对象，是因为读取的可能是二进制文件，如图片、音频；
    4. data.toString()的方式只适用于字符串，对二进制数据会乱码。
    fs.readFile(&quot;an.jpg&quot;, function(err, data){
        if(!err) {
            fs.writeFile(&quot;pn.jpg&quot;, data, function(err){ ... });
        }
    });
4. 流式文件读取：用于读取大文件，可以分多次读取文件
    1. var rs = fs.createReadStream(path, options); --&gt;创建一个读取流；
    2. 读取一个可读流中的数据，必须为可读流绑定一个data事件，绑定后会自动开始读取；
    rs.on(&quot;data&quot;, function(data){ --&gt; 读取过程不是一次性事件
        //data也是一个Buffer对象
    });
    3. 管道：rs.pipe(ws); --&gt; 可读流rs自动将数据传递给写入流ws，不需要绑定事件
</code></pre><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><pre><code>1. fs.exists(path, callback)/existsSync(path)：文件/目录是否存在
    1. fs.exists()：已废弃，被fs.stat()/fs.access()替代；
2. fs.stat(path, callback)/statSync(path)：获取文件信息，类似文件/目录的属性信息
    1. callback：function(err, stats) --&gt; stats对象中保存了文件的状态信息
    2. stats.size：获取文件的大小；
    3. stats.isFile()/isDirectory()：是否是一个文件/文件夹。
3. fs.unlink(path, callback)/unlinkSync(path)：删除文件；
4. fs.readdir(path, options, callback)/readdirSync(path, options)
    1. 读取一个目录的结构，获取指定目录下的所有文件/文件夹；
    2. callback：function(err, files) --&gt; files是一个数组，文件/文件夹的名称
5. fs.truncate(path, len, callback)/truncateSync(path, len)
    1. 截断文件，将文件修改为指定的大小，len表示字节大小，将文件大小设置为len
6. fs.mkdir(path, mode, callback)/mkdirSync(path, mode)：创建目录，但不会递归创建
7. fs.rmdir(path, callback)/rmdirSync(path)：删除目录，但不能删除非空目录
8. fs.rename(old, new, callback)：重命名/剪切
9. fs.watchFile(filename, options, listener)：监视文件的修改
    1. 内部原理是一个定时机制，定时检查文件中的内容；
    2. options：{ persistent: true, interval: 5007 }，默认5s检查一次；
    fs.watchFile(&quot;test.txt&quot;, {interval:1000}, function(curr, prev) {
        //curr是修改后的状态，prev是修改前的状态，它们都是stats对象
    });
10. fs.watch()：可以监听目录的状态变化
</code></pre><h3 id="fs-Promise"><a href="#fs-Promise" class="headerlink" title="fs Promise"></a>fs Promise</h3><pre><code>1. 在node10.0之后，fs模块中引入了Promise，文件操作不再区分异步和同步，而是返回Promise对象
2. const fsPromises = require(&apos;fs&apos;).promises;
</code></pre><h2 id="UDP之dgram"><a href="#UDP之dgram" class="headerlink" title="UDP之dgram"></a>UDP之dgram</h2><pre><code>1. dgram模块：提供UDP数据包socket的实现，const dgram = require(&apos;dgram&apos;);
2. 服务端
    1. 创建socket对象
    const server = dgram.createSocket(); --&gt; 静态方法创建socket对象
    const server = new dgram.Socket(type[, callback]);
    2. type：udp4 =&gt;IPV4、udp6 =&gt;IPV6;  callback：接收到数据的回调;
    3. 绑定IP和端口号
    server.bind(3000, &apos;127.0.0.1&apos;);
    4. 监听事件：close(关闭)、error(发生错误)、listening(启动监听)、message(收到消息)
    server.on(&apos;listening&apos;, ()=&gt;{ console.log(&apos;启动成功...&apos;); });
    server.on(&apos;message&apos;, (data) =&gt; {
        //网络传输的数据是二进制的，在node上是一个buffer对象
    });
    5. 关闭socket：server.close(callback);
3. 客户端
    1. let client = dgram.createSocket(&apos;udp4&apos;);
    2. 发送数据：client.send(&apos;Hello Server&apos;, 3000, &apos;127.0.0.1&apos;);
</code></pre><h2 id="TCP之net"><a href="#TCP之net" class="headerlink" title="TCP之net"></a>TCP之net</h2><pre><code>1. net模块：提供了创建基于流的 TCP/IPC 服务器和客户端的异步网络API
2. const net = require(&apos;net&apos;);
3. 服务端
    let server = new net.Server(); / net.createServer();
    1. 启动监听：server.listen(3000, &apos;127.0.0.1&apos;); --&gt; IP默认为0.0.0.0
    2. server.listen(3000, &apos;0.0.0.0&apos;); --&gt; 监听当前设备上的所有IP收到的3000端口消息
    4. 一台电脑可能有多个网卡(对应多个IP)，但端口号是唯一的，0.0.0.0 类似于通配符 *
    2. 连接事件、发送数据
    server.on(&apos;connect&apos;, (socket) =&gt; { --&gt; 回调的socket表示当前客户端的socket对象
        console.log(&apos;有客户端连接...&apos;);
        socket.write(&apos;hello client&apos;); --&gt; 向客户端写(发送)数据
        socket.on(&apos;data&apos;, (data) =&gt; { --&gt; 监听客户端发来的数据
            ...
        });
    });
    3. 获取客户端的IP和端口号：socket.remoteAddress，socket.remotePort
4. 客户端
    1. 创建客户端：new net.Socket(); / net.createConnection();
    let client = net.createConnection(3000, &apos;127.0.0.1&apos;);
    2. 监听服务器发来的数据
    client.on(&apos;data&apos;, data =&gt; {
        ...
    });
    3. 向服务器端发送数据：client.write(&apos;hello server&apos;);
5. socket数据的分包
    1. 当一个数据包很大时，并不会一次性传输，而是分多次，也就是说，data事件会被触发多次；
    2. 服务端告诉客户端数据传输完成：socket.end();
    server.on(&apos;connect&apos;, (socket) =&gt; {
        let data = fs.readFileSync(&apos;./a.mp4&apos;); --&gt; 读取一个大文件
        socket.write(data); --&gt; 开始传输，socket内部会分包传输
        socket.end(); --&gt; 通知客户端传输完成
    })
    3. socket.end(); 一旦执行，本次连接也会终止，客户端断开连接；
    4. 客户端收到数据传输完成的事件：client.on(&apos;end&apos;, () =&gt; { ... });
    5. 客户端需要把每次收到的数据(buffer)，拼接成一个buffer对象，才是一个完整的数据包。
    let list = [];
    client.on(&apos;data&apos;, chunk =&gt; {
        list.push(chunk);
    });
    client.on(&apos;end&apos;, () =&gt; { --&gt; 数据传输完成，连接已断开
        let data = Buffer.concat(list); --&gt; 把多个buffer对象合并为一个buffer
        fs.writeFile(&apos;./b.mp4&apos;, data, err=&gt;{});
    });
</code></pre><hr>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/NodeJs/" rel="tag"># NodeJs</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/07/02/EventLoop/" rel="next" title="EventLoop">
                <i class="fa fa-chevron-left"></i> EventLoop
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/07/08/NodeJs-2/" rel="prev" title="NodeJs-2">
                NodeJs-2 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">大麦田怪圈</p>
              <p class="site-description motion-element" itemprop="description">敢做就能赢！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">55</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#事件驱动"><span class="nav-number">1.</span> <span class="nav-text">事件驱动</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#events模块"><span class="nav-number">1.1.</span> <span class="nav-text">events模块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Process"><span class="nav-number">2.</span> <span class="nav-text">Process</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stream"><span class="nav-number">3.</span> <span class="nav-text">stream</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Buffer"><span class="nav-number">4.</span> <span class="nav-text">Buffer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fs"><span class="nav-number">5.</span> <span class="nav-text">fs</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简单读写"><span class="nav-number">5.1.</span> <span class="nav-text">简单读写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常用操作"><span class="nav-number">5.2.</span> <span class="nav-text">常用操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fs-Promise"><span class="nav-number">5.3.</span> <span class="nav-text">fs Promise</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP之dgram"><span class="nav-number">6.</span> <span class="nav-text">UDP之dgram</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP之net"><span class="nav-number">7.</span> <span class="nav-text">TCP之net</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大麦田怪圈</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
