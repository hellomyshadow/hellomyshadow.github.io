<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="NodeJs,">










<meta name="description" content="Express1. Express是一个基于NodeJs平台的后台开发框架；     1. 极简、开放、灵活的web应用开发框架，帮助开发各种Web和移动设备应用；     2. Express不对NodeJs已有的特性进行二次抽象，只是在它之上扩展了Web应用所需的功能；     3. Express提供了丰富的HTTP快捷方法和任意排列组合的Connect中间件。 2. Express的使用：">
<meta name="keywords" content="NodeJs">
<meta property="og:type" content="article">
<meta property="og:title" content="Express">
<meta property="og:url" content="http://yoursite.com/2018/08/01/Express/index.html">
<meta property="og:site_name" content="大麦田程序猿">
<meta property="og:description" content="Express1. Express是一个基于NodeJs平台的后台开发框架；     1. 极简、开放、灵活的web应用开发框架，帮助开发各种Web和移动设备应用；     2. Express不对NodeJs已有的特性进行二次抽象，只是在它之上扩展了Web应用所需的功能；     3. Express提供了丰富的HTTP快捷方法和任意排列组合的Connect中间件。 2. Express的使用：">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-12-14T13:25:09.953Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Express">
<meta name="twitter:description" content="Express1. Express是一个基于NodeJs平台的后台开发框架；     1. 极简、开放、灵活的web应用开发框架，帮助开发各种Web和移动设备应用；     2. Express不对NodeJs已有的特性进行二次抽象，只是在它之上扩展了Web应用所需的功能；     3. Express提供了丰富的HTTP快捷方法和任意排列组合的Connect中间件。 2. Express的使用：">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/08/01/Express/">





  <title>Express | 大麦田程序猿</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大麦田程序猿</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/01/Express/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Express</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-01T00:00:00+08:00">
                2018-08-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index">
                    <span itemprop="name">JavaScript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h2><pre><code>1. Express是一个基于NodeJs平台的后台开发框架；
    1. 极简、开放、灵活的web应用开发框架，帮助开发各种Web和移动设备应用；
    2. Express不对NodeJs已有的特性进行二次抽象，只是在它之上扩展了Web应用所需的功能；
    3. Express提供了丰富的HTTP快捷方法和任意排列组合的Connect中间件。
2. Express的使用：npm install express --save
    1. 引入：const express = require(&apos;express&apos;)，let app = new express()
    2. 配置get请求的路由
    app.get(&apos;/&apos;, (req, res) =&gt; {  ------&gt; 配置路由
        res.send(&apos;Hello Express&apos;) ----&gt; 响应内容
    })
    3. 配置post请求的路由
    app.post(&apos;/dologin&apos;, (req, res) =&gt; { ... })
    4. 设置监听的Ip和端口号：app.listen(3000, &apos;ip&apos;)，默认Ip是127.0.0.1
    5. node命令运行该js文件，它也就是项目的入口文件。
3. 传递参数
    1. 配置动态路由
    app.get(&apos;/news/:id&apos;, (req, res) =&gt; {
        let {id} = req.params ---&gt; 获取id参数
    }) --&gt; 访问http://localhost:3000/news/123
    2. get传值
    app.get(&apos;/news&apos;, (req, res) =&gt; {
        let {id} = req.query ---&gt; 获取id参数
    }) --&gt; 访问http://localhost:3000/news?id=123
4. 其他API
    1. 重定向：res.redirect(&apos;/index&apos;) --&gt;重定向到路由&apos;/index&apos;
    2. 获取访问的路由：req.url ---&gt; 如&apos;/login&apos;
    3. 响应一段JS代码，弹出alert()，并重定向页面路由：
    res.send(&quot;&lt;script&gt;alert(&apos;登录失败！&apos;);location.href=&apos;/login&apos;&lt;/script&gt;&quot;)
</code></pre><h2 id="express与ejs"><a href="#express与ejs" class="headerlink" title="express与ejs"></a>express与ejs</h2><pre><code>1. Express中引入ejs模板引擎：app.set(&apos;view engine&apos;, &apos;ejs&apos;)
2. 使用ejs模板：res.render(&apos;模板名&apos;, { key:value })
    1. 模板名不需要指定路径，默认使用的路径：项目根目录/views/模板名.ejs
    app.get(&apos;/news&apos;, (req, res) =&gt; {
        res.render(&apos;index&apos;, {newsId: 123}) --&gt;默认使用的模板：views/index.ejs
    })
    2. 指定模板的目录：app.set(&apos;views&apos;, __dirname + &apos;/static&apos;)，修改为static目录；
    3. 使用path模块拼接路径：require(&apos;path&apos;).join(__dirname, &apos;static&apos;)
3. 全局变量
    1. 如果多个模板都需要接收同一变量，每个模板对应的路由都必须传递该参数，而全局变量只需要
    设置一次即可，所有模板都可以接收全局变量；
    2. 设置全局变量：app.locals[&apos;全局变量名&apos;] = &apos;123&apos;
    3. 在第一个需要接收全局变量的模板被渲染之前，设置全局变量uname的值：
    app.post(&apos;/dologin&apos;, (req, res) =&gt; {
        app.locals[&apos;uname&apos;] = &apos;123&apos; --&gt;在任何模板中都可以接收变量uname：&lt;%= uname %&gt;
        ......
    })
    4. app.locals[&apos;变量名&apos;]是真正的全局，req.app.locals[&apos;变量名&apos;]表示请求的全局。
</code></pre><h2 id="静态服务"><a href="#静态服务" class="headerlink" title="静态服务"></a>静态服务</h2><pre><code>1. 静态服务/静态路由：用于提供静态资源服务，包括css文件、js文件、图片、供下载的文件...
2. 以css文件为例，在模板中直接使用&lt;link /&gt;引入是无效的
    app.get(&apos;/login&apos;, (req, res) =&gt; {
        res.render(&apos;login&apos;) ----&gt; views/login.ejs
    })
    1. login.ejs中引入css文件：&lt;link rel=&quot;stylesheet&quot; href=&quot;css/login.css&quot; /&gt;
    2. css文件的真实获取方式：http://localhost:3000/css/login.css
    3. 很明显，&quot;/css/login.css&quot;的路由是不存在，所以获取css文件失败。
2. 在express中，利用 express.static 中间件托管静态文件
    1. app.use(express.static(&apos;public&apos;)) --&gt; 给public目录下的文件提供静态web服务
    2. 在public目录下创建有效的css/login.css
    http://localhost:3000/css/login.css --&gt; 查找路径：public/css/login.css
    3. 同理，login.ejs中的&lt;img /&gt;加载的图片资源也必须提供静态服务
    &lt;img src=&quot;img/a.png&quot; /&gt; =&gt;http://localhost:3000/img/a.png =&gt;public/img/a.png
3. 注意：href=&quot;css/login.css&quot; 与 href=&quot;/css/login.css&quot; 并不完全相同
    1. &apos;/&apos;、&apos;/login&apos;、&apos;/user&apos;都属于一级路由，而&apos;/index/login&apos;属于二级路由；
    2. 在一级路由中渲染的ejs模板中，&quot;css/login.css&quot; 与 &quot;/css/login.css&quot; 是相同的
    http://localhost:3000/css/login.css ==&gt; public/css/login.css
    3. 对于二级路由，&quot;css/login.css&quot; 与 &quot;/css/login.css&quot;的参考路由不同，也就导致了资源
    路径出错，从而无法加载资源；
    4. 在二级路由 &apos;/index/login&apos; 中渲染login.ejs模板时：
    href=&quot;css/login.css&quot; -----&gt; http://localhost:3000/index/css/login.css ------
    --&gt; public/index/css/login.css --&gt; public目录下不存在 index目录，所以访问失败
    href=&quot;/css/login.css&quot; --&gt; http://localhost:3000/css/login.css --&gt; 访问成功
    5. 原因：href=&quot;css/login.css&quot;相对于当前路由，而href=&quot;/css/login.css&quot;相对于根路由。
5. 设置虚拟目录，映射真实的资源路径：app.use(&apos;/static&apos;, express.static(&apos;public&apos;))
    1. app.use(express.static(&apos;public&apos;)) --&gt;匹配的是根路由，而所有路由又都开始于根路由
    2. app.use(&apos;/static&apos;, express.static(&apos;public&apos;)) 匹配的路由是 &apos;/static&apos;
    3. href=&quot;/css/login.css&quot; 不能在访问了，需要使用 href=&quot;/static/css/login.css&quot;
    http://localhost:3000/static/css/login.css ==&gt; public/css/login.css
6. 如果静态资源存在多个目录，可以配置多个 express.static 中间件
    app.use(express.static(&apos;public&apos;)) ---&gt; public目录
    app.use(express.static(&apos;static&apos;)) ---&gt; static目录
    app.use(&apos;/static&apos;, express.static(&apos;public&apos;)) --&gt; 虚拟路径
    1. 访问静态资源时，express会依次匹配静态资源目录，如果都找不到，才会抛出404
7. href和src都是可以跨域的，可以直接指定静态资源的完整地址，包括域名和路径。
</code></pre><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><pre><code>1. Express本身非常简洁，它完全是由路由和中间件构成的web开发框架，其应用就是在调用各种中间件
2. 简单来说，中间件就是在匹配路由之前和之后所做的一系列操作；
3. 类型：应用级中间件、路由级中间件、错误处理中间件、内置中间件、第三方中间件
1. 应用级中间件：匹配任何路由
    app.use((req, res, next) =&gt; { ... })
    1. 路由默认只匹配一次，一旦匹配成功，则不再继续向下匹配；
    2. 调用 next()，让路由继续向下匹配，直到匹配正确的路由。
    http://localhost:3000/news
    app.use((req, res, next) =&gt; { ---&gt; 可用作权限判断
        ......
        next();  --&gt; 继续向下匹配
    })
    app.get(&apos;/news&apos;, (req, res) =&gt; { ---&gt; 匹配成功
        res.send(&apos;匹配news路由&apos;)
    })
    4. 默认匹配所有路由，也可以指定只匹配某个路由
    app.use(&apos;/news&apos;, (req, res, next) =&gt; {  --&gt; 只匹配 /news
        ......
        next();
    })
    5. 中间件和路由的排列顺序不能颠倒，否则一旦匹配成功，将不再继续执行。
2. 路由级中间件：匹配多个路由
    http://localhost:3000/news
    app.get(&apos;/news&apos;, (req, res, next) =&gt; {
        console.log(&apos;路由中间件news&apos;)
        next(); ---&gt; 不执行 res.send() 返回数据，让路由继续向下执行
    })
    app.get(&apos;/news&apos;, (req, res) =&gt; {
        res.send(&apos;匹配news路由&apos;)
    })
3. 错误处理中间件
    1. 写在所有路由的后面，当上面的所有路由都不匹配时，则返回404
    app.use((req, res) =&gt; {  ---&gt; 匹配所有路由
        res.status(404).send(&apos;404页面&apos;)
    })
4. 内置中间件：如 express.static()，用于托管静态资源
    app.use(&apos;/static&apos;, express.static(&apos;./static&apos;))
</code></pre><h3 id="第三方中间件"><a href="#第三方中间件" class="headerlink" title="第三方中间件"></a>第三方中间件</h3><pre><code>1. body-parser：用于获取POST提交的数据，npm install body-parser --save
    1. let parser = require(&apos;body-parser&apos;)
    2. 配置 body-parser 中间件
    //parse application/x-www-form-urlcoded
    app.use(parser.urlencoded({extended:false}))
    app.use(parser.json()) ---&gt; parse application/json
    app.post(&apos;/login&apos;, (req, res) =&gt; {
        let body = req.body  ---&gt; 获取post提交的数据
    })
2. 但是，如果表单中涉及文件上传，body-parser模块就无法处理了，需要使用multiparty模块
    1. npm install multiparty --save
    2. multiparty可以设置上传文件的保存路径、限制文件的大小...
    3. 对于涉及文件上传的表单，必须设置&lt;form enctype=&quot;multipart/form-data&quot;&gt;
    let multiparty = require(&apos;multiparty&apos;)
    let form = new multiparty.Form()
    form.uploadDir = &apos;upload&apos; ----&gt; 设置上传文件的保存目录，项目根目录/upload
    form.parse(req, (err, fields, files) =&gt; { ---&gt; 处理 req 中提交的表单数据
        // --&gt;fields是处理后的表单数据，files是文件上传成功后返回的信息
    })
    4. 使用虚拟目录为 upload 目录配置静态服务：
    app.use(&apos;/upload&apos;, express.static(&apos;upload&apos;))
    5. 访问 upload 目录中上传的图片文件：http://localhost:3000/upload/a.jpg
3. multiparty模块的问题
    1. 如果表单中没有选择上传的图片，即&lt;input type=&quot;file&quot; /&gt;是空的，multiparty模块仍会在
    上传目录中生成一个临时文件；
    2. 上传成功后，files中的originalFilename属性表示上传文件的原始名称，path属性表示上传
    文件在服务器端存储的路径，为了防止文件名重复，文件的名称已经被重新编码了；
    3. 如果表&lt;input type=&quot;file&quot; /&gt;是空的，那么 files.originalFilename=&apos;&apos;，由此判断文件
    是否上传，如果没有上传，则根据 files.path 删除临时文件。
</code></pre><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><pre><code>1. NodeJs操作Cookie的中间件：npm install cookie-parser --save
2. 配置 Cookie 中间件
    let cookieParser = require(&apos;cookie-parser&apos;)
    app.use(cookieParser())
3. 设置cookie
    app.get(&apos;/set&apos;, (req, res) =&gt; {
        res.cookie(&apos;username&apos;, &apos;Mack&apos;, { maxAge:90000, httpOnly:true })
        res.send(&apos;set Cookie&apos;)
    })
    1. 参数1和参数2分别是cookie的键-值，参数3是对cookie的配置；
    2. maxAge：表示过期时间(s)，最大失效时间
    3. httpOnly：默认为false，表示不允许客户端的脚本访问，只能在nodeJs服务的操作
    4. 获取cookie：一旦访问过 /set 路由，就可以在其他路由中获取 cookie
    app.get(&apos;/news&apos;, (req, res) =&gt; {
        let username = req.cookies.username; --&gt;{ username: &apos;Mack&apos; }
        res.send(`get Cookie: ${username}`);
    })
4. Cookie的更多设置
res.cookie(&apos;uname&apos;, &apos;Node&apos;, {expires:new Date(Date.now()+9000), httpOnly:true})
    1. expires：也是设置Cookie的过期时间，表示从当前时间开始，到 expires 设置的时间过期
res.cookie(&apos;uname&apos;, &apos;Node&apos;, {domain:&apos;.exa.com&apos;, path: &apos;/admin&apos;, secure: true})
    1. secure：设置为true，表示cookie在 HTTP 中是无效的，仅在 HTTPS 中才有效；
    2. path：指定cookie匹配的路由，如果访问的路由不匹配，浏览器不会发送cookie
    3. domain：域名，让所有子域名/二级域名共享同一个cookie信息，如domain:&apos;.exa.com&apos;的
    子域名www.exa.com、aaa.exa.com ...
5. cookie的签名/加密
    app.use(cookieParser(&apos;sign&apos;)) --&gt; 传入一个随机字符串，用于cookie的加密
    res.cookie(&apos;uname&apos;, [1,2,3], {maxAge:60000, signed:true})
    1. cookie默认是明文存储的，signed用于签名cookie，设置为true 会对cookie签名/加密；
    2. res.signedCookies：获取签名后的cookie
    3. 被篡改的签名cookie会被服务器拒绝，且cookie会被重置为初始值。
</code></pre><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><pre><code>1. session是另一种记录客户端状态的机制，与cookie不同的是，session保存在服务器端；
    1. 当客户端第一次访问服务器时，session可以保存客户端的登录状态，当客户访问其他路由时，
    判断客户的登录状态，作出响应提示；
    2. 工作机制：客户端第一次向服务器发送请求 --&gt; 服务器创建一个类似键-值的session对象，
    然后将key设置在cookie中，返回给客户端 --&gt; 客户端下次访问时会携带cookie，根据cookie中
    的key找到对应的session
2. 与cookie不同，session没有过期时间，浏览器一旦关闭，session就失效了；
3. session还可以和Redis等数据库结合，实现持久化，就算服务器宕机，也不会丢失用户状态；
4. express-session：nodeJs操作session的中间件
    1. npm install express-session --save
    2. 配置中间件
    const session = require(&apos;express-session&apos;)
    app.use(session({ 
        secret:&apos;anything&apos;,  --&gt; 服务器生成session的签名，可以是任意字符串，用于加密
        //name: &apos;&apos; --------&gt; 返回给客户端的cookie名称，默认为connect.sid
        resave: false, --&gt; 强制保存session，即使没有变化，默认值为true
        saveUninitialized:true, --&gt;强制将未初始化的session存储，默认为true
        cookie:{ secure:false } --&gt;设置cookie，maxAge、path、domain...
    }))  --&gt; 一旦关闭浏览器，session就失效了，相关的cookie也会失效
    2. 设置/获取session
    app.get(&apos;/&apos;, (req, res) =&gt; {
        if(req.session.userInfo) {  ---&gt; 获取session
            res.send(&apos;welcome back: &apos;, req.session.userInfo)
        } else {
            res.send(&apos;logout&apos;)
        }
    })
    app.get(&apos;/login&apos;, (req, res) =&gt; {
        req.session.userInfo = {uname:&apos;Mack&apos;, pwd:&apos;123&apos;}  ---&gt; 设置session
        res.send(&apos;login success&apos;)
    })
    3. 销毁session，如切换登陆、退出登录时，要主动销毁session
    req.session.cookie.maxAge=0  --&gt; 方式1：把cookie的过期时间设置为0ms后，立即过期
    req.session.destroy(err =&gt; {}) ---&gt; 方式2：调用session的销毁方法
5. 负载均衡配置Session
    1. 负载均衡：后台配置多个服务器，执行同一套node代码，通过Nginx服务器动态地把不同地区的
    用户请求转发给不同的服务器处理，或者把用户请求转发给同一地区压力比较小的服务器；
    2. session默认保存在服务器的缓存文件中，而后台配置了负载均衡之后，同一用户访问的服务器
    就可能发生变化，那么原本的session信息也就不存在了，但多个服务器会共享数据库，所以需要把
    session保存到数据库中；
    3. 把session保存在MongoDB数据库中：express-session和connect-mongo两大模块
    let session = require(&apos;express-session&apos;)
    const MongoStore = require(&apos;connect-mongo&apos;)(session)
    4. 配置中间件
    app.use(session({secret:&apos;1234&apos;, resave:false, saveUninitialized:true,
        cookie: { maxAge:1000*60*30 }, --&gt; 在浏览器未关闭的情况下，30min后过期
        rooling:true, --&gt;默认false，每次请求时强行设置cookie，这将会重置cookie过期时间
        store:new MongoStore({
            url: &apos;mongodb://127.0.0.1:27017/student&apos;, ---&gt;数据库地址
            touchAfter: 24*3600 --&gt; 不管多少次请求，24小时内只更新一次session，除非在
        }) ------------------------------------------&gt; session数据上更改了某些内容
    }))
    5. db.sessions.find(); --&gt; 查询MongoDB中保存的session
</code></pre><h2 id="express模块化"><a href="#express模块化" class="headerlink" title="express模块化"></a>express模块化</h2><pre><code>1. express.Router：路由模块化，进而实现项目的模块化，便于协作开发与维护；
2. 创建入口文件app.js：
    const express = require(&apos;express&apos;);  let app = express();
    1. 引入路由模块的文件
    let index = require(&apos;./routes/index&apos;)
    let user = require(&apos;./routes/user&apos;)
    2. 应用路由模块
    app.use(&apos;/&apos;, index) ---&gt;当访问 http://localhost:3000 时，进入index.js去匹配路由
    app.use(&apos;/user&apos;, user) --&gt; http://localhost:3000/user --&gt; user.js
    app.listen(3000)
2. 以index.js为例：const express = require(&apos;express&apos;);
    1. 创建路由对象：let router = express.Router();
    2. 引入index模块的子路由模块login.js、home.js
    let login = require(&apos;./index/login&apos;);  let home = require(&apos;./index/home&apos;)
    3. 配置匹配的路由
    router.use(&apos;/&apos;, login) --&gt; http://localhost:3000 --&gt; 进入login.js去匹配
    router.use(&apos;/home&apos;, home) --&gt; http://localhost:3000/home --&gt; home.js
    4. 暴露模块的路由对象：module.exports = router
3. 以home.js为例
    const express = require(&apos;express&apos;);  let router = express.Router();
    1. 响应处理请求
    router.get(&apos;/&apos;, (req, res) =&gt; { --&gt;处理响应http://localhost:3000/home
        res.send(&apos;index--&gt;home&apos;)
    })
    router.get(&apos;/item&apos;, (req, res) =&gt; { --&gt;响应http://localhost:3000/home/item
        res.send(&apos;index--&gt;home--&gt;item&apos;)
    })
    2. 暴露子模块的路由对象：module.exports = router
4. 使用ejs模板
    1. 在入口文件app.js中配置ejs引擎和静态服务：
    app.set(&apos;view engine&apos;, &apos;ejs&apos;);  app.use(express.static(&apos;public&apos;));
    2. 在login.js中使用
    router.get(&apos;/&apos;, (req, res) =&gt; {
        res.render(&apos;login&apos;) ---&gt; 默认使用的模板为views/login.ejs
    })
5. express脚手架：express-generator
</code></pre><hr>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/NodeJs/" rel="tag"># NodeJs</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/07/09/NodeJs-3/" rel="next" title="NodeJs-3">
                <i class="fa fa-chevron-left"></i> NodeJs-3
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/08/15/Koa-1/" rel="prev" title="Koa-1">
                Koa-1 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">大麦田怪圈</p>
              <p class="site-description motion-element" itemprop="description">敢做就能赢！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">61</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">35</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Express"><span class="nav-number">1.</span> <span class="nav-text">Express</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#express与ejs"><span class="nav-number">2.</span> <span class="nav-text">express与ejs</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态服务"><span class="nav-number">3.</span> <span class="nav-text">静态服务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#中间件"><span class="nav-number">4.</span> <span class="nav-text">中间件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第三方中间件"><span class="nav-number">4.1.</span> <span class="nav-text">第三方中间件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cookie"><span class="nav-number">5.</span> <span class="nav-text">Cookie</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Session"><span class="nav-number">6.</span> <span class="nav-text">Session</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#express模块化"><span class="nav-number">7.</span> <span class="nav-text">express模块化</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大麦田怪圈</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
