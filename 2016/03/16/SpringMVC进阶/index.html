<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Spring,">










<meta name="description" content="控制器方法的返回值1. resources/springmvc.xml：配置的视图解析器     &amp;lt;bean id=&amp;quot;internalResourceViewResolver&amp;quot;          class=&amp;quot;org.springframework.web.servlet.view.InternalResourceViewResolver&amp;quot;&amp;gt;">
<meta name="keywords" content="Spring">
<meta property="og:type" content="article">
<meta property="og:title" content="SpringMVC进阶">
<meta property="og:url" content="http://hellomyshadow.github.io/2016/03/16/SpringMVC进阶/index.html">
<meta property="og:site_name" content="大麦田程序猿">
<meta property="og:description" content="控制器方法的返回值1. resources/springmvc.xml：配置的视图解析器     &amp;lt;bean id=&amp;quot;internalResourceViewResolver&amp;quot;          class=&amp;quot;org.springframework.web.servlet.view.InternalResourceViewResolver&amp;quot;&amp;gt;">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-04-24T13:09:59.647Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SpringMVC进阶">
<meta name="twitter:description" content="控制器方法的返回值1. resources/springmvc.xml：配置的视图解析器     &amp;lt;bean id=&amp;quot;internalResourceViewResolver&amp;quot;          class=&amp;quot;org.springframework.web.servlet.view.InternalResourceViewResolver&amp;quot;&amp;gt;">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://hellomyshadow.github.io/2016/03/16/SpringMVC进阶/">





  <title>SpringMVC进阶 | 大麦田程序猿</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">大麦田程序猿</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://hellomyshadow.github.io/2016/03/16/SpringMVC进阶/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大麦田怪圈">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="大麦田程序猿">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">SpringMVC进阶</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-03-16T00:00:00+08:00">
                2016-03-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaEE/" itemprop="url" rel="index">
                    <span itemprop="name">JavaEE</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="控制器方法的返回值"><a href="#控制器方法的返回值" class="headerlink" title="控制器方法的返回值"></a>控制器方法的返回值</h2><pre><code>1. resources/springmvc.xml：配置的视图解析器
    &lt;bean id=&quot;internalResourceViewResolver&quot; 
        class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/pages/&quot; /&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;
2. String
    @RequestMapping(&quot;/test&quot;)
    public String testStr(Model model) {
        User user = new User();  user.setName(&quot;JavaEE&quot;);  user.setAge(20);
        model.addAttribute(&quot;user&quot;, user);
        return &quot;test&quot;;
    }
    1. 返回的字符串默认作为逻辑视图名，通过视图解析器解析为物理视图的真实地址;
    2. 物理视图的真实地址：webapp/pages/test.jsp，渲染页面并响应给客户端;
    3. Model默认把数据存入Request域中，在 test.jsp 中获取这些数据;
        &lt;div&gt;${user.name}&lt;/div&gt; &lt;div&gt;${user.age}&lt;/div&gt;
3. void
    1. 控制器方法没有返回值时，默认以URL的最后一级作为视图名去查找JSP文件;
    2. 使用Servlet API手动转发/重定向时，SpringMVC的视图解析器不会再介入，所以要声明完整的路径名;
    @RequestMapping(path=&quot;/hello&quot;)
    public void test(HttpServletRequest req, HttpServletResponse res) {
        //手动转发到test.jsp
        req.getRequestDispatcher(&quot;/pages/test.jsp&quot;).forward(req, res);
        //手动重定向到index.jsp
        req.sendRedirect(req.getContextPath() + &quot;/index.jsp&quot;);
    }
4. 响应流数据
    @RequestMapping(path=&quot;/hello&quot;)
    public void test(HttpServletRequest req, HttpServletResponse res) {
        res.setCharacterEncoding(&quot;UTF-8&quot;);
        res.setContentType(&quot;text/html;charset=UTF-8&quot;);
        res.getWriter().print(&quot;你好，Java&quot;);
    }
5. ModelAndView
    1. SpringMVC提供的对象，用于封装Model和视图名;
        @RequestMapping(path=&quot;/hello&quot;)
        public ModelAndView test() {
            ModelAndView mv = new ModelAndView();
            User user = new User();  user.setName(&quot;JavaEE&quot;);  user.setAge(20);
            mv.addObject(&quot;user&quot;, user);  //存入数据
            mv.setViewName(&quot;test&quot;);  //指定视图名
            return mv;
        }
    2. 控制器方法返回字符串时，底层其实也是用 ModelAndView 进行封装.
6. 请求转发和重定向的关键字
    1. 控制器方法在返回字符串时，默认使用的就是请求转发;
    2. 转发的关键字：forward;  重定向的关键字：redirect;
        @RequestMapping(path=&quot;/hello&quot;)
        public String test() {
            return &quot;forward:/pages/test.jsp&quot;;  //转发到test.jsp
            return &quot;redirect:/index.jsp&quot;;  //重定向到index.jsp
        }
</code></pre><h3 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h3><pre><code>1. 用于将控制器方法返回的对象，通过 HttpMessageConverter 接口转为指定格式的数据，如JSON、XML，
   然后响应给客户端;
2. SpringMVC默认使用MappingJacksonHttpMessageConverter对JSON数据进行转换;
3. 引入转换格式的依赖包jackson
    jackson-databind、jackson-core、jackson-annotations
4. 在JSP页面发送一个AJAX请求，参数为JSON格式
    public class User {
        private String username;  private String password;
        ......//setter、getter
    }
    $.ajax({
        url: &quot;user/getList&quot;,
        type: &quot;post&quot;,
        dataType: &quot;json&quot;,
        data: &apos;{&quot;username&quot;: &quot;Jack&quot;, &quot;password&quot;: &quot;123&quot;}&apos;,
        success: data=&gt;{ ... }
    });
    @RequestMapping(path=&quot;/getList&quot;)
    public @ResponseBody User test(@RequestBody User user) {
        String username = user.getUsername();
        String password = user.getPassword();
        ... //操作数据库
        User u = new User();
        ......  //封装一个新的User对象并返回
        return u;
    }
    1. @RequestBody：获取请求体的内容，SpringMVC会把JSON格式的请求体封装到User对象中;
    2. @ResponseBody：将返回的对象作为响应体，并转为JSON数据，响应给客户端.
</code></pre><h2 id="静态资源的处理"><a href="#静态资源的处理" class="headerlink" title="静态资源的处理"></a>静态资源的处理</h2><pre><code>1. 访问静态资源时，不需要经过前端控制器和过滤器，直接响应即可;
2. 使用Servlet来处理静态资源：web.xml 中配置名称为 default 的&lt;servlet&gt;标签;
    1. 处理 webapp/css 目录中的静态资源：以 /css/ 开头的URL;
        &lt;servlet-mapping&gt;
            &lt;servlet-name&gt;default&lt;/servlet-name&gt;
            &lt;url-pattern&gt;/css/*&lt;/url-pattern&gt;
        &lt;/servlet-mapping&gt;
    2. 处理后缀名为 .css、.js 的静态资源;
        &lt;servlet-mapping&gt;
            &lt;servlet-name&gt;default&lt;/servlet-name&gt;
            &lt;url-pattern&gt;*.css&lt;/url-pattern&gt;
        &lt;/servlet-mapping&gt;
        &lt;servlet-mapping&gt;
            &lt;servlet-name&gt;default&lt;/servlet-name&gt;
            &lt;url-pattern&gt;*.js&lt;/url-pattern&gt;
        &lt;/servlet-mapping&gt;
3. 在SpringMVC的配置文件springmvc.xml 中，使用 &lt;mvc:resources&gt; 标签配置静态资源的访问;
    &lt;mvc:annotation-driven /&gt;
    &lt;mvc:resources location=&quot;/css/&quot; mapping=&quot;/css/**&quot; /&gt;
    &lt;mvc:resources location=&quot;/images/&quot; mapping=&quot;/images/**&quot; /&gt;
    &lt;mvc:resources location=&quot;/js/&quot; mapping=&quot;/js/**&quot; /&gt;
    1. location属性：指定目录文件的路径，如 /css/ 表示 webapp/css 目录;
    2. mapping属性：匹配的请求路径，如 /css/** 表示匹配以 /css 开头的所有URL;
</code></pre><h3 id="SpringMVC的路径匹配模式"><a href="#SpringMVC的路径匹配模式" class="headerlink" title="SpringMVC的路径匹配模式"></a>SpringMVC的路径匹配模式</h3><pre><code>1. Spring MVC中的路径匹配模式，使用的是Apache Ant的样式路径，有三种通配符：?、*、**
    1. /*：拦截所有目录，不包含子目录;
    2. /**：拦截所有目录及其子目录.
2. ?：匹配任何单字符;
    1. /user/a?bc：能够匹配/user/axbc、/user/aXbc，但不包括/user/abc;
3. *：匹配 n&gt;=0 个字符，只能匹配一级目录，不能匹配子目录;
    1. /user/*：匹配 /user/、 /user/abc，但不能匹配 /user/abc/123;
    2. /app/*.jsp：匹配app目录下的所有 .jsp 文件.
4. **：匹配 n&gt;=0 个目录;
    1. /user/**：匹配以 /user 开头的所有URL;
    2. /**/example：匹配 /example、 /app/example、 /app/foo/example...
    3. /app/**/dir/file.：匹配 /app/dir/file.jsp、 /app/foo/dir/file.html ...
5. /**/*.jsp：匹配任何目录下的所有 .jsp 文件;
6. 所以，以 mvc 为命名空间的标签，在设置路径时，都遵循此路径匹配模式.
</code></pre><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><pre><code>1. 必要前提
    1. form表单的 enctype(表单请求正文的类型) 属性值为 multipart/form-data;
    2. method 必须是 POST;
    3. 提供一个文件选择域：&lt;input type=&quot;file&quot; /&gt;
2. 文件上传的依赖包：commons-fileupload、commons-io
    &lt;form action=&quot;user/fileupload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;
        &lt;input type=&quot;file&quot; name=&quot;upload&quot; /&gt;
        &lt;input type=&quot;submit&quot; value=&quot;上传&quot; /&gt;
    &lt;/form&gt;
3. 传统上传方式
    @RequestMapping(path=&quot;/fileupload&quot;)
    public String uploadFile(HttpServletRequest req) {
        //获取上传目录的绝对路径
        String path = req.getSession().getServletContext().getRealPath(&quot;/uploads/&quot;);
        File file = new File(path);
        if(!file.exists()) {
            file.mkdirs();  //目录不存在则创建
        }
        DiskFileItemFactory factory = new DiskFileItemFactory();
        ServletFileUpload upload = new ServletFileUpload(factory);
        List&lt;FileItem&gt; items = upload.parseRequest(req);  //解析request
        for(FileItem item: items) {
            if(item.isFormField()) {
                //item只是一个普通的表单项
            } else {
                //item是一个上传文件项
                String filename = item.getName();  //获取文件名
                String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);
                filename = uuid + &quot;_&quot; + filename;  //不重复的文件名
                item.write(new File(path, filename));  //完成文件上传
                item.delete();  //删除生成的临时文件
            }
        }
        return &quot;success&quot;;
    }
</code></pre><h3 id="SpringMVC处理文件上传"><a href="#SpringMVC处理文件上传" class="headerlink" title="SpringMVC处理文件上传"></a>SpringMVC处理文件上传</h3><pre><code>1. 前端控制器接收到文件上传的请求时，会调用文件解析器，由文件解析器处理此请求;
2. 文件解析器会将处理结果封装到MultipartFile对象中，并将返回给前端控制器;
3. 前端控制器将上传文件对象MultipartFile，再传给对应的控制器方法;
4. 在配置文件 springmvc.xml 中配置文件解析器，其id值是固定的：multipartResolver
    &lt;bean id=&quot;multipartResolver&quot; 
        class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
        &lt;property name=&quot;maxUploadSize&quot; value=&quot;10485760&quot; /&gt;  ==&gt;最大上传文件
    &lt;/bean&gt;
5. 上传标签的name属性值为upload，方法参数MultipartFile的变量名也必须为upload;
    @RequestMapping(path=&quot;/fileupload&quot;)
    public String uploadFile(HttpServletRequest req, MultipartFile upload) {
        //获取上传目录的绝对路径
        String path = req.getSession().getServletContext().getRealPath(&quot;/uploads/&quot;);
        File file = new File(path);
        if(!file.exists()) {
            file.mkdirs();  //目录不存在则创建
        }
        String filename = upload.getOriginalFilename();  //获取文件名
        String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);
        filename = uuid + &quot;_&quot; + filename;  //不重复的文件名
        upload.transferTo(new File(path, filename));  //完成文件上传
        return &quot;success&quot;;
    }
</code></pre><h3 id="跨服务器的文件上传"><a href="#跨服务器的文件上传" class="headerlink" title="跨服务器的文件上传"></a>跨服务器的文件上传</h3><pre><code>1. 实际开发中，可能会有很多负责不同功能的服务器
    1. 应用服务器：负责部署处理业务的应用;
    2. 数据库服务器：数据持久化;
    3. 缓存和消息服务器：负责处理高并发访问的缓存和消息;
    4. 文件服务器：负责存储用户上传的文件;
2. 注意：这并不是服务器集群;
3. 实现跨服务器的依赖：jersey-core、jersey-client
    @RequestMapping(path=&quot;/fileupload&quot;)
    public String uploadFile(MultipartFile upload) {
        String filename = upload.getOriginalFilename();  //获取文件名
        String uuid = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;);
        filename = uuid + &quot;_&quot; + filename;  //不重复的文件名
        //文件服务器的上传URL，一定有uploads目录
        String fileServer = &quot;http://localhost:9090/uploads/&quot;;
        //创建客户端对象
        Client client = Client.create();
        //与文件服务器建立连接
        WebResource web = client.resource(fileServer + filename);
        //上传文件
        web.put(upload.getBytes());
        return &quot;success&quot;;
    }
</code></pre><h2 id="异常处理器"><a href="#异常处理器" class="headerlink" title="异常处理器"></a>异常处理器</h2><pre><code>1. 控制器方法在处理业务发生异常时，会向上抛出，最终由前端控制器查找异常处理器，如果没有则抛给浏览器;
2. 使用异常处理器的目的是，当发生异常时，由异常处理器响应给用户一个友好页面；
3. 自定义异常类
    public class SysException extends Exception {
        private String message;  //存储提示信息
        //getter、setter
        public SysException(String message) {
            this.message = message;
        }
    }
4. 抛出异常
    @RequestMapping(path=&quot;/except&quot;)
    public String test() throws SysException {
        try {
            int i = 10/0;  //发生异常
        } catch(Exception e) {
            throw new SysException(&quot;保存用户失败！&quot;);
        }
        return &quot;success&quot;;
    }
5. 异常处理器：实现接口HandlerExceptionResolver
    public class SysExceptionResolver implements HandlerExceptionResolver {
        public ModelAndView resolveException(HttpServletRequest req, 
                HttpServletResponse res, Object handler, Exception ex) {
            SysException e = null;
            if(ex instanceof SysException) {
                e = (SysException) ex;
            } else {
                e = new SysException(&quot;不好意思，系统维护中~&quot;);
            }
            ModelAndView mv = new ModelAndView();
            mv.addObject(&quot;errorMsg&quot;, e.getMessage());  //向Request域存入提示信息
            mv.setViewName(&quot;error&quot;);  //跳转到自定义的错误页error.jsp
            return mv;
        }
    }
6. 在配置文件 springmvc.xml 中，配置异常处理器
    &lt;bean id=&quot;sysExceptionResolver&quot; class=&quot;cn.test.exception.SysExceptionResolver&quot;&gt;&lt;/bean&gt;
</code></pre><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><pre><code>1. SpringMVC的处理器拦截器类似于Servlet中的过滤器，用于对处理器进行预处理和后处理;
    1. 预处理和后处理类似于Koa的洋葱图；
    2. 请求到达 --&gt; 执行拦截器放行前的代码(预处理) --&gt; 放行到控制器方法 --&gt; 
    执行拦截器放行后的代码 --&gt; 响应结果
2. 拦截器链：将拦截器按照一定的顺序连接成一条链，在访问被拦截的方法/属性时，拦截器就会按顺序被调用;
3. 过滤器与拦截器
    1. 过滤器是Servlet规范中的一部分，拦截器是SpringMVC框架提供的；
    2. 过滤器在 url-pattern 中配置了 /* 之后，可以拦截所有要访问的资源；
    3. 拦截器只会拦截访问的控制器方法，如果是JSP、HTML、CSS、image、JS资源，是不会被拦截的。
4. 拦截器也是AOP思想的具体应用，自定义拦截器必须实现接口HandlerInterceptor
5. JDK1.8对接口做了增强，方法可以不是抽象的，所以在实现HandlerInterceptor时，并不强制实现此接口方法;
    public class MyInterceptor implements HandlerInterceptor {
        // preHandle()、postHandle()、afterCompletion()
    }
6. 在配置文件 springmvc.xml 中，配置拦截器：&lt;mvc:interceptors&gt;
    &lt;mvc:interceptors&gt;
        &lt;mvc:interceptor&gt;
            &lt;mvc:mapping path=&quot;/user/*&quot; /&gt;
            &lt;!-- &lt;mvc:exclude-mapping path=&quot;&quot;&gt; --&gt;
            &lt;bean class=&quot;cn.test.interceptor.MyInterceptor&quot; /&gt;
        &lt;/mvc:interceptor&gt;
    &lt;/mvc:interceptors&gt;
    1. 每一组 &lt;mvc:interceptor&gt; 标签，表示一个拦截器，标签的顺序决定了拦截器的调用顺序;
    2. &lt;mvc:mapping&gt;：配置拦截的控制器方法;
    3. &lt;mvc:exclude-mapping&gt;：配置不拦截的控制器方法;
    4. path 属性：指定URL，也就是控制器方法.
1. preHandle()：预处理方法
    public boolean preHandle(HttpServletRequest req, HttpServletResponse res, 
        Object handler) {
        return true;
    }
    1. 在控制器方法执行之前执行，返回true表示放行，执行下一个拦截器，如果没有了，则执行控制器方法;
    2. 返回false表示不放行，可以使用req对象和res对象自行处理请求与响应.
    public boolean preHandle(HttpServletRequest req, HttpServletResponse res, 
        Object handler) {
        req.getRequestDispatcher(&quot;/pages/error.jsp&quot;).forward(req, res); //转发到error.jsp
        return false;  //不放行
    }
2. postHandle()：后处理方法
    @RequestMapping(path=&quot;/test&quot;)
    public String test() {
        ....
        return &quot;success&quot;;
    }
    public void postHandle(HttpServletRequest req, HttpServletResponse res, 
        Object handler， ModelAndView mv) {
    }
    1. 在控制器方法执行完之后，执行success.jsp之前，执行postHandle();
    public void postHandle(HttpServletRequest req, HttpServletResponse res, 
        Object handler, ModelAndView mv) {
        req.getRequestDispatcher(&quot;/pages/error.jsp&quot;).forward(req, res);
    }
    2. 虽然postHandle()自行请求转发给error.jsp，但控制器方法的 success.jsp 仍会执行，
    响应给浏览器也是 error.jsp.
3. afterCompletion()：控制器方法的 success.jsp 执行完之后，才会执行;
    public void afterCompletion(HttpServletRequest req, HttpServletResponse res, 
        Object handler， Exception ex) {
    }
4. 当配置了多组拦截器时(都放行)
    @Controller
    @RequestMapping(path = &quot;/user&quot;)
    public class HelloController {
        @RequestMapping(path=&quot;/test&quot;)
        public String test() {
            ....
            return &quot;success&quot;;
        }
    }
    &lt;mvc:interceptors&gt;
        &lt;mvc:interceptor&gt;
            &lt;mvc:mapping path=&quot;/user/*&quot; /&gt;
            &lt;bean class=&quot;cn.test.interceptor.MyInterceptor&quot; /&gt;
        &lt;/mvc:interceptor&gt;
        &lt;mvc:interceptor&gt;
            &lt;mvc:mapping path=&quot;/**&quot; /&gt;
            &lt;bean class=&quot;cn.test.interceptor.TestInterceptor&quot; /&gt;
        &lt;/mvc:interceptor&gt;
    &lt;/mvc:interceptors&gt;
    &lt;a href=&quot;user/test&quot;&gt;to test&lt;/a&gt;
1. 执行顺序：
    MyInterceptor.preHandle() --&gt; TestInterceptor.preHandle() --&gt; HelloController.test()
    --&gt; TestInterceptor.postHandle() --&gt; MyInterceptor.postHandle() --&gt; success.jsp --&gt; 
    TestInterceptor.afterCompletion() --&gt; MyInterceptor.afterCompletion()
</code></pre><hr>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Spring/" rel="tag"># Spring</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/03/15/SpringMVC/" rel="next" title="SpringMVC">
                <i class="fa fa-chevron-left"></i> SpringMVC
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/03/25/SSM整合/" rel="prev" title="SSM整合">
                SSM整合 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">大麦田怪圈</p>
              <p class="site-description motion-element" itemprop="description">敢做就能赢！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">47</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#控制器方法的返回值"><span class="nav-number">1.</span> <span class="nav-text">控制器方法的返回值</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ResponseBody"><span class="nav-number">1.1.</span> <span class="nav-text">@ResponseBody</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#静态资源的处理"><span class="nav-number">2.</span> <span class="nav-text">静态资源的处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringMVC的路径匹配模式"><span class="nav-number">2.1.</span> <span class="nav-text">SpringMVC的路径匹配模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件上传"><span class="nav-number">3.</span> <span class="nav-text">文件上传</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringMVC处理文件上传"><span class="nav-number">3.1.</span> <span class="nav-text">SpringMVC处理文件上传</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#跨服务器的文件上传"><span class="nav-number">3.2.</span> <span class="nav-text">跨服务器的文件上传</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异常处理器"><span class="nav-number">4.</span> <span class="nav-text">异常处理器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拦截器"><span class="nav-number">5.</span> <span class="nav-text">拦截器</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大麦田怪圈</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
